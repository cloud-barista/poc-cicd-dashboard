
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/common/config.go (0.0%)</option>
				
				<option value="file1">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/common/namespace.go (10.3%)</option>
				
				<option value="file2">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/common/utility.go (1.0%)</option>
				
				<option value="file3">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/common.go (0.0%)</option>
				
				<option value="file4">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/image.go (0.0%)</option>
				
				<option value="file5">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/securitygroup.go (0.0%)</option>
				
				<option value="file6">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/spec.go (0.0%)</option>
				
				<option value="file7">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/sshkey.go (0.0%)</option>
				
				<option value="file8">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/vnet.go (0.0%)</option>
				
				<option value="file9">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/control.go (0.0%)</option>
				
				<option value="file10">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/monitor.go (0.0%)</option>
				
				<option value="file11">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/orchestration.go (0.0%)</option>
				
				<option value="file12">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/plan.go (0.0%)</option>
				
				<option value="file13">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/utility.go (0.0%)</option>
				
				<option value="file14">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/common.go (33.3%)</option>
				
				<option value="file15">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/config.go (11.2%)</option>
				
				<option value="file16">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/namespace.go (15.6%)</option>
				
				<option value="file17">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/utility.go (2.3%)</option>
				
				<option value="file18">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/common.go (0.0%)</option>
				
				<option value="file19">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/image.go (0.0%)</option>
				
				<option value="file20">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/securitygroup.go (0.0%)</option>
				
				<option value="file21">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/spec.go (0.0%)</option>
				
				<option value="file22">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/sshkey.go (0.0%)</option>
				
				<option value="file23">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/vnet.go (0.0%)</option>
				
				<option value="file24">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/control.go (0.0%)</option>
				
				<option value="file25">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/monitor.go (0.0%)</option>
				
				<option value="file26">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/orchestration.go (0.0%)</option>
				
				<option value="file27">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/plan.go (0.0%)</option>
				
				<option value="file28">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/sshrun.go (0.0%)</option>
				
				<option value="file29">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/utility.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package common

import (
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// RestInitConfig godoc
// @Summary Init config
// @Description Init config
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Param configId path string true "Config ID"
// @Success 200 {object} common.ConfigInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config/{configId} [delete]
func RestInitConfig(c echo.Context) error <span class="cov0" title="0">{
        //id := c.Param("configId")
        if err := Validate(c, []string{"configId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">err := common.InitConfig(c.Param("configId"))
        if err != nil </span><span class="cov0" title="0">{
                //mapA := common.SimpleMsg{"Failed to find the config " + id}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to init the config "+c.Param("configId"))
        }</span> else<span class="cov0" title="0"> {
                //return c.JSON(http.StatusOK, &amp;res)
                return SendMessage(c, http.StatusOK, "The config "+c.Param("configId")+" has been initialized.")
        }</span>
}

// RestGetConfig godoc
// @Summary Get config
// @Description Get config
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Param configId path string true "Config ID"
// @Success 200 {object} common.ConfigInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config/{configId} [get]
func RestGetConfig(c echo.Context) error <span class="cov0" title="0">{
        //id := c.Param("configId")
        if err := Validate(c, []string{"configId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">res, err := common.GetConfig(c.Param("configId"))
        if err != nil </span><span class="cov0" title="0">{
                //mapA := common.SimpleMsg{"Failed to find the config " + id}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to find the config "+c.Param("configId"))
        }</span> else<span class="cov0" title="0"> {
                //return c.JSON(http.StatusOK, &amp;res)
                return Send(c, http.StatusOK, res)
        }</span>
}

// Response structure for RestGetAllConfig
type RestGetAllConfigResponse struct {
        //Name string     `json:"name"`
        Config []common.ConfigInfo `json:"config"`
}

// RestGetAllConfig godoc
// @Summary List all configs
// @Description List all configs
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Success 200 {object} RestGetAllConfigResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config [get]
func RestGetAllConfig(c echo.Context) error <span class="cov0" title="0">{

        var content RestGetAllConfigResponse

        configList, err := common.ListConfig()
        if err != nil </span><span class="cov0" title="0">{
                //mapA := common.SimpleMsg{"Failed to list configs."}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to list configs.")
        }</span>

        <span class="cov0" title="0">if configList == nil </span><span class="cov0" title="0">{
                //return c.JSON(http.StatusOK, &amp;content)
                return Send(c, http.StatusOK, content)
        }</span>

        // When err == nil &amp;&amp; resourceList != nil
        <span class="cov0" title="0">content.Config = configList
        //return c.JSON(http.StatusOK, &amp;content)
        return Send(c, http.StatusOK, content)</span>

}

// RestPostConfig godoc
// @Summary Create or Update config
// @Description Create or Update config (SPIDER_REST_URL, DRAGONFLY_REST_URL, ...)
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Param config body common.ConfigReq true "Key and Value for configuration"
// @Success 200 {object} common.ConfigInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config [post]
func RestPostConfig(c echo.Context) error <span class="cov0" title="0">{

        u := &amp;common.ConfigReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                //return err
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">fmt.Println("[Creating or Updating Config]")
        content, err := common.UpdateConfig(u)
        if err != nil </span><span class="cov0" title="0">{
                //common.CBLog.Error(err)
                ////mapA := common.SimpleMsg{"Failed to create the config " + u.Name}
                //mapA := common.SimpleMsg{err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>
        //return c.JSON(http.StatusCreated, content)
        <span class="cov0" title="0">return Send(c, http.StatusOK, content)</span>

}

// RestInitAllConfig godoc
// @Summary Init all configs
// @Description Init all configs
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /config [delete]
func RestInitAllConfig(c echo.Context) error <span class="cov0" title="0">{

        err := common.InitAllConfig()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return SendMessage(c, http.StatusOK, "All configs has been initialized.")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package common

import (
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

func RestCheckNs(c echo.Context) error <span class="cov0" title="0">{

        /*
                nsId := c.Param("nsId")

                exists, err := common.CheckNs(nsId)

                type JsonTemplate struct {
                        Exists bool `json:"exists"`
                }
                content := JsonTemplate{}
                content.Exists = exists

                if err != nil {
                        common.CBLog.Error(err)
                        //mapA := common.SimpleMsg{err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return c.JSON(http.StatusNotFound, &amp;content)
                }

                return c.JSON(http.StatusOK, &amp;content)
        */

        if err := Validate(c, []string{"nsId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">nsId := c.Param("nsId")
        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">exists, err := common.CheckNs(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">return SendExistence(c, http.StatusOK, exists)</span>
}

// RestDelAllNs godoc
// @Summary Delete all namespaces
// @Description Delete all namespaces
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns [delete]
func RestDelAllNs(c echo.Context) error <span class="cov0" title="0">{

        /*
                err := common.DelAllNs()
                if err != nil {
                        common.CBLog.Error(err)
                        mapA := common.SimpleMsg{err.Error()}
                        return c.JSON(http.StatusConflict, &amp;mapA)
                }

                mapA := common.SimpleMsg{"All namespaces has been deleted"}
                return c.JSON(http.StatusOK, &amp;mapA)
        */

        err := common.DelAllNs()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return SendMessage(c, http.StatusOK, "All namespaces has been deleted")</span>
}

// RestDelNs godoc
// @Summary Delete namespace
// @Description Delete namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId} [delete]
func RestDelNs(c echo.Context) error <span class="cov0" title="0">{

        /*
                id := c.Param("nsId")

                err := common.DelNs(id)
                if err != nil {
                        common.CBLog.Error(err)
                        mapA := common.SimpleMsg{err.Error()}
                        return c.JSON(http.StatusFailedDependency, &amp;mapA)
                }

                mapA := common.SimpleMsg{"The ns has been deleted"}
                return c.JSON(http.StatusOK, &amp;mapA)
        */

        if err := Validate(c, []string{"nsId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">err := common.DelNs(c.Param("nsId"))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return SendMessage(c, http.StatusOK, "The ns "+c.Param("nsId")+" has been deleted")</span>
}

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

// Response structure for RestGetAllNs
type RestGetAllNsResponse struct {
        //Name string     `json:"name"`
        Ns []common.NsInfo `json:"ns"`
}

// RestGetAllNs godoc
// @Summary List all namespaces or namespaces' ID
// @Description List all namespaces or namespaces' ID
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllNsResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns [get]
func RestGetAllNs(c echo.Context) error <span class="cov0" title="0">{

        optionFlag := c.QueryParam("option")

        var content RestGetAllNsResponse
        if optionFlag == "id" </span><span class="cov0" title="0">{
                content := common.IdList{}

                var err error
                content.IdList, err = common.ListNsId()
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := common.SimpleMsg{"Failed to list namespaces."}
                        //return c.JSON(http.StatusNotFound, &amp;mapA)
                        return SendMessage(c, http.StatusOK, "Failed to list namespaces' ID: "+err.Error())
                }</span>

                <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov0" title="0"> {
                nsList, err := common.ListNs()
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := common.SimpleMsg{"Failed to list namespaces."}
                        //return c.JSON(http.StatusNotFound, &amp;mapA)
                        return SendMessage(c, http.StatusOK, "Failed to list namespaces.")
                }</span>

                <span class="cov0" title="0">if nsList == nil </span><span class="cov0" title="0">{
                        //return c.JSON(http.StatusOK, &amp;content)
                        return Send(c, http.StatusOK, content)
                }</span>

                // When err == nil &amp;&amp; resourceList != nil
                <span class="cov0" title="0">content.Ns = nsList
                //return c.JSON(http.StatusOK, &amp;content)
                return Send(c, http.StatusOK, content)</span>
        }
}

// RestGetNs godoc
// @Summary Get namespace
// @Description Get namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.NsInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId} [get]
func RestGetNs(c echo.Context) error <span class="cov0" title="0">{
        //id := c.Param("nsId")
        if err := Validate(c, []string{"nsId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">res, err := common.GetNs(c.Param("nsId"))
        if err != nil </span><span class="cov0" title="0">{
                //mapA := common.SimpleMsg{"Failed to find the namespace " + id}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to find the namespace "+c.Param("nsId"))
        }</span> else<span class="cov0" title="0"> {
                //return c.JSON(http.StatusOK, &amp;res)
                return Send(c, http.StatusOK, res)
        }</span>
}

// RestPostNs godoc
// @Summary Create namespace
// @Description Create namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param nsReq body common.NsReq true "Details for a new namespace"
// @Success 200 {object} common.NsInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns [post]
func RestPostNs(c echo.Context) error <span class="cov8" title="1">{

        u := &amp;common.NsReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                //return err
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">fmt.Println("[Creating Ns]")
        content, err := common.CreateNs(u)
        if err != nil </span><span class="cov0" title="0">{
                //common.CBLog.Error(err)
                ////mapA := common.SimpleMsg{"Failed to create the ns " + u.Name}
                //mapA := common.SimpleMsg{err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>
        //return c.JSON(http.StatusCreated, content)
        <span class="cov8" title="1">return Send(c, http.StatusOK, content)</span>

}

/* function RestPutNs not yet implemented
// RestPutNs godoc
// @Summary Update namespace
// @Description Update namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param namespace body common.NsInfo true "Details to update existing namespace"
// @Success 200 {object} common.NsInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId} [put]
*/
func RestPutNs(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package common

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "os"

        "github.com/beego/beego/v2/core/validation"
        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

type TbConnectionName struct {
        ConnectionName string `json:"connectionName"`
}

type Existence struct {
        Exists bool `json:"exists"`
}

func SendExistence(c echo.Context, httpCode int, existence bool) error <span class="cov0" title="0">{
        return c.JSON(httpCode, Existence{Exists: existence})
}</span>

type Status struct {
        Message string `json:"message"`
}

func SendMessage(c echo.Context, httpCode int, msg string) error <span class="cov0" title="0">{
        return c.JSON(httpCode, Status{Message: msg})
}</span>

func Send(c echo.Context, httpCode int, json interface{}) error <span class="cov8" title="1">{
        return c.JSON(httpCode, json)
}</span>

func Validate(c echo.Context, params []string) error <span class="cov0" title="0">{
        valid := validation.Validation{}

        for _, name := range params </span><span class="cov0" title="0">{
                valid.Required(c.Param(name), name)
        }</span>

        <span class="cov0" title="0">if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RestGetHealth func is for checking Tumblebug server health.
// RestGetHealth godoc
// @Summary Check Tumblebug is alive
// @Description Check Tumblebug is alive
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /health [get]
func RestGetHealth(c echo.Context) error <span class="cov0" title="0">{
        okMessage := common.SimpleMsg{}
        okMessage.Message = "API server of CB-Tumblebug is alive"

        return c.JSON(http.StatusOK, &amp;okMessage)
}</span>

// RestGetSwagger func is to get API document web.
// RestGetSwagger godoc
// @Summary Get API document web
// @Description Get API document web
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /swaggerActive [get]
func RestGetSwagger(c echo.Context) error <span class="cov0" title="0">{
        docFile := os.Getenv("API_DOC_PATH")

        f, err := os.Open(docFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        dec := json.NewDecoder(f)
        data := make(map[string]interface{}, 0)
        if err := dec.Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">data["host"] = os.Getenv("SELF_ENDPOINT")
        return c.JSON(http.StatusOK, data)</span>
}

// RestGetConnConfig func is a rest api wrapper for GetConnConfig.
// RestGetConnConfig godoc
// @Summary Get registered ConnConfig info
// @Description Get registered ConnConfig info
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param connConfigName path string true "Name of connection config (cloud config)"
// @Success 200 {object} common.ConnConfig
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /connConfig/{connConfigName} [get]
func RestGetConnConfig(c echo.Context) error <span class="cov0" title="0">{

        connConfigName := c.Param("connConfigName")

        fmt.Println("[Get ConnConfig for name]" + connConfigName)
        content, err := common.GetConnConfig(connConfigName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestGetConnConfigList func is a rest api wrapper for GetConnConfigList.
// RestGetConnConfigList godoc
// @Summary List all registered ConnConfig
// @Description List all registered ConnConfig
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.ConnConfigList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /connConfig [get]
func RestGetConnConfigList(c echo.Context) error <span class="cov0" title="0">{

        fmt.Println("[Get ConnConfig List]")
        content, err := common.GetConnConfigList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestGetRegion func is a rest api wrapper for GetRegion.
// RestGetRegion godoc
// @Summary Get registered region info
// @Description Get registered region info
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param regionName path string true "Name of region to retrieve"
// @Success 200 {object} common.Region
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /region/{regionName} [get]
func RestGetRegion(c echo.Context) error <span class="cov0" title="0">{

        regionName := c.Param("regionName")

        fmt.Println("[Get Region for name]" + regionName)
        content, err := common.GetRegion(regionName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestGetRegionList func is a rest api wrapper for GetRegionList.
// RestGetRegionList godoc
// @Summary List all registered regions
// @Description List all registered regions
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.RegionList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /region [get]
func RestGetRegionList(c echo.Context) error <span class="cov0" title="0">{

        fmt.Println("[Get Region List]")
        content, err := common.GetRegionList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// ObjectList struct consists of object IDs
type ObjectList struct {
        Object []string `json:"object"`
}

// func RestGetObjects is a rest api wrapper for GetObjectList.
// RestGetObjects godoc
// @Summary List all objects for a given key
// @Description List all objects for a given key
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "retrieve objects by key"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /objects [get]
func RestGetObjects(c echo.Context) error <span class="cov0" title="0">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Get Tumblebug Object List] with Key: %s \n", parentKey)

        content := common.GetObjectList(parentKey)

        objectList := ObjectList{}
        for i, v := range content </span><span class="cov0" title="0">{
                fmt.Printf("[Obj: %d] %s \n", i, v)
                objectList.Object = append(objectList.Object, v)
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;objectList)</span>
}

// func RestGetObject is a rest api wrapper for GetObject.
// RestGetObject godoc
// @Summary Get value of an object
// @Description Get value of an object
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "get object value by key"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /object [get]
func RestGetObject(c echo.Context) error <span class="cov0" title="0">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Get Tumblebug Object Value] with Key: %s \n", parentKey)

        content, err := common.GetObjectValue(parentKey)
        if err != nil || content == "" </span><span class="cov0" title="0">{
                return SendMessage(c, http.StatusOK, "Cannot find ["+parentKey+"] object")
        }</span>

        <span class="cov0" title="0">var contentJSON map[string]interface{}
        json.Unmarshal([]byte(content), &amp;contentJSON)

        return c.JSON(http.StatusOK, &amp;contentJSON)</span>
}

// func RestDeleteObject is a rest api wrapper for DeleteObject.
// RestDeleteObject godoc
// @Summary Delete an object
// @Description Delete an object
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "delete object value by key"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /object [delete]
func RestDeleteObject(c echo.Context) error <span class="cov0" title="0">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Delete Tumblebug Object] with Key: %s \n", parentKey)

        content, err := common.GetObjectValue(parentKey)
        if err != nil || content == "" </span><span class="cov0" title="0">{
                return SendMessage(c, http.StatusOK, "Cannot find ["+parentKey+"] object")
        }</span>

        <span class="cov0" title="0">err = common.DeleteObject(parentKey)
        if err != nil </span><span class="cov0" title="0">{
                return SendMessage(c, http.StatusOK, "Cannot delete ["+parentKey+"] object")
        }</span>

        <span class="cov0" title="0">return SendMessage(c, http.StatusOK, "The object has been deleted")</span>
}

// func RestDeleteObjects is a rest api wrapper for DeleteObjects.
// RestDeleteObjects godoc
// @Summary Delete child objects along with the given object
// @Description Delete child objects along with the given object
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "Delete child objects based on the given key string"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /objects [delete]
func RestDeleteObjects(c echo.Context) error <span class="cov0" title="0">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Delete Tumblebug child Objects] with Key: %s \n", parentKey)

        err := common.DeleteObjects(parentKey)
        if err != nil </span><span class="cov0" title="0">{
                return SendMessage(c, http.StatusOK, "Cannot delete  objects")
        }</span>

        <span class="cov0" title="0">return SendMessage(c, http.StatusOK, "Objects have been deleted")</span>
}

// Request struct for RestInspectResources
type RestInspectResourcesRequest struct {
        ConnectionName string `json:"connectionName"`
        Type           string `json:"type" example:"vNet" enums:"vNet,securityGroup,sshKey,vm"`
}

// RestInspectResources godoc
// @Summary Inspect Resources (vNet, securityGroup, sshKey, vm) registered in CB-Tumblebug, CB-Spider, CSP
// @Description Inspect Resources (vNet, securityGroup, sshKey, vm) registered in CB-Tumblebug, CB-Spider, CSP
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param connectionName body RestInspectResourcesRequest true "Specify connectionName and resource type"
// @Success 200 {object} mcis.TbInspectResourcesResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /inspectResources [post]
func RestInspectResources(c echo.Context) error <span class="cov0" title="0">{

        fmt.Println("RestInspectResources called;") // for debug

        u := &amp;RestInspectResourcesRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("[List Resource Status: %s]", u.Type)
        var content interface{}
        var err error
        if u.Type == common.StrVNet || u.Type == common.StrSecurityGroup || u.Type == common.StrSSHKey </span><span class="cov0" title="0">{
                content, err = mcir.InspectResources(u.ConnectionName, u.Type)
        }</span> else<span class="cov0" title="0"> if u.Type == "vm" </span><span class="cov0" title="0">{
                content, err = mcis.InspectVMs(u.ConnectionName)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package mcir

import (
        "net/http"
        "strings"

        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestDelAllResources(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        forceFlag := c.QueryParam("force")

        err := mcir.DelAllResources(nsId, resourceType, forceFlag)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusConflict, &amp;mapA)
        }</span>

        <span class="cov0" title="0">mapA := map[string]string{"message": "All " + resourceType + "s has been deleted"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestDelResource(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        resourceId := c.Param("resourceId")

        forceFlag := c.QueryParam("force")

        err := mcir.DelResource(nsId, resourceType, resourceId, forceFlag)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">mapA := map[string]string{"message": "The " + resourceType + " " + resourceId + " has been deleted"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestGetAllResources(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        optionFlag := c.QueryParam("option")

        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        if optionFlag == "id" </span><span class="cov0" title="0">{
                content := common.IdList{}
                var err error
                content.IdList, err = mcir.ListResourceId(nsId, resourceType)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": "Failed to list " + resourceType + "s' ID; " + err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov0" title="0"> {

                resourceList, err := mcir.ListResource(nsId, resourceType)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": "Failed to list " + resourceType + "s; " + err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                <span class="cov0" title="0">switch resourceType </span>{
                case common.StrImage:<span class="cov0" title="0">
                        var content struct {
                                Image []mcir.TbImageInfo `json:"image"`
                        }

                        if resourceList == nil </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov0" title="0">content.Image = resourceList.([]mcir.TbImageInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrSecurityGroup:<span class="cov0" title="0">
                        var content struct {
                                SecurityGroup []mcir.TbSecurityGroupInfo `json:"securityGroup"`
                        }

                        if resourceList == nil </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov0" title="0">content.SecurityGroup = resourceList.([]mcir.TbSecurityGroupInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrSpec:<span class="cov0" title="0">
                        var content struct {
                                Spec []mcir.TbSpecInfo `json:"spec"`
                        }

                        if resourceList == nil </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov0" title="0">content.Spec = resourceList.([]mcir.TbSpecInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrSSHKey:<span class="cov0" title="0">
                        var content struct {
                                SshKey []mcir.TbSshKeyInfo `json:"sshKey"`
                        }

                        if resourceList == nil </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov0" title="0">content.SshKey = resourceList.([]mcir.TbSshKeyInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrVNet:<span class="cov0" title="0">
                        var content struct {
                                VNet []mcir.TbVNetInfo `json:"vNet"`
                        }

                        if resourceList == nil </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov0" title="0">content.VNet = resourceList.([]mcir.TbVNetInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                default:<span class="cov0" title="0">
                        return c.JSON(http.StatusBadRequest, nil)</span>

                }
                // return c.JSON(http.StatusBadRequest, nil)
        }
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestGetResource(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        resourceId := c.Param("resourceId")

        res, err := mcir.GetResource(nsId, resourceType, resourceId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": "Failed to find " + resourceType + " " + resourceId}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span> else<span class="cov0" title="0"> {
                return c.JSON(http.StatusOK, &amp;res)
        }</span>
}

// RestCheckResource godoc
// @Summary Check resources' existence
// @Description Check resources' existence
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param resourceType path string true "Resource Type"
// @Param resourceId path string true "Resource ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /{nsId}/checkResource/{resourceType}/{resourceId} [get]
func RestCheckResource(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        exists, err := mcir.CheckResource(nsId, resourceType, resourceId)

        type JsonTemplate struct {
                Exists bool `json:"exists"`
        }
        content := JsonTemplate{}
        content.Exists = exists

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //mapA := map[string]string{"message": err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return c.JSON(http.StatusNotFound, &amp;content)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
}

// RestTestAddObjectAssociation is a REST API call handling function
// to test "mcir.UpdateAssociatedObjectList" function with "add" argument.
func RestTestAddObjectAssociation(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        //resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/testAddObjectAssociation/:resourceType/:resourceId
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        vmKeyList, err := mcir.UpdateAssociatedObjectList(nsId, resourceType, resourceId, common.StrAdd, "/test/vm/key")

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        //mapA := map[string]int8{"inUseCount": inUseCount}
        <span class="cov0" title="0">return c.JSON(http.StatusOK, vmKeyList)</span>
}

// RestTestDeleteObjectAssociation is a REST API call handling function
// to test "mcir.UpdateAssociatedObjectList" function with "delete" argument.
func RestTestDeleteObjectAssociation(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        //resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/testDeleteObjectAssociation/:resourceType/:resourceId
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        vmKeyList, err := mcir.UpdateAssociatedObjectList(nsId, resourceType, resourceId, common.StrDelete, "/test/vm/key")

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        //mapA := map[string]int8{"inUseCount": inUseCount}
        <span class="cov0" title="0">return c.JSON(http.StatusOK, vmKeyList)</span>
}

// RestTestGetAssociatedObjectCount is a REST API call handling function
// to test "mcir.GetAssociatedObjectCount" function.
func RestTestGetAssociatedObjectCount(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        //resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/testGetAssociatedObjectCount/:resourceType/:resourceId
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        associatedObjectCount, err := mcir.GetAssociatedObjectCount(nsId, resourceType, resourceId)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">mapA := map[string]int{"associatedObjectCount": associatedObjectCount}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostImage godoc
// @Summary Register image
// @Description Register image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param registeringMethod query string true "registerWithInfo or registerWithId"
// @Param nsId path string true "Namespace ID"
// @Param imageInfo body mcir.TbImageInfo false "Details for an image object"
// @Param imageId body mcir.TbImageReq false "name, connectionName and cspImageId"
// @Success 200 {object} mcir.TbImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image [post]
func RestPostImage(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        action := c.QueryParam("action")
        fmt.Println("[POST Image] (action: " + action + ")")
        /*
                if action == "create" {
                        fmt.Println("[Creating Image]")
                        content, _ := createImage(nsId, u)
                        return c.JSON(http.StatusCreated, content)

                } else */
        if action == "registerWithInfo" </span><span class="cov0" title="0">{
                fmt.Println("[Registering Image with info]")
                u := &amp;mcir.TbImageInfo{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">content, err := mcir.RegisterImageWithInfo(nsId, u)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>
        } else<span class="cov0" title="0"> if action == "registerWithId" </span><span class="cov0" title="0">{
                fmt.Println("[Registering Image with ID]")
                u := &amp;mcir.TbImageReq{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //content, responseCode, body, err := RegisterImageWithId(nsId, u)
                <span class="cov0" title="0">content, err := mcir.RegisterImageWithId(nsId, u)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        //fmt.Println("body: ", string(body))
                        //return c.JSONBlob(responseCode, body)
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>
        } else<span class="cov0" title="0"> {
                mapA := map[string]string{"message": "You must specify: action=registerWithInfo or action=registerWithId"}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

}

/* function RestPutImage not yet implemented
// RestPutImage godoc
// @Summary Update image
// @Description Update image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param imageInfo body mcir.TbImageInfo true "Details for an image object"
// @Success 200 {object} mcir.TbImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image/{imageId} [put]
*/
func RestPutImage(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// Request structure for RestLookupImage
type RestLookupImageRequest struct {
        ConnectionName string `json:"connectionName"`
        CspImageId     string `json:"cspImageId"`
}

// RestLookupImage godoc
// @Summary Lookup image
// @Description Lookup image
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupImageReq body RestLookupImageRequest true "Specify connectionName &amp; cspImageId"
// @Success 200 {object} mcir.SpiderImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupImage [get]
func RestLookupImage(c echo.Context) error <span class="cov0" title="0">{

        u := &amp;RestLookupImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Lookup image]: " + u.CspImageId)
        content, err := mcir.LookupImage(u.ConnectionName, u.CspImageId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestLookupImageList godoc
// @Summary Lookup image list
// @Description Lookup image list
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupImagesReq body common.TbConnectionName true "Specify connectionName"
// @Success 200 {object} mcir.SpiderImageList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupImages [get]
func RestLookupImageList(c echo.Context) error <span class="cov0" title="0">{

        //type JsonTemplate struct {
        //        ConnectionName string
        //}

        u := &amp;RestLookupImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Lookup images]")
        content, err := mcir.LookupImageList(u.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestFetchImages godoc
// @Summary Fetch images
// @Description Fetch images
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/fetchImages [post]
func RestFetchImages(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        // connConfigCount, imageCount, err := mcir.FetchImages(nsId)
        // if err != nil {
        //         common.CBLog.Error(err)
        //         mapA := map[string]string{
        //                 "message": err.Error()}
        //         return c.JSON(http.StatusInternalServerError, &amp;mapA)
        // }

        u := &amp;RestLookupImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var connConfigCount, imageCount uint
        var err error

        if u.ConnectionName == "" </span><span class="cov0" title="0">{
                connConfigCount, imageCount, err = mcir.FetchImagesForAllConnConfigs(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        } else<span class="cov0" title="0"> {
                connConfigCount = 1
                imageCount, err = mcir.FetchImagesForConnConfig(u.ConnectionName, nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        }

        <span class="cov0" title="0">mapA := map[string]string{
                "message": "Fetched " + fmt.Sprint(imageCount) + " images (from " + fmt.Sprint(connConfigCount) + " connConfigs)"}
        return c.JSON(http.StatusCreated, &amp;mapA)</span> //content)
}

// RestGetImage godoc
// @Summary Get image
// @Description Get image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param imageId path string true "Image ID"
// @Success 200 {object} mcir.TbImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image/{imageId} [get]
func RestGetImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllImage
type RestGetAllImageResponse struct {
        Image []mcir.TbImageInfo `json:"image"`
}

// RestGetAllImage godoc
// @Summary List all images or images' ID
// @Description List all images or images' ID
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllImageResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image [get]
func RestGetAllImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelImage godoc
// @Summary Delete image
// @Description Delete image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param imageId path string true "Image ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image/{imageId} [delete]
func RestDelImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllImage godoc
// @Summary Delete all images
// @Description Delete all images
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image [delete]
func RestDelAllImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestSearchImage
type RestSearchImageRequest struct {
        Keywords []string `json:"keywords"`
}

// RestSearchImage godoc
// @Summary Search image
// @Description Search image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param keywords body RestSearchImageRequest true "Keywords"
// @Success 200 {object} RestGetAllImageResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/searchImage [post]
func RestSearchImage(c echo.Context) error <span class="cov0" title="0">{
        nsId := c.Param("nsId")

        u := &amp;RestSearchImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //fmt.Println("RestSearchImage called; keywords: ") // for debug
        //fmt.Println(u.Keywords) // for debug

        <span class="cov0" title="0">content, err := mcir.SearchImage(nsId, u.Keywords...)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{
                        "message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">result := RestGetAllImageResponse{}
        result.Image = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostSecurityGroup godoc
// @Summary Create Security Group
// @Description Create Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param securityGroupReq body mcir.TbSecurityGroupReq true "Details for an securityGroup object"
// @Success 200 {object} mcir.TbSecurityGroupInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup [post]
func RestPostSecurityGroup(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSecurityGroupReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[POST SecurityGroup")
        //fmt.Println("[Creating SecurityGroup]")
        //content, responseCode, _, err := CreateSecurityGroup(nsId, u)
        content, err := mcir.CreateSecurityGroup(nsId, u)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                /*
                        mapA := map[string]string{
                                "message": "Failed to create a SecurityGroup"}
                */
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>
}

/* function RestPutSecurityGroup not yet implemented
// RestPutSecurityGroup godoc
// @Summary Update Security Group
// @Description Update Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param securityGroupInfo body mcir.TbSecurityGroupInfo true "Details for an securityGroup object"
// @Success 200 {object} mcir.TbSecurityGroupInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup/{securityGroupId} [put]
*/
func RestPutSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// RestGetSecurityGroup godoc
// @Summary Get Security Group
// @Description Get Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param securityGroupId path string true "Security Group ID"
// @Success 200 {object} mcir.TbSecurityGroupInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup/{securityGroupId} [get]
func RestGetSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllSecurityGroup
type RestGetAllSecurityGroupResponse struct {
        SecurityGroup []mcir.TbSecurityGroupInfo `json:"securityGroup"`
}

// RestGetAllSecurityGroup godoc
// @Summary List all Security Groups or Security Groups' ID
// @Description List all Security Groups or Security Groups' ID
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllSecurityGroupResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup [get]
func RestGetAllSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelSecurityGroup godoc
// @Summary Delete Security Group
// @Description Delete Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param securityGroupId path string true "Security Group ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup/{securityGroupId} [delete]
func RestDelSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllSecurityGroup godoc
// @Summary Delete all Security Groups
// @Description Delete all Security Groups
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup [delete]
func RestDelAllSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostSpec godoc
// @Summary Register spec
// @Description Register spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param registeringMethod query string true "registerWithInfo or else"
// @Param nsId path string true "Namespace ID"
// @Param specInfo body mcir.TbSpecInfo false "Details for an spec object"
// @Param specName body mcir.TbSpecReq false "name, connectionName and cspSpecName"
// @Success 200 {object} mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec [post]
func RestPostSpec(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        action := c.QueryParam("action")
        fmt.Println("[POST Spec] (action: " + action + ")")

        if action == "registerWithInfo" </span><span class="cov0" title="0">{ // `RegisterSpecWithInfo` will be deprecated in Cappuccino.
                fmt.Println("[Registering Spec with info]")
                u := &amp;mcir.TbSpecInfo{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">content, err := mcir.RegisterSpecWithInfo(nsId, u)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>

        } else<span class="cov0" title="0"> { // if action == "registerWithCspSpecName" { // The default mode.
                fmt.Println("[Registering Spec with CspSpecName]")
                u := &amp;mcir.TbSpecReq{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">content, err := mcir.RegisterSpecWithCspSpecName(nsId, u)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>

        } /* else {
                mapA := map[string]string{"message": "LookupSpec(specRequest) failed."}
                return c.JSON(http.StatusFailedDependency, &amp;mapA)
        } */

}

// RestPutSpec godoc
// @Summary Update spec
// @Description Update spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param specInfo body mcir.TbSpecInfo true "Details for an spec object"
// @Param nsId path string true "Namespace ID"
// @Param specId path string true "Spec ID"
// @Success 200 {object} mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec/{specId} [put]
func RestPutSpec(c echo.Context) error <span class="cov0" title="0">{
        nsId := c.Param("nsId")
        specId := c.Param("specId")
        fmt.Printf("RestPutSpec called; nsId: %s, specId: %s \n", nsId, specId) // for debug

        u := &amp;mcir.TbSpecInfo{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        /*
                if specId != u.Id {
                        err := fmt.Errorf("URL param " + specId + " and JSON param " + u.Id + " does not match.")
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusBadRequest, &amp;mapA)
                }
        */

        <span class="cov0" title="0">updatedSpec, err := mcir.UpdateSpec(nsId, *u)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{
                        "message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusOK, updatedSpec)</span>
}

// Request structure for RestLookupSpec
type RestLookupSpecRequest struct {
        ConnectionName string `json:"connectionName"`
        CspSpecName    string `json:"cspSpecName"`
}

// RestLookupSpec godoc
// @Summary Lookup spec
// @Description Lookup spec
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupSpecReq body RestLookupSpecRequest true "Specify connectionName &amp; cspSpecName"
// @Success 200 {object} mcir.SpiderSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupSpec [get]
func RestLookupSpec(c echo.Context) error <span class="cov0" title="0">{
        u := &amp;RestLookupSpecRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Lookup spec]: " + u.CspSpecName)
        content, err := mcir.LookupSpec(u.ConnectionName, u.CspSpecName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestLookupSpecList godoc
// @Summary Lookup spec list
// @Description Lookup spec list
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupSpecsReq body common.TbConnectionName true "Specify connectionName"
// @Success 200 {object} mcir.SpiderSpecList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupSpecs [get]
func RestLookupSpecList(c echo.Context) error <span class="cov0" title="0">{

        //type JsonTemplate struct {
        //        ConnectionName string
        //}

        u := &amp;RestLookupSpecRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Lookup specs]")
        content, err := mcir.LookupSpecList(u.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestFetchSpecs godoc
// @Summary Fetch specs
// @Description Fetch specs
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/fetchSpecs [post]
func RestFetchSpecs(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;RestLookupSpecRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var connConfigCount, specCount uint
        var err error

        if u.ConnectionName == "" </span><span class="cov0" title="0">{
                connConfigCount, specCount, err = mcir.FetchSpecsForAllConnConfigs(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        } else<span class="cov0" title="0"> {
                connConfigCount = 1
                specCount, err = mcir.FetchSpecsForConnConfig(u.ConnectionName, nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        }

        <span class="cov0" title="0">mapA := map[string]string{
                "message": "Fetched " + fmt.Sprint(specCount) + " specs (from " + fmt.Sprint(connConfigCount) + " connConfigs)"}
        return c.JSON(http.StatusCreated, &amp;mapA)</span> //content)
}

// RestFilterSpecsResponse is Response structure for RestFilterSpecs
type RestFilterSpecsResponse struct {
        Spec []mcir.TbSpecInfo `json:"spec"`
}

// RestFilterSpecs godoc
// @Summary Filter specs
// @Description Filter specs
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specFilter body mcir.TbSpecInfo false "Filter for filtering specs"
// @Success 200 {object} RestFilterSpecsResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/filterSpecs [post]
func RestFilterSpecs(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSpecInfo{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Filter specs]")
        content, err := mcir.FilterSpecs(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">result := RestFilterSpecsResponse{}
        result.Spec = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}

// RestFilterSpecsByRange godoc
// @Summary Filter specs by range
// @Description Filter specs by range
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specRangeFilter body mcir.FilterSpecsByRangeRequest false "Filter for range-filtering specs"
// @Success 200 {object} RestFilterSpecsResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/filterSpecsByRange [post]
func RestFilterSpecsByRange(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcir.FilterSpecsByRangeRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Filter specs]")
        content, err := mcir.FilterSpecsByRange(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">result := RestFilterSpecsResponse{}
        result.Spec = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}

func RestTestSortSpecs(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSpecInfo{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Filter specs]")
        content, err := mcir.FilterSpecs(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">content, err = mcir.SortSpecs(content, "mem_GiB", "descending")
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">result := RestFilterSpecsResponse{}
        result.Spec = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}

// RestGetSpec godoc
// @Summary Get spec
// @Description Get spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specId path string true "Spec ID"
// @Success 200 {object} mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec/{specId} [get]
func RestGetSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllSpec
type RestGetAllSpecResponse struct {
        Spec []mcir.TbSpecInfo `json:"spec"`
}

// RestGetAllSpec godoc
// @Summary List all specs or specs' ID
// @Description List all specs or specs' ID
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllSpecResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec [get]
func RestGetAllSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelSpec godoc
// @Summary Delete spec
// @Description Delete spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specId path string true "Spec ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec/{specId} [delete]
func RestDelSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllSpec godoc
// @Summary Delete all specs
// @Description Delete all specs
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec [delete]
func RestDelAllSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostSshKey godoc
// @Summary Create SSH Key
// @Description Create SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param sshKeyInfo body mcir.TbSshKeyReq true "Details for an SSH Key object"
// @Success 200 {object} mcir.TbSshKeyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey [post]
func RestPostSshKey(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSshKeyReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[POST SshKey")
        //fmt.Println("[Creating SshKey]")
        //content, responseCode, _, err := CreateSshKey(nsId, u)
        content, err := mcir.CreateSshKey(nsId, u)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>
}

/* function RestPutSshKey not yet implemented
// RestPutSshKey godoc
// @Summary Update SSH Key
// @Description Update SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param sshKeyInfo body mcir.TbSshKeyInfo true "Details for an SSH Key object"
// @Success 200 {object} mcir.TbSshKeyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey/{sshKeyId} [put]
*/
func RestPutSshKey(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// RestGetSshKey godoc
// @Summary Get SSH Key
// @Description Get SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param sshKeyId path string true "SSH Key ID"
// @Success 200 {object} mcir.TbSshKeyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey/{sshKeyId} [get]
func RestGetSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response struct for RestGetAllSshKey
type RestGetAllSshKeyResponse struct {
        SshKey []mcir.TbSshKeyInfo `json:"sshKey"`
}

// RestGetAllSshKey godoc
// @Summary List all SSH Keys or SSH Keys' ID
// @Description List all SSH Keys or SSH Keys' ID
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllSshKeyResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey [get]
func RestGetAllSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelSshKey godoc
// @Summary Delete SSH Key
// @Description Delete SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param sshKeyId path string true "SSH Key ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey/{sshKeyId} [delete]
func RestDelSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllSshKey godoc
// @Summary Delete all SSH Keys
// @Description Delete all SSH Keys
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey [delete]
func RestDelAllSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostVNet godoc
// @Summary Create VNet
// @Description Create VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param vNetReq body mcir.TbVNetReq true "Details for an VNet object"
// @Success 200 {object} mcir.TbVNetInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet [post]
func RestPostVNet(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbVNetReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[POST VNet]")
        //fmt.Println("[Creating VNet]")
        //content, responseCode, body, err := CreateVNet(nsId, u)
        content, err := mcir.CreateVNet(nsId, u)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                /*
                        mapA := map[string]string{
                                "message": "Failed to create a vNet"}
                */
                //return c.JSONBlob(responseCode, body)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>
}

/* function RestPutVNet not yet implemented
// RestPutVNet godoc
// @Summary Update VNet
// @Description Update VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param vNetInfo body mcir.TbVNetInfo true "Details for an VNet object"
// @Success 200 {object} mcir.TbVNetInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet/{vNetId} [put]
*/
func RestPutVNet(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// RestGetVNet godoc
// @Summary Get VNet
// @Description Get VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param vNetId path string true "VNet ID"
// @Success 200 {object} mcir.TbVNetInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet/{vNetId} [get]
func RestGetVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllVNet
type RestGetAllVNetResponse struct {
        VNet []mcir.TbVNetInfo `json:"vNet"`
}

// RestGetAllVNet godoc
// @Summary List all VNets or VNets' ID
// @Description List all VNets or VNets' ID
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllVNetResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet [get]
func RestGetAllVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelVNet godoc
// @Summary Delete VNet
// @Description Delete VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param vNetId path string true "VNet ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet/{vNetId} [delete]
func RestDelVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllVNet godoc
// @Summary Delete all VNets
// @Description Delete all VNets
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet [delete]
func RestDelAllVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package mcis

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestPostMcis godoc
// @Summary Create MCIS
// @Description Create MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisReq body TbMcisReq true "Details for an MCIS object"
// @Success 200 {object} TbMcisInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis [post]
func RestPostMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        req := &amp;mcis.TbMcisReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result, err := mcis.CreateMcis(nsId, req)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        //fmt.Printf("%+v\n", *result)
        <span class="cov0" title="0">common.PrintJsonPretty(*result)

        return c.JSON(http.StatusCreated, result)</span>
}

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

func RestTestListVmId(c echo.Context) error <span class="cov0" title="0">{ // for debug
        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        vmList, err := mcis.ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        // mapA := map[string]string{"message": result}
        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;vmList)</span>
}

// TODO: swag does not support multiple response types (success 200) in an API.
// Annotation for API documention Need to be revised.

// RestGetMcis godoc
// @Summary Get MCIS, Action to MCIS (status, suspend, resume, reboot, terminate, refine), or Get VMs' ID
// @Description Get MCIS, Action to MCIS (status, suspend, resume, reboot, terminate, refine), or Get VMs' ID
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param action query string false "Action to MCIS" Enums(status, suspend, resume, reboot, terminate, refine)
// @Param option query string false "Option" Enums(id)
// @success 200 {object} JSONResult{[DEFAULT]=mcis.TbMcisInfo,[STATUS]=mcis.McisStatusInfo,[CONTROL]=common.SimpleMsg,[ID]=common.IdList} "Different return structures by the given action param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId} [get]
func RestGetMcis(c echo.Context) error <span class="cov0" title="0">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        action := c.QueryParam("action")
        option := c.QueryParam("option")

        if option == "id" </span><span class="cov0" title="0">{
                content := common.IdList{}
                var err error
                content.IdList, err = mcis.ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov0" title="0"> if action == "suspend" || action == "resume" || action == "reboot" || action == "terminate" || action == "refine" </span><span class="cov0" title="0">{

                result, err := mcis.HandleMcisAction(nsId, mcisId, action)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov0" title="0">mapA := map[string]string{"message": result}
                return c.JSON(http.StatusOK, &amp;mapA)</span>

        } else<span class="cov0" title="0"> if action == "status" </span><span class="cov0" title="0">{

                result, err := mcis.GetMcisStatus(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov0" title="0">var content struct {
                        Result *mcis.McisStatusInfo `json:"status"`
                }
                content.Result = result

                //fmt.Printf("%+v\n", content)
                common.PrintJsonPretty(content)

                return c.JSON(http.StatusOK, &amp;content)</span>

        } else<span class="cov0" title="0"> {

                result, err := mcis.GetMcisInfo(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                //fmt.Printf("%+v\n", *result)
                <span class="cov0" title="0">common.PrintJsonPretty(*result)
                //return by string
                //return c.String(http.StatusOK, keyValue.Value)
                return c.JSON(http.StatusOK, result)</span>

        }
}

// Response structure for RestGetAllMcis
type RestGetAllMcisResponse struct {
        Mcis []mcis.TbMcisInfo `json:"mcis"`
}

// Response structure for RestGetAllMcisStatus
type RestGetAllMcisStatusResponse struct {
        Mcis []mcis.McisStatusInfo `json:"mcis"`
}

// RestGetAllMcis godoc
// @Summary List all MCISs or MCISs' ID
// @Description List all MCISs or MCISs' ID
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllMcisResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis [get]
func RestGetAllMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        option := c.QueryParam("option")
        fmt.Println("[Get MCIS List requested with option: " + option)

        if option == "id" </span><span class="cov0" title="0">{
                content := common.IdList{}
                var err error
                content.IdList, err = mcis.ListMcisId(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov0" title="0"> if option == "status" </span><span class="cov0" title="0">{
                result, err := mcis.GetMcisStatusAll(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>
                <span class="cov0" title="0">content := RestGetAllMcisStatusResponse{}
                content.Mcis = result
                common.PrintJsonPretty(content)
                return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov0" title="0"> {
                // mcis in detail (with status information)
                detail := "status"

                result, err := mcis.CoreGetAllMcis(nsId, detail)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>
                <span class="cov0" title="0">content := RestGetAllMcisResponse{}
                content.Mcis = result
                common.PrintJsonPretty(content)
                return c.JSON(http.StatusOK, &amp;content)</span>
        }
}

/* function RestPutMcis not yet implemented
// RestPutMcis godoc
// @Summary Update MCIS
// @Description Update MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param mcisInfo body TbMcisInfo true "Details for an MCIS object"
// @Success 200 {object} TbMcisInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId} [put]
*/
func RestPutMcis(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// RestDelMcis godoc
// @Summary Delete MCIS
// @Description Delete MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param option query string false "Option for delete MCIS (support force delete)" Enums(force)
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId} [delete]
func RestDelMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        option := c.QueryParam("option")

        err := mcis.DelMcis(nsId, mcisId, option)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">mapA := map[string]string{"message": "Deleting the MCIS " + mcisId}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// RestDelAllMcis godoc
// @Summary Delete all MCISs
// @Description Delete all MCISs
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option for delete MCIS (support force delete)" Enums(force)
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis [delete]
func RestDelAllMcis(c echo.Context) error <span class="cov0" title="0">{
        nsId := c.Param("nsId")
        option := c.QueryParam("option")

        result, err := mcis.CoreDelAllMcis(nsId, option)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">mapA := map[string]string{"message": result}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

type RestPostMcisRecommendResponse struct {
        //VmReq          []TbVmRecommendReq    `json:"vmReq"`
        Vm_recommend   []mcis.TbVmRecommendInfo `json:"vm_recommend"`
        PlacementAlgo  string                   `json:"placementAlgo"`
        PlacementParam []common.KeyValue        `json:"placementParam"`
}

// RestPostMcisRecommend godoc
// @Summary Get MCIS recommendation
// @Description Get MCIS recommendation
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisRecommendReq body mcis.McisRecommendReq true "Details for an MCIS object"
// @Success 200 {object} RestPostMcisRecommendResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/recommend [post]
// @Deprecated
func RestPostMcisRecommend(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        req := &amp;mcis.McisRecommendReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result, err := mcis.CorePostMcisRecommend(nsId, req)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">content := RestPostMcisRecommendResponse{}
        content.Vm_recommend = result
        content.PlacementAlgo = req.PlacementAlgo
        content.PlacementParam = req.PlacementParam

        //fmt.Printf("%+v\n", content)
        common.PrintJsonPretty(content)

        return c.JSON(http.StatusCreated, content)</span>
}

type RestPostCmdMcisVmResponse struct {
        Result string `json:"result"`
}

// RestPostCmdMcisVm godoc
// @Summary Send a command to specified VM
// @Description Send a command to specified VM
// @Tags [MCIS] Remote command
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param mcisCmdReq body mcis.McisCmdReq true "MCIS Command Request"
// @Success 200 {object} RestPostCmdMcisVmResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/cmd/mcis/{mcisId}/vm/{vmId} [post]
func RestPostCmdMcisVm(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result, err := mcis.CorePostCmdMcisVm(nsId, mcisId, vmId, req)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">response := RestPostCmdMcisVmResponse{Result: result}
        return c.JSON(http.StatusOK, response)</span>
}

type RestPostCmdMcisResponse struct {
        McisId string `json:"mcisId"`
        VmId   string `json:"vmId"`
        VmIp   string `json:"vmIp"`
        Result string `json:"result"`
}

type RestPostCmdMcisResponseWrapper struct {
        Result_array []RestPostCmdMcisResponse `json:"result_array"`
}

// RestPostCmdMcis godoc
// @Summary Send a command to specified MCIS
// @Description Send a command to specified MCIS
// @Tags [MCIS] Remote command
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisCmdReq body mcis.McisCmdReq true "MCIS Command Request"
// @Success 200 {object} RestPostCmdMcisResponseWrapper
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/cmd/mcis/{mcisId} [post]
func RestPostCmdMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resultArray, err := mcis.CorePostCmdMcis(nsId, mcisId, req)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">content := RestPostCmdMcisResponseWrapper{}

        for _, v := range resultArray </span><span class="cov0" title="0">{

                resultTmp := RestPostCmdMcisResponse{}
                resultTmp.McisId = mcisId
                resultTmp.VmId = v.VmId
                resultTmp.VmIp = v.VmIp
                resultTmp.Result = v.Result
                content.Result_array = append(content.Result_array, resultTmp)
                //fmt.Println("result from goroutin " + v)
        }</span>

        //fmt.Printf("%+v\n", content)
        <span class="cov0" title="0">common.PrintJsonPretty(content)

        return c.JSON(http.StatusOK, content)</span>

}

// RestPostInstallAgentToMcis godoc
// @Summary Install the benchmark agent to specified MCIS
// @Description Install the benchmark agent to specified MCIS
// @Tags [MCIS] Performance benchmarking (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisCmdReq body mcis.McisCmdReq true "MCIS Command Request"
// @Success 200 {object} mcis.AgentInstallContentWrapper
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/install/mcis/{mcisId} [post]
func RestPostInstallAgentToMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := mcis.InstallAgentToMcis(nsId, mcisId, req)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, content)</span>
}

// RestPostMcisVm godoc
// @Summary Create VM in specified MCIS
// @Description Create VM in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmReq body mcis.TbVmReq true "Details for an VM object"
// @Success 200 {object} mcis.TbVmInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm [post]
func RestPostMcisVm(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        vmInfoData := &amp;mcis.TbVmInfo{}
        if err := c.Bind(vmInfoData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">common.PrintJsonPretty(*vmInfoData)

        result, err := mcis.CorePostMcisVm(nsId, mcisId, vmInfoData)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">common.PrintJsonPretty(*result)

        return c.JSON(http.StatusCreated, result)</span>
}

// RestPostMcisVmGroup godoc
// @Summary Create multiple VMs by VM group in specified MCIS
// @Description Create multiple VMs by VM group in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmReq body mcis.TbVmReq true "Details for VM Group"
// @Success 200 {object} mcis.TbMcisInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vmgroup [post]
func RestPostMcisVmGroup(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        vmInfoData := &amp;mcis.TbVmReq{}
        if err := c.Bind(vmInfoData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">common.PrintJsonPretty(*vmInfoData)

        result, err := mcis.CorePostMcisGroupVm(nsId, mcisId, vmInfoData)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">common.PrintJsonPretty(*result)

        return c.JSON(http.StatusCreated, result)</span>
}

// TODO: swag does not support multiple response types (success 200) in an API.
// Annotation for API documention Need to be revised.

// RestGetMcisVm godoc
// @Summary Get VM in specified MCIS
// @Description Get VM in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param action query string false "Action to MCIS" Enums(status, suspend, resume, reboot, terminate)
// @success 200 {object} JSONResult{[DEFAULT]=mcis.TbVmInfo,[STATUS]=mcis.TbVmStatusInfo,[CONTROL]=common.SimpleMsg} "Different return structures by the given action param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm/{vmId} [get]
func RestGetMcisVm(c echo.Context) error <span class="cov0" title="0">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")

        action := c.QueryParam("action")

        if action == "suspend" || action == "resume" || action == "reboot" || action == "terminate" </span><span class="cov0" title="0">{

                result, err := mcis.CoreGetMcisVmAction(nsId, mcisId, vmId, action)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov0" title="0">mapA := map[string]string{"message": result}
                return c.JSON(http.StatusOK, &amp;mapA)</span>

        } else<span class="cov0" title="0"> if action == "status" </span><span class="cov0" title="0">{

                result, err := mcis.CoreGetMcisVmStatus(nsId, mcisId, vmId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                //fmt.Printf("%+v\n", *result)
                <span class="cov0" title="0">common.PrintJsonPretty(*result)

                return c.JSON(http.StatusOK, result)</span>

        } else<span class="cov0" title="0"> {

                result, err := mcis.CoreGetMcisVmInfo(nsId, mcisId, vmId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                //fmt.Printf("%+v\n", *result)
                <span class="cov0" title="0">common.PrintJsonPretty(*result)

                //return by string
                //return c.String(http.StatusOK, keyValue.Value)
                return c.JSON(http.StatusOK, result)</span>

        }
}

/* RestPutMcisVm function not yet implemented
// RestPutSshKey godoc
// @Summary Update MCIS
// @Description Update MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param vmInfo body mcis.TbVmInfo true "Details for an VM object"
// @Success 200 {object} mcis.TbVmInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm/{vmId} [put]
*/
func RestPutMcisVm(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// RestDelMcisVm godoc
// @Summary Delete VM in specified MCIS
// @Description Delete VM in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param option query string false "Option for delete VM (support force delete)" Enums(force)
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm/{vmId} [delete]
func RestDelMcisVm(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")
        option := c.QueryParam("option")

        err := mcis.DelMcisVm(nsId, mcisId, vmId, option)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": "Failed to delete the VM info"}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">mapA := map[string]string{"message": "Deleting the VM info"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// Request struct for RestGetAllBenchmark
type RestGetAllBenchmarkRequest struct {
        Host string `json:"host"`
}

// RestGetAllBenchmark godoc
// @Summary Run MCIS benchmark for all performance metrics and return results
// @Description Run MCIS benchmark for all performance metrics and return results
// @Tags [MCIS] Performance benchmarking (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param hostIP body RestGetAllBenchmarkRequest true "Host IP address to benchmark"
// @Success 200 {object} mcis.BenchmarkInfoArray
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/benchmarkall/mcis/{mcisId} [post]
func RestGetAllBenchmark(c echo.Context) error <span class="cov0" title="0">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        /*
                type bmReq struct {
                        Host string `json:"host"`
                }
                req := &amp;bmReq{}
        */
        req := &amp;RestGetAllBenchmarkRequest{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result, err := mcis.CoreGetAllBenchmark(nsId, mcisId, req.Host)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">common.PrintJsonPretty(*result)
        return c.JSON(http.StatusOK, result)</span>
}

type RestGetBenchmarkRequest struct {
        Host string `json:"host"`
}

// RestGetBenchmark godoc
// @Summary Run MCIS benchmark for a single performance metric and return results
// @Description Run MCIS benchmark for a single performance metric and return results
// @Tags [MCIS] Performance benchmarking (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param hostIP body RestGetBenchmarkRequest true "Host IP address to benchmark"
// @Param action query string true "Benchmark Action to MCIS" Enums(install, init, cpus, cpum, memR, memW, fioR, fioW, dbR, dbW, rtt, mrtt, clean)
// @Success 200 {object} mcis.BenchmarkInfoArray
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/benchmark/mcis/{mcisId} [post]
func RestGetBenchmark(c echo.Context) error <span class="cov0" title="0">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        action := c.QueryParam("action")

        /*
                type bmReq struct {
                        Host string `json:"host"`
                }
                req := &amp;bmReq{}
        */
        req := &amp;RestGetBenchmarkRequest{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result, err := mcis.CoreGetBenchmark(nsId, mcisId, action, req.Host)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">common.PrintJsonPretty(*result)
        return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mcis

import (
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestPostInstallMonitorAgentToMcis godoc
// @Summary Install monitoring agent (CB-Dragonfly agent) to MCIS
// @Description Install monitoring agent (CB-Dragonfly agent) to MCIS
// @Tags [MCIS] Resource monitor (Developer)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisInfo body mcis.McisCmdReq true "Details for an MCIS object"
// @Success 200 {object} mcis.AgentInstallContentWrapper
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/monitoring/install/mcis/{mcisId} [post]
func RestPostInstallMonitorAgentToMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := mcis.InstallMonitorAgentToMcis(nsId, mcisId, req)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, content)</span>
}

// RestGetMonitorData godoc
// @Summary Get monitoring data of specified MCIS for specified monitoring metric (cpu, memory, disk, network)
// @Description Get monitoring data of specified MCIS for specified monitoring metric (cpu, memory, disk, network)
// @Tags [MCIS] Resource monitor (Developer)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param metric path string true "Metric type: cpu, memory, disk, network"
// @Success 200 {object} mcis.MonResultSimpleResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/monitoring/mcis/{mcisId}/metric/{metric} [get]
func RestGetMonitorData(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        metric := c.Param("metric")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := mcis.GetMonitoringData(nsId, mcisId, metric)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, content)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package mcis

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestPostMcisPolicy godoc
// @Summary Create MCIS Automation policy
// @Description Create MCIS Automation policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisInfo body mcis.McisPolicyInfo true "Details for an MCIS object"
// @Success 200 {object} mcis.McisPolicyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [post]
func RestPostMcisPolicy(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisPolicyInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := mcis.CreateMcisPolicy(nsId, mcisId, req)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, content)</span>
}

// RestGetMcisPolicy godoc
// @Summary Get MCIS Policy
// @Description Get MCIS Policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Success 200 {object} mcis.McisPolicyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [get]
func RestGetMcisPolicy(c echo.Context) error <span class="cov0" title="0">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        result, err := mcis.GetMcisPolicyObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": "Error to find McisPolicyObject : " + mcisId + "ERROR : " + err.Error()}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span>

        <span class="cov0" title="0">if result.Id == "" </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": "Failed to find McisPolicyObject : " + mcisId}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span>

        <span class="cov0" title="0">common.PrintJsonPretty(result)
        return c.JSON(http.StatusOK, result)</span>

}

// Response structure for RestGetAllMcisPolicy
type RestGetAllMcisPolicyResponse struct {
        McisPolicy []mcis.McisPolicyInfo `json:"mcisPolicy"`
}

// RestGetAllMcisPolicy godoc
// @Summary List all MCIS policies
// @Description List all MCIS policies
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} RestGetAllMcisPolicyResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis [get]
func RestGetAllMcisPolicy(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        fmt.Println("[Get MCIS Policy List]")

        result, err := mcis.GetAllMcisPolicyObject(nsId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span>

        <span class="cov0" title="0">content := RestGetAllMcisPolicyResponse{}
        content.McisPolicy = result

        //fmt.Printf("content %+v\n", content)
        common.PrintJsonPretty(content)

        return c.JSON(http.StatusOK, &amp;content)</span>

}

/* function RestPutMcisPolicy not yet implemented
// RestPutMcisPolicy godoc
// @Summary Update MCIS Policy
// @Description Update MCIS Policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param mcisInfo body McisPolicyInfo true "Details for an MCIS Policy object"
// @Success 200 {object} McisPolicyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [put]
*/
func RestPutMcisPolicy(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// DelMcisPolicy godoc
// @Summary Delete MCIS Policy
// @Description Delete MCIS Policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [delete]
func RestDelMcisPolicy(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        err := mcis.DelMcisPolicy(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": "Failed to delete the MCIS Policy"}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">mapA := map[string]string{"message": "Deleting the MCIS Policy info"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// RestDelAllMcisPolicy godoc
// @Summary Delete all MCIS policies
// @Description Delete all MCIS policies
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis [delete]
func RestDelAllMcisPolicy(c echo.Context) error <span class="cov0" title="0">{
        nsId := c.Param("nsId")
        result, err := mcis.DelAllMcisPolicy(nsId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov0" title="0">mapA := map[string]string{"message": result}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package mcis

import (
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestRecommendVm godoc
// @Summary Recommend MCIS plan (filter and priority)
// @Description Recommend MCIS plan (filter and priority)
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param deploymentPlan body mcis.DeploymentPlan false "Recommend MCIS plan (filter and priority)"
// @Success 200 {object} []mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/testRecommendVm [post]
func RestRecommendVm(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcis.DeploymentPlan{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := mcis.RecommendVm(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        // result := RestFilterSpecsResponse{}
        // result.Spec = content
        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package mcis

import (
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

func RestCheckMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        exists, err := mcis.CheckMcis(nsId, mcisId)

        type JsonTemplate struct {
                Exists bool `json:"exists"`
        }
        content := JsonTemplate{}
        content.Exists = exists

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //mapA := map[string]string{"message": err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return c.JSON(http.StatusNotFound, &amp;content)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
}

func RestCheckVm(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")

        exists, err := mcis.CheckVm(nsId, mcisId, vmId)

        type JsonTemplate struct {
                Exists bool `json:"exists"`
        }
        content := JsonTemplate{}
        content.Exists = exists

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //mapA := map[string]string{"message": err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return c.JSON(http.StatusNotFound, &amp;content)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package common

import (
        "database/sql"
        "time"

        cbstore "github.com/cloud-barista/cb-store"
        "github.com/cloud-barista/cb-store/config"
        icbs "github.com/cloud-barista/cb-store/interfaces"
        "github.com/sirupsen/logrus"
        "xorm.io/xorm"
)

type KeyValue struct {
        Key   string
        Value string
}

type IdList struct {
        IdList []string `json:"idList"`
}

// CB-Store
var CBLog *logrus.Logger
var CBStore icbs.Store

var SPIDER_REST_URL string
var DRAGONFLY_REST_URL string
var DB_URL string
var DB_DATABASE string
var DB_USER string
var DB_PASSWORD string
var AUTOCONTROL_DURATION_MS string
var MYDB *sql.DB
var err error
var ORM *xorm.Engine

const (
        StrSPIDER_REST_URL            string = "SPIDER_REST_URL"
        StrDRAGONFLY_REST_URL         string = "DRAGONFLY_REST_URL"
        StrDB_URL                     string = "DB_URL"
        StrDB_DATABASE                string = "DB_DATABASE"
        StrDB_USER                    string = "DB_USER"
        StrDB_PASSWORD                string = "DB_PASSWORD"
        StrAUTOCONTROL_DURATION_MS    string = "AUTOCONTROL_DURATION_MS"
        CbStoreKeyNotFoundErrorString string = "key not found"
        StrAdd                        string = "add"
        StrDelete                     string = "delete"
        StrSSHKey                     string = "sshKey"
        StrImage                      string = "image"
        StrSecurityGroup              string = "securityGroup"
        StrSpec                       string = "spec"
        StrVNet                       string = "vNet"
)

var StartTime string

func init() <span class="cov8" title="1">{
        CBLog = config.Cblogger
        CBStore = cbstore.GetStore()

        StartTime = time.Now().Format("2006.01.02 15:04:05 Mon")
}</span>

// Spider 2020-03-30 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/IId.go
type IID struct {
        NameId   string // NameID by user
        SystemId string // SystemID by CloudOS
}

type SpiderConnectionName struct {
        ConnectionName string `json:"ConnectionName"`
}

func OpenSQL(path string) error <span class="cov0" title="0">{
        /*
                common.MYDB, err = sql.Open("mysql", //"root:pwd@tcp(127.0.0.1:3306)/testdb")
                        common.DB_USER+":"+
                                common.DB_PASSWORD+"@tcp("+
                                common.DB_URL+")/"+
                                common.DB_DATABASE)
        */

        fullPathString := "file:" + path
        MYDB, err = sql.Open("sqlite3", fullPathString)
        return err
}</span>

func SelectDatabase(database string) error <span class="cov0" title="0">{
        query := "USE " + database + ";"
        _, err = MYDB.Exec(query)
        return err
}</span>

/*
func CreateSpecTable() error {
        stmt, err := MYDB.Prepare("CREATE Table IF NOT EXISTS spec(" +
                "namespace varchar(50) NOT NULL," +
                "id varchar(50) NOT NULL," +
                "connectionName varchar(50) NOT NULL," +
                "cspSpecName varchar(50) NOT NULL," +
                "name varchar(50)," +
                "os_type varchar(50)," +
                "num_vCPU SMALLINT," + // SMALLINT: -32768 ~ 32767
                "num_core SMALLINT," + // SMALLINT: -32768 ~ 32767
                "mem_GiB SMALLINT," + // SMALLINT: -32768 ~ 32767
                "storage_GiB MEDIUMINT," + // MEDIUMINT: -8388608 to 8388607
                "description varchar(50)," +
                "cost_per_hour FLOAT," +
                "num_storage SMALLINT," + // SMALLINT: -32768 ~ 32767
                "max_num_storage SMALLINT," + // SMALLINT: -32768 ~ 32767
                "max_total_storage_TiB SMALLINT," + // SMALLINT: -32768 ~ 32767
                "net_bw_Gbps SMALLINT," + // SMALLINT: -32768 ~ 32767
                "ebs_bw_Mbps MEDIUMINT," + // MEDIUMINT: -8388608 to 8388607
                "gpu_model varchar(50)," +
                "num_gpu SMALLINT," + // SMALLINT: -32768 ~ 32767
                "gpumem_GiB SMALLINT," + // SMALLINT: -32768 ~ 32767
                "gpu_p2p varchar(50)," +
                "orderInFilteredResult SMALLINT," + // SMALLINT: -32768 ~ 32767
                "evaluationStatus varchar(50)," +
                "evaluationScore_01 FLOAT," +
                "evaluationScore_02 FLOAT," +
                "evaluationScore_03 FLOAT," +
                "evaluationScore_04 FLOAT," +
                "evaluationScore_05 FLOAT," +
                "evaluationScore_06 FLOAT," +
                "evaluationScore_07 FLOAT," +
                "evaluationScore_08 FLOAT," +
                "evaluationScore_09 FLOAT," +
                "evaluationScore_10 FLOAT," +
                "CONSTRAINT PK_Spec PRIMARY KEY (namespace, id));")
        if err != nil {
                fmt.Println(err.Error())
        }
        _, err = stmt.Exec()

        return err
}

func CreateImageTable() error {
        stmt, err := MYDB.Prepare("CREATE Table IF NOT EXISTS image(" +
                "namespace varchar(50) NOT NULL," +
                "id varchar(50) NOT NULL," +
                "name varchar(50)," +
                "connectionName varchar(50) NOT NULL," +
                "cspImageId varchar(400) NOT NULL," +
                "cspImageName varchar(400) NOT NULL," +
                "creationDate varchar(50) NOT NULL," +
                "description varchar(400) NOT NULL," +
                "guestOS varchar(50) NOT NULL," +
                "status varchar(50) NOT NULL," +
                "CONSTRAINT PK_Image PRIMARY KEY (namespace, id));")
        if err != nil {
                fmt.Println(err.Error())
        }
        _, err = stmt.Exec()

        return err
}
*/
</pre>
		
		<pre class="file" id="file15" style="display: none">package common

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        cbstore_utils "github.com/cloud-barista/cb-store/utils"
)

// swagger:request ConfigReq
type ConfigReq struct {
        Name  string `json:"name" example:"SPIDER_REST_URL"`
        Value string `json:"value" example:"http://localhost:1024/spider"`
}

// swagger:response ConfigInfo
type ConfigInfo struct {
        Id    string `json:"id" example:"SPIDER_REST_URL"`
        Name  string `json:"name" example:"SPIDER_REST_URL"`
        Value string `json:"value" example:"http://localhost:1024/spider"`
}

func UpdateConfig(u *ConfigReq) (ConfigInfo, error) <span class="cov0" title="0">{

        if u.Name == "" </span><span class="cov0" title="0">{
                temp := ConfigInfo{}
                err := fmt.Errorf("The provided name is empty.")
                return temp, err
        }</span>

        <span class="cov0" title="0">content := ConfigInfo{}
        content.Id = u.Name
        content.Name = u.Name
        content.Value = u.Value

        key := "/config/" + content.Id
        //mapA := map[string]string{"name": content.Name, "description": content.Description}
        val, _ := json.Marshal(content)
        err = CBStore.Put(string(key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := CBStore.Get(string(key))
        fmt.Println("UpdateConfig(); ===========================")
        fmt.Println("UpdateConfig(); Key: " + keyValue.Key + "\nValue: " + keyValue.Value)
        fmt.Println("UpdateConfig(); ===========================")

        UpdateGlobalVariable(content.Id)

        return content, nil</span>
}

func UpdateGlobalVariable(id string) error <span class="cov8" title="1">{

        /*
                common.SPIDER_REST_URL = common.NVL(os.Getenv("SPIDER_REST_URL"), "http://localhost:1024/spider")
                common.DRAGONFLY_REST_URL = common.NVL(os.Getenv("DRAGONFLY_REST_URL"), "http://localhost:9090/dragonfly")
                common.DB_URL = common.NVL(os.Getenv("DB_URL"), "localhost:3306")
                common.DB_DATABASE = common.NVL(os.Getenv("DB_DATABASE"), "cb_tumblebug")
                common.DB_USER = common.NVL(os.Getenv("DB_USER"), "cb_tumblebug")
                common.DB_PASSWORD = common.NVL(os.Getenv("DB_PASSWORD"), "cb_tumblebug")
        */

        configInfo, err := GetConfig(id)
        if err != nil </span><span class="cov8" title="1">{
                //CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">switch id </span>{
        case StrSPIDER_REST_URL:<span class="cov0" title="0">
                SPIDER_REST_URL = configInfo.Value
                fmt.Println("&lt;SPIDER_REST_URL&gt; " + SPIDER_REST_URL)</span>
        case StrDRAGONFLY_REST_URL:<span class="cov0" title="0">
                DRAGONFLY_REST_URL = configInfo.Value
                fmt.Println("&lt;DRAGONFLY_REST_URL&gt; " + DRAGONFLY_REST_URL)</span>
        case StrDB_URL:<span class="cov0" title="0">
                DB_URL = configInfo.Value
                fmt.Println("&lt;DB_URL&gt; " + DB_URL)</span>
        case StrDB_DATABASE:<span class="cov0" title="0">
                DB_DATABASE = configInfo.Value
                fmt.Println("&lt;DB_DATABASE&gt; " + DB_DATABASE)</span>
        case StrDB_USER:<span class="cov0" title="0">
                DB_USER = configInfo.Value
                fmt.Println("&lt;DB_USER&gt; " + DB_USER)</span>
        case StrDB_PASSWORD:<span class="cov0" title="0">
                DB_PASSWORD = configInfo.Value
                fmt.Println("&lt;DB_PASSWORD&gt; " + DB_PASSWORD)</span>
        case StrAUTOCONTROL_DURATION_MS:<span class="cov0" title="0">
                AUTOCONTROL_DURATION_MS = configInfo.Value
                fmt.Println("&lt;AUTOCONTROL_DURATION_MS&gt; " + AUTOCONTROL_DURATION_MS)</span>
        default:<span class="cov0" title="0"></span>

        }

        <span class="cov0" title="0">return nil</span>
}

func InitConfig(id string) error <span class="cov0" title="0">{

        switch id </span>{
        case StrSPIDER_REST_URL:<span class="cov0" title="0">
                SPIDER_REST_URL = NVL(os.Getenv("SPIDER_REST_URL"), "http://localhost:1024/spider")
                fmt.Println("&lt;SPIDER_REST_URL&gt; " + SPIDER_REST_URL)</span>
        case StrDRAGONFLY_REST_URL:<span class="cov0" title="0">
                DRAGONFLY_REST_URL = NVL(os.Getenv("DRAGONFLY_REST_URL"), "http://localhost:9090/dragonfly")
                fmt.Println("&lt;DRAGONFLY_REST_URL&gt; " + DRAGONFLY_REST_URL)</span>
        case StrDB_URL:<span class="cov0" title="0">
                DB_URL = NVL(os.Getenv("DB_URL"), "localhost:3306")
                fmt.Println("&lt;DB_URL&gt; " + DB_URL)</span>
        case StrDB_DATABASE:<span class="cov0" title="0">
                DB_DATABASE = NVL(os.Getenv("DB_DATABASE"), "cb_tumblebug")
                fmt.Println("&lt;DB_DATABASE&gt; " + DB_DATABASE)</span>
        case StrDB_USER:<span class="cov0" title="0">
                DB_USER = NVL(os.Getenv("DB_USER"), "cb_tumblebug")
                fmt.Println("&lt;DB_USER&gt; " + DB_USER)</span>
        case StrDB_PASSWORD:<span class="cov0" title="0">
                DB_PASSWORD = NVL(os.Getenv("DB_PASSWORD"), "cb_tumblebug")
                fmt.Println("&lt;DB_PASSWORD&gt; " + DB_PASSWORD)</span>
        case StrAUTOCONTROL_DURATION_MS:<span class="cov0" title="0">
                AUTOCONTROL_DURATION_MS = NVL(os.Getenv("AUTOCONTROL_DURATION_MS"), "10000")
                fmt.Println("&lt;AUTOCONTROL_DURATION_MS&gt; " + AUTOCONTROL_DURATION_MS)</span>
        default:<span class="cov0" title="0"></span>

        }

        <span class="cov0" title="0">check, err := CheckConfig(id)

        if check &amp;&amp; err == nil </span><span class="cov0" title="0">{
                fmt.Println("[Init config] " + id)
                key := "/config/" + id
                //fmt.Println(key)

                CBStore.Delete(key)
                // if err != nil {
                //         CBLog.Error(err)
                //         return err
                // }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetConfig(id string) (ConfigInfo, error) <span class="cov8" title="1">{

        res := ConfigInfo{}

        check, err := CheckConfig(id)

        if !check </span><span class="cov8" title="1">{
                errString := "The config " + id + " does not exist."
                err := fmt.Errorf(errString)
                return res, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                temp := ConfigInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Get config] " + id)
        key := "/config/" + id
        //fmt.Println(key)

        keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>

        <span class="cov0" title="0">fmt.Println("&lt;" + keyValue.Key + "&gt; " + keyValue.Value)
        //fmt.Println("===============================================")

        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func ListConfig() ([]ConfigInfo, error) <span class="cov0" title="0">{
        fmt.Println("[List config]")
        key := "/config"
        fmt.Println(key)

        keyValue, err := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                res := []ConfigInfo{}
                for _, v := range keyValue </span><span class="cov0" title="0">{
                        tempObj := ConfigInfo{}
                        err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                        if err != nil </span><span class="cov0" title="0">{
                                CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">res = append(res, tempObj)</span>
                }
                <span class="cov0" title="0">return res, nil</span>
                //return true, nil
        }
        <span class="cov0" title="0">return nil, nil</span> // When err == nil &amp;&amp; keyValue == nil
}

func ListConfigId() []string <span class="cov0" title="0">{

        fmt.Println("[List config]")
        key := "/config"
        fmt.Println(key)

        keyValue, _ := CBStore.GetList(key, true)

        var configList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                configList = append(configList, strings.TrimPrefix(v.Key, "/config/"))
        }</span>
        <span class="cov0" title="0">for _, v := range configList </span><span class="cov0" title="0">{
                fmt.Println("&lt;" + v + "&gt; \n")
        }</span>
        <span class="cov0" title="0">fmt.Println("===============================================")
        return configList</span>

}

/*
func DelAllConfig() error {
        fmt.Printf("DelAllConfig() called;")

        key := "/config"
        fmt.Println(key)
        keyValue, _ := CBStore.GetList(key, true)

        if len(keyValue) == 0 {
                return nil
        }

        for _, v := range keyValue {
                err = CBStore.Delete(v.Key)
                if err != nil {
                        return err
                }
        }
        return nil
}
*/

func InitAllConfig() error <span class="cov0" title="0">{
        fmt.Printf("InitAllConfig() called;")

        configIdList := ListConfigId()

        for _, v := range configIdList </span><span class="cov0" title="0">{
                InitConfig(v)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func CheckConfig(id string) (bool, error) <span class="cov8" title="1">{

        if id == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckConfig failed; configId given is null.")
                return false, err
        }</span>

        <span class="cov8" title="1">key := "/config/" + id
        //fmt.Println(key)

        keyValue, _ := CBStore.Get(key)
        if keyValue != nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package common

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"

        cbstore_utils "github.com/cloud-barista/cb-store/utils"
)

type NsReq struct {
        Name        string `json:"name"`
        Description string `json:"description"`
}

// swagger:response NsInfo
type NsInfo struct {
        Id          string `json:"id" example:"namespaceid01"`
        Name        string `json:"name" example:"namespacename01"`
        Description string `json:"description" example:"Description for this namespace"`
}

func NsValidation() echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        fmt.Printf("%v\n", "[Handle API Request]")
                        nsId := c.Param("nsId")
                        if nsId == "" </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov0" title="0">err := CheckString(nsId)
                        if err != nil </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusNotFound, "The first character of name must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.")
                        }</span>

                        <span class="cov0" title="0">check, err := CheckNs(nsId)

                        if !check || err != nil </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusNotFound, "Not valid namespace")
                        }</span>
                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

func CreateNs(u *NsReq) (NsInfo, error) <span class="cov8" title="1">{
        err := CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">check, err := CheckNs(u.Name)

        if check </span><span class="cov0" title="0">{
                temp := NsInfo{}
                err := fmt.Errorf("CreateNs(); The namespace " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">content := NsInfo{}
        //content.Id = GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.Description = u.Description

        // TODO here: implement the logic

        fmt.Println("CreateNs();")
        Key := "/ns/" + content.Id
        //mapA := map[string]string{"name": content.Name, "description": content.Description}
        Val, _ := json.Marshal(content)
        err = CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := CBStore.Get(string(Key))
        fmt.Println("CreateNs(); ===========================")
        fmt.Println("CreateNs(); Key: " + keyValue.Key + "\nValue: " + keyValue.Value)
        fmt.Println("CreateNs(); ===========================")
        return content, nil</span>
}

func GetNs(id string) (NsInfo, error) <span class="cov0" title="0">{

        res := NsInfo{}

        err := CheckString(id)
        if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, err := CheckNs(id)

        if !check </span><span class="cov0" title="0">{
                errString := "The namespace " + id + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return res, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Get namespace] " + id)
        key := "/ns/" + id
        fmt.Println(key)

        keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>

        <span class="cov0" title="0">fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===============================================")

        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func ListNs() ([]NsInfo, error) <span class="cov0" title="0">{
        fmt.Println("[List namespace]")
        key := "/ns"
        fmt.Println(key)

        keyValue, err := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                res := []NsInfo{}
                for _, v := range keyValue </span><span class="cov0" title="0">{
                        tempObj := NsInfo{}
                        err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                        if err != nil </span><span class="cov0" title="0">{
                                CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">res = append(res, tempObj)</span>
                }
                <span class="cov0" title="0">return res, nil</span>
                //return true, nil
        }
        <span class="cov0" title="0">return nil, nil</span> // When err == nil &amp;&amp; keyValue == nil
}

func AppendIfMissing(slice []string, i string) []string <span class="cov0" title="0">{
        for _, ele := range slice </span><span class="cov0" title="0">{
                if ele == i </span><span class="cov0" title="0">{
                        return slice
                }</span>
        }
        <span class="cov0" title="0">return append(slice, i)</span>
}

func ListNsId() ([]string, error) <span class="cov0" title="0">{

        //fmt.Println("[List ns]")
        key := "/ns"
        //fmt.Println(key)

        var nsList []string

        // Implementation Option 1
        // keyValue, _ := CBStore.GetList(key, true)

        // r, _ := regexp.Compile("/ns/[a-z]([-a-z0-9]*[a-z0-9])?$")

        // for _, v := range keyValue {

        //         if v.Key == "" {
        //                 continue
        //         }

        //         filtered := r.FindString(v.Key)

        //         if filtered != v.Key {
        //                 continue
        //         } else {
        //                 trimmedString := strings.TrimPrefix(v.Key, "/ns/")
        //                 nsList = AppendIfMissing(nsList, trimmedString)
        //         }
        // }
        // EOF of Implementation Option 1

        // Implementation Option 2
        keyValue, err := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                for _, v := range keyValue </span><span class="cov0" title="0">{
                        trimmedString := strings.TrimPrefix(v.Key, "/ns/")
                        nsList = append(nsList, trimmedString)
                }</span>
        }
        // EOF of Implementation Option 2

        //for _, v := range nsList {
        //        fmt.Println("&lt;" + v + "&gt; \n")
        //}
        //fmt.Println("===============================================")
        <span class="cov0" title="0">return nsList, nil</span>

}

func DelNs(id string) error <span class="cov0" title="0">{

        err := CheckString(id)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">check, err := CheckNs(id)

        if !check </span><span class="cov0" title="0">{
                errString := "The namespace " + id + " does not exist."
                err := fmt.Errorf(errString)
                return err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Delete ns] " + id)
        key := "/ns/" + id
        fmt.Println(key)

        mcisList := GetChildIdList(key + "/mcis")
        imageList := GetChildIdList(key + "/resources/image")
        vNetList := GetChildIdList(key + "/resources/vNet")
        //subnetList := GetChildIdList(key + "/resources/subnet")
        //publicIpList := GetChildIdList(key + "/resources/publicIp")
        securityGroupList := GetChildIdList(key + "/resources/securityGroup")
        specList := GetChildIdList(key + "/resources/spec")
        sshKeyList := GetChildIdList(key + "/resources/sshKey")
        //vNicList := GetChildIdList(key + "/resources/vNic")

        if len(mcisList)+
                len(imageList)+
                len(vNetList)+
                //len(subnetList)
                len(securityGroupList)+
                len(specList)+
                len(sshKeyList) &gt; 0 </span><span class="cov0" title="0">{
                errString := "Cannot delete NS " + id + ", which is not empty. There exists at least one MCIS or one of resources."
                errString += " \n len(mcisList): " + strconv.Itoa(len(mcisList))
                errString += " \n len(imageList): " + strconv.Itoa(len(imageList))
                errString += " \n len(vNetList): " + strconv.Itoa(len(vNetList))
                //errString += " \n len(publicIpList): " + strconv.Itoa(len(publicIpList))
                errString += " \n len(securityGroupList): " + strconv.Itoa(len(securityGroupList))
                errString += " \n len(specList): " + strconv.Itoa(len(specList))
                errString += " \n len(sshKeyList): " + strconv.Itoa(len(sshKeyList))
                //errString += " \n len(subnetList): " + strconv.Itoa(len(subnetList))
                //errString += " \n len(vNicList): " + strconv.Itoa(len(vNicList))

                err := fmt.Errorf(errString)
                CBLog.Error(err)
                return err
        }</span>

        // delete ns info
        <span class="cov0" title="0">err = CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func DelAllNs() error <span class="cov0" title="0">{
        fmt.Printf("DelAllNs() called;")

        nsIdList, err := ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(nsIdList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, v := range nsIdList </span><span class="cov0" title="0">{
                err := DelNs(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func CheckNs(id string) (bool, error) <span class="cov8" title="1">{

        if id == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckNs failed; nsId given is null.")
                return false, err
        }</span>

        <span class="cov8" title="1">err := CheckString(id)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return false, err
        }</span>

        //fmt.Println("[Check ns] " + lowerizedId)

        <span class="cov8" title="1">key := "/ns/" + id
        //fmt.Println(key)

        keyValue, _ := CBStore.Get(key)
        if keyValue != nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package common

import (
        "os"
        "regexp"
        "runtime"
        "strconv"
        "strings"

        //"encoding/json"

        "github.com/cloud-barista/cb-spider/interface/api"
        cbstore_utils "github.com/cloud-barista/cb-store/utils"
        uuid "github.com/google/uuid"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gopkg.in/yaml.v2"

        // CB-Store
        //"github.com/cloud-barista/cb-grpc-project/pkg/logging"

        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"

        "encoding/json"
        "fmt"

        //"net/http"
        //"io/ioutil"
        //"strconv"
        "github.com/go-resty/resty/v2"
)

// MCIS utilities

// JSON Simple message struct
type SimpleMsg struct {
        Message string `json:"message" example:"Any message"`
}

func GenUuid() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>

func CheckString(name string) error <span class="cov8" title="1">{

        if name == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("The provided name is empty.")
                return err
        }</span>

        <span class="cov8" title="1">r, _ := regexp.Compile("[a-z]([-a-z0-9]*[a-z0-9])?")
        filtered := r.FindString(name)

        if filtered != name </span><span class="cov0" title="0">{
                err := fmt.Errorf(name + ": The first character of name must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.")
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// To be deprecated
func ToLower(name string) string <span class="cov0" title="0">{
        out := strings.ReplaceAll(name, "_", "-")
        out = strings.ReplaceAll(out, " ", "-")
        out = strings.ToLower(out)
        return out
}</span>

func GenMcisKey(nsId string, mcisId string, vmId string) string <span class="cov0" title="0">{

        if vmId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId + "/mcis/" + mcisId + "/vm/" + vmId
        }</span> else<span class="cov0" title="0"> if mcisId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId + "/mcis/" + mcisId
        }</span> else<span class="cov0" title="0"> if nsId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>

}

func GenMcisVmGroupKey(nsId string, mcisId string, groupId string) string <span class="cov0" title="0">{

        return "/ns/" + nsId + "/mcis/" + mcisId + "/vmgroup/" + groupId

}</span>

// Generate Mcis policy key
func GenMcisPolicyKey(nsId string, mcisId string, vmId string) string <span class="cov0" title="0">{
        if vmId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId + "/policy/mcis/" + mcisId + "/vm/" + vmId
        }</span> else<span class="cov0" title="0"> if mcisId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId + "/policy/mcis/" + mcisId
        }</span> else<span class="cov0" title="0"> if nsId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}

func LookupKeyValueList(kvl []KeyValue, key string) string <span class="cov0" title="0">{
        for _, v := range kvl </span><span class="cov0" title="0">{
                if v.Key == key </span><span class="cov0" title="0">{
                        return v.Value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func PrintJsonPretty(v interface{}) <span class="cov0" title="0">{
        prettyJSON, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%+v\n", v)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%s\n", string(prettyJSON))
        }</span>
}

func GenResourceKey(nsId string, resourceType string, resourceId string) string <span class="cov0" title="0">{

        if resourceType == StrImage ||
                resourceType == StrSSHKey ||
                resourceType == StrSpec ||
                resourceType == StrVNet ||
                resourceType == StrSecurityGroup </span><span class="cov0" title="0">{
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" {
                return "/ns/" + nsId + "/resources/" + resourceType + "/" + resourceId
        }</span> else<span class="cov0" title="0"> {
                return "/invalidKey"
        }</span>
}

type mcirIds struct { // Tumblebug
        CspImageId           string
        CspImageName         string
        CspSshKeyName        string
        CspSpecName          string
        CspVNetId            string
        CspVNetName          string
        CspSecurityGroupId   string
        CspSecurityGroupName string
        CspPublicIpId        string
        CspPublicIpName      string
        CspVNicId            string
        CspVNicName          string

        ConnectionName string
}

func GetCspResourceId(nsId string, resourceType string, resourceId string) (string, error) <span class="cov0" title="0">{
        key := GenResourceKey(nsId, resourceType, resourceId)
        if key == "/invalidKey" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid nsId or resourceType or resourceId")
        }</span>
        <span class="cov0" title="0">keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                //CBLog.Error(err)
                // if there is no matched value for the key, return empty string. Error will be handled in a parent function
                return "", fmt.Errorf("cannot find the key " + key)
        }</span>

        <span class="cov0" title="0">switch resourceType </span>{
        case StrImage:<span class="cov0" title="0">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return content.CspImageId, nil</span>
        case StrSSHKey:<span class="cov0" title="0">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return resourceId, nil</span>
        case StrSpec:<span class="cov0" title="0">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return content.CspSpecName, nil</span>
        case StrVNet:<span class="cov0" title="0">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return resourceId, nil</span> // contains CspSubnetId
        // case "subnet":
        //         content := subnetInfo{}
        //         json.Unmarshal([]byte(keyValue.Value), &amp;content)
        //         return content.CspSubnetId
        case StrSecurityGroup:<span class="cov0" title="0">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return content.CspSecurityGroupName, nil</span>
        /*
                case "publicIp":
                        content := mcirIds{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        return content.CspPublicIpName
                case "vNic":
                        content := mcirIds{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        if err != nil {
                                CBLog.Error(err)
                                // if there is no matched value for the key, return empty string. Error will be handled in a parent function
                                return ""
                        }
                        return content.CspVNicName
        */
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid resourceType")</span>
        }
        //}
}

type ConnConfig struct { // Spider
        ConfigName     string
        ProviderName   string
        DriverName     string
        CredentialName string
        RegionName     string
}

func GetConnConfig(ConnConfigName string) (ConnConfig, error) <span class="cov0" title="0">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := SPIDER_REST_URL + "/connectionconfig/" + ConnConfigName

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;ConnConfig{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := ConnConfig{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := ConnConfig{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp, _ := resp.Result().(*ConnConfig)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CIM API 
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return ConnConfig{}, err
                }</span>
                <span class="cov0" title="0">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return ConnConfig{}, err
                }</span>
                <span class="cov0" title="0">defer cim.Close()

                result, err := cim.GetConnectionConfigByParam(ConnConfigName)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return ConnConfig{}, err
                }</span>

                <span class="cov0" title="0">temp := ConnConfig{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return ConnConfig{}, err
                }</span>
                <span class="cov0" title="0">return temp, nil</span>
        }
}

type ConnConfigList struct { // Spider
        Connectionconfig []ConnConfig `json:"connectionconfig"`
}

func GetConnConfigList() (ConnConfigList, error) <span class="cov0" title="0">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := SPIDER_REST_URL + "/connectionconfig"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;ConnConfigList{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := ConnConfigList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := ConnConfigList{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp, _ := resp.Result().(*ConnConfigList)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CIM API 
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return ConnConfigList{}, err
                }</span>
                <span class="cov0" title="0">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return ConnConfigList{}, err
                }</span>
                <span class="cov0" title="0">defer cim.Close()

                result, err := cim.ListConnectionConfig()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return ConnConfigList{}, err
                }</span>

                <span class="cov0" title="0">temp := ConnConfigList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api Unmarshal failed : ", err)
                        return ConnConfigList{}, err
                }</span>
                <span class="cov0" title="0">return temp, nil</span>

        }
}

type Region struct { // Spider
        RegionName       string     // ex) "region01"
        ProviderName     string     // ex) "GCP"
        KeyValueInfoList []KeyValue // ex) { {region, us-east1}, {zone, us-east1-c} }
}

func GetRegion(RegionName string) (Region, error) <span class="cov0" title="0">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := SPIDER_REST_URL + "/region/" + RegionName

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;Region{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := Region{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := Region{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp, _ := resp.Result().(*Region)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CIM API 
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return Region{}, err
                }</span>
                <span class="cov0" title="0">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return Region{}, err
                }</span>
                <span class="cov0" title="0">defer cim.Close()

                result, err := cim.GetRegionByParam(RegionName)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return Region{}, err
                }</span>

                <span class="cov0" title="0">temp := Region{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api Unmarshal failed : ", err)
                        return Region{}, err
                }</span>
                <span class="cov0" title="0">return temp, nil</span>

        }
}

// RegionList is array struct for Region
type RegionList struct {
        Region []Region `json:"region"`
}

// GetRegionList retrieves region list
func GetRegionList() (RegionList, error) <span class="cov0" title="0">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := SPIDER_REST_URL + "/region"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;RegionList{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := RegionList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := RegionList{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp, _ := resp.Result().(*RegionList)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CIM API 
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return RegionList{}, err
                }</span>
                <span class="cov0" title="0">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return RegionList{}, err
                }</span>
                <span class="cov0" title="0">defer cim.Close()

                result, err := cim.ListRegion()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return RegionList{}, err
                }</span>

                <span class="cov0" title="0">temp := RegionList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api Unmarshal failed : ", err)
                        return RegionList{}, err
                }</span>
                <span class="cov0" title="0">return temp, nil</span>

        }
}

// ConvertToMessage -   grpc  
func ConvertToMessage(inType string, inData string, obj interface{}) error <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        if inType == "yaml" </span><span class="cov0" title="0">{
                err := yaml.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //logger.Debug("yaml Unmarshal: \n", obj)
        }

        <span class="cov0" title="0">if inType == "json" </span><span class="cov0" title="0">{
                err := json.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //logger.Debug("json Unmarshal: \n", obj)
        }

        <span class="cov0" title="0">return nil</span>
}

// ConvertToOutput - grpc   
func ConvertToOutput(outType string, obj interface{}) (string, error) <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        if outType == "yaml" </span><span class="cov0" title="0">{
                //    (XXX_  )   json   
                j, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                //        MapSlice 
                <span class="cov0" title="0">jsonObj := yaml.MapSlice{}
                err2 := yaml.Unmarshal(j, &amp;jsonObj)
                if err2 != nil </span><span class="cov0" title="0">{
                        return "", err2
                }</span>

                // yaml 
                <span class="cov0" title="0">y, err3 := yaml.Marshal(jsonObj)
                if err3 != nil </span><span class="cov0" title="0">{
                        return "", err3
                }</span>
                //logger.Debug("yaml Marshal: \n", string(y))

                <span class="cov0" title="0">return string(y), nil</span>
        }

        <span class="cov0" title="0">if outType == "json" </span><span class="cov0" title="0">{
                j, err := json.MarshalIndent(obj, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                //logger.Debug("json Marshal: \n", string(j))

                <span class="cov0" title="0">return string(j), nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// CopySrcToDest -    
func CopySrcToDest(src interface{}, dest interface{}) error <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        j, err := json.MarshalIndent(src, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //logger.Debug("source value : \n", string(j))

        <span class="cov0" title="0">err = json.Unmarshal(j, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">j, err = json.MarshalIndent(dest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //logger.Debug("target value : \n", string(j))

        <span class="cov0" title="0">return nil</span>
}

// ConvGrpcStatusErr - GRPC    
func ConvGrpcStatusErr(err error, tag string, method string) error <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        //_, fn, line, _ := runtime.Caller(1)
        runtime.Caller(1)
        if err != nil </span><span class="cov0" title="0">{
                if errStatus, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        //logger.Error(tag, " error while calling ", method, " method: [", fn, ":", line, "] ", errStatus.Message())
                        return status.Errorf(errStatus.Code(), "%s error while calling %s method: %v ", tag, method, errStatus.Message())
                }</span>
                //logger.Error(tag, " error while calling ", method, " method: [", fn, ":", line, "] ", err)
                <span class="cov0" title="0">return status.Errorf(codes.Internal, "%s error while calling %s method: %v ", tag, method, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewGrpcStatusErr - GRPC    
func NewGrpcStatusErr(msg string, tag string, method string) error <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        //_, fn, line, _ := runtime.Caller(1)
        runtime.Caller(1)
        //logger.Error(tag, " error while calling ", method, " method: [", fn, ":", line, "] ", msg)
        return status.Errorf(codes.Internal, "%s error while calling %s method: %s ", tag, method, msg)
}</span>

// NVL is null value logic
func NVL(str string, def string) string <span class="cov8" title="1">{
        if len(str) == 0 </span><span class="cov0" title="0">{
                return def
        }</span>
        <span class="cov8" title="1">return str</span>
}

func GetChildIdList(key string) []string <span class="cov0" title="0">{

        keyValue, _ := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        var childIdList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                childIdList = append(childIdList, strings.TrimPrefix(v.Key, key+"/"))

        }</span>
        <span class="cov0" title="0">for _, v := range childIdList </span><span class="cov0" title="0">{
                fmt.Println("&lt;" + v + "&gt; \n")
        }</span>
        <span class="cov0" title="0">fmt.Println("===============================================")
        return childIdList</span>

}

// func GetObjectList returns IDs of each child objects that has the same key.
func GetObjectList(key string) []string <span class="cov0" title="0">{

        keyValue, _ := CBStore.GetList(key, true)

        var childIdList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                childIdList = append(childIdList, v.Key)
        }</span>

        <span class="cov0" title="0">fmt.Println("===============================================")
        return childIdList</span>

}

// func GetObjectValue returns the object value.
func GetObjectValue(key string) (string, error) <span class="cov0" title="0">{

        keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return keyValue.Value, nil</span>
}

// func DeleteObject delete the object.
func DeleteObject(key string) error <span class="cov0" title="0">{

        err := CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// func DeleteObjects delete objects.
func DeleteObjects(key string) error <span class="cov0" title="0">{
        keyValue, _ := CBStore.GetList(key, true)
        for _, v := range keyValue </span><span class="cov0" title="0">{
                err := CBStore.Delete(v.Key)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "strings"

        //uuid "github.com/google/uuid"
        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"

        // CB-Store
        cbstore_utils "github.com/cloud-barista/cb-store/utils"
        "github.com/tidwall/gjson"
        "github.com/tidwall/sjson"
)

// CB-Store
//var cblog *logrus.Logger
//var store icbs.Store

//var SPIDER_REST_URL string

func init() {<span class="cov8" title="1">
        //cblog = config.Cblogger
        //store = cbstore.GetStore()
        //SPIDER_REST_URL = os.Getenv("SPIDER_REST_URL")
}</span>

// DelAllResources deletes all TB MCIR object of given resourceType
func DelAllResources(nsId string, resourceType string, forceFlag string) error <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">resourceIdList, err := ListResourceId(nsId, resourceType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(resourceIdList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, v := range resourceIdList </span><span class="cov0" title="0">{
                err := DelResource(nsId, resourceType, v, forceFlag)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// DelResource deletes the TB MCIR object
func DelResource(nsId string, resourceType string, resourceId string, forceFlag string) error <span class="cov0" title="0">{

        fmt.Printf("DelResource() called; %s %s %s \n", nsId, resourceType, resourceId) // for debug

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov0" title="0">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                //return http.StatusNotFound, mapB, err
                return err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">key := common.GenResourceKey(nsId, resourceType, resourceId)
        fmt.Println("key: " + key)

        keyValue, _ := common.CBStore.Get(key)
        /*
                if keyValue == nil {
                        mapA := map[string]string{"message": "Failed to find the resource with given ID."}
                        mapB, _ := json.Marshal(mapA)
                        err := fmt.Errorf("Failed to find the resource with given ID.")
                        return http.StatusNotFound, mapB, err
                }
        */
        //fmt.Println("keyValue: " + keyValue.Key + " / " + keyValue.Value)

        //cspType := common.GetResourcesCspType(nsId, resourceType, resourceId)

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                var url string

                // Create Req body
                type JsonTemplate struct {
                        ConnectionName string
                }
                tempReq := JsonTemplate{}

                switch resourceType </span>{
                case common.StrImage:<span class="cov0" title="0">
                        // delete image info
                        err := common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //return http.StatusInternalServerError, nil, err
                                return err
                        }</span>

                        // "DELETE FROM `image` WHERE `id` = '" + resourceId + "';"
                        <span class="cov0" title="0">_, err = common.ORM.Delete(&amp;TbImageInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        //return http.StatusOK, nil, nil
                        <span class="cov0" title="0">return nil</span>
                case common.StrSpec:<span class="cov0" title="0">
                        // delete spec info

                        //get related recommend spec
                        //keyValue, err := common.CBStore.Get(key)
                        content := TbSpecInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov0" title="0">err = common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        //delete related recommend spec
                        <span class="cov0" title="0">err = DelRecommendSpec(nsId, resourceId, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        // "DELETE FROM `spec` WHERE `id` = '" + resourceId + "';"
                        <span class="cov0" title="0">_, err = common.ORM.Delete(&amp;TbSpecInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        //return http.StatusOK, nil, nil
                        <span class="cov0" title="0">return nil</span>
                case common.StrSSHKey:<span class="cov0" title="0">
                        temp := TbSshKeyInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">tempReq.ConnectionName = temp.ConnectionName
                        url = common.SPIDER_REST_URL + "/keypair/" + temp.Name</span>
                case common.StrVNet:<span class="cov0" title="0">
                        temp := TbVNetInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">tempReq.ConnectionName = temp.ConnectionName
                        url = common.SPIDER_REST_URL + "/vpc/" + temp.Name</span>
                case common.StrSecurityGroup:<span class="cov0" title="0">
                        temp := TbSecurityGroupInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">tempReq.ConnectionName = temp.ConnectionName
                        url = common.SPIDER_REST_URL + "/securitygroup/" + temp.Name</span>
                /*
                        case "subnet":
                                temp := subnetInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                                return content.CspSubnetId
                        case "publicIp":
                                temp := publicIpInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                                tempReq.ConnectionName = temp.ConnectionName
                                url = common.SPIDER_REST_URL + "/publicip/" + temp.CspPublicIpName
                        case "vNic":
                                temp := vNicInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                                tempReq.ConnectionName = temp.ConnectionName
                                url = common.SPIDER_REST_URL + "/vnic/" + temp.CspVNicName
                */
                default:<span class="cov0" title="0">
                        err := fmt.Errorf("invalid resourceType")
                        //return http.StatusBadRequest, nil, err
                        return err</span>
                }

                <span class="cov0" title="0">fmt.Println("url: " + url)

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        //SetResult(&amp;SpiderSpecInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Delete(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return err
                }</span>

                <span class="cov0" title="0">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case forceFlag == "true":<span class="cov0" title="0">
                        url += "?force=true"
                        fmt.Println("forceFlag == true; url: " + url)

                        _, err := client.R().
                                SetHeader("Content-Type", "application/json").
                                SetBody(tempReq).
                                //SetResult(&amp;SpiderSpecInfo{}). // or SetResult(AuthSuccess{}).
                                //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                                Delete(url)

                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                                return err
                        }</span>

                        <span class="cov0" title="0">err = common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        return err</span>
                default:<span class="cov0" title="0">
                        err := common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                switch resourceType </span>{
                case common.StrImage:<span class="cov0" title="0">
                        // delete image info
                        err := common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //return http.StatusInternalServerError, nil, err
                                return err
                        }</span>

                        // "DELETE FROM `image` WHERE `id` = '" + resourceId + "';"
                        <span class="cov0" title="0">_, err = common.ORM.Delete(&amp;TbImageInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        //return http.StatusOK, nil, nil
                        <span class="cov0" title="0">return nil</span>
                case common.StrSpec:<span class="cov0" title="0">
                        // delete spec info

                        //get related recommend spec
                        content := TbSpecInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov0" title="0">err = common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        //delete related recommend spec
                        <span class="cov0" title="0">err = DelRecommendSpec(nsId, resourceId, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        // "DELETE FROM `spec` WHERE `id` = '" + resourceId + "';"
                        <span class="cov0" title="0">_, err = common.ORM.Delete(&amp;TbSpecInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        <span class="cov0" title="0">return nil</span>

                case common.StrSSHKey:<span class="cov0" title="0">
                        temp := TbSshKeyInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov0" title="0">_, err = ccm.DeleteKeyByParam(temp.ConnectionName, temp.Name, forceFlag)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case common.StrVNet:<span class="cov0" title="0">
                        temp := TbVNetInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov0" title="0">_, err = ccm.DeleteVPCByParam(temp.ConnectionName, temp.Name, forceFlag)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case common.StrSecurityGroup:<span class="cov0" title="0">
                        temp := TbSecurityGroupInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov0" title="0">_, err = ccm.DeleteSecurityByParam(temp.ConnectionName, temp.Name, forceFlag)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                default:<span class="cov0" title="0">
                        err := fmt.Errorf("invalid resourceType")
                        return err</span>
                }

                <span class="cov0" title="0">err = common.CBStore.Delete(key)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>

        }
}

type SpiderNameIdSystemId struct {
        NameId   string
        SystemId string
}

type SpiderAllListWrapper struct {
        AllList SpiderAllList
}

type SpiderAllList struct {
        MappedList     []SpiderNameIdSystemId
        OnlySpiderList []SpiderNameIdSystemId
        OnlyCSPList    []SpiderNameIdSystemId
}

// Response struct for InspectResources
type TbInspectResourcesResponse struct {
        // ResourcesOnCsp       interface{} `json:"resourcesOnCsp"`
        // ResourcesOnSpider    interface{} `json:"resourcesOnSpider"`
        // ResourcesOnTumblebug interface{} `json:"resourcesOnTumblebug"`
        ResourcesOnCsp       []resourceOnCspOrSpider `json:"resourcesOnCsp"`
        ResourcesOnSpider    []resourceOnCspOrSpider `json:"resourcesOnSpider"`
        ResourcesOnTumblebug []resourceOnTumblebug   `json:"resourcesOnTumblebug"`
}

type resourceOnCspOrSpider struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
}

type resourceOnTumblebug struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
        NsId        string `json:"nsId"`
        //McisId      string `json:"mcisId"`
        Type      string `json:"type"`
        ObjectKey string `json:"objectKey"`
}

// InspectResources returns the state list of TB MCIR objects of given connConfig and resourceType
func InspectResources(connConfig string, resourceType string) (interface{}, error) <span class="cov0" title="0">{

        nsList, err := common.ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err = fmt.Errorf("an error occurred while getting namespaces' list: " + err.Error())
                return nil, err
        }</span>
        // var TbResourceList []string
        <span class="cov0" title="0">var TbResourceList []resourceOnTumblebug
        for _, ns := range nsList </span><span class="cov0" title="0">{
                /*
                        resourceListInNs := ListResourceId(ns, resourceType)
                        for i, _ := range resourceListInNs {
                                resourceListInNs[i] = ns + "/" + resourceListInNs[i]
                        }
                        TbResourceList = append(TbResourceList, resourceListInNs...)
                */

                resourceListInNs, err := ListResource(ns, resourceType)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        err := fmt.Errorf("an error occurred while getting resource list")
                        return nil, err
                }</span>
                <span class="cov0" title="0">if resourceListInNs == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch resourceType </span>{
                case common.StrVNet:<span class="cov0" title="0">
                        resourcesInNs := resourceListInNs.([]TbVNetInfo) // type assertion
                        for _, resource := range resourcesInNs </span><span class="cov0" title="0">{
                                if resource.ConnectionName == connConfig </span><span class="cov0" title="0">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = resource.Id
                                        temp.CspNativeId = resource.CspVNetId
                                        temp.NsId = ns
                                        //temp.McisId = ""
                                        temp.Type = resourceType
                                        temp.ObjectKey = common.GenResourceKey(ns, resourceType, resource.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                case common.StrSecurityGroup:<span class="cov0" title="0">
                        resourcesInNs := resourceListInNs.([]TbSecurityGroupInfo) // type assertion
                        for _, resource := range resourcesInNs </span><span class="cov0" title="0">{
                                if resource.ConnectionName == connConfig </span><span class="cov0" title="0">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = resource.Id
                                        temp.CspNativeId = resource.CspSecurityGroupId
                                        temp.NsId = ns
                                        //temp.McisId = ""
                                        temp.Type = resourceType
                                        temp.ObjectKey = common.GenResourceKey(ns, resourceType, resource.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                case common.StrSSHKey:<span class="cov0" title="0">
                        resourcesInNs := resourceListInNs.([]TbSshKeyInfo) // type assertion
                        for _, resource := range resourcesInNs </span><span class="cov0" title="0">{
                                if resource.ConnectionName == connConfig </span><span class="cov0" title="0">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = resource.Id
                                        temp.CspNativeId = resource.CspSshKeyName
                                        temp.NsId = ns
                                        //temp.McisId = ""
                                        temp.Type = resourceType
                                        temp.ObjectKey = common.GenResourceKey(ns, resourceType, resource.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">client := resty.New().SetCloseConnection(true)
        client.SetAllowGetMethodPayload(true)

        // Create Req body
        type JsonTemplate struct {
                ConnectionName string
        }
        tempReq := JsonTemplate{}
        tempReq.ConnectionName = connConfig

        var spiderRequestURL string
        switch resourceType </span>{
        case common.StrVNet:<span class="cov0" title="0">
                spiderRequestURL = common.SPIDER_REST_URL + "/allvpc"</span>
        case common.StrSecurityGroup:<span class="cov0" title="0">
                spiderRequestURL = common.SPIDER_REST_URL + "/allsecuritygroup"</span>
        case common.StrSSHKey:<span class="cov0" title="0">
                spiderRequestURL = common.SPIDER_REST_URL + "/allkeypair"</span>
        }

        <span class="cov0" title="0">resp, err := client.R().
                SetHeader("Content-Type", "application/json").
                SetBody(tempReq).
                SetResult(&amp;SpiderAllListWrapper{}). // or SetResult(AuthSuccess{}).
                //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                Get(spiderRequestURL)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
        switch </span>{
        case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                err := fmt.Errorf(string(resp.Body()))
                common.CBLog.Error(err)
                return nil, err</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">temp, _ := resp.Result().(*SpiderAllListWrapper) // type assertion

        result := TbInspectResourcesResponse{}

        /*
                // Implementation style 1
                if len(TbResourceList) &gt; 0 {
                        result.ResourcesOnTumblebug = TbResourceList
                } else {
                        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
                }
        */
        // Implementation style 2
        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
        result.ResourcesOnTumblebug = append(result.ResourcesOnTumblebug, TbResourceList...)

        // result.ResourcesOnCsp = append((*temp).AllList.MappedList, (*temp).AllList.OnlyCSPList...)
        // result.ResourcesOnSpider = append((*temp).AllList.MappedList, (*temp).AllList.OnlySpiderList...)
        result.ResourcesOnCsp = []resourceOnCspOrSpider{}
        result.ResourcesOnSpider = []resourceOnCspOrSpider{}

        for _, v := range (*temp).AllList.MappedList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov0" title="0">for _, v := range (*temp).AllList.OnlySpiderList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov0" title="0">for _, v := range (*temp).AllList.OnlyCSPList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ListResourceId returns the list of TB MCIR object IDs of given resourceType
func ListResourceId(nsId string, resourceType string) ([]string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" ||
                resourceType == common.StrSecurityGroup </span>{<span class="cov0" title="0">
                // continue
        }</span> else<span class="cov0" title="0"> {
                err = fmt.Errorf("invalid resource type")
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[ListResourceId] ns: " + nsId + ", type: " + resourceType)
        key := "/ns/" + nsId + "/resources/"
        fmt.Println(key)

        keyValue, _ := common.CBStore.GetList(key, true)

        var resourceList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                trimmedString := strings.TrimPrefix(v.Key, (key + resourceType + "/"))
                // prevent malformed key (if key for resource id includes '/', the key does not represent resource ID)
                if !strings.Contains(trimmedString, "/") </span><span class="cov0" title="0">{
                        resourceList = append(resourceList, trimmedString)
                }</span>
        }
        // for _, v := range resourceList {
        //         fmt.Println("&lt;" + v + "&gt; \n")
        // }
        // fmt.Println("===============================================")
        <span class="cov0" title="0">return resourceList, nil</span>

}

// ListResource returns the list of TB MCIR objects of given resourceType
func ListResource(nsId string, resourceType string) (interface{}, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" ||
                resourceType == common.StrSecurityGroup </span>{<span class="cov0" title="0">
                // continue
        }</span> else<span class="cov0" title="0"> {
                errString := "Cannot list " + resourceType + "s."
                err := fmt.Errorf(errString)
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Get " + resourceType + " list")
        key := "/ns/" + nsId + "/resources/" + resourceType
        fmt.Println(key)

        keyValue, err := common.CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                /*
                        fmt.Println("func ListResource; common.CBStore.GetList gave error")
                        var resourceList []string
                        for _, v := range keyValue {
                                resourceList = append(resourceList, strings.TrimPrefix(v.Key, "/ns/"+nsId+"/resources/"+resourceType+"/"))
                        }
                        for _, v := range resourceList {
                                fmt.Println("&lt;" + v + "&gt; \n")
                        }
                        fmt.Println("===============================================")
                */
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                switch resourceType </span>{
                case common.StrImage:<span class="cov0" title="0">
                        res := []TbImageInfo{}
                        for _, v := range keyValue </span><span class="cov0" title="0">{
                                tempObj := TbImageInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">res = append(res, tempObj)</span>
                        }
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrSecurityGroup:<span class="cov0" title="0">
                        res := []TbSecurityGroupInfo{}
                        for _, v := range keyValue </span><span class="cov0" title="0">{
                                tempObj := TbSecurityGroupInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">res = append(res, tempObj)</span>
                        }
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrSpec:<span class="cov0" title="0">
                        res := []TbSpecInfo{}
                        for _, v := range keyValue </span><span class="cov0" title="0">{
                                tempObj := TbSpecInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">res = append(res, tempObj)</span>
                        }
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrSSHKey:<span class="cov0" title="0">
                        res := []TbSshKeyInfo{}
                        for _, v := range keyValue </span><span class="cov0" title="0">{
                                tempObj := TbSshKeyInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">res = append(res, tempObj)</span>
                        }
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrVNet:<span class="cov0" title="0">
                        res := []TbVNetInfo{}
                        for _, v := range keyValue </span><span class="cov0" title="0">{
                                tempObj := TbVNetInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">res = append(res, tempObj)</span>
                        }
                        <span class="cov0" title="0">return res, nil</span>
                }

                //return true, nil
        }

        <span class="cov0" title="0">return nil, nil</span> // When err == nil &amp;&amp; keyValue == nil
}

// GetAssociatedObjectCount returns the number of MCIR's associated Tumblebug objects
func GetAssociatedObjectCount(nsId string, resourceType string, resourceId string) (int, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov0" title="0">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return -1, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>
        <span class="cov0" title="0">fmt.Println("[Get count] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>
        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                inUseCount := int(gjson.Get(keyValue.Value, "associatedObjectList.#").Int())
                return inUseCount, nil
        }</span>
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return -1, err</span>
}

// GetAssociatedObjectList returns the list of MCIR's associated Tumblebug objects
func GetAssociatedObjectList(nsId string, resourceType string, resourceId string) ([]string, error) <span class="cov0" title="0">{

        var result []string

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov0" title="0">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return nil, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Println("[Get count] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                /*
                        objList := gjson.Get(keyValue.Value, "associatedObjectList")
                        objList.ForEach(func(key, value gjson.Result) bool {
                                result = append(result, value.String())
                                return true
                        })
                */

                /*
                        switch resourceType {
                        case common.StrImage:
                                res := TbImageInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)
                                //result = res.
                        case common.StrSecurityGroup:
                                res := TbSecurityGroupInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)

                        case common.StrSpec:
                                res := TbSpecInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)

                        case common.StrSSHKey:
                                res := TbSshKeyInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)
                                result = res.AssociatedObjectList
                        case common.StrVNet:
                                res := TbVNetInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)

                        }
                */

                type stringList struct {
                        AssociatedObjectList []string `json:"associatedObjectList"`
                }
                res := stringList{}
                err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = res.AssociatedObjectList

                return result, nil</span>
        }
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return nil, err</span>
}

// UpdateAssociatedObjectList adds or deletes the objectKey (currently, vmKey) to/from TB object's associatedObjectList
func UpdateAssociatedObjectList(nsId string, resourceType string, resourceId string, cmd string, objectKey string) ([]string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        /*
                check, err := CheckResource(nsId, resourceType, resourceId)

                if !check {
                        errString := "The " + resourceType + " " + resourceId + " does not exist."
                        //mapA := map[string]string{"message": errString}
                        //mapB, _ := json.Marshal(mapA)
                        err := fmt.Errorf(errString)
                        return -1, err
                }

                if err != nil {
                        common.CBLog.Error(err)
                        return -1, err
                }
        */
        <span class="cov0" title="0">fmt.Println("[Set count] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                objList, _ := GetAssociatedObjectList(nsId, resourceType, resourceId)
                switch cmd </span>{
                case common.StrAdd:<span class="cov0" title="0">
                        for _, v := range objList </span><span class="cov0" title="0">{
                                if v == objectKey </span><span class="cov0" title="0">{
                                        errString := objectKey + " is already associated with " + resourceType + " " + resourceId + "."
                                        err = fmt.Errorf(errString)
                                        return nil, err
                                }</span>
                        }
                        // fmt.Println("len(objList): " + strconv.Itoa(len(objList))) // for debug
                        // fmt.Print("objList: ")                                     // for debug
                        // fmt.Println(objList)                                       // for debug

                        <span class="cov0" title="0">var anyJson map[string]interface{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;anyJson)
                        if anyJson["associatedObjectList"] == nil </span><span class="cov0" title="0">{
                                array_to_be := []string{objectKey}
                                // fmt.Println("array_to_be: ", array_to_be) // for debug

                                anyJson["associatedObjectList"] = array_to_be
                        }</span> else<span class="cov0" title="0"> { // anyJson["associatedObjectList"] != nil
                                array_as_is := anyJson["associatedObjectList"].([]interface{})
                                // fmt.Println("array_as_is: ", array_as_is) // for debug

                                array_to_be := append(array_as_is, objectKey)
                                // fmt.Println("array_to_be: ", array_to_be) // for debug

                                anyJson["associatedObjectList"] = array_to_be
                        }</span>
                        <span class="cov0" title="0">updatedJson, _ := json.Marshal(anyJson)
                        // fmt.Println(string(updatedJson)) // for debug

                        keyValue.Value = string(updatedJson)</span>
                case common.StrDelete:<span class="cov0" title="0">
                        var foundKey int
                        var foundVal string
                        for k, v := range objList </span><span class="cov0" title="0">{
                                if v == objectKey </span><span class="cov0" title="0">{
                                        foundKey = k
                                        foundVal = v
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if foundVal == "" </span><span class="cov0" title="0">{
                                errString := "Cannot find the associated object " + objectKey + "."
                                err = fmt.Errorf(errString)
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                keyValue.Value, err = sjson.Delete(keyValue.Value, "associatedObjectList."+strconv.Itoa(foundKey))
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                        }
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = common.CBStore.Put(key, keyValue.Value)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>
                /*
                        keyValue, _ := common.CBStore.Get(key)
                        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                        fmt.Println("===========================")
                        to_be = int8(gjson.Get(keyValue.Value, "inUseCount").Uint())
                        return to_be, nil
                */

                <span class="cov0" title="0">result, _ := GetAssociatedObjectList(nsId, resourceType, resourceId)
                return result, nil</span>
        }
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return nil, err</span>
}

// GetResource returns the requested TB MCIR object
func GetResource(nsId string, resourceType string, resourceId string) (interface{}, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov0" title="0">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return nil, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Println("[Get resource] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                switch resourceType </span>{
                case common.StrImage:<span class="cov0" title="0">
                        res := TbImageInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrSecurityGroup:<span class="cov0" title="0">
                        res := TbSecurityGroupInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrSpec:<span class="cov0" title="0">
                        res := TbSpecInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrSSHKey:<span class="cov0" title="0">
                        res := TbSshKeyInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return res, nil</span>
                case common.StrVNet:<span class="cov0" title="0">
                        res := TbVNetInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return res, nil</span>
                }

                //return true, nil
        }
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return nil, err</span>
}

// CheckResource returns the existence of the TB MCIR resource in bool form.
func CheckResource(nsId string, resourceType string, resourceId string) (bool, error) <span class="cov0" title="0">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckResource failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov0" title="0"> if resourceType == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckResource failed; resourceType given is null.")
                return false, err
        }</span> else<span class="cov0" title="0"> if resourceId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckResource failed; resourceId given is null.")
                return false, err
        }</span>

        // Check resourceType's validity
        <span class="cov0" title="0">if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                resourceType == common.StrSecurityGroup </span>{<span class="cov0" title="0">
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" {
                // continue
        }</span> else<span class="cov0" title="0"> {
                err := fmt.Errorf("invalid resource type")
                return false, err
        }</span>

        <span class="cov0" title="0">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Check resource] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        if keyValue != nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return false, nil</span>

}

/*
func convertSpiderResourceToTumblebugResource(resourceType string, i interface{}) (interface{}, error) {
        if resourceType == "" {
                err := fmt.Errorf("CheckResource failed; resourceType given is null.")
                return nil, err
        }

        // Check resourceType's validity
        if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                resourceType == common.StrSecurityGroup {
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" {
                // continue
        } else {
                err := fmt.Errorf("invalid resource type")
                return nil, err
        }

}
*/

// https://stackoverflow.com/questions/45139954/dynamic-struct-as-parameter-golang

type ReturnValue struct {
        CustomStruct interface{}
}

type NameOnly struct {
        Name string
}

// GetNameFromStruct accepts any struct for argument, and returns
func GetNameFromStruct(u interface{}) string <span class="cov0" title="0">{
        var result = ReturnValue{CustomStruct: u}

        //fmt.Println(result)

        msg, ok := result.CustomStruct.(NameOnly)
        if ok </span><span class="cov0" title="0">{
                //fmt.Printf("Message1 is %s\n", msg.Name)
                return msg.Name
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}

//func createResource(nsId string, resourceType string, u interface{}) (interface{}, int, []byte, error) {
</pre>
		
		<pre class="file" id="file19" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "net/url"
        "os"
        "strconv"
        "strings"

        "github.com/go-resty/resty/v2"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// 2020-04-03 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/ImageHandler.go

type SpiderImageReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderImageInfo
}

/*
type SpiderImageReqInfo struct { // Spider
        //IId   IID         // {NameId, SystemId}
        Name string
        // @todo
}
*/

type SpiderImageInfo struct { // Spider
        // Fields for request
        Name string

        // Fields for response
        IId          common.IID // {NameId, SystemId}
        GuestOS      string     // Windows7, Ubuntu etc.
        Status       string     // available, unavailable
        KeyValueList []common.KeyValue
}

type TbImageReq struct {
        Name           string `json:"name"`
        ConnectionName string `json:"connectionName"`
        CspImageId     string `json:"cspImageId"`
        Description    string `json:"description"`
}

type TbImageInfo struct {
        Namespace            string            `json:"namespace"` // required to save in RDB
        Id                   string            `json:"id"`
        Name                 string            `json:"name"`
        ConnectionName       string            `json:"connectionName"`
        CspImageId           string            `json:"cspImageId"`
        CspImageName         string            `json:"cspImageName"`
        Description          string            `json:"description,omitempty"`
        CreationDate         string            `json:"creationDate,omitempty"`
        GuestOS              string            `json:"guestOS,omitempty"` // Windows7, Ubuntu etc.
        Status               string            `json:"status,omitempty"`  // available, unavailable
        KeyValueList         []common.KeyValue `json:"keyValueList,omitempty"`
        AssociatedObjectList []string          `json:"associatedObjectList"`
        IsAutoGenerated      bool              `json:"isAutoGenerated"`
}

// ConvertSpiderImageToTumblebugImage accepts an Spider image object, converts to and returns an TB image object
func ConvertSpiderImageToTumblebugImage(spiderImage SpiderImageInfo) (TbImageInfo, error) <span class="cov0" title="0">{
        if spiderImage.IId.NameId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("ConvertSpiderImageToTumblebugImage failed; spiderImage.IId.NameId == \"\" ")
                emptyTumblebugImage := TbImageInfo{}
                return emptyTumblebugImage, err
        }</span>

        <span class="cov0" title="0">tumblebugImage := TbImageInfo{}
        //tumblebugImage.Id = spiderImage.IId.NameId

        spiderKeyValueListName := common.LookupKeyValueList(spiderImage.KeyValueList, "Name")
        if len(spiderKeyValueListName) &gt; 0 </span><span class="cov0" title="0">{
                tumblebugImage.Name = spiderKeyValueListName
        }</span> else<span class="cov0" title="0"> {
                tumblebugImage.Name = spiderImage.IId.NameId
        }</span>

        <span class="cov0" title="0">tumblebugImage.CspImageId = spiderImage.IId.NameId
        tumblebugImage.CspImageName = common.LookupKeyValueList(spiderImage.KeyValueList, "Name")
        tumblebugImage.Description = common.LookupKeyValueList(spiderImage.KeyValueList, "Description")
        tumblebugImage.CreationDate = common.LookupKeyValueList(spiderImage.KeyValueList, "CreationDate")
        tumblebugImage.GuestOS = spiderImage.GuestOS
        tumblebugImage.Status = spiderImage.Status
        tumblebugImage.KeyValueList = spiderImage.KeyValueList

        return tumblebugImage, nil</span>
}

// RegisterImageWithId accepts image creation request, creates and returns an TB image object
func RegisterImageWithId(nsId string, u *TbImageReq) (TbImageInfo, error) <span class="cov0" title="0">{

        resourceType := common.StrImage

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                err := fmt.Errorf("The image " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                err := fmt.Errorf("Failed to check the existence of the image " + u.Name + ".")
                return temp, err
        }</span>

        <span class="cov0" title="0">res, err := LookupImage(u.ConnectionName, u.CspImageId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //err := fmt.Errorf("an error occurred while lookup image via CB-Spider")
                emptyImageInfoObj := TbImageInfo{}
                return emptyImageInfoObj, err
        }</span>

        <span class="cov0" title="0">content, err := ConvertSpiderImageToTumblebugImage(res)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //err := fmt.Errorf("an error occurred while converting Spider image info to Tumblebug image info.")
                emptyImageInfoObj := TbImageInfo{}
                return emptyImageInfoObj, err
        }</span>
        <span class="cov0" title="0">content.Namespace = nsId
        content.ConnectionName = u.ConnectionName
        content.Id = u.Name
        content.Name = u.Name
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT registerImage")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // "INSERT INTO `image`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        _, err = common.ORM.Insert(&amp;content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

// RegisterImageWithInfo accepts image creation request, creates and returns an TB image object
func RegisterImageWithInfo(nsId string, content *TbImageInfo) (TbImageInfo, error) <span class="cov0" title="0">{

        resourceType := common.StrImage

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(content.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, content.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                err := fmt.Errorf("The image " + content.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                err := fmt.Errorf("Failed to check the existence of the image " + content.Name + ".")
                return temp, err
        }</span>

        <span class="cov0" title="0">content.Namespace = nsId
        //content.Id = common.GenUuid()
        content.Id = content.Name
        content.AssociatedObjectList = []string{}

        fmt.Println("=========================== PUT registerImage")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return *content, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // "INSERT INTO `image`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        _, err = common.ORM.Insert(content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov0" title="0">return *content, nil</span>
}

type SpiderImageList struct {
        Image []SpiderImageInfo `json:"image"`
}

// LookupImageList accepts Spider conn config,
// lookups and returns the list of all images in the region of conn config
// in the form of the list of Spider image objects
func LookupImageList(connConfig string) (SpiderImageList, error) <span class="cov0" title="0">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderImageList{}
                err := fmt.Errorf("LookupImage() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov0" title="0">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/vmimage"

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderImageList{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderImageList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderImageList{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp := resp.Result().(*SpiderImageList)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderImageList{}, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderImageList{}, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                result, err := ccm.ListImageByParam(connConfig)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderImageList{}, err
                }</span>

                <span class="cov0" title="0">temp := SpiderImageList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderImageList{}, err
                }</span>
                <span class="cov0" title="0">return temp, nil</span>

        }
}

// LookupImage accepts Spider conn config and CSP image ID, lookups and returns the Spider image object
func LookupImage(connConfig string, imageId string) (SpiderImageInfo, error) <span class="cov0" title="0">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderImageInfo{}
                err := fmt.Errorf("LookupImage() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span> else<span class="cov0" title="0"> if imageId == "" </span><span class="cov0" title="0">{
                content := SpiderImageInfo{}
                err := fmt.Errorf("LookupImage() called with empty imageId.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov0" title="0">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/vmimage/" + url.QueryEscape(imageId)

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderImageInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderImageInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderImageInfo{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp := resp.Result().(*SpiderImageInfo)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderImageInfo{}, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderImageInfo{}, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                result, err := ccm.GetImageByParam(connConfig, imageId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderImageInfo{}, err
                }</span>

                <span class="cov0" title="0">temp := SpiderImageInfo{}
                err2 := json.Unmarshal([]byte(result), &amp;temp)
                if err2 != nil </span><span class="cov0" title="0">{
                        //fmt.Errorf("an error occurred while unmarshaling: " + err2.Error())
                        common.CBLog.Error(err2)
                }</span>
                <span class="cov0" title="0">return temp, nil</span>

        }
}

func RefineImageName(imageName string) string <span class="cov0" title="0">{
        out := strings.ToLower(imageName)
        out = strings.ReplaceAll(out, ".", "-")
        out = strings.ReplaceAll(out, "_", "-")
        out = strings.ReplaceAll(out, ":", "-")
        out = strings.ReplaceAll(out, "/", "-")

        return out
}</span>

// FetchImagesForAllConnConfigs gets all conn configs from Spider, lookups all images for each region of conn config, and saves into TB image objects
func FetchImagesForConnConfig(connConfig string, nsId string) (imageCount uint, err error) <span class="cov0" title="0">{
        fmt.Println("FetchImagesForConnConfig(" + connConfig + ")")

        spiderImageList, err := LookupImageList(connConfig)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>

        <span class="cov0" title="0">for _, spiderImage := range spiderImageList.Image </span><span class="cov0" title="0">{
                tumblebugImage, err := ConvertSpiderImageToTumblebugImage(spiderImage)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return 0, err
                }</span>

                <span class="cov0" title="0">tumblebugImageId := connConfig + "-" + RefineImageName(tumblebugImage.Name)
                //fmt.Println("tumblebugImageId: " + tumblebugImageId) // for debug

                check, err := CheckResource(nsId, common.StrImage, tumblebugImageId)
                if check </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("The image " + tumblebugImageId + " already exists in TB; continue")
                        continue</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("Cannot check the existence of " + tumblebugImageId + " in TB; continue")
                        continue</span>
                } else<span class="cov0" title="0"> {
                        tumblebugImage.Name = tumblebugImageId
                        tumblebugImage.ConnectionName = connConfig

                        _, err := RegisterImageWithInfo(nsId, &amp;tumblebugImage)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">imageCount++</span>
                }
        }
        <span class="cov0" title="0">return imageCount, nil</span>
}

// FetchImagesForAllConnConfigs gets all conn configs from Spider, lookups all images for each region of conn config, and saves into TB image objects
func FetchImagesForAllConnConfigs(nsId string) (connConfigCount uint, imageCount uint, err error) <span class="cov0" title="0">{

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">connConfigs, err := common.GetConnConfigList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">for _, connConfig := range connConfigs.Connectionconfig </span><span class="cov0" title="0">{
                temp, _ := FetchImagesForConnConfig(connConfig.ConfigName, nsId)
                imageCount += temp
                connConfigCount++
        }</span>
        <span class="cov0" title="0">return connConfigCount, imageCount, nil</span>
}

// SearchImage accepts arbitrary number of keywords, and returns the list of matched TB image objects
func SearchImage(nsId string, keywords ...string) ([]TbImageInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">tempList := []TbImageInfo{}

        //sqlQuery := "SELECT * FROM `image` WHERE `namespace`='" + nsId + "'"
        sqlQuery := common.ORM.Where("Namespace = ?", nsId)

        for _, keyword := range keywords </span><span class="cov0" title="0">{
                keyword = RefineImageName(keyword)
                //sqlQuery += " AND `name` LIKE '%" + keyword + "%'"
                sqlQuery = sqlQuery.And("Name LIKE ?", "%"+keyword+"%")
        }</span>

        <span class="cov0" title="0">err = sqlQuery.Find(&amp;tempList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempList, err
        }</span>
        <span class="cov0" title="0">return tempList, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"
)

// 2020-04-13 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/SecurityHandler.go

type SpiderSecurityReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderSecurityInfo
}

/*
type SpiderSecurityReqInfo struct { // Spider
        Name          string
        VPCName       string
        SecurityRules *[]SpiderSecurityRuleInfo
        //Direction     string // @todo used??
}
*/

type SpiderSecurityRuleInfo struct { // Spider
        FromPort   string //`json:"fromPort"`
        ToPort     string //`json:"toPort"`
        IPProtocol string //`json:"ipProtocol"`
        Direction  string //`json:"direction"`
        CIDR       string
}

type SpiderSecurityInfo struct { // Spider
        // Fields for request
        Name    string
        VPCName string

        // Fields for both request and response
        SecurityRules *[]SpiderSecurityRuleInfo

        // Fields for response
        IId          common.IID // {NameId, SystemId}
        VpcIID       common.IID // {NameId, SystemId}
        Direction    string     // @todo userd??
        KeyValueList []common.KeyValue
}

type TbSecurityGroupReq struct { // Tumblebug
        Name           string                    `json:"name"`
        ConnectionName string                    `json:"connectionName"`
        VNetId         string                    `json:"vNetId"`
        Description    string                    `json:"description"`
        FirewallRules  *[]SpiderSecurityRuleInfo `json:"firewallRules"`
}

type TbSecurityGroupInfo struct { // Tumblebug
        Id                   string                    `json:"id"`
        Name                 string                    `json:"name"`
        ConnectionName       string                    `json:"connectionName"`
        VNetId               string                    `json:"vNetId"`
        Description          string                    `json:"description"`
        FirewallRules        *[]SpiderSecurityRuleInfo `json:"firewallRules"`
        CspSecurityGroupId   string                    `json:"cspSecurityGroupId"`
        CspSecurityGroupName string                    `json:"cspSecurityGroupName"`
        KeyValueList         []common.KeyValue         `json:"keyValueList"`
        AssociatedObjectList []string                  `json:"associatedObjectList"`
        IsAutoGenerated      bool                      `json:"isAutoGenerated"`

        // Disabled for now
        //ResourceGroupName  string `json:"resourceGroupName"`
}

// CreateSecurityGroup accepts SG creation request, creates and returns an TB SG object
func CreateSecurityGroup(nsId string, u *TbSecurityGroupReq) (TbSecurityGroupInfo, error) <span class="cov0" title="0">{

        resourceType := common.StrSecurityGroup

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSecurityGroupInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSecurityGroupInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbSecurityGroupInfo{}
                err := fmt.Errorf("The securityGroup " + u.Name + " already exists.")
                //return temp, http.StatusConflict, nil, err
                return temp, err
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                content := TbSecurityGroupInfo{}
                err := fmt.Errorf("Cannot create securityGroup")
                return content, err
        }</span>

        <span class="cov0" title="0">tempReq := SpiderSecurityReqInfoWrapper{}
        tempReq.ConnectionName = u.ConnectionName
        tempReq.ReqInfo.Name = u.Name
        tempReq.ReqInfo.VPCName = u.VNetId
        tempReq.ReqInfo.SecurityRules = u.FirewallRules

        var tempSpiderSecurityInfo *SpiderSecurityInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/securitygroup"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderSecurityInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Post(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := TbSecurityGroupInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := TbSecurityGroupInfo{}
                        return content, err</span>
                }

                <span class="cov0" title="0">tempSpiderSecurityInfo = resp.Result().(*SpiderSecurityInfo)</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return TbSecurityGroupInfo{}, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return TbSecurityGroupInfo{}, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                payload, _ := json.Marshal(tempReq)
                fmt.Println("payload: " + string(payload)) // for debug

                result, err := ccm.CreateSecurity(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSecurityGroupInfo{}, err
                }</span>

                <span class="cov0" title="0">tempSpiderSecurityInfo = &amp;SpiderSecurityInfo{}
                err = json.Unmarshal([]byte(result), &amp;tempSpiderSecurityInfo)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSecurityGroupInfo{}, err
                }</span>
        }

        <span class="cov0" title="0">content := TbSecurityGroupInfo{}
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.ConnectionName = u.ConnectionName
        content.VNetId = tempSpiderSecurityInfo.VpcIID.NameId
        content.CspSecurityGroupId = tempSpiderSecurityInfo.IId.SystemId
        content.CspSecurityGroupName = tempSpiderSecurityInfo.IId.NameId
        content.Description = u.Description
        content.FirewallRules = tempSpiderSecurityInfo.SecurityRules
        content.KeyValueList = tempSpiderSecurityInfo.KeyValueList
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT CreateSecurityGroup")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")
        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strconv"
        "strings"

        //"strings"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"

        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"

        _ "github.com/go-sql-driver/mysql"
)

type SpiderSpecInfo struct { // Spider
        // https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/VMSpecHandler.go

        Region string
        Name   string
        VCpu   SpiderVCpuInfo
        Mem    string
        Gpu    []SpiderGpuInfo

        KeyValueList []common.KeyValue
}

type SpiderVCpuInfo struct { // Spider
        Count string
        Clock string // GHz
}

type SpiderGpuInfo struct { // Spider
        Count string
        Mfr   string
        Model string
        Mem   string
}

type TbSpecReq struct { // Tumblebug
        Name           string `json:"name"`
        ConnectionName string `json:"connectionName"`
        CspSpecName    string `json:"cspSpecName"`
        Description    string `json:"description"`
}

type TbSpecInfo struct { // Tumblebug
        Namespace             string   `json:"namespace"` // required to save in RDB
        Id                    string   `json:"id"`
        Name                  string   `json:"name"`
        ConnectionName        string   `json:"connectionName"`
        CspSpecName           string   `json:"cspSpecName"`
        Os_type               string   `json:"os_type"`
        Num_vCPU              uint16   `json:"num_vCPU"`
        Num_core              uint16   `json:"num_core"`
        Mem_GiB               uint16   `json:"mem_GiB"`
        Storage_GiB           uint32   `json:"storage_GiB"`
        Description           string   `json:"description"`
        Cost_per_hour         float32  `json:"cost_per_hour"`
        Num_storage           uint8    `json:"num_storage"`
        Max_num_storage       uint8    `json:"max_num_storage"`
        Max_total_storage_TiB uint16   `json:"max_total_storage_TiB"`
        Net_bw_Gbps           uint16   `json:"net_bw_Gbps"`
        Ebs_bw_Mbps           uint32   `json:"ebs_bw_Mbps"`
        Gpu_model             string   `json:"gpu_model"`
        Num_gpu               uint8    `json:"num_gpu"`
        Gpumem_GiB            uint16   `json:"gpumem_GiB"`
        Gpu_p2p               string   `json:"gpu_p2p"`
        OrderInFilteredResult uint16   `json:"orderInFilteredResult"`
        EvaluationStatus      string   `json:"evaluationStatus"`
        EvaluationScore_01    float32  `json:"evaluationScore_01"`
        EvaluationScore_02    float32  `json:"evaluationScore_02"`
        EvaluationScore_03    float32  `json:"evaluationScore_03"`
        EvaluationScore_04    float32  `json:"evaluationScore_04"`
        EvaluationScore_05    float32  `json:"evaluationScore_05"`
        EvaluationScore_06    float32  `json:"evaluationScore_06"`
        EvaluationScore_07    float32  `json:"evaluationScore_07"`
        EvaluationScore_08    float32  `json:"evaluationScore_08"`
        EvaluationScore_09    float32  `json:"evaluationScore_09"`
        EvaluationScore_10    float32  `json:"evaluationScore_10"`
        AssociatedObjectList  []string `json:"associatedObjectList"`
        IsAutoGenerated       bool     `json:"isAutoGenerated"`
}

// ConvertSpiderSpecToTumblebugSpec accepts an Spider spec object, converts to and returns an TB spec object
func ConvertSpiderSpecToTumblebugSpec(spiderSpec SpiderSpecInfo) (TbSpecInfo, error) <span class="cov0" title="0">{
        if spiderSpec.Name == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("ConvertSpiderSpecToTumblebugSpec failed; spiderSpec.Name == \"\" ")
                emptyTumblebugSpec := TbSpecInfo{}
                return emptyTumblebugSpec, err
        }</span>

        <span class="cov0" title="0">tumblebugSpec := TbSpecInfo{}

        tumblebugSpec.Name = spiderSpec.Name
        tumblebugSpec.CspSpecName = spiderSpec.Name
        tempUint64, _ := strconv.ParseUint(spiderSpec.VCpu.Count, 10, 16)
        tumblebugSpec.Num_vCPU = uint16(tempUint64)
        tempFloat64, _ := strconv.ParseFloat(spiderSpec.Mem, 32)
        tumblebugSpec.Mem_GiB = uint16(tempFloat64 / 1024) //fmt.Sprintf("%.0f", tempFloat64/1024)

        return tumblebugSpec, nil</span>
}

type SpiderSpecList struct {
        Vmspec []SpiderSpecInfo `json:"vmspec"`
}

// LookupSpecList accepts Spider conn config,
// lookups and returns the list of all specs in the region of conn config
// in the form of the list of Spider spec objects
func LookupSpecList(connConfig string) (SpiderSpecList, error) <span class="cov0" title="0">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderSpecList{}
                err := fmt.Errorf("LookupSpec() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov0" title="0">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/vmspec"

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderSpecList{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderSpecList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderSpecList{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp := resp.Result().(*SpiderSpecList)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderSpecList{}, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderSpecList{}, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                result, err := ccm.ListVMSpecByParam(connConfig)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderSpecList{}, err
                }</span>

                <span class="cov0" title="0">temp := SpiderSpecList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderSpecList{}, err
                }</span>
                <span class="cov0" title="0">return temp, nil</span>

        }
}

// LookupSpec accepts Spider conn config and CSP spec name, lookups and returns the Spider spec object
func LookupSpec(connConfig string, specName string) (SpiderSpecInfo, error) <span class="cov0" title="0">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderSpecInfo{}
                err := fmt.Errorf("LookupSpec() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span> else<span class="cov0" title="0"> if specName == "" </span><span class="cov0" title="0">{
                content := SpiderSpecInfo{}
                err := fmt.Errorf("LookupSpec() called with empty specName.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov0" title="0">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                //url := common.SPIDER_REST_URL + "/vmspec/" + u.CspSpecName
                url := common.SPIDER_REST_URL + "/vmspec/" + specName

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderSpecInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderSpecInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderSpecInfo{}
                        return content, err</span>
                }

                <span class="cov0" title="0">temp := resp.Result().(*SpiderSpecInfo)
                return *temp, nil</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderSpecInfo{}, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderSpecInfo{}, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                result, err := ccm.GetVMSpecByParam(connConfig, specName)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderSpecInfo{}, err
                }</span>

                <span class="cov0" title="0">temp := SpiderSpecInfo{}
                err2 := json.Unmarshal([]byte(result), &amp;temp)
                if err2 != nil </span><span class="cov0" title="0">{
                        fmt.Errorf("an error occurred while unmarshaling: " + err2.Error())
                }</span>
                <span class="cov0" title="0">return temp, nil</span>

        }
}

func RefineSpecName(specName string) string <span class="cov0" title="0">{
        out := strings.ToLower(specName)
        out = strings.ReplaceAll(out, ".", "-")
        out = strings.ReplaceAll(out, "_", "-")

        return out
}</span>

// FetchSpecsForConnConfig lookups all specs for region of conn config, and saves into TB spec objects
func FetchSpecsForConnConfig(connConfig string, nsId string) (specCount uint, err error) <span class="cov0" title="0">{
        fmt.Println("FetchSpecsForConnConfig(" + connConfig + ")")

        spiderSpecList, err := LookupSpecList(connConfig)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>

        <span class="cov0" title="0">for _, spiderSpec := range spiderSpecList.Vmspec </span><span class="cov0" title="0">{
                tumblebugSpec, err := ConvertSpiderSpecToTumblebugSpec(spiderSpec)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return 0, err
                }</span>

                <span class="cov0" title="0">tumblebugSpecId := connConfig + "-" + RefineSpecName(tumblebugSpec.Name)
                //fmt.Println("tumblebugSpecId: " + tumblebugSpecId) // for debug

                check, err := CheckResource(nsId, common.StrSpec, tumblebugSpecId)
                if check </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("The spec " + tumblebugSpecId + " already exists in TB; continue")
                        continue</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("Cannot check the existence of " + tumblebugSpecId + " in TB; continue")
                        continue</span>
                } else<span class="cov0" title="0"> {
                        tumblebugSpec.Name = tumblebugSpecId
                        tumblebugSpec.ConnectionName = connConfig

                        _, err := RegisterSpecWithInfo(nsId, &amp;tumblebugSpec)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">specCount++</span>
                }
        }
        <span class="cov0" title="0">return specCount, nil</span>
}

// FetchSpecsForAllConnConfigs gets all conn configs from Spider, lookups all specs for each region of conn config, and saves into TB spec objects
func FetchSpecsForAllConnConfigs(nsId string) (connConfigCount uint, specCount uint, err error) <span class="cov0" title="0">{

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">connConfigs, err := common.GetConnConfigList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">for _, connConfig := range connConfigs.Connectionconfig </span><span class="cov0" title="0">{
                temp, _ := FetchSpecsForConnConfig(connConfig.ConfigName, nsId)
                specCount += temp
                connConfigCount++
        }</span>
        <span class="cov0" title="0">return connConfigCount, specCount, nil</span>
}

// RegisterSpecWithCspSpecName accepts spec creation request, creates and returns an TB spec object
func RegisterSpecWithCspSpecName(nsId string, u *TbSpecReq) (TbSpecInfo, error) <span class="cov0" title="0">{

        resourceType := common.StrSpec

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("The spec " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov0" title="0">res, err := LookupSpec(u.ConnectionName, u.CspSpecName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err := fmt.Errorf("an error occurred while lookup spec via CB-Spider")
                emptySpecInfoObj := TbSpecInfo{}
                return emptySpecInfoObj, err
        }</span>

        <span class="cov0" title="0">content := TbSpecInfo{}
        content.Namespace = nsId
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.CspSpecName = res.Name
        content.ConnectionName = u.ConnectionName
        content.AssociatedObjectList = []string{}

        tempUint64, _ := strconv.ParseUint(res.VCpu.Count, 10, 16)
        content.Num_vCPU = uint16(tempUint64)

        //content.Num_core = res.Num_core

        tempFloat64, _ := strconv.ParseFloat(res.Mem, 32)
        content.Mem_GiB = uint16(tempFloat64 / 1024)

        //content.Storage_GiB = res.Storage_GiB
        //content.Description = res.Description

        // cb-store
        fmt.Println("=========================== PUT registerSpec")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // register information related with MCIS recommendation
        err = RegisterRecommendList(nsId, content.ConnectionName, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB, content.Id, content.Cost_per_hour)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>

        // "INSERT INTO `spec`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        <span class="cov0" title="0">_, err = common.ORM.Insert(&amp;content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

// RegisterSpecWithInfo accepts spec creation request, creates and returns an TB spec object
func RegisterSpecWithInfo(nsId string, content *TbSpecInfo) (TbSpecInfo, error) <span class="cov0" title="0">{

        resourceType := common.StrSpec

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(content.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckResource(nsId, resourceType, content.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("The spec " + content.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov0" title="0">content.Namespace = nsId
        content.Id = content.Name
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT registerSpec")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return *content, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // register information related with MCIS recommendation
        err = RegisterRecommendList(nsId, content.ConnectionName, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB, content.Id, content.Cost_per_hour)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return *content, err
        }</span>

        // "INSERT INTO `spec`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        <span class="cov0" title="0">_, err = common.ORM.Insert(content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov0" title="0">return *content, nil</span>
}

// RegisterRecommendList creates the spec recommendation info
func RegisterRecommendList(nsId string, connectionName string, cpuSize uint16, memSize uint16, diskSize uint32, specId string, price float32) error <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        //fmt.Println("[Get MCISs")
        <span class="cov0" title="0">key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + strconv.Itoa(int(cpuSize)) + "/memSize/" + strconv.Itoa(int(memSize)) + "/diskSize/" + strconv.Itoa(int(diskSize)) + "/specId/" + specId
        fmt.Println(key)

        mapA := map[string]string{"id": specId, "price": fmt.Sprintf("%.6f", price), "connectionName": connectionName}
        Val, _ := json.Marshal(mapA)

        err = common.CBStore.Put(string(key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("===============================================")
        return nil</span>

}

// DelRecommendSpec deletes the spec recommendation info
func DelRecommendSpec(nsId string, specId string, cpuSize uint16, memSize uint16, diskSize uint32) error <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("DelRecommendSpec()")

        key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + strconv.Itoa(int(cpuSize)) + "/memSize/" + strconv.Itoa(int(memSize)) + "/diskSize/" + strconv.Itoa(int(diskSize)) + "/specId/" + specId

        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

// FilterSpecs accepts criteria for filtering, and returns the list of filtered TB spec objects
func FilterSpecs(nsId string, filter TbSpecInfo) ([]TbSpecInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">tempList := []TbSpecInfo{}

        //sqlQuery := "SELECT * FROM `spec` WHERE `namespace`='" + nsId + "'"
        sqlQuery := common.ORM.Where("Namespace = ?", nsId)

        if filter.Id != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `id` LIKE '%" + filter.Id + "%'"
                filter.Id = RefineSpecName(filter.Id)
                sqlQuery = sqlQuery.And("Id LIKE ?", "%"+filter.Id+"%")
        }</span>
        <span class="cov0" title="0">if filter.Name != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `name` LIKE '%" + filter.Name + "%'"
                filter.Name = RefineSpecName(filter.Name)
                sqlQuery = sqlQuery.And("Name LIKE ?", "%"+filter.Name+"%")
        }</span>
        <span class="cov0" title="0">if filter.ConnectionName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `connectionName` LIKE '%" + filter.ConnectionName + "%'"
                filter.ConnectionName = RefineSpecName(filter.ConnectionName)
                sqlQuery = sqlQuery.And("ConnectionName LIKE ?", "%"+filter.ConnectionName+"%")
        }</span>
        <span class="cov0" title="0">if filter.CspSpecName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cspSpecName` LIKE '%" + filter.CspSpecName + "%'"
                filter.CspSpecName = RefineSpecName(filter.CspSpecName)
                sqlQuery = sqlQuery.And("CspSpecName LIKE ?", "%"+filter.CspSpecName+"%")
        }</span>
        <span class="cov0" title="0">if filter.Os_type != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `os_type` LIKE '%" + filter.Os_type + "%'"
                filter.Os_type = RefineSpecName(filter.Os_type)
                sqlQuery = sqlQuery.And("Os_type LIKE ?", "%"+filter.Os_type+"%")
        }</span>

        <span class="cov0" title="0">if filter.Num_vCPU &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_vCPU`=" + strconv.Itoa(int(filter.Num_vCPU))
                sqlQuery = sqlQuery.And("Num_vCPU = ?", filter.Num_vCPU)
        }</span>
        <span class="cov0" title="0">if filter.Num_core &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_core`=" + strconv.Itoa(int(filter.Num_core))
                sqlQuery = sqlQuery.And("Num_core = ?", filter.Num_core)
        }</span>
        <span class="cov0" title="0">if filter.Mem_GiB &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `mem_GiB`=" + strconv.Itoa(int(filter.Mem_GiB))
                sqlQuery = sqlQuery.And("Mem_GiB = ?", filter.Mem_GiB)
        }</span>
        <span class="cov0" title="0">if filter.Storage_GiB &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `storage_GiB`=" + strconv.Itoa(int(filter.Storage_GiB))
                sqlQuery = sqlQuery.And("Storage_GiB = ?", filter.Storage_GiB)
        }</span>
        <span class="cov0" title="0">if filter.Description != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `description` LIKE '%" + filter.Description + "%'"
                filter.Description = RefineSpecName(filter.Description)
                sqlQuery = sqlQuery.And("Description LIKE ?", "%"+filter.Description+"%")
        }</span>
        <span class="cov0" title="0">if filter.Cost_per_hour &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cost_per_hour`=" + fmt.Sprintf("%.6f", filter.Cost_per_hour)
                sqlQuery = sqlQuery.And("Cost_per_hour = ?", filter.Cost_per_hour)
        }</span>
        <span class="cov0" title="0">if filter.Num_storage &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_storage`=" + strconv.Itoa(int(filter.Num_storage))
                sqlQuery = sqlQuery.And("Num_storage = ?", filter.Num_storage)
        }</span>
        <span class="cov0" title="0">if filter.Max_num_storage &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_num_storage`=" + strconv.Itoa(int(filter.Max_num_storage))
                sqlQuery = sqlQuery.And("Max_num_storage = ?", filter.Max_num_storage)
        }</span>
        <span class="cov0" title="0">if filter.Max_total_storage_TiB &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_total_storage_TiB`=" + strconv.Itoa(int(filter.Max_total_storage_TiB))
                sqlQuery = sqlQuery.And("Max_total_storage_TiB = ?", filter.Max_total_storage_TiB)
        }</span>
        <span class="cov0" title="0">if filter.Net_bw_Gbps &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `net_bw_Gbps`=" + strconv.Itoa(int(filter.Net_bw_Gbps))
                sqlQuery = sqlQuery.And("Net_bw_Gbps = ?", filter.Net_bw_Gbps)
        }</span>
        <span class="cov0" title="0">if filter.Ebs_bw_Mbps &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `ebs_bw_Mbps`=" + strconv.Itoa(int(filter.Ebs_bw_Mbps))
                sqlQuery = sqlQuery.And("Ebs_bw_Mbps = ?", filter.Ebs_bw_Mbps)
        }</span>
        <span class="cov0" title="0">if filter.Gpu_model != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_model` LIKE '%" + filter.Gpu_model + "%'"
                filter.Gpu_model = RefineSpecName(filter.Gpu_model)
                sqlQuery = sqlQuery.And("Gpu_model LIKE ?", "%"+filter.Gpu_model+"%")
        }</span>
        <span class="cov0" title="0">if filter.Num_gpu &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_gpu`=" + strconv.Itoa(int(filter.Num_gpu))
                sqlQuery = sqlQuery.And("Num_gpu = ?", filter.Num_gpu)
        }</span>
        <span class="cov0" title="0">if filter.Gpumem_GiB &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpumem_GiB`=" + strconv.Itoa(int(filter.Gpumem_GiB))
                sqlQuery = sqlQuery.And("Gpumem_GiB = ?", filter.Gpumem_GiB)
        }</span>
        <span class="cov0" title="0">if filter.Gpu_p2p != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_p2p` LIKE '%" + filter.Gpu_p2p + "%'"
                filter.Gpu_p2p = RefineSpecName(filter.Gpu_p2p)
                sqlQuery = sqlQuery.And("Gpu_p2p LIKE ?", "%"+filter.Gpu_p2p+"%")
        }</span>
        <span class="cov0" title="0">if filter.EvaluationStatus != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationStatus` LIKE '%" + filter.EvaluationStatus + "%'"
                filter.EvaluationStatus = RefineSpecName(filter.EvaluationStatus)
                sqlQuery = sqlQuery.And("EvaluationStatus LIKE ?", "%"+filter.EvaluationStatus+"%")
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_01 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_01`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_01)
                sqlQuery = sqlQuery.And("EvaluationScore_01 = ?", filter.EvaluationScore_01)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_02 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_02`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_02)
                sqlQuery = sqlQuery.And("EvaluationScore_02 = ?", filter.EvaluationScore_02)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_03 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_03`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_03)
                sqlQuery = sqlQuery.And("EvaluationScore_03 = ?", filter.EvaluationScore_03)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_04 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_04`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_04)
                sqlQuery = sqlQuery.And("EvaluationScore_04 = ?", filter.EvaluationScore_04)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_05 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_05`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_05)
                sqlQuery = sqlQuery.And("EvaluationScore_05 = ?", filter.EvaluationScore_05)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_06 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_06`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_06)
                sqlQuery = sqlQuery.And("EvaluationScore_06 = ?", filter.EvaluationScore_06)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_07 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_07`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_07)
                sqlQuery = sqlQuery.And("EvaluationScore_07 = ?", filter.EvaluationScore_07)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_08 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_08`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_08)
                sqlQuery = sqlQuery.And("EvaluationScore_08 = ?", filter.EvaluationScore_08)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_09 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_09`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_09)
                sqlQuery = sqlQuery.And("EvaluationScore_09 = ?", filter.EvaluationScore_09)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_10 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_10`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_10)
                sqlQuery = sqlQuery.And("EvaluationScore_10 = ?", filter.EvaluationScore_10)
        }</span>

        <span class="cov0" title="0">err = sqlQuery.Find(&amp;tempList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempList, err
        }</span>
        <span class="cov0" title="0">return tempList, nil</span>
}

type Range struct {
        Min float32 `json:"min"`
        Max float32 `json:"max"`
}

type FilterSpecsByRangeRequest struct {
        Id                    string `json:"id"`
        Name                  string `json:"name"`
        ConnectionName        string `json:"connectionName"`
        CspSpecName           string `json:"cspSpecName"`
        Os_type               string `json:"os_type"`
        Num_vCPU              Range  `json:"num_vCPU"`
        Num_core              Range  `json:"num_core"`
        Mem_GiB               Range  `json:"mem_GiB"`
        Storage_GiB           Range  `json:"storage_GiB"`
        Description           string `json:"description"`
        Cost_per_hour         Range  `json:"cost_per_hour"`
        Num_storage           Range  `json:"num_storage"`
        Max_num_storage       Range  `json:"max_num_storage"`
        Max_total_storage_TiB Range  `json:"max_total_storage_TiB"`
        Net_bw_Gbps           Range  `json:"net_bw_Gbps"`
        Ebs_bw_Mbps           Range  `json:"ebs_bw_Mbps"`
        Gpu_model             string `json:"gpu_model"`
        Num_gpu               Range  `json:"num_gpu"`
        Gpumem_GiB            Range  `json:"gpumem_GiB"`
        Gpu_p2p               string `json:"gpu_p2p"`
        EvaluationStatus      string `json:"evaluationStatus"`
        EvaluationScore_01    Range  `json:"evaluationScore_01"`
        EvaluationScore_02    Range  `json:"evaluationScore_02"`
        EvaluationScore_03    Range  `json:"evaluationScore_03"`
        EvaluationScore_04    Range  `json:"evaluationScore_04"`
        EvaluationScore_05    Range  `json:"evaluationScore_05"`
        EvaluationScore_06    Range  `json:"evaluationScore_06"`
        EvaluationScore_07    Range  `json:"evaluationScore_07"`
        EvaluationScore_08    Range  `json:"evaluationScore_08"`
        EvaluationScore_09    Range  `json:"evaluationScore_09"`
        EvaluationScore_10    Range  `json:"evaluationScore_10"`
}

// FilterSpecsByRange accepts criteria ranges for filtering, and returns the list of filtered TB spec objects
func FilterSpecsByRange(nsId string, filter FilterSpecsByRangeRequest) ([]TbSpecInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">tempList := []TbSpecInfo{}

        //sqlQuery := "SELECT * FROM `spec` WHERE `namespace`='" + nsId + "'"
        sqlQuery := common.ORM.Where("Namespace = ?", nsId)

        if filter.Id != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `id` LIKE '%" + filter.Id + "%'"
                filter.Id = RefineSpecName(filter.Id)
                sqlQuery = sqlQuery.And("Id LIKE ?", "%"+filter.Id+"%")
        }</span>
        <span class="cov0" title="0">if filter.Name != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `name` LIKE '%" + filter.Name + "%'"
                filter.Name = RefineSpecName(filter.Name)
                sqlQuery = sqlQuery.And("Name LIKE ?", "%"+filter.Name+"%")
        }</span>
        <span class="cov0" title="0">if filter.ConnectionName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `connectionName` LIKE '%" + filter.ConnectionName + "%'"
                filter.ConnectionName = RefineSpecName(filter.ConnectionName)
                sqlQuery = sqlQuery.And("ConnectionName LIKE ?", "%"+filter.ConnectionName+"%")
        }</span>
        <span class="cov0" title="0">if filter.CspSpecName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cspSpecName` LIKE '%" + filter.CspSpecName + "%'"
                filter.CspSpecName = RefineSpecName(filter.CspSpecName)
                sqlQuery = sqlQuery.And("CspSpecName LIKE ?", "%"+filter.CspSpecName+"%")
        }</span>
        <span class="cov0" title="0">if filter.Os_type != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `os_type` LIKE '%" + filter.Os_type + "%'"
                filter.Os_type = RefineSpecName(filter.Os_type)
                sqlQuery = sqlQuery.And("Os_type LIKE ?", "%"+filter.Os_type+"%")
        }</span>

        <span class="cov0" title="0">if filter.Num_vCPU.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_vCPU`&gt;=" + fmt.Sprintf("%.6f", filter.Num_vCPU.Min)
                sqlQuery = sqlQuery.And("Num_vCPU &gt;= ?", filter.Num_vCPU.Min)
        }</span>
        <span class="cov0" title="0">if filter.Num_vCPU.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_vCPU`&lt;=" + fmt.Sprintf("%.6f", filter.Num_vCPU.Max)
                sqlQuery = sqlQuery.And("Num_vCPU &lt;= ?", filter.Num_vCPU.Max)
        }</span>

        <span class="cov0" title="0">if filter.Num_core.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_core`&gt;=" + fmt.Sprintf("%.6f", filter.Num_core.Min)
                sqlQuery = sqlQuery.And("Num_core &gt;= ?", filter.Num_core.Min)
        }</span>
        <span class="cov0" title="0">if filter.Num_core.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_core`&lt;=" + fmt.Sprintf("%.6f", filter.Num_core.Max)
                sqlQuery = sqlQuery.And("Num_core &lt;= ?", filter.Num_core.Max)
        }</span>

        <span class="cov0" title="0">if filter.Mem_GiB.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `mem_GiB`&gt;=" + fmt.Sprintf("%.6f", filter.Mem_GiB.Min)
                sqlQuery = sqlQuery.And("Mem_GiB &gt;= ?", filter.Mem_GiB.Min)
        }</span>
        <span class="cov0" title="0">if filter.Mem_GiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `mem_GiB`&lt;=" + fmt.Sprintf("%.6f", filter.Mem_GiB.Max)
                sqlQuery = sqlQuery.And("Mem_GiB &lt;= ?", filter.Mem_GiB.Max)
        }</span>

        <span class="cov0" title="0">if filter.Storage_GiB.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `storage_GiB`&gt;=" + fmt.Sprintf("%.6f", filter.Storage_GiB.Min)
                sqlQuery = sqlQuery.And("Storage_GiB &gt;= ?", filter.Storage_GiB.Min)
        }</span>
        <span class="cov0" title="0">if filter.Storage_GiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `storage_GiB`&lt;=" + fmt.Sprintf("%.6f", filter.Storage_GiB.Max)
                sqlQuery = sqlQuery.And("Storage_GiB &lt;= ?", filter.Storage_GiB.Max)
        }</span>

        <span class="cov0" title="0">if filter.Description != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `description` LIKE '%" + filter.Description + "%'"
                filter.Description = RefineSpecName(filter.Description)
                sqlQuery = sqlQuery.And("Description LIKE ?", "%"+filter.Description+"%")
        }</span>

        <span class="cov0" title="0">if filter.Cost_per_hour.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cost_per_hour`&gt;=" + fmt.Sprintf("%.6f", filter.Cost_per_hour.Min)
                sqlQuery = sqlQuery.And("Cost_per_hour &gt;= ?", filter.Cost_per_hour.Min)
        }</span>
        <span class="cov0" title="0">if filter.Cost_per_hour.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cost_per_hour`&lt;=" + fmt.Sprintf("%.6f", filter.Cost_per_hour.Max)
                sqlQuery = sqlQuery.And("Cost_per_hour &lt;= ?", filter.Cost_per_hour.Max)
        }</span>

        <span class="cov0" title="0">if filter.Num_storage.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_storage`&gt;=" + fmt.Sprintf("%.6f", filter.Num_storage.Min)
                sqlQuery = sqlQuery.And("Num_storage &gt;= ?", filter.Num_storage.Min)
        }</span>
        <span class="cov0" title="0">if filter.Num_storage.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_storage`&lt;=" + fmt.Sprintf("%.6f", filter.Num_storage.Max)
                sqlQuery = sqlQuery.And("Num_storage &lt;= ?", filter.Num_storage.Max)
        }</span>

        <span class="cov0" title="0">if filter.Max_num_storage.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_num_storage`&gt;=" + fmt.Sprintf("%.6f", filter.Max_num_storage.Min)
                sqlQuery = sqlQuery.And("Max_num_storage &gt;= ?", filter.Max_num_storage.Min)
        }</span>
        <span class="cov0" title="0">if filter.Max_num_storage.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_num_storage`&lt;=" + fmt.Sprintf("%.6f", filter.Max_num_storage.Max)
                sqlQuery = sqlQuery.And("Max_num_storage &lt;= ?", filter.Max_num_storage.Max)
        }</span>

        <span class="cov0" title="0">if filter.Max_total_storage_TiB.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_total_storage_TiB`&gt;=" + fmt.Sprintf("%.6f", filter.Max_total_storage_TiB.Min)
                sqlQuery = sqlQuery.And("Max_total_storage_TiB &gt;= ?", filter.Max_total_storage_TiB.Min)
        }</span>
        <span class="cov0" title="0">if filter.Max_total_storage_TiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_total_storage_TiB`&lt;=" + fmt.Sprintf("%.6f", filter.Max_total_storage_TiB.Max)
                sqlQuery = sqlQuery.And("Max_total_storage_TiB &lt;= ?", filter.Max_total_storage_TiB.Max)
        }</span>

        <span class="cov0" title="0">if filter.Net_bw_Gbps.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `net_bw_Gbps`&gt;=" + fmt.Sprintf("%.6f", filter.Net_bw_Gbps.Min)
                sqlQuery = sqlQuery.And("Net_bw_Gbps &gt;= ?", filter.Net_bw_Gbps.Min)
        }</span>
        <span class="cov0" title="0">if filter.Net_bw_Gbps.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `net_bw_Gbps`&lt;=" + fmt.Sprintf("%.6f", filter.Net_bw_Gbps.Max)
                sqlQuery = sqlQuery.And("Net_bw_Gbps &lt;= ?", filter.Net_bw_Gbps.Max)
        }</span>

        <span class="cov0" title="0">if filter.Ebs_bw_Mbps.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `ebs_bw_Mbps`&gt;=" + fmt.Sprintf("%.6f", filter.Ebs_bw_Mbps.Min)
                sqlQuery = sqlQuery.And("Ebs_bw_Mbps &gt;= ?", filter.Ebs_bw_Mbps.Min)
        }</span>
        <span class="cov0" title="0">if filter.Ebs_bw_Mbps.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `ebs_bw_Mbps`&lt;=" + fmt.Sprintf("%.6f", filter.Ebs_bw_Mbps.Max)
                sqlQuery = sqlQuery.And("Ebs_bw_Mbps &lt;= ?", filter.Ebs_bw_Mbps.Max)
        }</span>

        <span class="cov0" title="0">if filter.Gpu_model != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_model` LIKE '%" + filter.Gpu_model + "%'"
                filter.Gpu_model = RefineSpecName(filter.Gpu_model)
                sqlQuery = sqlQuery.And("Gpu_model LIKE ?", "%"+filter.Gpu_model+"%")
        }</span>

        <span class="cov0" title="0">if filter.Num_gpu.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_gpu`&gt;=" + fmt.Sprintf("%.6f", filter.Num_gpu.Min)
                sqlQuery = sqlQuery.And("Num_gpu &gt;= ?", filter.Num_gpu.Min)
        }</span>
        <span class="cov0" title="0">if filter.Num_gpu.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_gpu`&lt;=" + fmt.Sprintf("%.6f", filter.Num_gpu.Max)
                sqlQuery = sqlQuery.And("Num_gpu &lt;= ?", filter.Num_gpu.Max)
        }</span>

        <span class="cov0" title="0">if filter.Gpumem_GiB.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpumem_GiB`&gt;=" + fmt.Sprintf("%.6f", filter.Gpumem_GiB.Min)
                sqlQuery = sqlQuery.And("Gpumem_GiB &gt;= ?", filter.Gpumem_GiB.Min)
        }</span>
        <span class="cov0" title="0">if filter.Gpumem_GiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpumem_GiB`&lt;=" + fmt.Sprintf("%.6f", filter.Gpumem_GiB.Max)
                sqlQuery = sqlQuery.And("Gpumem_GiB &lt;= ?", filter.Gpumem_GiB.Max)
        }</span>

        <span class="cov0" title="0">if filter.Gpu_p2p != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_p2p` LIKE '%" + filter.Gpu_p2p + "%'"
                filter.Gpu_p2p = RefineSpecName(filter.Gpu_p2p)
                sqlQuery = sqlQuery.And("Gpu_p2p LIKE ?", "%"+filter.Gpu_p2p+"%")
        }</span>
        <span class="cov0" title="0">if filter.EvaluationStatus != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationStatus` LIKE '%" + filter.EvaluationStatus + "%'"
                filter.EvaluationStatus = RefineSpecName(filter.EvaluationStatus)
                sqlQuery = sqlQuery.And("EvaluationStatus LIKE ?", "%"+filter.EvaluationStatus+"%")
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_01.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_01`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_01.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_01 &gt;= ?", filter.EvaluationScore_01.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_01.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_01`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_01.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_01 &lt;= ?", filter.EvaluationScore_01.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_02.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_02`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_02.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_02 &gt;= ?", filter.EvaluationScore_02.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_02.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_02`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_02.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_02 &lt;= ?", filter.EvaluationScore_02.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_03.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_03`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_03.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_03 &gt;= ?", filter.EvaluationScore_03.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_03.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_03`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_03.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_03 &lt;= ?", filter.EvaluationScore_03.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_04.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_04`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_04.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_04 &gt;= ?", filter.EvaluationScore_04.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_04.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_04`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_04.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_04 &lt;= ?", filter.EvaluationScore_04.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_05.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_05`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_05.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_05 &gt;= ?", filter.EvaluationScore_05.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_05.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_05`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_05.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_05 &lt;= ?", filter.EvaluationScore_05.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_06.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_06`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_06.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_06 &gt;= ?", filter.EvaluationScore_06.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_06.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_06`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_06.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_06 &lt;= ?", filter.EvaluationScore_06.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_07.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_07`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_07.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_07 &gt;= ?", filter.EvaluationScore_07.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_07.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_07`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_07.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_07 &lt;= ?", filter.EvaluationScore_07.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_08.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_08`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_08.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_08 &gt;= ?", filter.EvaluationScore_08.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_08.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_08`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_08.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_08 &lt;= ?", filter.EvaluationScore_08.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_09.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_09`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_09.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_09 &gt;= ?", filter.EvaluationScore_09.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_09.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_09`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_09.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_09 &lt;= ?", filter.EvaluationScore_09.Max)
        }</span>

        <span class="cov0" title="0">if filter.EvaluationScore_10.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_10`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_10.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_10 &gt;= ?", filter.EvaluationScore_10.Min)
        }</span>
        <span class="cov0" title="0">if filter.EvaluationScore_10.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_10`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_10.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_10 &lt;= ?", filter.EvaluationScore_10.Max)
        }</span>

        <span class="cov0" title="0">err = sqlQuery.Find(&amp;tempList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempList, err
        }</span>

        <span class="cov0" title="0">return tempList, nil</span>
}

// SortSpecs accepts the list of TB spec objects, criteria and sorting direction,
// sorts and returns the sorted list of TB spec objects
func SortSpecs(specList []TbSpecInfo, orderBy string, direction string) ([]TbSpecInfo, error) <span class="cov0" title="0">{
        var err error = nil

        sort.Slice(specList, func(i, j int) bool </span><span class="cov0" title="0">{
                if orderBy == "num_vCPU" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].Num_vCPU &gt; specList[j].Num_vCPU
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].Num_vCPU &lt; specList[j].Num_vCPU
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "mem_GiB" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].Mem_GiB &gt; specList[j].Mem_GiB
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].Mem_GiB &lt; specList[j].Mem_GiB
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "storage_GiB" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].Storage_GiB &gt; specList[j].Storage_GiB
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].Storage_GiB &lt; specList[j].Storage_GiB
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_01" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_01 &gt; specList[j].EvaluationScore_01
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_01 &lt; specList[j].EvaluationScore_01
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_02" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_02 &gt; specList[j].EvaluationScore_02
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_02 &lt; specList[j].EvaluationScore_02
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_03" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_03 &gt; specList[j].EvaluationScore_03
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_03 &lt; specList[j].EvaluationScore_03
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_04" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_04 &gt; specList[j].EvaluationScore_04
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_04 &lt; specList[j].EvaluationScore_04
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_05" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_05 &gt; specList[j].EvaluationScore_05
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_05 &lt; specList[j].EvaluationScore_05
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_06" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_06 &gt; specList[j].EvaluationScore_06
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_06 &lt; specList[j].EvaluationScore_06
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_07" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_07 &gt; specList[j].EvaluationScore_07
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_07 &lt; specList[j].EvaluationScore_07
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_08" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_08 &gt; specList[j].EvaluationScore_08
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_08 &lt; specList[j].EvaluationScore_08
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_09" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_09 &gt; specList[j].EvaluationScore_09
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_09 &lt; specList[j].EvaluationScore_09
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_10" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_10 &gt; specList[j].EvaluationScore_10
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_10 &lt; specList[j].EvaluationScore_10
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> {
                        err = fmt.Errorf("'orderBy' should one of these: num_vCPU, mem_GiB, storage_GiB")
                        return true
                }</span>
        })

        <span class="cov0" title="0">for i := range specList </span><span class="cov0" title="0">{
                specList[i].OrderInFilteredResult = uint16(i + 1)
        }</span>

        <span class="cov0" title="0">return specList, err</span>
}

// UpdateSpec accepts to-be TB spec objects,
// updates and returns the updated TB spec objects
func UpdateSpec(nsId string, newSpec TbSpecInfo) (TbSpecInfo, error) <span class="cov0" title="0">{
        resourceType := common.StrSpec

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(newSpec.Id)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckResource(nsId, resourceType, newSpec.Id)

        if !check </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("The spec " + newSpec.Id + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">tempInterface, err := GetResource(nsId, resourceType, newSpec.Id)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("Failed to get the spec " + newSpec.Id + ".")
                return temp, err
        }</span>
        <span class="cov0" title="0">tempSpec := TbSpecInfo{}
        err = common.CopySrcToDest(&amp;tempInterface, &amp;tempSpec)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("Failed to CopySrcToDest() " + newSpec.Id + ".")
                return temp, err
        }</span>

        // cb-store
        <span class="cov0" title="0">fmt.Println("=========================== PUT registerSpec")
        Key := common.GenResourceKey(nsId, resourceType, tempSpec.Id)
        Val, _ := json.Marshal(tempSpec)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // register information related with MCIS recommendation
        err = RegisterRecommendList(nsId, tempSpec.ConnectionName, tempSpec.Num_vCPU, tempSpec.Mem_GiB, tempSpec.Storage_GiB, tempSpec.Id, tempSpec.Cost_per_hour)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempSpec, err
        }</span>

        // "UPDATE `spec` SET `id`='" + newSpec.Id + "', ... WHERE `namespace`='" + nsId + "' AND `id`='" + newSpec.Id + "';"
        <span class="cov0" title="0">_, err = common.ORM.Update(&amp;newSpec, &amp;TbSpecInfo{Namespace: nsId, Id: newSpec.Id})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov0" title="0">return tempSpec, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"
)

// 2020-04-03 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/KeyPairHandler.go

type SpiderKeyPairReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderKeyPairInfo
}

/*
type SpiderKeyPairReqInfo struct { // Spider
        Name string
}
*/

type SpiderKeyPairInfo struct { // Spider
        // Fields for request
        Name string

        // Fields for response
        IId          common.IID // {NameId, SystemId}
        Fingerprint  string
        PublicKey    string
        PrivateKey   string
        VMUserID     string
        KeyValueList []common.KeyValue
}

type TbSshKeyReq struct {
        Name           string `json:"name"`
        ConnectionName string `json:"connectionName"`
        Description    string `json:"description"`
}

type TbSshKeyInfo struct {
        Id                   string            `json:"id"`
        Name                 string            `json:"name"`
        ConnectionName       string            `json:"connectionName"`
        Description          string            `json:"description"`
        CspSshKeyName        string            `json:"cspSshKeyName"`
        Fingerprint          string            `json:"fingerprint"`
        Username             string            `json:"username"`
        VerifiedUsername     string            `json:"verifiedUsername"`
        PublicKey            string            `json:"publicKey"`
        PrivateKey           string            `json:"privateKey"`
        KeyValueList         []common.KeyValue `json:"keyValueList"`
        AssociatedObjectList []string          `json:"associatedObjectList"`
        IsAutoGenerated      bool              `json:"isAutoGenerated"`
}

// CreateSshKey accepts SSH key creation request, creates and returns an TB sshKey object
func CreateSshKey(nsId string, u *TbSshKeyReq) (TbSshKeyInfo, error) <span class="cov0" title="0">{

        resourceType := common.StrSSHKey

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSshKeyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSshKeyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbSshKeyInfo{}
                err := fmt.Errorf("The sshKey " + u.Name + " already exists.")
                //return temp, http.StatusConflict, nil, err
                return temp, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                temp := TbSshKeyInfo{}
                err := fmt.Errorf("Failed to check the existence of the sshKey " + u.Name + ".")
                return temp, err
        }</span>

        <span class="cov0" title="0">tempReq := SpiderKeyPairReqInfoWrapper{}
        tempReq.ConnectionName = u.ConnectionName
        tempReq.ReqInfo.Name = u.Name

        var tempSpiderKeyPairInfo *SpiderKeyPairInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/keypair"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderKeyPairInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Post(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := TbSshKeyInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        fmt.Println("body: ", string(resp.Body()))
                        common.CBLog.Error(err)
                        content := TbSshKeyInfo{}
                        return content, err</span>
                }

                <span class="cov0" title="0">tempSpiderKeyPairInfo = resp.Result().(*SpiderKeyPairInfo)</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return TbSshKeyInfo{}, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return TbSshKeyInfo{}, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                //fmt.Println("payload: " + string(payload)) // for debug

                result, err := ccm.CreateKey(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSshKeyInfo{}, err
                }</span>

                <span class="cov0" title="0">tempSpiderKeyPairInfo = &amp;SpiderKeyPairInfo{}
                err = json.Unmarshal([]byte(result), &amp;tempSpiderKeyPairInfo)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSshKeyInfo{}, err
                }</span>

        }

        <span class="cov0" title="0">content := TbSshKeyInfo{}
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.ConnectionName = u.ConnectionName
        content.CspSshKeyName = tempSpiderKeyPairInfo.IId.NameId
        content.Fingerprint = tempSpiderKeyPairInfo.Fingerprint
        content.Username = tempSpiderKeyPairInfo.VMUserID
        content.PublicKey = tempSpiderKeyPairInfo.PublicKey
        content.PrivateKey = tempSpiderKeyPairInfo.PrivateKey
        content.Description = u.Description
        content.KeyValueList = tempSpiderKeyPairInfo.KeyValueList
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT CreateSshKey")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        //keyValue, _ := common.CBStore.Get(string(Key))
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        <span class="cov0" title="0">fmt.Println("===========================")
        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"
)

// 2020-04-09 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/VPCHandler.go

type SpiderVPCReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderVPCReqInfo
}

type SpiderVPCReqInfo struct { // Spider
        Name           string
        IPv4_CIDR      string
        SubnetInfoList []SpiderSubnetReqInfo
        //SubnetInfoList []SpiderSubnetInfo
}

type SpiderSubnetReqInfo struct { // Spider
        Name         string
        IPv4_CIDR    string
        KeyValueList []common.KeyValue
}

type SpiderVPCInfo struct { // Spider
        IId            common.IID // {NameId, SystemId}
        IPv4_CIDR      string
        SubnetInfoList []SpiderSubnetInfo
        KeyValueList   []common.KeyValue
}

type SpiderSubnetInfo struct { // Spider
        IId          common.IID // {NameId, SystemId}
        IPv4_CIDR    string
        KeyValueList []common.KeyValue
}

type TbVNetReq struct { // Tumblebug
        Name           string                `json:"name"`
        ConnectionName string                `json:"connectionName"`
        CidrBlock      string                `json:"cidrBlock"`
        SubnetInfoList []SpiderSubnetReqInfo `json:"subnetInfoList"`
        Description    string                `json:"description"`
}

type TbVNetInfo struct { // Tumblebug
        Id                   string             `json:"id"`
        Name                 string             `json:"name"`
        ConnectionName       string             `json:"connectionName"`
        CidrBlock            string             `json:"cidrBlock"`
        SubnetInfoList       []SpiderSubnetInfo `json:"subnetInfoList"`
        Description          string             `json:"description"`
        CspVNetId            string             `json:"cspVNetId"`
        CspVNetName          string             `json:"cspVNetName"`
        Status               string             `json:"status"`
        KeyValueList         []common.KeyValue  `json:"keyValueList"`
        AssociatedObjectList []string           `json:"associatedObjectList"`
        IsAutoGenerated      bool               `json:"isAutoGenerated"`

        // Disabled for now
        //Region         string `json:"region"`
        //ResourceGroupName string `json:"resourceGroupName"`
}

// CreateVNet accepts vNet creation request, creates and returns an TB vNet object
func CreateVNet(nsId string, u *TbVNetReq) (TbVNetInfo, error) <span class="cov0" title="0">{

        resourceType := common.StrVNet

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbVNetInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbVNetInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbVNetInfo{}
                err := fmt.Errorf("The vNet " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                temp := TbVNetInfo{}
                err := fmt.Errorf("Failed to check the existence of the vNet " + u.Name + ".")
                return temp, err
        }</span>

        <span class="cov0" title="0">tempReq := SpiderVPCReqInfoWrapper{}
        tempReq.ConnectionName = u.ConnectionName
        tempReq.ReqInfo.Name = u.Name
        tempReq.ReqInfo.IPv4_CIDR = u.CidrBlock
        tempReq.ReqInfo.SubnetInfoList = u.SubnetInfoList

        var tempSpiderVPCInfo *SpiderVPCInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/vpc"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderVPCInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Post(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := TbVNetInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov0" title="0">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := TbVNetInfo{}
                        return content, err</span>
                }

                <span class="cov0" title="0">tempSpiderVPCInfo = resp.Result().(*SpiderVPCInfo)</span>

        } else<span class="cov0" title="0"> {

                // Set CCM API
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return TbVNetInfo{}, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return TbVNetInfo{}, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                fmt.Println("payload: " + string(payload)) // for debug

                result, err := ccm.CreateVPC(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbVNetInfo{}, err
                }</span>

                <span class="cov0" title="0">tempSpiderVPCInfo = &amp;SpiderVPCInfo{} // Spider
                err = json.Unmarshal([]byte(result), &amp;tempSpiderVPCInfo)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbVNetInfo{}, err
                }</span>

        }

        <span class="cov0" title="0">content := TbVNetInfo{}
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.ConnectionName = u.ConnectionName
        content.CspVNetId = tempSpiderVPCInfo.IId.SystemId
        content.CspVNetName = tempSpiderVPCInfo.IId.NameId
        content.CidrBlock = tempSpiderVPCInfo.IPv4_CIDR
        content.SubnetInfoList = tempSpiderVPCInfo.SubnetInfoList
        content.Description = u.Description
        content.KeyValueList = tempSpiderVPCInfo.KeyValueList
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT CreateVNet")
        Key := common.GenResourceKey(nsId, common.StrVNet, content.Id)
        Val, _ := json.Marshal(content)

        //fmt.Println("Key: ", Key)
        //fmt.Println("Val: ", Val)
        err3 := common.CBStore.Put(string(Key), string(Val))
        if err3 != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err3)
                return content, err3
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")
        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package mcis

import (
        "errors"

        "encoding/json"
        "fmt"
        "io/ioutil"

        //"log"
        "strconv"
        "strings"
        "time"

        //csv file handling
        "bufio"
        "encoding/csv"
        "os"

        "math/rand"
        "reflect"

        // REST API (echo)
        "net/http"

        "sync"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"

        cbstore_utils "github.com/cloud-barista/cb-store/utils"
)

// const ActionCreate
const ActionCreate string = "Create"

// const ActionTerminate
const ActionTerminate string = "Terminate"

// const ActionSuspend
const ActionSuspend string = "Suspend"

// const ActionResume
const ActionResume string = "Resume"

// const ActionReboot
const ActionReboot string = "Reboot"

// const ActionComplete
const ActionComplete string = "None"

// const StatusRunning
const StatusRunning string = "Running"

// const StatusSuspended
const StatusSuspended string = "Suspended"

// const StatusFailed
const StatusFailed string = "Failed"

// const StatusTerminated
const StatusTerminated string = "Terminated"

// const StatusCreating
const StatusCreating string = "Creating"

// const StatusSuspending
const StatusSuspending string = "Suspending"

// const StatusResuming
const StatusResuming string = "Resuming"

// const StatusRebooting
const StatusRebooting string = "Rebooting"

// const StatusTerminating
const StatusTerminating string = "Terminating"

// const StatusUndefined
const StatusUndefined string = "Undefined"

// const StatusComplete
const StatusComplete string = "None"

const milkywayPort string = ":1324/milkyway/"

const sshDefaultUserName01 string = "cb-user"
const sshDefaultUserName02 string = "ubuntu"
const sshDefaultUserName03 string = "root"
const sshDefaultUserName04 string = "ec2-user"

const labelAutoGen string = "AutoGen"

// Structs for REST API

// 2020-04-13 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/VMHandler.go
type SpiderVMReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderVMInfo
}

type SpiderVMInfo struct { // Spider
        // Fields for request
        Name               string
        ImageName          string
        VPCName            string
        SubnetName         string
        SecurityGroupNames []string
        KeyPairName        string

        // Fields for both request and response
        VMSpecName   string //  instance type or flavour, etc... ex) t2.micro or f1.micro
        VMUserId     string // ex) user1
        VMUserPasswd string

        // Fields for response
        IId               common.IID // {NameId, SystemId}
        ImageIId          common.IID
        VpcIID            common.IID
        SubnetIID         common.IID   // AWS, ex) subnet-8c4a53e4
        SecurityGroupIIds []common.IID // AWS, ex) sg-0b7452563e1121bb6
        KeyPairIId        common.IID
        StartTime         time.Time  // Timezone: based on cloud-barista server location.
        Region            RegionInfo //  ex) {us-east1, us-east1-c} or {ap-northeast-2}
        NetworkInterface  string     // ex) eth0
        PublicIP          string
        PublicDNS         string
        PrivateIP         string
        PrivateDNS        string
        VMBootDisk        string // ex) /dev/sda1
        VMBlockDisk       string // ex)
        SSHAccessPoint    string
        KeyValueList      []common.KeyValue
}

type RegionInfo struct { // Spider
        Region string
        Zone   string
}

type TbMcisReq struct {
        Name string `json:"name"`

        // InstallMonAgent Option for CB-Dragonfly agent installation ([yes/no] default:yes)
        InstallMonAgent string `json:"installMonAgent" example:"yes" default:"yes" enums:"yes,no"` // yes or no

        Label string `json:"label"`

        PlacementAlgo string `json:"placementAlgo"`
        Description   string `json:"description"`

        Vm []TbVmReq `json:"vm"`
}

type TbMcisInfo struct {
        Id           string `json:"id"`
        Name         string `json:"name"`
        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`

        // InstallMonAgent Option for CB-Dragonfly agent installation ([yes/no] default:yes)
        InstallMonAgent string `json:"installMonAgent" example:"yes" default:"yes" enums:"yes,no"` // yes or no

        Label string `json:"label"`

        PlacementAlgo string     `json:"placementAlgo"`
        Description   string     `json:"description"`
        Vm            []TbVmInfo `json:"vm"`
}

// struct TbVmReq is to get requirements to create a new server instance.
type TbVmReq struct {
        // VM name or VM group name if is (not empty) &amp;&amp; (&gt; 0). If it is a group, actual VM name will be generated with -N postfix.
        Name string `json:"name"`

        // if vmGroupSize is (not empty) &amp;&amp; (&gt; 0), VM group will be gernetad. VMs will be created accordingly.
        VmGroupSize string `json:"vmGroupSize" example:"3" default:""`

        Label string `json:"label"`

        Description string `json:"description"`

        ConnectionName   string   `json:"connectionName"`
        SpecId           string   `json:"specId"`
        ImageId          string   `json:"imageId"`
        VNetId           string   `json:"vNetId"`
        SubnetId         string   `json:"subnetId"`
        SecurityGroupIds []string `json:"securityGroupIds"`
        SshKeyId         string   `json:"sshKeyId"`
        VmUserAccount    string   `json:"vmUserAccount"`
        VmUserPassword   string   `json:"vmUserPassword"`
}

// struct TbVmGroupInfo is to define an object that includes homogeneous VMs.
type TbVmGroupInfo struct {
        Id          string   `json:"id"`
        Name        string   `json:"name"`
        VmId        []string `json:"vmId"`
        VmGroupSize string   `json:"vmGroupSize"`
}

// struct TbVmGroupInfo is to define a server instance object
type TbVmInfo struct {
        Id   string `json:"id"`
        Name string `json:"name"`

        // defined if the VM is in a group
        VmGroupId string `json:"vmGroupId"`

        Location GeoLocation `json:"location"`

        // Required by CB-Tumblebug
        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`

        // Montoring agent status
        MonAgentStatus string `json:"monAgentStatus" example:"[installed, notInstalled, failed]"` // yes or no// installed, notInstalled, failed

        // Latest system message such as error message
        SystemMessage string `json:"systemMessage" example:"Failed because ..." default:""` // systeam-given string message

        // Created time
        CreatedTime string `json:"createdTime" example:"2022-11-10 23:00:00" default:""`

        Label       string `json:"label"`
        Description string `json:"description"`

        Region      RegionInfo `json:"region"` // AWS, ex) {us-east1, us-east1-c} or {ap-northeast-2}
        PublicIP    string     `json:"publicIP"`
        SSHPort     string     `json:"sshPort"`
        PublicDNS   string     `json:"publicDNS"`
        PrivateIP   string     `json:"privateIP"`
        PrivateDNS  string     `json:"privateDNS"`
        VMBootDisk  string     `json:"vmBootDisk"` // ex) /dev/sda1
        VMBlockDisk string     `json:"vmBlockDisk"`

        ConnectionName   string   `json:"connectionName"`
        SpecId           string   `json:"specId"`
        ImageId          string   `json:"imageId"`
        VNetId           string   `json:"vNetId"`
        SubnetId         string   `json:"subnetId"`
        SecurityGroupIds []string `json:"securityGroupIds"`
        SshKeyId         string   `json:"sshKeyId"`
        VmUserAccount    string   `json:"vmUserAccount"`
        VmUserPassword   string   `json:"vmUserPassword"`

        CspViewVmDetail SpiderVMInfo `json:"cspViewVmDetail"`
}

type GeoLocation struct {
        Latitude     string `json:"latitude"`
        Longitude    string `json:"longitude"`
        BriefAddr    string `json:"briefAddr"`
        CloudType    string `json:"cloudType"`
        NativeRegion string `json:"nativeRegion"`
}

// struct McisStatusInfo is to define simple information of MCIS with updated status of all VMs
type McisStatusInfo struct {
        Id   string `json:"id"`
        Name string `json:"name"`

        //Vm_num string         `json:"vm_num"`
        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`

        // InstallMonAgent Option for CB-Dragonfly agent installation ([yes/no] default:yes)
        InstallMonAgent string `json:"installMonAgent" example:"[yes, no]"` // yes or no

        MasterVmId    string `json:"masterVmId" example:"vm-asiaeast1-cb-01"`
        MasterIp      string `json:"masterIp" example:"32.201.134.113"`
        MasterSSHPort string `json:"masterSSHPort"`

        Vm []TbVmStatusInfo `json:"vm"`
}

// TbVmStatusInfo is to define simple information of VM with updated status
type TbVmStatusInfo struct {
        Id      string `json:"id"`
        Name    string `json:"name"`
        CspVmId string `json:"cspVmId"`

        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`
        NativeStatus string `json:"nativeStatus"`

        // Montoring agent status
        MonAgentStatus string `json:"monAgentStatus" example:"[installed, notInstalled, failed]"` // yes or no// installed, notInstalled, failed

        // Latest system message such as error message
        SystemMessage string `json:"systemMessage" example:"Failed because ..." default:""` // systeam-given string message

        // Created time
        CreatedTime string `json:"createdTime" example:"2022-11-10 23:00:00" default:""`

        PublicIp  string `json:"publicIp"`
        PrivateIp string `json:"privateIp"`
        SSHPort   string `json:"sshPort"`

        Location GeoLocation `json:"location"`
}

// McisCmdReq is remote command struct
type McisCmdReq struct {
        UserName string `json:"userName" example:"cb-user" default:""`
        Command  string `json:"command" example:"sudo apt-get install ..." default:""`
}

type McisRecommendReq struct {
        VmReq          []TbVmRecommendReq `json:"vmReq"`
        PlacementAlgo  string             `json:"placementAlgo"`
        PlacementParam []common.KeyValue  `json:"placementParam"`
        MaxResultNum   string             `json:"maxResultNum"`
}

type TbVmRecommendReq struct {
        RequestName  string `json:"requestName"`
        MaxResultNum string `json:"maxResultNum"`

        VcpuSize   string `json:"vcpuSize"`
        MemorySize string `json:"memorySize"`
        DiskSize   string `json:"diskSize"`
        //Disk_type   string `json:"disk_type"`

        PlacementAlgo  string            `json:"placementAlgo"`
        PlacementParam []common.KeyValue `json:"placementParam"`
}

type TbVmPriority struct {
        Priority string          `json:"priority"`
        VmSpec   mcir.TbSpecInfo `json:"vmSpec"`
}

type TbVmRecommendInfo struct {
        VmReq          TbVmRecommendReq  `json:"vmReq"`
        VmPriority     []TbVmPriority    `json:"vmPriority"`
        PlacementAlgo  string            `json:"placementAlgo"`
        PlacementParam []common.KeyValue `json:"placementParam"`
}

func VerifySshUserName(nsId string, mcisId string, vmId string, vmIp string, sshPort string, givenUserName string) (string, string, error) <span class="cov0" title="0">{

        // verify if vm is running with a public ip.
        if vmIp == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("Cannot do ssh, VM IP is null")
        }</span>
        <span class="cov0" title="0">vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", "", err
        }</span>
        <span class="cov0" title="0">if vmStatusInfoTmp.Status != StatusRunning || vmIp == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("Cannot do ssh, VM IP is not Running")
        }</span>

        // find vaild username
        <span class="cov0" title="0">userName, _, privateKey := GetVmSshKey(nsId, mcisId, vmId)
        userNames := []string{
                userName,
                givenUserName,
                sshDefaultUserName01,
                sshDefaultUserName02,
                sshDefaultUserName03,
                sshDefaultUserName04,
        }

        theUserName := ""
        cmd := "ls"

        _, verifiedUserName, _ := GetVmSshKey(nsId, mcisId, vmId)

        if verifiedUserName != "" </span><span class="cov0" title="0">{
                fmt.Println("[SSH] " + "(" + vmIp + ")" + "with userName:" + verifiedUserName)
                fmt.Println("[CMD] " + cmd)

                retrycheck := 10
                for i := 0; i &lt; retrycheck; i++ </span><span class="cov0" title="0">{
                        conerr := CheckConnectivity(vmIp, sshPort)
                        if conerr == nil </span><span class="cov0" title="0">{
                                fmt.Println("[ERR: CheckConnectivity] nil. break")
                                break</span>
                        }
                        <span class="cov0" title="0">if i == retrycheck-1 </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("Cannot do ssh, the port is not opened (10 trials)")
                        }</span>
                        <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
                }

                <span class="cov0" title="0">result, err := RunSSH(vmIp, sshPort, verifiedUserName, privateKey, cmd)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("[ERR: result] " + "[ERR: err] " + err.Error())
                        return "", "", fmt.Errorf("Cannot do ssh, with" + verifiedUserName + ", " + err.Error())
                }</span>
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        theUserName = verifiedUserName
                        fmt.Println("[RST] " + *result + "[Username] " + verifiedUserName)
                        return theUserName, privateKey, nil
                }</span>
        }

        <span class="cov0" title="0">retrycheck := 10
        for i := 0; i &lt; retrycheck; i++ </span><span class="cov0" title="0">{
                conerr := CheckConnectivity(vmIp, sshPort)
                if conerr == nil </span><span class="cov0" title="0">{
                        //fmt.Println("[ERR: conerr] nil. break")
                        break</span>
                }
                <span class="cov0" title="0">if i == retrycheck-1 </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("Cannot do ssh, the port is not opened (10 trials)")
                }</span>
                <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
        }
        <span class="cov0" title="0">fmt.Println("[Retrieve ssh username from the given list]")
        for _, v := range userNames </span><span class="cov0" title="0">{
                if v != "" </span><span class="cov0" title="0">{
                        fmt.Println("[SSH] " + "(" + vmIp + ")" + "with userName:" + v)
                        result, err := RunSSH(vmIp, sshPort, v, privateKey, cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("[ERR: result] " + "[ERR: err] " + err.Error())
                        }</span>
                        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                                theUserName = v
                                fmt.Println("[RST] " + *result + "[Username] " + v)
                                break</span>
                        }
                        <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
                }
        }
        <span class="cov0" title="0">if theUserName != "" </span><span class="cov0" title="0">{
                err := UpdateVmSshKey(nsId, mcisId, vmId, theUserName)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("[ERR: result] " + "[ERR: err] " + err.Error())
                        return "", "", err
                }</span>
        } else<span class="cov0" title="0"> {
                return "", "", fmt.Errorf("Could not find username")
        }</span>

        <span class="cov0" title="0">return theUserName, privateKey, nil</span>
}

type SshCmdResult struct { // Tumblebug
        McisId string `json:"mcisId"`
        VmId   string `json:"vmId"`
        VmIp   string `json:"vmIp"`
        Result string `json:"result"`
        Err    error  `json:"err"`
}

// AgentInstallContentWrapper ...
type AgentInstallContentWrapper struct {
        Result_array []AgentInstallContent `json:"result_array"`
}

// AgentInstallContent ...
type AgentInstallContent struct {
        McisId string `json:"mcisId"`
        VmId   string `json:"vmId"`
        VmIp   string `json:"vmIp"`
        Result string `json:"result"`
}

func InstallAgentToMcis(nsId string, mcisId string, req *McisCmdReq) (AgentInstallContentWrapper, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">content := AgentInstallContentWrapper{}

        //install script
        cmd := "wget https://github.com/cloud-barista/cb-milkyway/raw/master/src/milkyway -O ~/milkyway; chmod +x ~/milkyway; ~/milkyway &gt; /dev/null 2&gt;&amp;1 &amp; netstat -tulpn | grep milkyway"

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>

        //goroutin sync wg
        <span class="cov0" title="0">var wg sync.WaitGroup

        var resultArray []SshCmdResult

        for _, v := range vmList </span><span class="cov0" title="0">{

                vmId := v
                vmIp, sshPort := GetVmIp(nsId, mcisId, vmId)

                //cmd := req.Command

                // userName, sshKey := GetVmSshKey(nsId, mcisId, vmId)
                // if (userName == "") {
                //         userName = req.UserName
                // }
                // if (userName == "") {
                //         userName = sshDefaultUserName
                // }

                // find vaild username
                userName, sshKey, err := VerifySshUserName(nsId, mcisId, vmId, vmIp, sshPort, req.UserName)

                fmt.Println("[SSH] " + mcisId + "/" + vmId + "(" + vmIp + ")" + "with userName:" + userName)
                fmt.Println("[CMD] " + cmd)

                // Avoid RunSSH to not ready VM
                if err != nil </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go RunSSHAsync(&amp;wg, vmId, vmIp, sshPort, userName, sshKey, cmd, &amp;resultArray)
                }</span> else<span class="cov0" title="0"> {
                        common.CBLog.Error(err)
                        sshResultTmp := SshCmdResult{}
                        sshResultTmp.McisId = mcisId
                        sshResultTmp.VmId = vmId
                        sshResultTmp.VmIp = vmIp
                        sshResultTmp.Result = err.Error()
                        sshResultTmp.Err = err
                }</span>

        }
        <span class="cov0" title="0">wg.Wait() //goroutin sync wg

        for _, v := range resultArray </span><span class="cov0" title="0">{

                resultTmp := AgentInstallContent{}
                resultTmp.McisId = mcisId
                resultTmp.VmId = v.VmId
                resultTmp.VmIp = v.VmIp
                resultTmp.Result = v.Result
                content.Result_array = append(content.Result_array, resultTmp)
                //fmt.Println("result from goroutin " + v)
        }</span>

        //fmt.Printf("%+v\n", content)
        <span class="cov0" title="0">common.PrintJsonPretty(content)

        return content, nil</span>

}

type SpecBenchmarkInfo struct {
        SpecId     string `json:"specid"`
        Cpus       string `json:"cpus"`
        Cpum       string `json:"cpum"`
        MemR       string `json:"memR"`
        MemW       string `json:"memW"`
        FioR       string `json:"fioR"`
        FioW       string `json:"fioW"`
        DbR        string `json:"dbR"`
        DbW        string `json:"dbW"`
        Rtt        string `json:"rtt"`
        EvaledTime string `json:"evaledTime"`
}

type BenchmarkInfo struct {
        Result      string          `json:"result"`
        Unit        string          `json:"unit"`
        Desc        string          `json:"desc"`
        Elapsed     string          `json:"elapsed"`
        SpecId      string          `json:"specid"`
        ResultArray []BenchmarkInfo `json:"resultarray"` // struct-element cycle ?
}

type BenchmarkInfoArray struct {
        ResultArray []BenchmarkInfo `json:"resultarray"`
}

type BenchmarkReq struct {
        Host string `json:"host"`
        Spec string `json:"spec"`
}

type MultihostBenchmarkReq struct {
        Multihost []BenchmarkReq `json:"multihost"`
}

func CallMilkyway(wg *sync.WaitGroup, vmList []string, nsId string, mcisId string, vmId string, vmIp string, action string, option string, results *BenchmarkInfoArray) <span class="cov0" title="0">{
        defer wg.Done() //goroutine sync done

        url := "http://" + vmIp + milkywayPort + action
        method := "GET"

        client := &amp;http.Client{
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse
                }</span>,
        }

        // Create Req body
        <span class="cov0" title="0">type JsonTemplate struct {
                Host string `json:"host"`
        }
        tempReq := JsonTemplate{}
        tempReq.Host = option
        payload, _ := json.MarshalIndent(tempReq, "", "  ")

        if action == "mrtt" </span><span class="cov0" title="0">{
                reqTmp := MultihostBenchmarkReq{}
                for _, vm := range vmList </span><span class="cov0" title="0">{
                        vmIdTmp := vm
                        vmIpTmp, _ := GetVmIp(nsId, mcisId, vmIdTmp)
                        fmt.Println("[Test for vmList " + vmIdTmp + ", " + vmIpTmp + "]")

                        hostTmp := BenchmarkReq{}
                        hostTmp.Host = vmIpTmp
                        hostTmp.Spec = GetVmSpecId(nsId, mcisId, vmIdTmp)
                        reqTmp.Multihost = append(reqTmp.Multihost, hostTmp)
                }</span>
                <span class="cov0" title="0">common.PrintJsonPretty(reqTmp)
                payload, _ = json.MarshalIndent(reqTmp, "", "  ")</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))
        req.Header.Add("Content-Type", "application/json")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
        <span class="cov0" title="0">errStr := ""
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        body, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>
        <span class="cov0" title="0">fmt.Println(string(body))

        fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
        switch </span>{
        case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                err := fmt.Errorf(string(body))
                common.CBLog.Error(err)
                errStr = err.Error()</span>
        }

        //benchInfoTmp := BenchmarkInfo{}
        <span class="cov0" title="0">resultTmp := BenchmarkInfo{}
        err2 := json.Unmarshal(body, &amp;resultTmp)
        if err2 != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err2)
                errStr = err2.Error()
        }</span>
        //benchInfoTmp.ResultArray =  resultTmp.ResultArray
        <span class="cov0" title="0">if errStr != "" </span><span class="cov0" title="0">{
                resultTmp.Result = errStr
        }</span>
        <span class="cov0" title="0">resultTmp.SpecId = GetVmSpecId(nsId, mcisId, vmId)
        results.ResultArray = append(results.ResultArray, resultTmp)</span>
}

func CoreGetAllBenchmark(nsId string, mcisId string, host string) (*BenchmarkInfoArray, error) <span class="cov0" title="0">{

        var err error

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;BenchmarkInfoArray{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">target := host

        action := "all"
        fmt.Println("[Get MCIS benchmark action: " + action + target)

        option := "localhost"
        option = target

        content := BenchmarkInfoArray{}

        allBenchCmd := []string{"cpus", "cpum", "memR", "memW", "fioR", "fioW", "dbR", "dbW", "rtt"}

        resultMap := make(map[string]SpecBenchmarkInfo)

        for i, v := range allBenchCmd </span><span class="cov0" title="0">{
                fmt.Println("[Benchmark] " + v)
                content, err = BenchmarkAction(nsId, mcisId, v, option)
                for _, k := range content.ResultArray </span><span class="cov0" title="0">{
                        SpecId := k.SpecId
                        Result := k.Result
                        specBenchInfoTmp := SpecBenchmarkInfo{}

                        val, exist := resultMap[SpecId]
                        if exist </span><span class="cov0" title="0">{
                                specBenchInfoTmp = val
                        }</span> else<span class="cov0" title="0"> {
                                specBenchInfoTmp.SpecId = SpecId
                        }</span>

                        <span class="cov0" title="0">switch i </span>{
                        case 0:<span class="cov0" title="0">
                                specBenchInfoTmp.Cpus = Result</span>
                        case 1:<span class="cov0" title="0">
                                specBenchInfoTmp.Cpum = Result</span>
                        case 2:<span class="cov0" title="0">
                                specBenchInfoTmp.MemR = Result</span>
                        case 3:<span class="cov0" title="0">
                                specBenchInfoTmp.MemW = Result</span>
                        case 4:<span class="cov0" title="0">
                                specBenchInfoTmp.FioR = Result</span>
                        case 5:<span class="cov0" title="0">
                                specBenchInfoTmp.FioW = Result</span>
                        case 6:<span class="cov0" title="0">
                                specBenchInfoTmp.DbR = Result</span>
                        case 7:<span class="cov0" title="0">
                                specBenchInfoTmp.DbW = Result</span>
                        case 8:<span class="cov0" title="0">
                                specBenchInfoTmp.Rtt = Result</span>
                        }

                        <span class="cov0" title="0">resultMap[SpecId] = specBenchInfoTmp</span>

                }
        }

        <span class="cov0" title="0">file, err := os.OpenFile("benchmarking.csv", os.O_CREATE|os.O_WRONLY, 0777)
        defer file.Close()
        csvWriter := csv.NewWriter(file)
        strsTmp := []string{}
        for key, val := range resultMap </span><span class="cov0" title="0">{
                strsTmp = nil
                fmt.Println(key, val)
                strsTmp = append(strsTmp, val.SpecId)
                strsTmp = append(strsTmp, val.Cpus)
                strsTmp = append(strsTmp, val.Cpum)
                strsTmp = append(strsTmp, val.MemR)
                strsTmp = append(strsTmp, val.MemW)
                strsTmp = append(strsTmp, val.FioR)
                strsTmp = append(strsTmp, val.FioW)
                strsTmp = append(strsTmp, val.DbR)
                strsTmp = append(strsTmp, val.DbW)
                strsTmp = append(strsTmp, val.Rtt)
                csvWriter.Write(strsTmp)
                csvWriter.Flush()
        }</span>

        <span class="cov0" title="0">file2, err := os.OpenFile("rttmap.csv", os.O_CREATE|os.O_WRONLY, 0777)
        defer file2.Close()
        csvWriter2 := csv.NewWriter(file2)

        const mrttArrayXMax = 50
        const mrttArrayYMax = 50
        mrttArray := make([][]string, mrttArrayXMax)
        for i := 0; i &lt; mrttArrayXMax; i++ </span><span class="cov0" title="0">{
                mrttArray[i] = make([]string, mrttArrayYMax)
                for j := 0; j &lt; mrttArrayYMax; j++ </span><span class="cov0" title="0">{
                        mrttArray[i][j] = "0"
                }</span>
        }

        <span class="cov0" title="0">rttIndexMapX := make(map[string]int)
        cntTargetX := 1
        rttIndexMapY := make(map[string]int)
        cntTargetY := 1

        action = "mrtt"
        fmt.Println("[Benchmark] " + action)
        content, err = BenchmarkAction(nsId, mcisId, action, option)
        for _, k := range content.ResultArray </span><span class="cov0" title="0">{
                SpecId := k.SpecId
                iX, exist := rttIndexMapX[SpecId]
                if !exist </span><span class="cov0" title="0">{
                        rttIndexMapX[SpecId] = cntTargetX
                        iX = cntTargetX
                        mrttArray[iX][0] = SpecId
                        cntTargetX++
                }</span>
                <span class="cov0" title="0">for _, m := range k.ResultArray </span><span class="cov0" title="0">{
                        tagetSpecId := m.SpecId
                        tagetRtt := m.Result
                        iY, exist2 := rttIndexMapY[tagetSpecId]
                        if !exist2 </span><span class="cov0" title="0">{
                                rttIndexMapY[tagetSpecId] = cntTargetY
                                iY = cntTargetY
                                mrttArray[0][iY] = tagetSpecId
                                cntTargetY++
                        }</span>
                        <span class="cov0" title="0">mrttArray[iX][iY] = tagetRtt</span>
                }
        }

        <span class="cov0" title="0">csvWriter2.WriteAll(mrttArray)
        csvWriter2.Flush()

        if err != nil </span><span class="cov0" title="0">{
                //mapError := map[string]string{"message": "Benchmark Error"}
                //return c.JSON(http.StatusFailedDependency, &amp;mapError)
                return nil, fmt.Errorf("Benchmark Error")
        }</span>

        <span class="cov0" title="0">return &amp;content, nil</span>
}

func CoreGetBenchmark(nsId string, mcisId string, action string, host string) (*BenchmarkInfoArray, error) <span class="cov0" title="0">{

        var err error

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;BenchmarkInfoArray{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">target := host

        fmt.Println("[Get MCIS benchmark action: " + action + target)

        option := "localhost"
        option = target

        content := BenchmarkInfoArray{}

        vaildActions := "install init cpus cpum memR memW fioR fioW dbR dbW rtt mrtt clean"

        fmt.Println("[Benchmark] " + action)
        if strings.Contains(vaildActions, action) </span><span class="cov0" title="0">{
                content, err = BenchmarkAction(nsId, mcisId, action, option)
        }</span> else<span class="cov0" title="0"> {
                //mapA := map[string]string{"message": "Not available action"}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return nil, fmt.Errorf("Not available action")
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                //mapError := map[string]string{"message": "Benchmark Error"}
                //return c.JSON(http.StatusFailedDependency, &amp;mapError)
                return nil, fmt.Errorf("Benchmark Error")
        }</span>

        <span class="cov0" title="0">return &amp;content, nil</span>
}

func BenchmarkAction(nsId string, mcisId string, action string, option string) (BenchmarkInfoArray, error) <span class="cov0" title="0">{

        var results BenchmarkInfoArray

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return BenchmarkInfoArray{}, err
        }</span>

        //goroutin sync wg
        <span class="cov0" title="0">var wg sync.WaitGroup

        for _, v := range vmList </span><span class="cov0" title="0">{
                wg.Add(1)

                vmId := v
                vmIp, _ := GetVmIp(nsId, mcisId, vmId)

                go CallMilkyway(&amp;wg, vmList, nsId, mcisId, vmId, vmIp, action, option, &amp;results)
        }</span>
        <span class="cov0" title="0">wg.Wait() //goroutine sync wg

        return results, nil</span>

}

/*
func BenchmarkAction(nsId string, mcisId string, action string, option string) (BenchmarkInfoArray, error) {


        var results BenchmarkInfoArray

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil {
                common.CBLog.Error(err)
                return BenchmarkInfoArray{}, err
        }

        for _, v := range vmList {

                vmId := v
                vmIp := GetVmIp(nsId, mcisId, vmId)

                url := "http://"+ vmIp + milkywayPort + action
                method := "GET"

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error {
                                return http.ErrUseLastResponse
                        },
                }



                // Create Req body
                type JsonTemplate struct {
                        Host string `json:"host"`
                }
                tempReq := JsonTemplate{}
                tempReq.Host = option
                payload, _ := json.MarshalIndent(tempReq, "", "  ")

                if action == "mrtt" {
                        reqTmp := MultihostBenchmarkReq{}
                        for _, vm := range vmList {
                                vmIdTmp := vm
                                vmIpTmp := GetVmIp(nsId, mcisId, vmIdTmp)
                                fmt.Println("[Test for vmList " + vmIdTmp + ", " +vmIpTmp + "]")

                                hostTmp := BenchmarkReq{}
                                hostTmp.Host = vmIpTmp
                                reqTmp.Multihost = append(reqTmp.Multihost, hostTmp)
                        }
                        common.PrintJsonPretty(reqTmp)
                        payload, _ = json.MarshalIndent(reqTmp, "", "  ")
                }

                req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))
                req.Header.Add("Content-Type", "application/json")
                if err != nil {
                        fmt.Println(err)
                }

                res, err := client.Do(req)
                if err != nil {
                        common.CBLog.Error(err)
                        return BenchmarkInfoArray{}, err
                }
                defer res.Body.Close()

                body, err := ioutil.ReadAll(res.Body)
                if err != nil {
                        common.CBLog.Error(err)
                        return BenchmarkInfoArray{}, err
                }
                fmt.Println(string(body))

                fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch {
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:
                        err := fmt.Errorf(string(body))
                        common.CBLog.Error(err)
                        return BenchmarkInfoArray{}, err
                }

                if action == "mrtt" {
                        //benchInfoTmp := BenchmarkInfo{}
                        resultTmp := BenchmarkInfo{}
                        err2 := json.Unmarshal(body, &amp;resultTmp)
                        if err2 != nil {
                                common.CBLog.Error(err2)
                                return BenchmarkInfoArray{}, err2
                        }
                        //benchInfoTmp.ResultArray =  resultTmp.ResultArray
                        results.ResultArray = append(results.ResultArray, resultTmp)

                } else{
                        resultTmp := BenchmarkInfo{}
                        err2 := json.Unmarshal(body, &amp;resultTmp)
                        if err2 != nil {
                                common.CBLog.Error(err2)
                                return BenchmarkInfoArray{}, err2
                        }
                        results.ResultArray = append(results.ResultArray, resultTmp)
                }

        }

        return results, nil

}
*/

// MCIS Information Managemenet

/*
func AddVmInfoToMcis(nsId string, mcisId string, vmInfoData TbVmInfo) {

        key := common.GenMcisKey(nsId, mcisId, vmInfoData.Id)
        val, _ := json.Marshal(vmInfoData)
        err := common.CBStore.Put(string(key), string(val))
        if err != nil {
                common.CBLog.Error(err)
        }
        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")

}
*/

// UpdateMcisInfo func Update MCIS Info (without VM info in MCIS)
func UpdateMcisInfo(nsId string, mcisInfoData TbMcisInfo) <span class="cov0" title="0">{

        mcisInfoData.Vm = nil

        key := common.GenMcisKey(nsId, mcisInfoData.Id, "")

        // Check existence of the key. If no key, no update.
        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mcisTmp := TbMcisInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)

        if !reflect.DeepEqual(mcisTmp, mcisInfoData) </span><span class="cov0" title="0">{
                val, _ := json.Marshal(mcisInfoData)
                err = common.CBStore.Put(string(key), string(val))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                }</span>
        }
        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")
}

func UpdateVmInfo(nsId string, mcisId string, vmInfoData TbVmInfo) <span class="cov0" title="0">{
        key := common.GenMcisKey(nsId, mcisId, vmInfoData.Id)

        // Check existence of the key. If no key, no update.
        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">vmTmp := TbVmInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;vmTmp)

        if !reflect.DeepEqual(vmTmp, vmInfoData) </span><span class="cov0" title="0">{
                val, _ := json.Marshal(vmInfoData)
                err = common.CBStore.Put(string(key), string(val))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                }</span>
        }

        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")
}

func ListMcisId(nsId string) ([]string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        // fmt.Println("[ListMcisId]")
        <span class="cov0" title="0">var mcisList []string

        // Check MCIS exists
        key := common.GenMcisKey(nsId, "", "")
        key += "/"

        keyValue, err := common.CBStore.GetList(key, true)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, v := range keyValue </span><span class="cov0" title="0">{
                if strings.Contains(v.Key, "/mcis/") </span><span class="cov0" title="0">{
                        trimmedString := strings.TrimPrefix(v.Key, (key + "mcis/"))
                        // prevent malformed key (if key for mcis id includes '/', the key does not represent MCIS ID)
                        if !strings.Contains(trimmedString, "/") </span><span class="cov0" title="0">{
                                mcisList = append(mcisList, trimmedString)
                        }</span>
                }
        }

        <span class="cov0" title="0">return mcisList, nil</span>
}

func ListVmId(nsId string, mcisId string) ([]string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        // fmt.Println("[ListVmId]")
        <span class="cov0" title="0">var vmList []string

        // Check MCIS exists
        key := common.GenMcisKey(nsId, mcisId, "")
        key += "/"

        _, err = common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("[Not found] " + mcisId)
                common.CBLog.Error(err)
                return vmList, err
        }</span>

        <span class="cov0" title="0">keyValue, err := common.CBStore.GetList(key, true)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, v := range keyValue </span><span class="cov0" title="0">{
                if strings.Contains(v.Key, "/vm/") </span><span class="cov0" title="0">{
                        trimmedString := strings.TrimPrefix(v.Key, (key + "vm/"))
                        // prevent malformed key (if key for vm id includes '/', the key does not represent VM ID)
                        if !strings.Contains(trimmedString, "/") </span><span class="cov0" title="0">{
                                vmList = append(vmList, trimmedString)
                        }</span>
                }
        }
        /*
                for _, v := range vmList {
                        fmt.Println("&lt;" + v + "&gt;")
                }
                fmt.Println("===============================================")
        */
        <span class="cov0" title="0">return vmList, nil</span>

}

// func ListVmGroupId returns list of VmGroups in a given MCIS.
func ListVmGroupId(nsId string, mcisId string) ([]string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[ListVmGroupId]")
        key := common.GenMcisKey(nsId, mcisId, "")
        key += "/"

        keyValue, err := common.CBStore.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">var vmGroupList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                if strings.Contains(v.Key, "/vmgroup/") </span><span class="cov0" title="0">{
                        trimmedString := strings.TrimPrefix(v.Key, (key + "vmgroup/"))
                        // prevent malformed key (if key for vm id includes '/', the key does not represent VM ID)
                        if !strings.Contains(trimmedString, "/") </span><span class="cov0" title="0">{
                                vmGroupList = append(vmGroupList, trimmedString)
                        }</span>
                }
        }
        <span class="cov0" title="0">return vmGroupList, nil</span>
}

func DelMcis(nsId string, mcisId string, option string) error <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Delete MCIS] " + mcisId)

        // // ControlMcis first
        // err = ControlMcisAsync(nsId, mcisId, ActionTerminate)
        // if err != nil {
        //         common.CBLog.Error(err)
        //         if option != "force" {
        //                 return err
        //         }
        // }
        // // for deletion, need to wait until termination is finished
        // // Sleep for 5 seconds
        // fmt.Printf("\n\n[Info] Sleep for 5 seconds for safe MCIS-VMs termination.\n\n")
        // time.Sleep(5 * time.Second)

        // Check MCIS status is Terminated so that approve deletion
        mcisStatus, _ := GetMcisStatus(nsId, mcisId)
        if mcisStatus == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("MCIS " + mcisId + " status nil, Deletion is not allowed (use option=force for force deletion)")
                common.CBLog.Error(err)
                if option != "force" </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // Check MCIS status is Terminated (not Partial)
        <span class="cov0" title="0">if !(!strings.Contains(mcisStatus.Status, "Partial-") &amp;&amp; (strings.Contains(mcisStatus.Status, StatusTerminated) || strings.Contains(mcisStatus.Status, StatusUndefined) || strings.Contains(mcisStatus.Status, StatusFailed))) </span><span class="cov0" title="0">{
                err := fmt.Errorf("MCIS " + mcisId + " is " + mcisStatus.Status + " and not " + StatusTerminated + "/" + StatusUndefined + "/" + StatusFailed + ", Deletion is not allowed (use option=force for force deletion)")
                common.CBLog.Error(err)
                if option != "force" </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">key := common.GenMcisKey(nsId, mcisId, "")
        fmt.Println(key)

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        // delete vms info
        <span class="cov0" title="0">for _, v := range vmList </span><span class="cov0" title="0">{
                vmKey := common.GenMcisKey(nsId, mcisId, v)
                fmt.Println(vmKey)

                // get vm info
                vmInfo, err := GetVmObject(nsId, mcisId, v)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">err = common.CBStore.Delete(vmKey)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">mcir.UpdateAssociatedObjectList(nsId, common.StrImage, vmInfo.ImageId, common.StrDelete, vmKey)
                mcir.UpdateAssociatedObjectList(nsId, common.StrSpec, vmInfo.SpecId, common.StrDelete, vmKey)
                mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfo.SshKeyId, common.StrDelete, vmKey)
                mcir.UpdateAssociatedObjectList(nsId, common.StrVNet, vmInfo.VNetId, common.StrDelete, vmKey)

                for _, v2 := range vmInfo.SecurityGroupIds </span><span class="cov0" title="0">{
                        mcir.UpdateAssociatedObjectList(nsId, common.StrSecurityGroup, v2, common.StrDelete, vmKey)
                }</span>
        }

        // delete vm group info
        <span class="cov0" title="0">vmGroupList, err := ListVmGroupId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">for _, v := range vmGroupList </span><span class="cov0" title="0">{
                vmGroupKey := common.GenMcisVmGroupKey(nsId, mcisId, v)
                fmt.Println(vmGroupKey)
                err := common.CBStore.Delete(vmGroupKey)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>
        }

        // delete mcis info
        <span class="cov0" title="0">err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func DelMcisVm(nsId string, mcisId string, vmId string, option string) error <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Delete VM] " + vmId)

        // ControlVm first
        err = ControlVm(nsId, mcisId, vmId, ActionTerminate)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                if option != "force" </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // for deletion, need to wait until termination is finished
        // Sleep for 5 seconds
        <span class="cov0" title="0">fmt.Printf("\n\n[Info] Sleep for 20 seconds for safe VM termination.\n\n")
        time.Sleep(5 * time.Second)

        // get vm info
        vmInfo, _ := GetVmObject(nsId, mcisId, vmId)

        // delete vms info
        key := common.GenMcisKey(nsId, mcisId, vmId)
        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">mcir.UpdateAssociatedObjectList(nsId, common.StrImage, vmInfo.ImageId, common.StrDelete, key)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSpec, vmInfo.SpecId, common.StrDelete, key)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfo.SshKeyId, common.StrDelete, key)
        mcir.UpdateAssociatedObjectList(nsId, common.StrVNet, vmInfo.VNetId, common.StrDelete, key)

        for _, v2 := range vmInfo.SecurityGroupIds </span><span class="cov0" title="0">{
                mcir.UpdateAssociatedObjectList(nsId, common.StrSecurityGroup, v2, common.StrDelete, key)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

//// Info manage for MCIS recommendation
func GetRecommendList(nsId string, cpuSize string, memSize string, diskSize string) ([]TbVmPriority, error) <span class="cov0" title="0">{

        fmt.Println("GetRecommendList")

        var content struct {
                Id             string
                Price          string
                ConnectionName string
        }
        //fmt.Println("[Get MCISs")
        key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + cpuSize + "/memSize/" + memSize + "/diskSize/" + diskSize
        fmt.Println(key)
        keyValue, err := common.CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return []TbVmPriority{}, err
        }</span>

        <span class="cov0" title="0">var vmPriorityList []TbVmPriority

        for cnt, v := range keyValue </span><span class="cov0" title="0">{
                fmt.Println("getRecommendList1: " + v.Key)
                err = json.Unmarshal([]byte(v.Value), &amp;content)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return []TbVmPriority{}, err
                }</span>

                <span class="cov0" title="0">content2 := mcir.TbSpecInfo{}
                key2 := common.GenResourceKey(nsId, common.StrSpec, content.Id)

                keyValue2, err := common.CBStore.Get(key2)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return []TbVmPriority{}, err
                }</span>
                <span class="cov0" title="0">json.Unmarshal([]byte(keyValue2.Value), &amp;content2)
                content2.Id = content.Id

                vmPriorityTmp := TbVmPriority{}
                vmPriorityTmp.Priority = strconv.Itoa(cnt)
                vmPriorityTmp.VmSpec = content2
                vmPriorityList = append(vmPriorityList, vmPriorityTmp)</span>
        }

        <span class="cov0" title="0">fmt.Println("===============================================")
        return vmPriorityList, err</span>

        //requires error handling

}

// MCIS Control

func HandleMcisAction(nsId string, mcisId string, action string) (string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return err.Error(), err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Get MCIS requested action: " + action)
        if action == "suspend" </span><span class="cov0" title="0">{
                fmt.Println("[suspend MCIS]")

                err := ControlMcisAsync(nsId, mcisId, ActionSuspend)
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", err
                }</span>

                //mapA := map[string]string{"message": "Suspending the MCIS"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                <span class="cov0" title="0">return "Suspending the MCIS", nil</span>

        } else<span class="cov0" title="0"> if action == "resume" </span><span class="cov0" title="0">{
                fmt.Println("[resume MCIS]")

                err := ControlMcisAsync(nsId, mcisId, ActionResume)
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", err
                }</span>

                //mapA := map[string]string{"message": "Resuming the MCIS"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                <span class="cov0" title="0">return "Resuming the MCIS", nil</span>

        } else<span class="cov0" title="0"> if action == "reboot" </span><span class="cov0" title="0">{
                fmt.Println("[reboot MCIS]")

                err := ControlMcisAsync(nsId, mcisId, ActionReboot)
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", err
                }</span>

                //mapA := map[string]string{"message": "Rebooting the MCIS"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                <span class="cov0" title="0">return "Rebooting the MCIS", nil</span>

        } else<span class="cov0" title="0"> if action == "terminate" </span><span class="cov0" title="0">{
                fmt.Println("[terminate MCIS]")

                vmList, err := ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return "", err
                }</span>

                //fmt.Println("len(vmList) %d ", len(vmList))
                <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": "No VM to terminate in the MCIS"}
                        //return c.JSON(http.StatusOK, &amp;mapA)
                        return "No VM to terminate in the MCIS", nil
                }</span>

                /*
                        for _, v := range vmList {
                                ControlVm(nsId, mcisId, v, ActionTerminate)
                        }
                */
                <span class="cov0" title="0">err = ControlMcisAsync(nsId, mcisId, ActionTerminate)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return "Terminating the MCIS", nil</span>

        } else<span class="cov0" title="0"> if action == "refine" </span><span class="cov0" title="0">{ //refine delete VMs in StatusFailed or StatusUndefined
                fmt.Println("[terminate MCIS]")

                vmList, err := ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return "", err
                }</span>

                <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                        return "No VM in the MCIS", nil
                }</span>

                <span class="cov0" title="0">mcisStatus, err := GetMcisStatus(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return "", err
                }</span>

                <span class="cov0" title="0">for _, v := range mcisStatus.Vm </span><span class="cov0" title="0">{

                        // Remove VMs in StatusFailed or StatusUndefined
                        fmt.Println("[vmInfo.Status]", v.Status)
                        if v.Status == StatusFailed || v.Status == StatusUndefined </span><span class="cov0" title="0">{
                                // Delete VM sequentially for safety (for performance, need to use goroutine)
                                err := DelMcisVm(nsId, mcisId, v.Id, "force")
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return "", err
                                }</span>
                        }
                }

                <span class="cov0" title="0">return "Refined the MCIS", nil</span>

        } else<span class="cov0" title="0"> {
                return "", fmt.Errorf(action + " not supported")
        }</span>
}

// GetMcisInfo func returns MCIS information with the current status update
func GetMcisInfo(nsId string, mcisId string) (*TbMcisInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">mcisObj, err := GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        // common.PrintJsonPretty(mcisObj)

        <span class="cov0" title="0">mcisStatus, err := GetMcisStatus(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        // common.PrintJsonPretty(mcisStatus)

        <span class="cov0" title="0">mcisObj.Status = mcisStatus.Status

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">for num := range vmList </span><span class="cov0" title="0">{
                //fmt.Println("[GetMcisInfo compare two VMs]")
                //common.PrintJsonPretty(mcisObj.Vm[num])
                //common.PrintJsonPretty(mcisStatus.Vm[num])

                mcisObj.Vm[num].Status = mcisStatus.Vm[num].Status
                mcisObj.Vm[num].TargetStatus = mcisStatus.Vm[num].TargetStatus
                mcisObj.Vm[num].TargetAction = mcisStatus.Vm[num].TargetAction
        }</span>

        <span class="cov0" title="0">return &amp;mcisObj, nil</span>
}

func CoreGetAllMcis(nsId string, option string) ([]TbMcisInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        /*
                var content struct {
                        //Name string     `json:"name"`
                        Mcis []mcis.TbMcisInfo `json:"mcis"`
                }
        */
        // content := RestGetAllMcisResponse{}

        <span class="cov0" title="0">Mcis := []TbMcisInfo{}

        mcisList, err := ListMcisId(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, v := range mcisList </span><span class="cov0" title="0">{

                key := common.GenMcisKey(nsId, v, "")
                //fmt.Println(key)
                keyValue, _ := common.CBStore.Get(key)
                if keyValue == nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": "Cannot find " + key}
                        //return c.JSON(http.StatusOK, &amp;mapA)
                        return nil, fmt.Errorf("in CoreGetAllMcis() mcis loop; Cannot find " + key)
                }</span>
                //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                <span class="cov0" title="0">mcisTmp := TbMcisInfo{}
                json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
                mcisId := v
                mcisTmp.Id = mcisId

                if option == "status" </span><span class="cov0" title="0">{
                        //get current mcis status
                        mcisStatus, err := GetMcisStatus(nsId, mcisId)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">mcisTmp.Status = mcisStatus.Status</span>
                } else<span class="cov0" title="0"> {
                        //Set current mcis status with NullStr
                        mcisTmp.Status = ""
                }</span>

                <span class="cov0" title="0">vmList, err := ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, v1 := range vmList </span><span class="cov0" title="0">{
                        vmKey := common.GenMcisKey(nsId, mcisId, v1)
                        //fmt.Println(vmKey)
                        vmKeyValue, _ := common.CBStore.Get(vmKey)
                        if vmKeyValue == nil </span><span class="cov0" title="0">{
                                //mapA := map[string]string{"message": "Cannot find " + key}
                                //return c.JSON(http.StatusOK, &amp;mapA)
                                return nil, fmt.Errorf("in CoreGetAllMcis() vm loop; Cannot find " + vmKey)
                        }</span>
                        //fmt.Println("&lt;" + vmKeyValue.Key + "&gt; \n" + vmKeyValue.Value)
                        //vmTmp := vmOverview{}
                        <span class="cov0" title="0">vmTmp := TbVmInfo{}
                        json.Unmarshal([]byte(vmKeyValue.Value), &amp;vmTmp)
                        vmTmp.Id = v1

                        if option == "status" </span><span class="cov0" title="0">{
                                //get current vm status
                                vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, v1)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                }</span>
                                <span class="cov0" title="0">vmTmp.Status = vmStatusInfoTmp.Status</span>
                        } else<span class="cov0" title="0"> {
                                //Set current vm status with NullStr
                                vmTmp.Status = ""
                        }</span>

                        <span class="cov0" title="0">mcisTmp.Vm = append(mcisTmp.Vm, vmTmp)</span>
                }

                <span class="cov0" title="0">Mcis = append(Mcis, mcisTmp)</span>

        }

        <span class="cov0" title="0">return Mcis, nil</span>
}

func CoreDelAllMcis(nsId string, option string) (string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">mcisList, err := ListMcisId(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">if len(mcisList) == 0 </span><span class="cov0" title="0">{
                //mapA := map[string]string{"message": "No MCIS to delete"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "No MCIS to delete", nil
        }</span>

        <span class="cov0" title="0">for _, v := range mcisList </span><span class="cov0" title="0">{
                err := DelMcis(nsId, v, option)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        //mapA := map[string]string{"message": "Failed to delete All MCISs"}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", fmt.Errorf("Failed to delete All MCISs")
                }</span>
        }

        <span class="cov0" title="0">return "All MCISs has been deleted", nil</span>
}

func CorePostMcisRecommend(nsId string, req *McisRecommendReq) ([]TbVmRecommendInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        /*
                var content struct {
                        //VmReq          []TbVmRecommendReq    `json:"vmReq"`
                        Vm_recommend    []mcis.TbVmRecommendInfo `json:"vm_recommend"`
                        PlacementAlgo  string                   `json:"placementAlgo"`
                        PlacementParam []common.KeyValue        `json:"placementParam"`
                }
        */
        //content := RestPostMcisRecommendResponse{}
        //content.VmReq = req.VmReq
        //content.PlacementAlgo = req.PlacementAlgo
        //content.PlacementParam = req.PlacementParam

        <span class="cov0" title="0">Vm_recommend := []TbVmRecommendInfo{}

        vmList := req.VmReq

        for i, v := range vmList </span><span class="cov0" title="0">{
                vmTmp := TbVmRecommendInfo{}
                //vmTmp.RequestName = v.RequestName
                vmTmp.VmReq = req.VmReq[i]
                vmTmp.PlacementAlgo = v.PlacementAlgo
                vmTmp.PlacementParam = v.PlacementParam

                var err error
                vmTmp.VmPriority, err = GetRecommendList(nsId, v.VcpuSize, v.MemorySize, v.DiskSize)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        //mapA := map[string]string{"message": "Failed to recommend MCIS"}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return nil, fmt.Errorf("Failed to recommend MCIS")
                }</span>

                <span class="cov0" title="0">Vm_recommend = append(Vm_recommend, vmTmp)</span>
        }

        <span class="cov0" title="0">return Vm_recommend, nil</span>
}

func CorePostCmdMcisVm(nsId string, mcisId string, vmId string, req *McisCmdReq) (string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return err.Error(), err
        }</span>

        <span class="cov0" title="0">vmIp, sshPort := GetVmIp(nsId, mcisId, vmId)

        //fmt.Printf("[vmIp] " +vmIp)

        //sshKey := req.SshKey
        cmd := req.Command

        // find vaild username
        userName, sshKey, err := VerifySshUserName(nsId, mcisId, vmId, vmIp, sshPort, req.UserName)

        if err != nil || userName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Not found: valid ssh username, " + err.Error())
        }</span>

        <span class="cov0" title="0">fmt.Println("[SSH] " + mcisId + "/" + vmId + "(" + vmIp + ")" + "with userName:" + userName)
        fmt.Println("[CMD] " + cmd)

        if result, err := RunSSH(vmIp, sshPort, userName, sshKey, cmd); err != nil </span><span class="cov0" title="0">{
                //return c.JSON(http.StatusInternalServerError, err)
                return "", err
        }</span> else<span class="cov0" title="0"> {
                //response := echo.Map{}
                //response["result"] = *result
                //response := RestPostCmdMcisVmResponse{Result: *result}
                //return c.JSON(http.StatusOK, response)
                return *result, nil
        }</span>
}

func CorePostCmdMcis(nsId string, mcisId string, req *McisCmdReq) ([]SshCmdResult, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := []SshCmdResult{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        /*
                type contentSub struct {
                        McisId string `json:"mcisId"`
                        VmId   string `json:"vmId"`
                        VmIp   string `json:"vmIp"`
                        Result  string `json:"result"`
                }
                var content struct {
                        Result_array []contentSub `json:"result_array"`
                }
        */
        //content := RestPostCmdMcisResponseWrapper{}

        <span class="cov0" title="0">vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        //goroutine sync wg
        <span class="cov0" title="0">var wg sync.WaitGroup

        var resultArray []SshCmdResult

        for _, v := range vmList </span><span class="cov0" title="0">{

                vmId := v
                vmIp, sshPort := GetVmIp(nsId, mcisId, vmId)

                cmd := req.Command

                // userName, sshKey := GetVmSshKey(nsId, mcisId, vmId)
                // if (userName == "") {
                //         userName = req.UserName
                // }
                // if (userName == "") {
                //         userName = sshDefaultUserName
                // }
                // find vaild username
                userName, sshKey, err := VerifySshUserName(nsId, mcisId, vmId, vmIp, sshPort, req.UserName)

                fmt.Println("[SSH] " + mcisId + "/" + vmId + "(" + vmIp + ")" + "with userName:" + userName)
                fmt.Println("[CMD] " + cmd)

                // Avoid RunSSH to not ready VM
                if err == nil </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go RunSSHAsync(&amp;wg, vmId, vmIp, sshPort, userName, sshKey, cmd, &amp;resultArray)
                }</span> else<span class="cov0" title="0"> {
                        common.CBLog.Error(err)
                        sshResultTmp := SshCmdResult{}
                        sshResultTmp.McisId = mcisId
                        sshResultTmp.VmId = vmId
                        sshResultTmp.VmIp = vmIp
                        sshResultTmp.Result = err.Error()
                        sshResultTmp.Err = err
                }</span>

        }
        <span class="cov0" title="0">wg.Wait() //goroutine sync wg

        return resultArray, nil</span>
}

func CorePostMcisVm(nsId string, mcisId string, vmInfoData *TbVmInfo) (*TbVmInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(vmInfoData.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckVm(nsId, mcisId, vmInfoData.Name)

        if check </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                err := fmt.Errorf("The vm " + vmInfoData.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov0" title="0">targetAction := ActionCreate
        targetStatus := StatusRunning

        vmInfoData.Id = vmInfoData.Name
        vmInfoData.PublicIP = "Not assigned yet"
        vmInfoData.PublicDNS = "Not assigned yet"
        vmInfoData.TargetAction = targetAction
        vmInfoData.TargetStatus = targetStatus
        vmInfoData.Status = StatusCreating

        //goroutin
        var wg sync.WaitGroup
        wg.Add(1)

        go AddVmToMcis(&amp;wg, nsId, mcisId, vmInfoData)

        wg.Wait()

        vmStatus, err := GetVmStatus(nsId, mcisId, vmInfoData.Id)
        if err != nil </span><span class="cov0" title="0">{
                //mapA := map[string]string{"message": "Cannot find " + common.GenMcisKey(nsId, mcisId, "")}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return nil, fmt.Errorf("Cannot find " + common.GenMcisKey(nsId, mcisId, vmInfoData.Id))
        }</span>

        <span class="cov0" title="0">vmInfoData.Status = vmStatus.Status
        vmInfoData.TargetStatus = vmStatus.TargetStatus
        vmInfoData.TargetAction = vmStatus.TargetAction

        // Install CB-Dragonfly monitoring agent

        mcisTmp, _ := GetMcisObject(nsId, mcisId)

        fmt.Printf("\n[Init monitoring agent] for %+v\n - req.InstallMonAgent: %+v\n\n", mcisId, mcisTmp.InstallMonAgent)

        if mcisTmp.InstallMonAgent != "no" </span><span class="cov0" title="0">{

                // Sleep for 20 seconds for a safe DF agent installation.
                fmt.Printf("\n\n[Info] Sleep for 20 seconds for safe CB-Dragonfly Agent installation.\n\n")
                time.Sleep(20 * time.Second)

                check := CheckDragonflyEndpoint()
                if check != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\n\n[Warring] CB-Dragonfly is not available\n\n")
                }</span> else<span class="cov0" title="0"> {
                        reqToMon := &amp;McisCmdReq{}
                        reqToMon.UserName = "ubuntu" // this MCIS user name is temporal code. Need to improve.

                        fmt.Printf("\n[InstallMonitorAgentToMcis]\n\n")
                        content, err := InstallMonitorAgentToMcis(nsId, mcisId, reqToMon)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //mcisTmp.InstallMonAgent = "no"
                        }</span>
                        <span class="cov0" title="0">common.PrintJsonPretty(content)</span>
                        //mcisTmp.InstallMonAgent = "yes"
                }
        }

        <span class="cov0" title="0">return vmInfoData, nil</span>
}

// CorePostMcisGroupVm function is a wrapper for CreateMcisGroupVm
func CorePostMcisGroupVm(nsId string, mcisId string, vmReq *TbVmReq) (*TbMcisInfo, error) <span class="cov0" title="0">{

        content, err := CreateMcisGroupVm(nsId, mcisId, vmReq)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov0" title="0">return content, nil</span>
}

func CreateMcisGroupVm(nsId string, mcisId string, vmRequest *TbVmReq) (*TbMcisInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(vmRequest.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">mcisTmp, err := GetMcisObject(nsId, mcisId)

        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                return temp, err
        }</span>

        //vmRequest := req

        <span class="cov0" title="0">targetAction := ActionCreate
        targetStatus := StatusRunning

        //goroutin
        var wg sync.WaitGroup

        // VM Group handling
        vmGroupSize, _ := strconv.Atoi(vmRequest.VmGroupSize)
        fmt.Printf("vmGroupSize: %v\n", vmGroupSize)

        if vmGroupSize &gt; 0 </span><span class="cov0" title="0">{

                fmt.Println("=========================== Create MCIS VM Group object")
                key := common.GenMcisVmGroupKey(nsId, mcisId, vmRequest.Name)

                // TODO: Enhancement Required. Need to check existing VM Group. Need to update it if exist.
                vmGroupInfoData := TbVmGroupInfo{}
                vmGroupInfoData.Id = vmRequest.Name
                vmGroupInfoData.Name = vmRequest.Name
                vmGroupInfoData.VmGroupSize = vmRequest.VmGroupSize

                for i := 0; i &lt; vmGroupSize; i++ </span><span class="cov0" title="0">{
                        vmGroupInfoData.VmId = append(vmGroupInfoData.VmId, vmGroupInfoData.Id+"-"+strconv.Itoa(i))
                }</span>

                <span class="cov0" title="0">val, _ := json.Marshal(vmGroupInfoData)
                err := common.CBStore.Put(string(key), string(val))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                }</span>
                <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(key))
                fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                fmt.Println("===========================")</span>

        }

        <span class="cov0" title="0">for i := 0; i &lt;= vmGroupSize; i++ </span><span class="cov0" title="0">{
                vmInfoData := TbVmInfo{}

                if vmGroupSize == 0 </span><span class="cov0" title="0">{ // for VM (not in a group)
                        vmInfoData.Name = vmRequest.Name
                }</span> else<span class="cov0" title="0"> { // for VM (in a group)
                        if i == vmGroupSize </span><span class="cov0" title="0">{
                                break</span> // if vmGroupSize != 0 &amp;&amp; vmGroupSize == i, skip the final loop
                        }
                        <span class="cov0" title="0">vmInfoData.VmGroupId = vmRequest.Name
                        // TODO: Enhancement Required. Need to check existing VM Group. Need to update it if exist.
                        vmInfoData.Name = vmRequest.Name + "-" + strconv.Itoa(i)
                        fmt.Println("===========================")
                        fmt.Println("vmInfoData.Name: " + vmInfoData.Name)
                        fmt.Println("===========================")</span>

                }
                <span class="cov0" title="0">vmInfoData.Id = vmInfoData.Name

                vmInfoData.Description = vmRequest.Description
                vmInfoData.PublicIP = "Not assigned yet"
                vmInfoData.PublicDNS = "Not assigned yet"

                vmInfoData.Status = StatusCreating
                vmInfoData.TargetAction = targetAction
                vmInfoData.TargetStatus = targetStatus

                vmInfoData.ConnectionName = vmRequest.ConnectionName
                vmInfoData.SpecId = vmRequest.SpecId
                vmInfoData.ImageId = vmRequest.ImageId
                vmInfoData.VNetId = vmRequest.VNetId
                vmInfoData.SubnetId = vmRequest.SubnetId
                //vmInfoData.VnicId = vmRequest.VnicId
                //vmInfoData.PublicIpId = vmRequest.PublicIpId
                vmInfoData.SecurityGroupIds = vmRequest.SecurityGroupIds
                vmInfoData.SshKeyId = vmRequest.SshKeyId
                vmInfoData.Description = vmRequest.Description

                vmInfoData.VmUserAccount = vmRequest.VmUserAccount
                vmInfoData.VmUserPassword = vmRequest.VmUserPassword

                wg.Add(1)
                go AddVmToMcis(&amp;wg, nsId, mcisId, &amp;vmInfoData)</span>

        }

        <span class="cov0" title="0">wg.Wait()

        //Update MCIS status

        mcisTmp, err = GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                return temp, err
        }</span>

        <span class="cov0" title="0">mcisStatusTmp, _ := GetMcisStatus(nsId, mcisId)

        mcisTmp.Status = mcisStatusTmp.Status

        if mcisTmp.TargetStatus == mcisTmp.Status </span><span class="cov0" title="0">{
                mcisTmp.TargetStatus = StatusComplete
                mcisTmp.TargetAction = ActionComplete
        }</span>
        <span class="cov0" title="0">UpdateMcisInfo(nsId, mcisTmp)

        // Install CB-Dragonfly monitoring agent

        fmt.Printf("\n[Init monitoring agent] for %+v\n - req.InstallMonAgent: %+v\n\n", mcisId, mcisTmp.InstallMonAgent)
        if mcisTmp.InstallMonAgent != "no" </span><span class="cov0" title="0">{

                // Sleep for 60 seconds for a safe DF agent installation.
                fmt.Printf("\n\n[Info] Sleep for 60 seconds for safe CB-Dragonfly Agent installation.\n\n")
                time.Sleep(60 * time.Second)

                check := CheckDragonflyEndpoint()
                if check != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\n\n[Warring] CB-Dragonfly is not available\n\n")
                }</span> else<span class="cov0" title="0"> {
                        reqToMon := &amp;McisCmdReq{}
                        reqToMon.UserName = "ubuntu" // this MCIS user name is temporal code. Need to improve.

                        fmt.Printf("\n[InstallMonitorAgentToMcis]\n\n")
                        content, err := InstallMonitorAgentToMcis(nsId, mcisId, reqToMon)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //mcisTmp.InstallMonAgent = "no"
                        }</span>
                        <span class="cov0" title="0">common.PrintJsonPretty(content)</span>
                        //mcisTmp.InstallMonAgent = "yes"
                }
        }
        <span class="cov0" title="0">return &amp;mcisTmp, nil</span>

}

func CoreGetMcisVmAction(nsId string, mcisId string, vmId string, action string) (string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return err.Error(), err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Get VM requested action: " + action)
        if action == "suspend" </span><span class="cov0" title="0">{
                fmt.Println("[suspend VM]")

                ControlVm(nsId, mcisId, vmId, ActionSuspend)
                //mapA := map[string]string{"message": "Suspending the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Suspending the VM", nil

        }</span> else<span class="cov0" title="0"> if action == "resume" </span><span class="cov0" title="0">{
                fmt.Println("[resume VM]")

                ControlVm(nsId, mcisId, vmId, ActionResume)
                //mapA := map[string]string{"message": "Resuming the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Resuming the VM", nil

        }</span> else<span class="cov0" title="0"> if action == "reboot" </span><span class="cov0" title="0">{
                fmt.Println("[reboot VM]")

                ControlVm(nsId, mcisId, vmId, ActionReboot)
                //mapA := map[string]string{"message": "Rebooting the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Rebooting the VM", nil

        }</span> else<span class="cov0" title="0"> if action == "terminate" </span><span class="cov0" title="0">{
                fmt.Println("[terminate VM]")

                ControlVm(nsId, mcisId, vmId, ActionTerminate)

                //mapA := map[string]string{"message": "Terminating the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Terminating the VM", nil
        }</span> else<span class="cov0" title="0"> {
                return "", fmt.Errorf(action + " not supported")
        }</span>
}

func CoreGetMcisVmStatus(nsId string, mcisId string, vmId string) (*TbVmStatusInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[status VM]")

        vmKey := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(vmKey)
        vmKeyValue, _ := common.CBStore.Get(vmKey)
        if vmKeyValue == nil </span><span class="cov0" title="0">{
                //mapA := map[string]string{"message": "Cannot find " + vmKey}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return nil, fmt.Errorf("Cannot find " + vmKey)
        }</span>

        <span class="cov0" title="0">vmStatusResponse, err := GetVmStatus(nsId, mcisId, vmId)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;vmStatusResponse, nil</span>
}

func CoreGetMcisVmInfo(nsId string, mcisId string, vmId string) (*TbVmInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Get MCIS-VM info for id]" + vmId)

        key := common.GenMcisKey(nsId, mcisId, "")
        //fmt.Println(key)

        vmKey := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(vmKey)
        vmKeyValue, _ := common.CBStore.Get(vmKey)
        if vmKeyValue == nil </span><span class="cov0" title="0">{
                //mapA := map[string]string{"message": "Cannot find " + key}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return nil, fmt.Errorf("Cannot find " + key)
        }</span>
        //fmt.Println("&lt;" + vmKeyValue.Key + "&gt; \n" + vmKeyValue.Value)
        <span class="cov0" title="0">vmTmp := TbVmInfo{}
        json.Unmarshal([]byte(vmKeyValue.Value), &amp;vmTmp)
        vmTmp.Id = vmId

        //get current vm status
        vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
        }</span>

        <span class="cov0" title="0">vmTmp.Status = vmStatusInfoTmp.Status
        vmTmp.TargetStatus = vmStatusInfoTmp.TargetStatus
        vmTmp.TargetAction = vmStatusInfoTmp.TargetAction

        return &amp;vmTmp, nil</span>
}

// CreateMcis function create MCIS obeject and deploy requested VMs.
func CreateMcis(nsId string, req *TbMcisReq) (*TbMcisInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(req.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, req.Name)
        if check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The mcis " + req.Name + " already exists.")
                return nil, err
        }</span>

        <span class="cov0" title="0">targetAction := ActionCreate
        targetStatus := StatusRunning

        mcisId := req.Name
        vmRequest := req.Vm

        fmt.Println("=========================== Create MCIS object")
        key := common.GenMcisKey(nsId, mcisId, "")
        mapA := map[string]string{
                "id":              mcisId,
                "name":            mcisId,
                "description":     req.Description,
                "status":          StatusCreating,
                "targetAction":    targetAction,
                "targetStatus":    targetStatus,
                "InstallMonAgent": req.InstallMonAgent,
        }
        val, err := json.Marshal(mapA)
        if err != nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("System Error: CreateMcis json.Marshal(mapA) Error")
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">err = common.CBStore.Put(string(key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("System Error: CreateMcis CBStore.Put Error")
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // Check whether VM names meet requirement.
        for _, k := range vmRequest </span><span class="cov0" title="0">{
                err = common.CheckString(k.Name)
                if err != nil </span><span class="cov0" title="0">{
                        temp := &amp;TbMcisInfo{}
                        common.CBLog.Error(err)
                        return temp, err
                }</span>
        }

        //goroutin
        <span class="cov0" title="0">var wg sync.WaitGroup

        for _, k := range vmRequest </span><span class="cov0" title="0">{

                // VM Group handling
                vmGroupSize, _ := strconv.Atoi(k.VmGroupSize)
                fmt.Printf("vmGroupSize: %v\n", vmGroupSize)

                if vmGroupSize &gt; 0 </span><span class="cov0" title="0">{

                        fmt.Println("=========================== Create MCIS VM Group object")
                        key := common.GenMcisVmGroupKey(nsId, mcisId, k.Name)

                        vmGroupInfoData := TbVmGroupInfo{}
                        vmGroupInfoData.Id = common.ToLower(k.Name)
                        vmGroupInfoData.Name = common.ToLower(k.Name)
                        vmGroupInfoData.VmGroupSize = k.VmGroupSize

                        for i := 0; i &lt; vmGroupSize; i++ </span><span class="cov0" title="0">{
                                vmGroupInfoData.VmId = append(vmGroupInfoData.VmId, vmGroupInfoData.Id+"-"+strconv.Itoa(i))
                        }</span>

                        <span class="cov0" title="0">val, _ := json.Marshal(vmGroupInfoData)
                        err := common.CBStore.Put(string(key), string(val))
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                        }</span>
                        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(key))
                        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                        fmt.Println("===========================")</span>

                }

                <span class="cov0" title="0">for i := 0; i &lt;= vmGroupSize; i++ </span><span class="cov0" title="0">{
                        vmInfoData := TbVmInfo{}

                        if vmGroupSize == 0 </span><span class="cov0" title="0">{ // for VM (not in a group)
                                vmInfoData.Name = common.ToLower(k.Name)
                        }</span> else<span class="cov0" title="0"> { // for VM (in a group)
                                if i == vmGroupSize </span><span class="cov0" title="0">{
                                        break</span> // if vmGroupSize != 0 &amp;&amp; vmGroupSize == i, skip the final loop
                                }
                                <span class="cov0" title="0">vmInfoData.VmGroupId = common.ToLower(k.Name)
                                vmInfoData.Name = common.ToLower(k.Name) + "-" + strconv.Itoa(i)
                                fmt.Println("===========================")
                                fmt.Println("vmInfoData.Name: " + vmInfoData.Name)
                                fmt.Println("===========================")</span>

                        }
                        <span class="cov0" title="0">vmInfoData.Id = vmInfoData.Name

                        vmInfoData.PublicIP = "Not assigned yet"
                        vmInfoData.PublicDNS = "Not assigned yet"

                        vmInfoData.Status = StatusCreating
                        vmInfoData.TargetAction = targetAction
                        vmInfoData.TargetStatus = targetStatus

                        vmInfoData.ConnectionName = k.ConnectionName
                        vmInfoData.SpecId = k.SpecId
                        vmInfoData.ImageId = k.ImageId
                        vmInfoData.VNetId = k.VNetId
                        vmInfoData.SubnetId = k.SubnetId
                        vmInfoData.SecurityGroupIds = k.SecurityGroupIds
                        vmInfoData.SshKeyId = k.SshKeyId
                        vmInfoData.Description = k.Description
                        vmInfoData.VmUserAccount = k.VmUserAccount
                        vmInfoData.VmUserPassword = k.VmUserPassword

                        // Avoid concurrent requests to CSP.
                        time.Sleep(time.Duration(i) * time.Second)

                        wg.Add(1)
                        go AddVmToMcis(&amp;wg, nsId, mcisId, &amp;vmInfoData)</span>
                        //AddVmToMcis(nsId, req.Id, vmInfoData)

                }
        }
        <span class="cov0" title="0">wg.Wait()

        mcisTmp, err := GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">mcisStatusTmp, err := GetMcisStatus(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">mcisTmp.Status = mcisStatusTmp.Status

        if mcisTmp.TargetStatus == mcisTmp.Status </span><span class="cov0" title="0">{
                mcisTmp.TargetStatus = StatusComplete
                mcisTmp.TargetAction = ActionComplete
        }</span>
        <span class="cov0" title="0">UpdateMcisInfo(nsId, mcisTmp)

        fmt.Println("[MCIS has been created]" + mcisId)
        //common.PrintJsonPretty(mcisTmp)

        // Install CB-Dragonfly monitoring agent

        fmt.Printf("[Init monitoring agent] for %+v\n - req.InstallMonAgent: %+v\n\n", mcisTmp.Id, req.InstallMonAgent)

        mcisTmp.InstallMonAgent = req.InstallMonAgent
        UpdateMcisInfo(nsId, mcisTmp)

        if req.InstallMonAgent != "no" </span><span class="cov0" title="0">{

                check := CheckDragonflyEndpoint()
                if check != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\n\n[Warring] CB-Dragonfly is not available\n\n")
                }</span> else<span class="cov0" title="0"> {
                        reqToMon := &amp;McisCmdReq{}
                        reqToMon.UserName = "ubuntu" // this MCIS user name is temporal code. Need to improve.

                        fmt.Printf("\n===========================\n")
                        // Sleep for 60 seconds for a safe DF agent installation.
                        fmt.Printf("\n\n[Info] Sleep for 60 seconds for safe CB-Dragonfly Agent installation.\n")
                        time.Sleep(60 * time.Second)

                        fmt.Printf("\n[InstallMonitorAgentToMcis]\n\n")
                        content, err := InstallMonitorAgentToMcis(nsId, mcisId, reqToMon)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //mcisTmp.InstallMonAgent = "no"
                        }</span>
                        <span class="cov0" title="0">common.PrintJsonPretty(content)</span>
                        //mcisTmp.InstallMonAgent = "yes"
                }
        }

        <span class="cov0" title="0">mcisTmp, err = GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mcisTmp, nil</span>
}

func AddVmToMcis(wg *sync.WaitGroup, nsId string, mcisId string, vmInfoData *TbVmInfo) error <span class="cov0" title="0">{
        fmt.Printf("\n[AddVmToMcis]\n")
        //goroutin
        defer wg.Done()

        key := common.GenMcisKey(nsId, mcisId, "")
        keyValue, _ := common.CBStore.Get(key)
        if keyValue == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("AddVmToMcis: Cannot find mcisId. Key: %s", key)
        }</span>

        <span class="cov0" title="0">configTmp, _ := common.GetConnConfig(vmInfoData.ConnectionName)
        regionTmp, _ := common.GetRegion(configTmp.RegionName)

        nativeRegion := ""
        for _, v := range regionTmp.KeyValueInfoList </span><span class="cov0" title="0">{
                if strings.ToLower(v.Key) == "region" || strings.ToLower(v.Key) == "location" </span><span class="cov0" title="0">{
                        nativeRegion = v.Value
                        break</span>
                }
        }

        <span class="cov0" title="0">vmInfoData.Location = GetCloudLocation(strings.ToLower(configTmp.ProviderName), strings.ToLower(nativeRegion))

        //fmt.Printf("\n[configTmp]\n %+v regionTmp %+v \n", configTmp, regionTmp)
        //fmt.Printf("\n[vmInfoData.Location]\n %+v\n", vmInfoData.Location)

        //AddVmInfoToMcis(nsId, mcisId, *vmInfoData)
        // Make VM object
        key = common.GenMcisKey(nsId, mcisId, vmInfoData.Id)
        val, _ := json.Marshal(vmInfoData)
        err := common.CBStore.Put(string(key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n[AddVmToMcis Befor request vmInfoData]\n")
        //common.PrintJsonPretty(vmInfoData)

        //instanceIds, publicIPs := CreateVm(&amp;vmInfoData)
        err = CreateVm(nsId, mcisId, vmInfoData)

        fmt.Printf("\n[AddVmToMcis After request vmInfoData]\n")
        //common.PrintJsonPretty(vmInfoData)

        if err != nil </span><span class="cov0" title="0">{
                vmInfoData.Status = StatusFailed
                vmInfoData.SystemMessage = err.Error()
                UpdateVmInfo(nsId, mcisId, *vmInfoData)
                common.CBLog.Error(err)
                return err
        }</span>

        // set initial TargetAction, TargetStatus
        <span class="cov0" title="0">vmInfoData.TargetAction = ActionComplete
        vmInfoData.TargetStatus = StatusComplete

        // get and set current vm status
        vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, vmInfoData.Id)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n[AddVmToMcis vmStatusInfoTmp]\n")
        common.PrintJsonPretty(vmStatusInfoTmp)

        vmInfoData.Status = vmStatusInfoTmp.Status

        // Monitoring Agent Installation Status (init: notInstalled)
        vmInfoData.MonAgentStatus = "notInstalled"

        // set CreatedTime
        t := time.Now()
        vmInfoData.CreatedTime = t.Format("2006-01-02 15:04:05")
        fmt.Println(vmInfoData.CreatedTime)

        UpdateVmInfo(nsId, mcisId, *vmInfoData)

        return nil</span>

}

func CreateVm(nsId string, mcisId string, vmInfoData *TbVmInfo) error <span class="cov0" title="0">{

        fmt.Printf("\n\n[CreateVm(vmInfoData *TbVmInfo)]\n\n")

        switch </span>{
        case vmInfoData.Name == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.Name is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.ImageId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.ImageId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.ConnectionName == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.ConnectionName is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SshKeyId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SshKeyId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SpecId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SpecId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SecurityGroupIds == nil:<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SecurityGroupIds is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.VNetId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.VNetId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SubnetId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SubnetId is empty")
                common.CBLog.Error(err)
                return err</span>
        default:<span class="cov0" title="0"></span>

        }

        //prettyJSON, err := json.MarshalIndent(vmInfoData, "", "    ")
        //if err != nil {
        //log.Fatal("Failed to generate json")
        //}
        //fmt.Printf("%s\n", string(prettyJSON))

        //common.PrintJsonPretty(vmInfoData)

        //fmt.Printf("%+v\n", vmInfoData.CspVmId)

        <span class="cov0" title="0">var tempSpiderVMInfo SpiderVMInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/vm"

                method := "POST"

                fmt.Println("\n[Calling SPIDER]START")
                fmt.Println("url: " + url + " method: " + method)

                tempReq := SpiderVMReqInfoWrapper{}
                tempReq.ConnectionName = vmInfoData.ConnectionName

                //generate VM ID(Name) to request to CSP(Spider)
                //combination of nsId, mcidId, and vmName reqested from user
                cspVmIdToRequest := nsId + "-" + mcisId + "-" + vmInfoData.Name
                tempReq.ReqInfo.Name = cspVmIdToRequest

                err := fmt.Errorf("")

                tempReq.ReqInfo.ImageName, err = common.GetCspResourceId(nsId, common.StrImage, vmInfoData.ImageId)
                if tempReq.ReqInfo.ImageName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempReq.ReqInfo.VMSpecName, err = common.GetCspResourceId(nsId, common.StrSpec, vmInfoData.SpecId)
                if tempReq.ReqInfo.VMSpecName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempReq.ReqInfo.VPCName, err = common.GetCspResourceId(nsId, common.StrVNet, vmInfoData.VNetId)
                if tempReq.ReqInfo.VPCName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                // TODO: needs to be enhnaced to use GetCspResourceId (GetCspResourceId needs to be updated as well)
                <span class="cov0" title="0">tempReq.ReqInfo.SubnetName = vmInfoData.SubnetId //common.GetCspResourceId(nsId, common.StrVNet, vmInfoData.SubnetId)
                if tempReq.ReqInfo.SubnetName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">var SecurityGroupIdsTmp []string
                for _, v := range vmInfoData.SecurityGroupIds </span><span class="cov0" title="0">{
                        CspSgId := v //common.GetCspResourceId(nsId, common.StrSecurityGroup, v)
                        if CspSgId == "" </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov0" title="0">SecurityGroupIdsTmp = append(SecurityGroupIdsTmp, CspSgId)</span>
                }
                <span class="cov0" title="0">tempReq.ReqInfo.SecurityGroupNames = SecurityGroupIdsTmp

                tempReq.ReqInfo.KeyPairName, err = common.GetCspResourceId(nsId, common.StrSSHKey, vmInfoData.SshKeyId)
                if tempReq.ReqInfo.KeyPairName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempReq.ReqInfo.VMUserId = vmInfoData.VmUserAccount
                tempReq.ReqInfo.VMUserPasswd = vmInfoData.VmUserPassword

                fmt.Printf("\n[Request body to CB-SPIDER for Creating VM]\n")
                common.PrintJsonPretty(tempReq)

                payload, _ := json.Marshal(tempReq)
                // fmt.Println("payload: " + string(payload))

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>,
                }
                <span class="cov0" title="0">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">req.Header.Add("Content-Type", "application/json")

                //reqBody, _ := ioutil.ReadAll(req.Body)
                //fmt.Println(string(reqBody))

                res, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        common.PrintJsonPretty(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">fmt.Println("Called CB-Spider API.")
                defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)

                if err != nil </span><span class="cov0" title="0">{
                        common.PrintJsonPretty(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempSpiderVMInfo = SpiderVMInfo{} // FYI; SpiderVMInfo: the struct in CB-Spider
                err = json.Unmarshal(body, &amp;tempSpiderVMInfo)

                if err != nil </span><span class="cov0" title="0">{
                        common.PrintJsonPretty(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">fmt.Println("[Response from SPIDER]")
                common.PrintJsonPretty(tempSpiderVMInfo)
                fmt.Println("[Calling SPIDER]END")

                fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch </span>{
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(body))
                        fmt.Println("body: ", string(body))
                        common.CBLog.Error(err)
                        return err</span>
                }

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                fmt.Println("\n[Calling SPIDER]START")

                tempReq := SpiderVMReqInfoWrapper{}
                tempReq.ConnectionName = vmInfoData.ConnectionName

                //generate VM ID(Name) to request to CSP(Spider)
                //combination of nsId, mcidId, and vmName reqested from user
                cspVmIdToRequest := nsId + "-" + mcisId + "-" + vmInfoData.Name
                tempReq.ReqInfo.Name = cspVmIdToRequest

                err = fmt.Errorf("")

                tempReq.ReqInfo.ImageName, err = common.GetCspResourceId(nsId, common.StrImage, vmInfoData.ImageId)
                if tempReq.ReqInfo.ImageName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempReq.ReqInfo.VMSpecName, err = common.GetCspResourceId(nsId, common.StrSpec, vmInfoData.SpecId)
                if tempReq.ReqInfo.VMSpecName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempReq.ReqInfo.VPCName = vmInfoData.VNetId //common.GetCspResourceId(nsId, common.StrVNet, vmInfoData.VNetId)
                if tempReq.ReqInfo.VPCName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempReq.ReqInfo.SubnetName = vmInfoData.SubnetId //common.GetCspResourceId(nsId, "subnet", vmInfoData.SubnetId)
                if tempReq.ReqInfo.SubnetName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">var SecurityGroupIdsTmp []string
                for _, v := range vmInfoData.SecurityGroupIds </span><span class="cov0" title="0">{
                        CspSgId := v //common.GetCspResourceId(nsId, common.StrSecurityGroup, v)
                        if CspSgId == "" </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov0" title="0">SecurityGroupIdsTmp = append(SecurityGroupIdsTmp, CspSgId)</span>
                }
                <span class="cov0" title="0">tempReq.ReqInfo.SecurityGroupNames = SecurityGroupIdsTmp

                tempReq.ReqInfo.KeyPairName = vmInfoData.SshKeyId //common.GetCspResourceId(nsId, common.StrSSHKey, vmInfoData.SshKeyId)
                if tempReq.ReqInfo.KeyPairName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempReq.ReqInfo.VMUserId = vmInfoData.VmUserAccount
                tempReq.ReqInfo.VMUserPasswd = vmInfoData.VmUserPassword

                fmt.Printf("\n[Request body to CB-SPIDER for Creating VM]\n")
                common.PrintJsonPretty(tempReq)

                payload, _ := json.Marshal(tempReq)
                fmt.Println("payload: " + string(payload))

                result, err := ccm.StartVM(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">tempSpiderVMInfo = SpiderVMInfo{} // FYI; SpiderVMInfo: the struct in CB-Spider
                err2 := json.Unmarshal([]byte(result), &amp;tempSpiderVMInfo)

                if err2 != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

        }

        <span class="cov0" title="0">vmInfoData.CspViewVmDetail = tempSpiderVMInfo

        vmInfoData.VmUserAccount = tempSpiderVMInfo.VMUserId
        vmInfoData.VmUserPassword = tempSpiderVMInfo.VMUserPasswd

        //vmInfoData.Location = vmInfoData.Location

        //vmInfoData.VcpuSize = vmInfoData.VcpuSize
        //vmInfoData.MemorySize = vmInfoData.MemorySize
        //vmInfoData.DiskSize = vmInfoData.DiskSize
        //vmInfoData.Disk_type = vmInfoData.Disk_type

        //vmInfoData.PlacementAlgo = vmInfoData.PlacementAlgo

        // 2. Provided by CB-Spider
        //vmInfoData.CspVmId = temp.Id
        //vmInfoData.StartTime = temp.StartTime
        vmInfoData.Region = tempSpiderVMInfo.Region
        vmInfoData.PublicIP = tempSpiderVMInfo.PublicIP
        vmInfoData.SSHPort, _ = TrimIP(tempSpiderVMInfo.SSHAccessPoint)
        vmInfoData.PublicDNS = tempSpiderVMInfo.PublicDNS
        vmInfoData.PrivateIP = tempSpiderVMInfo.PrivateIP
        vmInfoData.PrivateDNS = tempSpiderVMInfo.PrivateDNS
        vmInfoData.VMBootDisk = tempSpiderVMInfo.VMBootDisk
        vmInfoData.VMBlockDisk = tempSpiderVMInfo.VMBlockDisk
        //vmInfoData.KeyValueList = temp.KeyValueList

        //configTmp, _ := common.GetConnConfig(vmInfoData.ConnectionName)
        //vmInfoData.Location = GetCloudLocation(strings.ToLower(configTmp.ProviderName), strings.ToLower(tempSpiderVMInfo.Region.Region))

        vmKey := common.GenMcisKey(nsId, mcisId, vmInfoData.Id)
        //mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfoData.SshKeyId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrImage, vmInfoData.ImageId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSpec, vmInfoData.SpecId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfoData.SshKeyId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrVNet, vmInfoData.VNetId, common.StrAdd, vmKey)

        for _, v2 := range vmInfoData.SecurityGroupIds </span><span class="cov0" title="0">{
                mcir.UpdateAssociatedObjectList(nsId, common.StrSecurityGroup, v2, common.StrAdd, vmKey)
        }</span>

        //content.Status = temp.
        //content.CloudId = temp.

        // cb-store
        //fmt.Println("=========================== PUT createVM")
        /*
                Key := genResourceKey(nsId, "vm", content.Id)

                Val, _ := json.Marshal(content)
                fmt.Println("Key: ", Key)
                fmt.Println("Val: ", Val)
                err := common.CBStore.Put(string(Key), string(Val))
                if err != nil {
                        common.CBLog.Error(err)
                        return nil, nil
                }
                keyValue, _ := common.CBStore.Get(string(Key))
                fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                fmt.Println("===========================")
                return content, nil
        */

        //instanceIds := make([]*string, 1)
        //publicIPs := make([]*string, 1)
        //instanceIds[0] = &amp;content.CspVmId
        //publicIPs[0] = &amp;content.PublicIP

        <span class="cov0" title="0">UpdateVmInfo(nsId, mcisId, *vmInfoData)

        return nil</span>
}

func ControlMcis(nsId string, mcisId string, action string) error <span class="cov0" title="0">{

        key := common.GenMcisKey(nsId, mcisId, "")
        fmt.Println("[ControlMcis] " + key + " to " + action)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)

        vmList, err := ListVmId(nsId, mcisId)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Println("vmList ", vmList)

        for _, v := range vmList </span><span class="cov0" title="0">{
                ControlVm(nsId, mcisId, v, action)
        }</span>
        <span class="cov0" title="0">return nil</span>

        //need to change status

}

func CheckAllowedTransition(nsId string, mcisId string, action string) error <span class="cov0" title="0">{

        fmt.Println("[CheckAllowedTransition]" + mcisId + " to " + action)
        key := common.GenMcisKey(nsId, mcisId, "")
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">mcisTmp := TbMcisInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("Unmarshal Error:", unmarshalErr)
        }</span>

        <span class="cov0" title="0">mcisStatusTmp, _ := GetMcisStatus(nsId, mcisId)

        UpdateMcisInfo(nsId, mcisTmp)

        if strings.Contains(mcisStatusTmp.Status, StatusTerminating) || strings.Contains(mcisStatusTmp.Status, StatusResuming) || strings.Contains(mcisStatusTmp.Status, StatusSuspending) || strings.Contains(mcisStatusTmp.Status, StatusCreating) || strings.Contains(mcisStatusTmp.Status, StatusRebooting) </span><span class="cov0" title="0">{
                return errors.New(action + " is not allowed for MCIS under " + mcisStatusTmp.Status)
        }</span>
        <span class="cov0" title="0">if !strings.Contains(mcisStatusTmp.Status, "Partial-") &amp;&amp; strings.Contains(mcisStatusTmp.Status, StatusTerminated) </span><span class="cov0" title="0">{
                return errors.New(action + " is not allowed for " + mcisStatusTmp.Status + " MCIS")
        }</span>
        <span class="cov0" title="0">if strings.Contains(mcisStatusTmp.Status, StatusSuspended) </span><span class="cov0" title="0">{
                if strings.EqualFold(action, ActionResume) || strings.EqualFold(action, ActionSuspend) </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> {
                        return errors.New(action + " is not allowed for " + mcisStatusTmp.Status + " MCIS")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func ControlMcisAsync(nsId string, mcisId string, action string) error <span class="cov0" title="0">{

        checkError := CheckAllowedTransition(nsId, mcisId, action)
        if checkError != nil </span><span class="cov0" title="0">{
                return checkError
        }</span>

        <span class="cov0" title="0">key := common.GenMcisKey(nsId, mcisId, "")
        fmt.Println("[ControlMcisAsync] " + key + " to " + action)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===============================================")

        mcisTmp := TbMcisInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
        }</span>

        <span class="cov0" title="0">vmList, err := ListVmId(nsId, mcisId)
        fmt.Println("=============================================== ", vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch action </span>{
        case ActionTerminate:<span class="cov0" title="0">

                mcisTmp.TargetAction = ActionTerminate
                mcisTmp.TargetStatus = StatusTerminated
                mcisTmp.Status = StatusTerminating</span>

        case ActionReboot:<span class="cov0" title="0">

                mcisTmp.TargetAction = ActionReboot
                mcisTmp.TargetStatus = StatusRunning
                mcisTmp.Status = StatusRebooting</span>

        case ActionSuspend:<span class="cov0" title="0">

                mcisTmp.TargetAction = ActionSuspend
                mcisTmp.TargetStatus = StatusSuspended
                mcisTmp.Status = StatusSuspending</span>

        case ActionResume:<span class="cov0" title="0">

                mcisTmp.TargetAction = ActionResume
                mcisTmp.TargetStatus = StatusRunning
                mcisTmp.Status = StatusResuming</span>

        default:<span class="cov0" title="0">
                return errors.New(action + "is invalid actionType")</span>
        }
        <span class="cov0" title="0">UpdateMcisInfo(nsId, mcisTmp)

        //goroutin sync wg
        var wg sync.WaitGroup
        var results ControlVmResultWrapper

        for _, v := range vmList </span><span class="cov0" title="0">{
                wg.Add(1)

                // Avoid concurrent requests to CSP.
                time.Sleep(time.Duration(3) * time.Second)

                go ControlVmAsync(&amp;wg, nsId, mcisId, v, action, &amp;results)
        }</span>
        <span class="cov0" title="0">wg.Wait() //goroutine sync wg

        checkErrFlag := ""
        for _, v := range results.ResultArray </span><span class="cov0" title="0">{
                if v.Error != nil </span><span class="cov0" title="0">{
                        checkErrFlag += "["
                        checkErrFlag += v.Error.Error()
                        checkErrFlag += "]"
                }</span>
        }
        <span class="cov0" title="0">if checkErrFlag != "" </span><span class="cov0" title="0">{
                return fmt.Errorf(checkErrFlag)
        }</span>

        <span class="cov0" title="0">return nil</span>

        //need to change status

}

type ControlVmResult struct {
        VmId   string `json:"vmId"`
        Status string `json:"Status"`
        Error  error  `json:"Error"`
}
type ControlVmResultWrapper struct {
        ResultArray []ControlVmResult `json:"resultarray"`
}

func ControlVmAsync(wg *sync.WaitGroup, nsId string, mcisId string, vmId string, action string, results *ControlVmResultWrapper) error <span class="cov0" title="0">{
        defer wg.Done() //goroutine sync done

        var errTmp error
        var err error
        var err2 error
        resultTmp := ControlVmResult{}
        resultTmp.VmId = vmId
        resultTmp.Status = ""
        temp := TbVmInfo{}

        key := common.GenMcisKey(nsId, mcisId, vmId)
        fmt.Println("[ControlVmAsync] " + key)

        keyValue, err := common.CBStore.Get(key)

        if keyValue == nil || err != nil </span><span class="cov0" title="0">{

                resultTmp.Error = fmt.Errorf("CBStoreGetErr. keyValue == nil || err != nil. key[" + key + "]")
                results.ResultArray = append(results.ResultArray, resultTmp)
                common.PrintJsonPretty(resultTmp)
                return resultTmp.Error

        }</span> else<span class="cov0" title="0"> {
                fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                fmt.Println("===============================================")

                unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                if unmarshalErr != nil </span><span class="cov0" title="0">{
                        fmt.Println("Unmarshal error:", unmarshalErr)
                }</span>

                <span class="cov0" title="0">fmt.Println("\n[Calling SPIDER]START vmControl")

                cspVmId := temp.CspViewVmDetail.IId.NameId
                common.PrintJsonPretty(temp.CspViewVmDetail)

                // Prevent malformed cspVmId
                if cspVmId == "" || common.CheckString(cspVmId) != nil </span><span class="cov0" title="0">{
                        resultTmp.Error = fmt.Errorf("Not valid requested CSPNativeVmId: [" + cspVmId + "]")
                        temp.Status = StatusFailed
                        temp.SystemMessage = resultTmp.Error.Error()
                        UpdateVmInfo(nsId, mcisId, temp)
                        //return err
                }</span> else<span class="cov0" title="0"> {
                        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                                url := ""
                                method := ""
                                switch action </span>{
                                case ActionTerminate:<span class="cov0" title="0">

                                        temp.TargetAction = ActionTerminate
                                        temp.TargetStatus = StatusTerminated
                                        temp.Status = StatusTerminating

                                        url = common.SPIDER_REST_URL + "/vm/" + cspVmId
                                        method = "DELETE"</span>
                                case ActionReboot:<span class="cov0" title="0">

                                        temp.TargetAction = ActionReboot
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusRebooting

                                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=reboot"
                                        method = "GET"</span>
                                case ActionSuspend:<span class="cov0" title="0">

                                        temp.TargetAction = ActionSuspend
                                        temp.TargetStatus = StatusSuspended
                                        temp.Status = StatusSuspending

                                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=suspend"
                                        method = "GET"</span>
                                case ActionResume:<span class="cov0" title="0">

                                        temp.TargetAction = ActionResume
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusResuming

                                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=resume"
                                        method = "GET"</span>
                                default:<span class="cov0" title="0">
                                        return errors.New(action + "is invalid actionType")</span>
                                }

                                <span class="cov0" title="0">UpdateVmInfo(nsId, mcisId, temp)
                                //fmt.Println("url: " + url + " method: " + method)

                                type ControlVMReqInfo struct {
                                        ConnectionName string
                                }
                                tempReq := ControlVMReqInfo{}
                                tempReq.ConnectionName = temp.ConnectionName
                                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                                //fmt.Println("payload: " + string(payload)) // for debug

                                client := &amp;http.Client{
                                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                                return http.ErrUseLastResponse
                                        }</span>,
                                }
                                <span class="cov0" title="0">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return err
                                }</span>
                                <span class="cov0" title="0">req.Header.Add("Content-Type", "application/json")

                                res, err := client.Do(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return err
                                }</span>
                                <span class="cov0" title="0">defer res.Body.Close()
                                body, err := ioutil.ReadAll(res.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return err
                                }</span>

                                <span class="cov0" title="0">fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                                switch </span>{
                                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                                        err := fmt.Errorf(string(body))
                                        common.CBLog.Error(err)
                                        errTmp = err</span>
                                }

                                <span class="cov0" title="0">err2 = json.Unmarshal(body, &amp;resultTmp)</span>

                        } else<span class="cov0" title="0"> {

                                // CCM API 
                                ccm := api.NewCloudResourceHandler()
                                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error("ccm failed to set config : ", err)
                                        temp.Status = StatusFailed
                                        UpdateVmInfo(nsId, mcisId, temp)
                                        return err
                                }</span>
                                <span class="cov0" title="0">err = ccm.Open()
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error("ccm api open failed : ", err)
                                        temp.Status = StatusFailed
                                        UpdateVmInfo(nsId, mcisId, temp)
                                        return err
                                }</span>
                                <span class="cov0" title="0">defer ccm.Close()

                                var result string

                                switch action </span>{
                                case ActionTerminate:<span class="cov0" title="0">

                                        temp.TargetAction = ActionTerminate
                                        temp.TargetStatus = StatusTerminated
                                        temp.Status = StatusTerminating

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.TerminateVMByParam(temp.ConnectionName, cspVmId, "false")</span>

                                case ActionReboot:<span class="cov0" title="0">

                                        temp.TargetAction = ActionReboot
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusRebooting

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "reboot")</span>

                                case ActionSuspend:<span class="cov0" title="0">

                                        temp.TargetAction = ActionSuspend
                                        temp.TargetStatus = StatusSuspended
                                        temp.Status = StatusSuspending

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "suspend")</span>

                                case ActionResume:<span class="cov0" title="0">

                                        temp.TargetAction = ActionResume
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusResuming

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "resume")</span>

                                default:<span class="cov0" title="0">
                                        return errors.New(action + "is invalid actionType")</span>
                                }

                                <span class="cov0" title="0">err2 = json.Unmarshal([]byte(result), &amp;resultTmp)</span>

                        }

                        <span class="cov0" title="0">if err2 != nil </span><span class="cov0" title="0">{
                                fmt.Println(err2)
                                common.CBLog.Error(err)
                                errTmp = err
                        }</span>
                        <span class="cov0" title="0">if errTmp != nil </span><span class="cov0" title="0">{
                                resultTmp.Error = errTmp

                                temp.Status = StatusFailed
                                temp.SystemMessage = errTmp.Error()
                                UpdateVmInfo(nsId, mcisId, temp)
                        }</span>
                        <span class="cov0" title="0">results.ResultArray = append(results.ResultArray, resultTmp)

                        common.PrintJsonPretty(resultTmp)

                        fmt.Println("[Calling SPIDER]END vmControl")

                        if action != ActionTerminate </span><span class="cov0" title="0">{
                                //When VM is restared, temporal PublicIP will be chanaged. Need update.
                                UpdateVmPublicIp(nsId, mcisId, temp)
                        }</span>
                }

        }

        <span class="cov0" title="0">return nil</span>

}

func ControlVm(nsId string, mcisId string, vmId string, action string) error <span class="cov0" title="0">{

        var content struct {
                CloudId string `json:"cloudId"`
                CspVmId string `json:"cspVmId"`
        }

        key := common.GenMcisKey(nsId, mcisId, vmId)
        fmt.Println("[ControlVm] " + key)

        keyValue, _ := common.CBStore.Get(key)
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===============================================")

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        //fmt.Printf("%+v\n", content.CloudId)
        //fmt.Printf("%+v\n", content.CspVmId)

        temp := TbVmInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n[Calling SPIDER]START vmControl")

        //fmt.Println("temp.CspVmId: " + temp.CspViewVmDetail.IId.NameId)

        /*
                cspType := getVMsCspType(nsId, mcisId, vmId)
                var cspVmId string
                if cspType == "AWS" {
                        cspVmId = temp.CspViewVmDetail.Id
                } else {
        */
        cspVmId := temp.CspViewVmDetail.IId.NameId
        common.PrintJsonPretty(temp.CspViewVmDetail)

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := ""
                method := ""
                switch action </span>{
                case ActionTerminate:<span class="cov0" title="0">

                        temp.TargetAction = ActionTerminate
                        temp.TargetStatus = StatusTerminated
                        temp.Status = StatusTerminating

                        url = common.SPIDER_REST_URL + "/vm/" + cspVmId
                        method = "DELETE"</span>
                case ActionReboot:<span class="cov0" title="0">

                        temp.TargetAction = ActionReboot
                        temp.TargetStatus = StatusRunning
                        temp.Status = StatusRebooting

                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=reboot"
                        method = "GET"</span>
                case ActionSuspend:<span class="cov0" title="0">

                        temp.TargetAction = ActionSuspend
                        temp.TargetStatus = StatusSuspended
                        temp.Status = StatusSuspending

                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=suspend"
                        method = "GET"</span>
                case ActionResume:<span class="cov0" title="0">

                        temp.TargetAction = ActionResume
                        temp.TargetStatus = StatusRunning
                        temp.Status = StatusResuming

                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=resume"
                        method = "GET"</span>
                default:<span class="cov0" title="0">
                        return errors.New(action + "is invalid actionType")</span>
                }

                <span class="cov0" title="0">UpdateVmInfo(nsId, mcisId, temp)
                //fmt.Println("url: " + url + " method: " + method)

                type ControlVMReqInfo struct {
                        ConnectionName string
                }
                tempReq := ControlVMReqInfo{}
                tempReq.ConnectionName = temp.ConnectionName
                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                //fmt.Println("payload: " + string(payload)) // for debug

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>,
                }
                <span class="cov0" title="0">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return err
                }</span>
                <span class="cov0" title="0">req.Header.Add("Content-Type", "application/json")

                res, err := client.Do(req)
                //fmt.Println("Called mockAPI.")
                defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)

                fmt.Println(string(body))

                fmt.Println("[Calling SPIDER]END vmControl\n")
                /*
                        if strings.Compare(content.CspVmId, "Not assigned yet") == 0 {
                                return nil
                        }
                        if strings.Compare(content.CloudId, "aws") == 0 {
                                controlVmAws(content.CspVmId)
                        } else if strings.Compare(content.CloudId, "gcp") == 0 {
                                controlVmGcp(content.CspVmId)
                        } else if strings.Compare(content.CloudId, "azure") == 0 {
                                controlVmAzure(content.CspVmId)
                        } else {
                                fmt.Println("==============ERROR=no matched providerId=================")
                        }
                */

                return nil</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                var result string

                switch action </span>{
                case ActionTerminate:<span class="cov0" title="0">

                        result, err = ccm.TerminateVMByParam(temp.ConnectionName, cspVmId, "false")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case ActionReboot:<span class="cov0" title="0">

                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "reboot")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case ActionSuspend:<span class="cov0" title="0">

                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "suspend")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case ActionResume:<span class="cov0" title="0">

                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "resume")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                default:<span class="cov0" title="0">
                        return errors.New(action + "is invalid actionType")</span>
                }

                <span class="cov0" title="0">fmt.Println(result)
                fmt.Println("[Calling SPIDER]END vmControl\n")

                return nil</span>
        }
}

// GetMcisObject func retrieve MCIS object from database (no current status update)
func GetMcisObject(nsId string, mcisId string) (TbMcisInfo, error) <span class="cov0" title="0">{
        fmt.Println("[GetMcisObject]" + mcisId)
        key := common.GenMcisKey(nsId, mcisId, "")
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbMcisInfo{}, err
        }</span>
        <span class="cov0" title="0">mcisTmp := TbMcisInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbMcisInfo{}, err
        }</span>

        <span class="cov0" title="0">for _, vmID := range vmList </span><span class="cov0" title="0">{
                vmtmp, err := GetVmObject(nsId, mcisId, vmID)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbMcisInfo{}, err
                }</span>
                <span class="cov0" title="0">mcisTmp.Vm = append(mcisTmp.Vm, vmtmp)</span>
        }

        <span class="cov0" title="0">return mcisTmp, nil</span>
}

func GetMcisStatus(nsId string, mcisId string) (*McisStatusInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[GetMcisStatus]" + mcisId)

        key := common.GenMcisKey(nsId, mcisId, "")
        //fmt.Println(key)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>
        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("Not found [" + key + "]")
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        //fmt.Println("===============================================")

        <span class="cov0" title="0">mcisStatus := McisStatusInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisStatus)

        mcisTmp := TbMcisInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)

        vmList, err := ListVmId(nsId, mcisId)
        //fmt.Println("=============================================== %#v", vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return &amp;McisStatusInfo{}, nil
        }</span>

        //goroutin sync wg
        <span class="cov0" title="0">var wg sync.WaitGroup
        for _, v := range vmList </span><span class="cov0" title="0">{
                wg.Add(1)
                go GetVmStatusAsync(&amp;wg, nsId, mcisId, v, &amp;mcisStatus)
        }</span>
        <span class="cov0" title="0">wg.Wait() //goroutine sync wg

        for _, v := range vmList </span><span class="cov0" title="0">{
                // set master IP of MCIS (Default rule: select 1st Running VM as master)
                vmtmp, _ := GetVmObject(nsId, mcisId, v)
                if vmtmp.Status == StatusRunning </span><span class="cov0" title="0">{
                        mcisStatus.MasterVmId = vmtmp.Id
                        mcisStatus.MasterIp = vmtmp.PublicIP
                        mcisStatus.MasterSSHPort = vmtmp.SSHPort
                        break</span>
                }
        }

        <span class="cov0" title="0">statusFlag := []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        statusFlagStr := []string{StatusFailed, StatusSuspended, StatusRunning, StatusTerminated, StatusCreating, StatusSuspending, StatusResuming, StatusRebooting, StatusTerminating, StatusUndefined}
        for _, v := range mcisStatus.Vm </span><span class="cov0" title="0">{

                switch v.Status </span>{
                case StatusFailed:<span class="cov0" title="0">
                        statusFlag[0]++</span>
                case StatusSuspended:<span class="cov0" title="0">
                        statusFlag[1]++</span>
                case StatusRunning:<span class="cov0" title="0">
                        statusFlag[2]++</span>
                case StatusTerminated:<span class="cov0" title="0">
                        statusFlag[3]++</span>
                case StatusCreating:<span class="cov0" title="0">
                        statusFlag[4]++</span>
                case StatusSuspending:<span class="cov0" title="0">
                        statusFlag[5]++</span>
                case StatusResuming:<span class="cov0" title="0">
                        statusFlag[6]++</span>
                case StatusRebooting:<span class="cov0" title="0">
                        statusFlag[7]++</span>
                case StatusTerminating:<span class="cov0" title="0">
                        statusFlag[8]++</span>
                default:<span class="cov0" title="0">
                        statusFlag[9]++</span>
                }
        }

        <span class="cov0" title="0">tmpMax := 0
        tmpMaxIndex := 0
        for i, v := range statusFlag </span><span class="cov0" title="0">{
                if v &gt; tmpMax </span><span class="cov0" title="0">{
                        tmpMax = v
                        tmpMaxIndex = i
                }</span>
        }

        <span class="cov0" title="0">numVm := len(mcisStatus.Vm)
        numUnNormalStatus := statusFlag[0] + statusFlag[9]
        numNormalStatus := numVm - numUnNormalStatus

        proportionStr := "-" + strconv.Itoa(tmpMax) + "(" + strconv.Itoa(numNormalStatus) + "/" + strconv.Itoa(numVm) + ")"
        if tmpMax == numVm </span><span class="cov0" title="0">{
                mcisStatus.Status = statusFlagStr[tmpMaxIndex] + proportionStr
        }</span> else<span class="cov0" title="0"> if tmpMax &lt; numVm </span><span class="cov0" title="0">{
                mcisStatus.Status = "Partial-" + statusFlagStr[tmpMaxIndex] + proportionStr
        }</span> else<span class="cov0" title="0"> {
                mcisStatus.Status = statusFlagStr[9] + proportionStr
        }</span>
        // for representing Failed status in front.

        <span class="cov0" title="0">proportionStr = "-" + strconv.Itoa(statusFlag[0]) + "(" + strconv.Itoa(numNormalStatus) + "/" + strconv.Itoa(numVm) + ")"
        if statusFlag[0] &gt; 0 </span><span class="cov0" title="0">{
                mcisStatus.Status = "Partial-" + statusFlagStr[0] + proportionStr
                if statusFlag[0] == numVm </span><span class="cov0" title="0">{
                        mcisStatus.Status = statusFlagStr[0] + proportionStr
                }</span>
        }

        // proportionStr = "-(" + strconv.Itoa(statusFlag[9]) + "/" + strconv.Itoa(numVm) + ")"
        // if statusFlag[9] &gt; 0 {
        //         mcisStatus.Status = statusFlagStr[9] + proportionStr
        // }

        <span class="cov0" title="0">var isDone bool
        isDone = true
        for _, v := range mcisStatus.Vm </span><span class="cov0" title="0">{
                if v.TargetStatus != StatusComplete </span><span class="cov0" title="0">{
                        isDone = false
                }</span>
        }
        <span class="cov0" title="0">if isDone </span><span class="cov0" title="0">{
                mcisStatus.TargetAction = ActionComplete
                mcisStatus.TargetStatus = StatusComplete
                mcisTmp.TargetAction = ActionComplete
                mcisTmp.TargetStatus = StatusComplete
                UpdateMcisInfo(nsId, mcisTmp)
        }</span>

        <span class="cov0" title="0">return &amp;mcisStatus, nil</span>

        //need to change status

}

func GetMcisStatusAll(nsId string) ([]McisStatusInfo, error) <span class="cov0" title="0">{

        mcisStatuslist := []McisStatusInfo{}
        mcisList, err := ListMcisId(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return mcisStatuslist, err
        }</span>

        <span class="cov0" title="0">for _, mcisId := range mcisList </span><span class="cov0" title="0">{
                mcisStatus, err := GetMcisStatus(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return mcisStatuslist, err
                }</span>
                <span class="cov0" title="0">mcisStatuslist = append(mcisStatuslist, *mcisStatus)</span>
        }
        <span class="cov0" title="0">return mcisStatuslist, nil</span>

        //need to change status

}

func GetVmObject(nsId string, mcisId string, vmId string) (TbVmInfo, error) <span class="cov0" title="0">{
        //fmt.Println("[GetVmObject] mcisId: " + mcisId + ", vmId: " + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbVmInfo{}, err
        }</span>
        <span class="cov0" title="0">vmTmp := TbVmInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;vmTmp)
        return vmTmp, nil</span>
}

func GetVmStatusAsync(wg *sync.WaitGroup, nsId string, mcisId string, vmId string, results *McisStatusInfo) error <span class="cov0" title="0">{
        defer wg.Done() //goroutine sync done

        vmStatusTmp, err := GetVmStatus(nsId, mcisId, vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                vmStatusTmp.Status = StatusFailed
                vmStatusTmp.SystemMessage = err.Error()
        }</span>

        <span class="cov0" title="0">results.Vm = append(results.Vm, vmStatusTmp)
        return nil</span>
}

func GetVmStatus(nsId string, mcisId string, vmId string) (TbVmStatusInfo, error) <span class="cov0" title="0">{

        // defer func() {
        //         if runtimeErr := recover(); runtimeErr != nil {
        //                 myErr := fmt.Errorf("in GetVmStatus; mcisId: " + mcisId + ", vmId: " + vmId)
        //                 common.CBLog.Error(myErr)
        //                 common.CBLog.Error(runtimeErr)
        //         }
        // }()

        //fmt.Println("[GetVmStatus]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)
        errorInfo := TbVmStatusInfo{}

        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                fmt.Println("CBStoreGetErr. keyValue == nil || err != nil", err)
                fmt.Println(err)
                return errorInfo, err
        }</span>

        // fmt.Println(keyValue.Value)
        // fmt.Println("&lt;" + keyValue.Key + "&gt; \n")
        // fmt.Println("===============================================")

        <span class="cov0" title="0">temp := TbVmInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
                fmt.Println(err)
                return errorInfo, err
        }</span>

        <span class="cov0" title="0">errorInfo.Id = temp.Id
        errorInfo.Name = temp.Name
        errorInfo.CspVmId = temp.CspViewVmDetail.IId.NameId
        errorInfo.PublicIp = temp.PublicIP
        errorInfo.SSHPort = temp.SSHPort
        errorInfo.PrivateIp = temp.PrivateIP
        errorInfo.NativeStatus = StatusUndefined
        errorInfo.TargetAction = temp.TargetAction
        errorInfo.TargetStatus = temp.TargetStatus
        errorInfo.Location = temp.Location
        errorInfo.MonAgentStatus = temp.MonAgentStatus
        errorInfo.CreatedTime = temp.CreatedTime
        errorInfo.SystemMessage = "Error in GetVmStatus"

        cspVmId := temp.CspViewVmDetail.IId.NameId

        type statusResponse struct {
                Status string
        }
        statusResponseTmp := statusResponse{}
        statusResponseTmp.Status = ""

        if cspVmId != "" &amp;&amp; temp.Status != StatusTerminated </span><span class="cov0" title="0">{
                fmt.Print("[Calling SPIDER] vmstatus, ")
                fmt.Println("CspVmId: " + cspVmId)
                if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                        url := common.SPIDER_REST_URL + "/vmstatus/" + cspVmId
                        method := "GET"

                        type VMStatusReqInfo struct {
                                ConnectionName string
                        }
                        tempReq := VMStatusReqInfo{}
                        tempReq.ConnectionName = temp.ConnectionName
                        payload, _ := json.MarshalIndent(tempReq, "", "  ")
                        //fmt.Println("payload: " + string(payload)) // for debug

                        client := &amp;http.Client{
                                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                        return http.ErrUseLastResponse
                                }</span>,
                        }

                        // Retry to get right VM status from cb-spider. Sometimes cb-spider returns not approriate status.
                        <span class="cov0" title="0">retrycheck := 2
                        for i := 0; i &lt; retrycheck; i++ </span><span class="cov0" title="0">{

                                req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))
                                errorInfo.Status = StatusFailed
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err)
                                        return errorInfo, err
                                }</span>
                                <span class="cov0" title="0">req.Header.Add("Content-Type", "application/json")

                                res, err := client.Do(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err)
                                        errorInfo.SystemMessage = err.Error()
                                        //return errorInfo, err
                                }</span> else<span class="cov0" title="0"> {
                                        body, err := ioutil.ReadAll(res.Body)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Println(err)
                                                errorInfo.SystemMessage = err.Error()
                                                return errorInfo, err
                                        }</span>
                                        <span class="cov0" title="0">err = json.Unmarshal(body, &amp;statusResponseTmp)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Println(err)
                                                errorInfo.SystemMessage = err.Error()
                                                return errorInfo, err
                                        }</span>
                                        <span class="cov0" title="0">defer res.Body.Close()</span>
                                }

                                <span class="cov0" title="0">if statusResponseTmp.Status != "" </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
                        }

                } else<span class="cov0" title="0"> {

                        // CCM API 
                        ccm := api.NewCloudResourceHandler()
                        err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error("ccm failed to set config : ", err)
                                return errorInfo, err
                        }</span>
                        <span class="cov0" title="0">err = ccm.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error("ccm api open failed : ", err)
                                return errorInfo, err
                        }</span>
                        <span class="cov0" title="0">defer ccm.Close()

                        // Retry to get right VM status from cb-spider. Sometimes cb-spider returns not approriate status.
                        retrycheck := 2
                        for i := 0; i &lt; retrycheck; i++ </span><span class="cov0" title="0">{
                                result, err := ccm.GetVMStatusByParam(temp.ConnectionName, cspVmId)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        errorInfo.SystemMessage = err.Error()
                                        //return errorInfo, err
                                }</span> else<span class="cov0" title="0"> {
                                        err = json.Unmarshal([]byte(result), &amp;statusResponseTmp)
                                        if err != nil </span><span class="cov0" title="0">{
                                                common.CBLog.Error(err)
                                                errorInfo.SystemMessage = err.Error()
                                                return errorInfo, err
                                        }</span>
                                }

                                <span class="cov0" title="0">if statusResponseTmp.Status != "" </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
                        }
                }

        } else<span class="cov0" title="0"> {
                statusResponseTmp.Status = ""
        }</span>

        <span class="cov0" title="0">nativeStatus := statusResponseTmp.Status
        // Temporal CODE. This should be changed after CB-Spider fixes status types and strings/
        if nativeStatus == "Creating" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusCreating
        }</span> else<span class="cov0" title="0"> if nativeStatus == "Running" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusRunning
        }</span> else<span class="cov0" title="0"> if nativeStatus == "Suspending" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusSuspending
        }</span> else<span class="cov0" title="0"> if nativeStatus == "Suspended" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusSuspended
        }</span> else<span class="cov0" title="0"> if nativeStatus == "Resuming" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusResuming
        }</span> else<span class="cov0" title="0"> if nativeStatus == "Rebooting" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusRebooting
        }</span> else<span class="cov0" title="0"> if nativeStatus == "Terminating" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusTerminating
        }</span> else<span class="cov0" title="0"> if nativeStatus == "Terminated" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusTerminated
        }</span> else<span class="cov0" title="0"> {
                statusResponseTmp.Status = StatusUndefined
        }</span>
        // End of Temporal CODE.
        <span class="cov0" title="0">temp, err = GetVmObject(nsId, mcisId, vmId)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                fmt.Println("CBStoreGetErr. keyValue == nil || err != nil", err)
                fmt.Println(err)
                return errorInfo, err
        }</span>
        <span class="cov0" title="0">vmStatusTmp := TbVmStatusInfo{}
        vmStatusTmp.Id = temp.Id
        vmStatusTmp.Name = temp.Name
        vmStatusTmp.CspVmId = temp.CspViewVmDetail.IId.NameId

        vmStatusTmp.PrivateIp = temp.PrivateIP
        vmStatusTmp.NativeStatus = nativeStatus
        vmStatusTmp.TargetAction = temp.TargetAction
        vmStatusTmp.TargetStatus = temp.TargetStatus
        vmStatusTmp.Location = temp.Location
        vmStatusTmp.MonAgentStatus = temp.MonAgentStatus
        vmStatusTmp.CreatedTime = temp.CreatedTime
        vmStatusTmp.SystemMessage = temp.SystemMessage

        // fmt.Println("[VM Native Status]" + temp.Id + ":" + nativeStatus)

        //Correct undefined status using TargetAction
        if vmStatusTmp.TargetAction == ActionCreate </span><span class="cov0" title="0">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusCreating
                }</span>
                <span class="cov0" title="0">if temp.Status == StatusFailed </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusFailed
                }</span>
        }
        <span class="cov0" title="0">if vmStatusTmp.TargetAction == ActionTerminate </span><span class="cov0" title="0">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusTerminated
                }</span>
                <span class="cov0" title="0">if statusResponseTmp.Status == StatusSuspending </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusTerminated
                }</span>
        }
        <span class="cov0" title="0">if vmStatusTmp.TargetAction == ActionResume </span><span class="cov0" title="0">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusResuming
                }</span>
                <span class="cov0" title="0">if statusResponseTmp.Status == StatusCreating </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusResuming
                }</span>
        }
        // for action reboot, some csp's native status are suspending, suspended, creating, resuming
        <span class="cov0" title="0">if vmStatusTmp.TargetAction == ActionReboot </span><span class="cov0" title="0">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusRebooting
                }</span>
                <span class="cov0" title="0">if statusResponseTmp.Status == StatusSuspending || statusResponseTmp.Status == StatusSuspended || statusResponseTmp.Status == StatusCreating || statusResponseTmp.Status == StatusResuming </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusRebooting
                }</span>
        }

        <span class="cov0" title="0">if vmStatusTmp.Status == StatusTerminated </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusTerminated
        }</span>

        <span class="cov0" title="0">vmStatusTmp.Status = statusResponseTmp.Status

        // TODO: Alibaba Undefined status error is not resolved yet.
        // (After Terminate action. "status": "Undefined", "targetStatus": "None", "targetAction": "None")

        //if TargetStatus == CurrentStatus, record to finialize the control operation
        if vmStatusTmp.TargetStatus == vmStatusTmp.Status </span><span class="cov0" title="0">{
                if vmStatusTmp.TargetStatus != StatusTerminated </span><span class="cov0" title="0">{
                        vmStatusTmp.SystemMessage = vmStatusTmp.TargetStatus + "==" + vmStatusTmp.Status
                        vmStatusTmp.TargetStatus = StatusComplete
                        vmStatusTmp.TargetAction = ActionComplete

                        //Get current public IP when status has been changed.
                        //UpdateVmPublicIp(nsId, mcisId, temp)
                        vmInfoTmp, err := GetVmCurrentPublicIp(nsId, mcisId, temp.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                errorInfo.SystemMessage = err.Error()
                                return errorInfo, err
                        }</span>
                        <span class="cov0" title="0">temp.PublicIP = vmInfoTmp.PublicIp
                        temp.SSHPort = vmInfoTmp.SSHPort</span>

                } else<span class="cov0" title="0"> {
                        // Don't init TargetStatus if the TargetStatus is StatusTerminated. It is to finalize VM lifecycle if StatusTerminated.
                        vmStatusTmp.TargetStatus = StatusTerminated
                        vmStatusTmp.TargetAction = ActionTerminate
                        vmStatusTmp.Status = StatusTerminated
                        vmStatusTmp.SystemMessage = "This VM has been terminated. No action is acceptable except deletion"
                }</span>
        }

        <span class="cov0" title="0">vmStatusTmp.PublicIp = temp.PublicIP
        vmStatusTmp.SSHPort = temp.SSHPort

        // Apply current status to vmInfo
        temp.Status = vmStatusTmp.Status
        temp.SystemMessage = vmStatusTmp.SystemMessage
        temp.TargetAction = vmStatusTmp.TargetAction
        temp.TargetStatus = vmStatusTmp.TargetStatus

        if cspVmId != "" </span><span class="cov0" title="0">{
                // don't update VM info, if cspVmId is empty
                UpdateVmInfo(nsId, mcisId, temp)
        }</span>

        <span class="cov0" title="0">return vmStatusTmp, nil</span>
}

func UpdateVmPublicIp(nsId string, mcisId string, vmInfoData TbVmInfo) error <span class="cov0" title="0">{

        vmInfoTmp, err := GetVmCurrentPublicIp(nsId, mcisId, vmInfoData.Id)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">if vmInfoData.PublicIP != vmInfoTmp.PublicIp || vmInfoData.SSHPort != vmInfoTmp.SSHPort </span><span class="cov0" title="0">{
                vmInfoData.PublicIP = vmInfoTmp.PublicIp
                vmInfoData.SSHPort = vmInfoTmp.SSHPort
                UpdateVmInfo(nsId, mcisId, vmInfoData)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetVmCurrentPublicIp(nsId string, mcisId string, vmId string) (TbVmStatusInfo, error) <span class="cov0" title="0">{

        fmt.Println("[GetVmStatus]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        errorInfo := TbVmStatusInfo{}
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil || keyValue == nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return errorInfo, err
        }</span>

        <span class="cov0" title="0">temp := TbVmInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
        }</span>
        <span class="cov0" title="0">fmt.Println("\n[Calling SPIDER]START")
        fmt.Println("CspVmId: " + temp.CspViewVmDetail.IId.NameId)

        cspVmId := temp.CspViewVmDetail.IId.NameId

        type statusResponse struct {
                Status         string
                PublicIP       string
                SSHAccessPoint string
        }
        var statusResponseTmp statusResponse

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov0" title="0">{

                url := common.SPIDER_REST_URL + "/vm/" + cspVmId
                method := "GET"

                type VMStatusReqInfo struct {
                        ConnectionName string
                }
                tempReq := VMStatusReqInfo{}
                tempReq.ConnectionName = temp.ConnectionName
                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                //fmt.Println("payload: " + string(payload)) // for debug

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>,
                }
                <span class="cov0" title="0">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                errorInfo.Status = StatusFailed

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return errorInfo, err
                }</span>
                <span class="cov0" title="0">req.Header.Add("Content-Type", "application/json")

                res, err := client.Do(req)
                //fmt.Println("Called CB-Spider API.")

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return errorInfo, err
                }</span>

                <span class="cov0" title="0">defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)

                statusResponseTmp = statusResponse{}

                err2 := json.Unmarshal(body, &amp;statusResponseTmp)
                if err2 != nil </span><span class="cov0" title="0">{
                        fmt.Println(err2)
                        return errorInfo, err2
                }</span>

        } else<span class="cov0" title="0"> {

                // CCM API 
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return errorInfo, err
                }</span>
                <span class="cov0" title="0">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return errorInfo, err
                }</span>
                <span class="cov0" title="0">defer ccm.Close()

                result, err := ccm.GetVMByParam(temp.ConnectionName, cspVmId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return errorInfo, err
                }</span>

                <span class="cov0" title="0">statusResponseTmp = statusResponse{}
                err2 := json.Unmarshal([]byte(result), &amp;statusResponseTmp)
                if err2 != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err2)
                        return errorInfo, err2
                }</span>

        }

        //common.PrintJsonPretty(statusResponseTmp)
        <span class="cov0" title="0">fmt.Println(statusResponseTmp)
        //fmt.Println("[Calling SPIDER]END\n")

        vmStatusTmp := TbVmStatusInfo{}
        vmStatusTmp.PublicIp = statusResponseTmp.PublicIP
        vmStatusTmp.SSHPort, _ = TrimIP(statusResponseTmp.SSHAccessPoint)

        return vmStatusTmp, nil</span>

}

func GetVmSshKey(nsId string, mcisId string, vmId string) (string, string, string) <span class="cov0" title="0">{

        var content struct {
                SshKeyId string `json:"sshKeyId"`
        }

        fmt.Println("[GetVmSshKey]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        //fmt.Println("===============================================")

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        fmt.Printf("%+v\n", content.SshKeyId)

        sshKey := common.GenResourceKey(nsId, common.StrSSHKey, content.SshKeyId)
        keyValue, _ = common.CBStore.Get(sshKey)
        var keyContent struct {
                Username         string `json:"username"`
                VerifiedUsername string `json:"verifiedUsername"`
                PrivateKey       string `json:"privateKey"`
        }
        json.Unmarshal([]byte(keyValue.Value), &amp;keyContent)

        return keyContent.Username, keyContent.VerifiedUsername, keyContent.PrivateKey
}</span>

// func UpdateVmInfo(nsId string, mcisId string, vmInfoData TbVmInfo)
func UpdateVmSshKey(nsId string, mcisId string, vmId string, verifiedUserName string) error <span class="cov0" title="0">{

        var content struct {
                SshKeyId string `json:"sshKeyId"`
        }
        fmt.Println("[GetVmSshKey]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        keyValue, _ := common.CBStore.Get(key)
        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        sshKey := common.GenResourceKey(nsId, common.StrSSHKey, content.SshKeyId)
        keyValue, _ = common.CBStore.Get(sshKey)

        tmpSshKeyInfo := mcir.TbSshKeyInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;tmpSshKeyInfo)

        tmpSshKeyInfo.VerifiedUsername = verifiedUserName

        val, _ := json.Marshal(tmpSshKeyInfo)
        err := common.CBStore.Put(string(keyValue.Key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetVmIp(nsId string, mcisId string, vmId string) (string, string) <span class="cov0" title="0">{

        var content struct {
                PublicIP string `json:"publicIP"`
                SSHPort  string `json:"sshPort"`
        }

        fmt.Printf("[GetVmIp] " + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        //fmt.Println("===============================================")

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        fmt.Printf(" %+v\n", content.PublicIP)

        return content.PublicIP, content.SSHPort
}</span>

func GetVmSpecId(nsId string, mcisId string, vmId string) string <span class="cov0" title="0">{

        var content struct {
                SpecId string `json:"specId"`
        }

        fmt.Println("[getVmSpecID]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)

        keyValue, _ := common.CBStore.Get(key)

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        fmt.Printf("%+v\n", content.SpecId)

        return content.SpecId
}</span>

func GetVmListByLabel(nsId string, mcisId string, label string) ([]string, error) <span class="cov0" title="0">{

        fmt.Println("[GetVmListByLabel]" + mcisId + " by " + label)

        var vmListByLabel []string

        vmList, err := ListVmId(nsId, mcisId)
        fmt.Println(vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // delete vms info
        <span class="cov0" title="0">for _, v := range vmList </span><span class="cov0" title="0">{
                vmObj, vmErr := GetVmObject(nsId, mcisId, v)
                if vmErr != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, vmErr
                }</span>
                //fmt.Println("vmObj.Label: "+ vmObj.Label)
                <span class="cov0" title="0">if vmObj.Label == label </span><span class="cov0" title="0">{
                        fmt.Println("Found VM with " + vmObj.Label + ", VM ID: " + vmObj.Id)
                        vmListByLabel = append(vmListByLabel, vmObj.Id)
                }</span>
        }
        <span class="cov0" title="0">return vmListByLabel, nil</span>

}

func GetVmTemplate(nsId string, mcisId string, algo string) (TbVmInfo, error) <span class="cov0" title="0">{

        fmt.Println("[GetVmTemplate]" + mcisId + " by algo: " + algo)

        vmList, err := ListVmId(nsId, mcisId)
        //fmt.Println(vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbVmInfo{}, err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return TbVmInfo{}, nil
        }</span>

        <span class="cov0" title="0">rand.Seed(time.Now().UnixNano())
        index := rand.Intn(len(vmList))
        vmObj, vmErr := GetVmObject(nsId, mcisId, vmList[index])
        var vmTemplate TbVmInfo

        // only take template required to create VM
        vmTemplate.Name = vmObj.Name
        vmTemplate.ConnectionName = vmObj.ConnectionName
        vmTemplate.ImageId = vmObj.ImageId
        vmTemplate.SpecId = vmObj.SpecId
        vmTemplate.VNetId = vmObj.VNetId
        vmTemplate.SubnetId = vmObj.SubnetId
        vmTemplate.SecurityGroupIds = vmObj.SecurityGroupIds
        vmTemplate.SshKeyId = vmObj.SshKeyId
        vmTemplate.VmUserAccount = vmObj.VmUserAccount
        vmTemplate.VmUserPassword = vmObj.VmUserPassword

        if vmErr != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbVmInfo{}, vmErr
        }</span>

        <span class="cov0" title="0">return vmTemplate, nil</span>

}

// GetCloudLocation. (need error handling)
func GetCloudLocation(cloudType string, nativeRegion string) GeoLocation <span class="cov0" title="0">{

        location := GeoLocation{}

        if cloudType == "" || nativeRegion == "" </span><span class="cov0" title="0">{

                // need error handling instead of assigning default value
                location.CloudType = "ufc"
                location.NativeRegion = "ufc"
                location.BriefAddr = "South Korea (Seoul)"
                location.Latitude = "37.4767"
                location.Longitude = "126.8841"

                return location
        }</span>

        <span class="cov0" title="0">key := "/cloudtype/" + cloudType + "/region/" + nativeRegion

        fmt.Printf("[GetCloudLocation] KEY: %+v\n", key)

        keyValue, err := common.CBStore.Get(key)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return location
        }</span>

        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                file, fileErr := os.Open("../assets/cloudlocation.csv")
                defer file.Close()
                if fileErr != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(fileErr)
                        return location
                }</span>

                <span class="cov0" title="0">rdr := csv.NewReader(bufio.NewReader(file))
                rows, _ := rdr.ReadAll()
                for i, row := range rows </span><span class="cov0" title="0">{
                        keyLoc := "/cloudtype/" + rows[i][0] + "/region/" + rows[i][1]
                        location.CloudType = rows[i][0]
                        location.NativeRegion = rows[i][1]
                        location.BriefAddr = rows[i][2]
                        location.Latitude = rows[i][3]
                        location.Longitude = rows[i][4]
                        valLoc, _ := json.Marshal(location)
                        dbErr := common.CBStore.Put(string(keyLoc), string(valLoc))
                        if dbErr != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(dbErr)
                                return location
                        }</span>
                        <span class="cov0" title="0">for j := range row </span><span class="cov0" title="0">{
                                fmt.Printf("%s ", rows[i][j])
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                <span class="cov0" title="0">keyValue, err = common.CBStore.Get(key)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return location
                }</span>
        }

        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                fmt.Printf("[GetCloudLocation] %+v %+v\n", keyValue.Key, keyValue.Value)
                err = json.Unmarshal([]byte(keyValue.Value), &amp;location)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return location
                }</span>
        }

        <span class="cov0" title="0">return location</span>
}

/*
type vmOverview struct {
        Id          string      `json:"id"`
        Name        string      `json:"name"`
        ConnectionName string      `json:"connectionName"`
        Region      RegionInfo  `json:"region"` // AWS, ex) {us-east1, us-east1-c} or {ap-northeast-2}
        Location    GeoLocation `json:"location"`
        PublicIP    string      `json:"publicIP"`
        PublicDNS   string      `json:"publicDNS"`
        Status      string      `json:"status"`
}
*/

/* Use "SpiderVMInfo" (from Spider), instead of this.
type vmCspViewInfo struct {
        Name      string    // AWS,
        Id        string    // AWS,
        StartTime time.Time // Timezone: based on cloud-barista server location.

        Region           RegionInfo // AWS, ex) {us-east1, us-east1-c} or {ap-northeast-2}
        ImageId          string
        VMSpecId         string   // AWS, instance type or flavour, etc... ex) t2.micro or f1.micro
        VirtualNetworkId string   // AWS, ex) subnet-8c4a53e4
        SecurityGroupIds []string // AWS, ex) sg-0b7452563e1121bb6

        NetworkInterfaceId string // ex) eth0
        PublicIP           string // ex) AWS, 13.125.43.21
        PublicDNS          string // ex) AWS, ec2-13-125-43-0.ap-northeast-2.compute.amazonaws.com
        PrivateIP          string // ex) AWS, ip-172-31-4-60.ap-northeast-2.compute.internal
        PrivateDNS         string // ex) AWS, 172.31.4.60

        KeyPairName  string // ex) AWS, powerkimKeyPair
        VMUserId     string // ex) user1
        VMUserPasswd string

        VMBootDisk  string // ex) /dev/sda1
        VMBlockDisk string // ex)

        KeyValueList []common.KeyValue
}
*/
</pre>
		
		<pre class="file" id="file25" style="display: none">package mcis

import (

        //"encoding/json"

        "time"

        "github.com/tidwall/gjson"

        "fmt"
        "io/ioutil"

        //"log"

        //"strings"
        "strconv"

        "bytes"
        "mime/multipart"

        // REST API (echo)
        "net/http"

        "sync"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

const monMetricAll string = "all"
const monMetricCpu string = "cpu"
const monMetricCpufreq string = "cpufreq"
const monMetricMem string = "mem"
const monMetricNet string = "net"
const monMetricSwap string = "swap"
const monMetricDisk string = "disk"
const monMetricDiskio string = "diskio"

// MonAgentInstallReq struct
type MonAgentInstallReq struct {
        NsId     string `json:"nsId,omitempty"`
        McisId   string `json:"mcisId,omitempty"`
        VmId     string `json:"vmId,omitempty"`
        PublicIp string `json:"publicIp,omitempty"`
        Port     string `json:"port,omitempty"`
        UserName string `json:"userName,omitempty"`
        SshKey   string `json:"sshKey,omitempty"`
        Csp_type string `json:"cspType,omitempty"`
}

/*
type DfTelegrafMetric struct {
        Name      string                 `json:"name"`
        Tags      map[string]interface{} `json:"tags"`
        Fields    map[string]interface{} `json:"fields"`
        Timestamp int64                  `json:"timestamp"`
        TagInfo   map[string]interface{} `json:"tagInfo"`
}
*/

// MonResultSimple struct is for containing vm monitoring results
type MonResultSimple struct {
        Metric string `json:"metric"`
        VmId   string `json:"vmId"`
        Value  string `json:"value"`
        Err    string `json:"err"`
}

// MonResultSimpleResponse struct is for containing Mcis monitoring results
type MonResultSimpleResponse struct {
        NsId           string            `json:"nsId"`
        McisId         string            `json:"mcisId"`
        McisMonitoring []MonResultSimple `json:"mcisMonitoring"`
}

// Module for checking CB-Dragonfly endpoint (call get config)
func CheckDragonflyEndpoint() error <span class="cov0" title="0">{
        cmd := "/config"

        url := common.DRAGONFLY_REST_URL + cmd
        method := "GET"

        client := &amp;http.Client{}
        req, err := http.NewRequest(method, url, nil)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov0" title="0">res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        body, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println(string(body))
        return nil</span>
}

func CallMonitoringAsync(wg *sync.WaitGroup, nsID string, mcisID string, vmID string, givenUserName string, method string, cmd string, returnResult *[]SshCmdResult) <span class="cov0" title="0">{

        defer wg.Done() //goroutin sync done

        vmIP, sshPort := GetVmIp(nsID, mcisID, vmID)
        userName, privateKey, err := VerifySshUserName(nsID, mcisID, vmID, vmIP, sshPort, givenUserName)
        errStr := ""
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>
        <span class="cov0" title="0">fmt.Println("[CallMonitoringAsync] " + mcisID + "/" + vmID + "(" + vmIP + ")" + "with userName:" + userName)

        // set vm MonAgentStatus = "installing" (to avoid duplicated requests)
        vmInfoTmp, _ := GetVmObject(nsID, mcisID, vmID)
        vmInfoTmp.MonAgentStatus = "installing"
        UpdateVmInfo(nsID, mcisID, vmInfoTmp)

        url := common.DRAGONFLY_REST_URL + cmd
        fmt.Println("\n[Calling DRAGONFLY] START")
        fmt.Println("VM:" + nsID + "_" + mcisID + "_" + vmID + ", URL:" + url + ", userName:" + userName + ", cspType:" + vmInfoTmp.Location.CloudType)

        tempReq := MonAgentInstallReq{
                NsId:     nsID,
                McisId:   mcisID,
                VmId:     vmID,
                PublicIp: vmIP,
                Port:     sshPort,
                UserName: userName,
                SshKey:   privateKey,
        }
        if tempReq.SshKey == "" </span><span class="cov0" title="0">{
                fmt.Printf("\n[Request body to CB-DRAGONFLY]A problem detected.SshKey is empty.\n")
                common.PrintJsonPretty(tempReq)
        }</span>

        <span class="cov0" title="0">payload := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(payload)
        _ = writer.WriteField("ns_id", nsID)
        _ = writer.WriteField("mcis_id", mcisID)
        _ = writer.WriteField("vm_id", vmID)
        _ = writer.WriteField("public_ip", vmIP)
        _ = writer.WriteField("port", sshPort)
        _ = writer.WriteField("user_name", userName)
        _ = writer.WriteField("ssh_key", privateKey)
        _ = writer.WriteField("cspType", vmInfoTmp.Location.CloudType)
        err = writer.Close()

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>

        <span class="cov0" title="0">responseLimit := 8
        client := &amp;http.Client{
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse
                }</span>,
                Timeout: time.Duration(responseLimit) * time.Minute,
        }
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, payload)
        req.Header.Set("Content-Type", writer.FormDataContentType())

        res, err := client.Do(req)

        result := ""

        fmt.Println("Called CB-DRAGONFLY API")
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch </span>{
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                        err1 := fmt.Errorf("HTTP Status: not in 200-399")
                        common.CBLog.Error(err1)
                        errStr = err1.Error()</span>
                }

                <span class="cov0" title="0">defer res.Body.Close()
                body, err2 := ioutil.ReadAll(res.Body)
                if err2 != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err2)
                        errStr = err2.Error()
                }</span>

                <span class="cov0" title="0">result = string(body)</span>
        }

        //wg.Done() //goroutin sync done

        //vmInfoTmp, _ := GetVmObject(nsID, mcisID, vmID)

        <span class="cov0" title="0">sshResultTmp := SshCmdResult{}
        sshResultTmp.McisId = mcisID
        sshResultTmp.VmId = vmID
        sshResultTmp.VmIp = vmIP

        if err != nil </span><span class="cov0" title="0">{
                sshResultTmp.Result = errStr
                sshResultTmp.Err = err
                *returnResult = append(*returnResult, sshResultTmp)
                vmInfoTmp.MonAgentStatus = "failed"
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("result " + result)
                sshResultTmp.Result = result
                sshResultTmp.Err = nil
                *returnResult = append(*returnResult, sshResultTmp)
                vmInfoTmp.MonAgentStatus = "installed"
        }</span>

        <span class="cov0" title="0">UpdateVmInfo(nsID, mcisID, vmInfoTmp)</span>

}

func InstallMonitorAgentToMcis(nsId string, mcisId string, req *McisCmdReq) (AgentInstallContentWrapper, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">content := AgentInstallContentWrapper{}

        //install script
        cmd := "/agent"

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Install agent for each VM]")

        //goroutin sync wg
        var wg sync.WaitGroup

        var resultArray []SshCmdResult

        method := "POST"

        for _, v := range vmList </span><span class="cov0" title="0">{
                vmObjTmp, _ := GetVmObject(nsId, mcisId, v)
                fmt.Println("MonAgentStatus : " + vmObjTmp.MonAgentStatus)

                // Request agent installation (skip if in installing or installed status)
                if vmObjTmp.MonAgentStatus != "installed" &amp;&amp; vmObjTmp.MonAgentStatus != "installing" </span><span class="cov0" title="0">{

                        // Avoid RunSSH to not ready VM
                        if err == nil </span><span class="cov0" title="0">{
                                wg.Add(1)
                                go CallMonitoringAsync(&amp;wg, nsId, mcisId, v, req.UserName, method, cmd, &amp;resultArray)
                        }</span> else<span class="cov0" title="0"> {
                                common.CBLog.Error(err)
                        }</span>

                }
        }
        <span class="cov0" title="0">wg.Wait() //goroutin sync wg

        for _, v := range resultArray </span><span class="cov0" title="0">{

                resultTmp := AgentInstallContent{}
                resultTmp.McisId = mcisId
                resultTmp.VmId = v.VmId
                resultTmp.VmIp = v.VmIp
                resultTmp.Result = v.Result
                content.Result_array = append(content.Result_array, resultTmp)
                //fmt.Println("result from goroutin " + v)
        }</span>

        //fmt.Printf("%+v\n", content)
        <span class="cov0" title="0">common.PrintJsonPretty(content)

        return content, nil</span>

}

// GetMonitoringData func retrieves monitoring data from cb-dragonfly
func GetMonitoringData(nsId string, mcisId string, metric string) (MonResultSimpleResponse, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := MonResultSimpleResponse{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := MonResultSimpleResponse{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := MonResultSimpleResponse{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">content := MonResultSimpleResponse{}

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                //common.CBLog.Error(err)
                return content, err
        }</span>

        //goroutin sync wg
        <span class="cov0" title="0">var wg sync.WaitGroup

        var resultArray []MonResultSimple

        method := "GET"

        for _, v := range vmList </span><span class="cov0" title="0">{
                wg.Add(1)

                vmId := v
                vmIp, _ := GetVmIp(nsId, mcisId, vmId)

                // DF: Get vm on-demand monitoring metric info
                // Path Para: /ns/:nsId/mcis/:mcisId/vm/:vmId/agent_ip/:agent_ip/metric/:metric_name/ondemand-monitoring-info
                cmd := "/ns/" + nsId + "/mcis/" + mcisId + "/vm/" + vmId + "/agent_ip/" + vmIp + "/metric/" + metric + "/ondemand-monitoring-info"
                //fmt.Println("[CMD] " + cmd)

                go CallGetMonitoringAsync(&amp;wg, nsId, mcisId, vmId, vmIp, method, metric, cmd, &amp;resultArray)

        }</span>
        <span class="cov0" title="0">wg.Wait() //goroutin sync wg

        content.NsId = nsId
        content.McisId = mcisId
        for _, v := range resultArray </span><span class="cov0" title="0">{
                content.McisMonitoring = append(content.McisMonitoring, v)
                //fmt.Println("result from goroutin " + v)
        }</span>

        <span class="cov0" title="0">fmt.Printf("%+v\n", content)
        //common.PrintJsonPretty(content)

        return content, nil</span>

}

func CallGetMonitoringAsync(wg *sync.WaitGroup, nsID string, mcisID string, vmID string, vmIP string, method string, metric string, cmd string, returnResult *[]MonResultSimple) <span class="cov0" title="0">{

        defer wg.Done() //goroutin sync done

        url := common.DRAGONFLY_REST_URL + cmd
        fmt.Print("[Call CB-DF] ")
        fmt.Println("URL: " + url)

        responseLimit := 8
        client := &amp;http.Client{
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse
                }</span>,
                Timeout: time.Duration(responseLimit) * time.Minute,
        }
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, nil)
        errStr := ""
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>

        <span class="cov0" title="0">res, err := client.Do(req)

        result := ""

        fmt.Print("[Call CB-DF Result (" + mcisID + "," + vmID + ")] ")
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span> else<span class="cov0" title="0"> {
                //fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch </span>{
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                        err1 := fmt.Errorf("HTTP Status: not in 200-399")
                        common.CBLog.Error(err1)
                        errStr = err1.Error()</span>
                }

                <span class="cov0" title="0">defer res.Body.Close()
                body, err2 := ioutil.ReadAll(res.Body)
                if err2 != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err2)
                        errStr = err2.Error()
                }</span>

                <span class="cov0" title="0">switch </span>{
                case metric == monMetricCpu:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.cpu_utilization")
                        result = value.String()</span>
                case metric == monMetricMem:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.mem_utilization")
                        result = value.String()</span>
                case metric == monMetricDisk:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.disk_utilization")
                        result = value.String()</span>
                case metric == monMetricNet:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.bytes_out")
                        result = value.String()</span>
                default:<span class="cov0" title="0">
                        result = string(body)</span>
                }

        }

        //wg.Done() //goroutin sync done

        <span class="cov0" title="0">ResultTmp := MonResultSimple{}
        ResultTmp.VmId = vmID
        ResultTmp.Metric = metric

        if err != nil </span><span class="cov0" title="0">{
                ResultTmp.Value = errStr
                ResultTmp.Err = err.Error()
                *returnResult = append(*returnResult, ResultTmp)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("result " + result)
                ResultTmp.Value = result
                *returnResult = append(*returnResult, ResultTmp)
        }</span>

}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mcis

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// Status for mcis automation
const (
        // AutoStatusReady is const for "Ready" status.
        AutoStatusReady string = "Ready"
        // AutoStatusChecking is const for "Checking" status.
        AutoStatusChecking string = "Checking"
        // AutoStatusDetected is const for "Detected" status.
        AutoStatusDetected string = "Detected"
        // AutoStatusOperating is const for "Operating" status.
        AutoStatusOperating string = "Operating"
        // AutoStatusStabilizing is const for "Stabilizing" status.
        AutoStatusStabilizing string = "Stabilizing"
        // AutoStatusTimeout is const for "Timeout" status.
        AutoStatusTimeout string = "Timeout"
        // AutoStatusError is const for "Failed" status.
        AutoStatusError string = "Failed"
        // AutoStatusSuspended is const for "Suspended" status.
        AutoStatusSuspended string = "Suspended"
)

// Action for mcis automation
const (
        // AutoActionScaleOut is const for "ScaleOut" action.
        AutoActionScaleOut string = "ScaleOut"
        // AutoActionScaleIn is const for "ScaleIn" action.
        AutoActionScaleIn string = "ScaleIn"
)

// AutoCondition is struct for MCIS auto-control condition.
type AutoCondition struct {
        Metric           string   `json:"metric"`
        Operator         string   `json:"operator"`         // &lt;, &lt;=, &gt;, &gt;=, ...
        Operand          string   `json:"operand"`          // 10, 70, 80, 98, ...
        EvaluationPeriod string   `json:"evaluationPeriod"` // evaluationPeriod
        EvaluationValue  []string `json:"evaluationValue"`
        //InitTime           string           `json:"initTime"`  // to check start of duration
        //Duration           string           `json:"duration"`  // duration for checking
}

// AutoAction is struct for MCIS auto-control action.
type AutoAction struct {
        ActionType    string     `json:"actionType"`
        Vm            TbVmInfo   `json:"vm"`
        PostCommand   McisCmdReq `json:"postCommand"`
        PlacementAlgo string     `json:"placementAlgo"`
}

// Policy is struct for MCIS auto-control Policy request that includes AutoCondition, AutoAction, Status.
type Policy struct {
        AutoCondition AutoCondition `json:"autoCondition"`
        AutoAction    AutoAction    `json:"autoAction"`
        Status        string        `json:"status"`
}

// McisPolicyInfo is struct for MCIS auto-control Policy object.
type McisPolicyInfo struct {
        Name   string   `json:"Name"` //MCIS Name (for request)
        Id     string   `json:"Id"`   //MCIS Id (generated ID by the Name)
        Policy []Policy `json:"policy"`

        ActionLog   string `json:"actionLog"`
        Description string `json:"description"`
}

// OrchestrationController is responsible for executing MCIS automation policy.
// OrchestrationController will be periodically involked by a time.NewTicker in main.go.
func OrchestrationController() <span class="cov0" title="0">{

        nsList, err := common.ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err = fmt.Errorf("an error occurred while getting namespaces' list: " + err.Error())
                return
        }</span>

        //fmt.Println("")
        <span class="cov0" title="0">for _, nsId := range nsList </span><span class="cov0" title="0">{

                mcisPolicyList := ListMcisPolicyId(nsId)

                for _, m := range mcisPolicyList </span><span class="cov0" title="0">{
                        fmt.Println("NS[" + nsId + "]" + "McisPolicy[" + m + "]")
                }</span>

                <span class="cov0" title="0">for _, v := range mcisPolicyList </span><span class="cov0" title="0">{

                        key := common.GenMcisPolicyKey(nsId, v, "")
                        //fmt.Println(key)
                        keyValue, _ := common.CBStore.Get(key)
                        if keyValue == nil </span><span class="cov0" title="0">{
                                //mapA := map[string]string{"message": "Cannot find " + key}
                                //return c.JSON(http.StatusOK, &amp;mapA)
                                fmt.Println("keyValue is nil")
                        }</span>
                        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                        <span class="cov0" title="0">mcisPolicyTmp := McisPolicyInfo{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;mcisPolicyTmp)

                        /* FYI
                        const AutoStatusReady string = "Ready"
                        const AutoStatusChecking string = "Checking"
                        const AutoStatusHappened string = "Happened"
                        const AutoStatusOperating string = "Operating"
                        const AutoStatusTimeout string = "Timeout"
                        const AutoStatusError string = "Error"
                        const AutoStatusSuspend string = "Suspend"
                        */

                        for policyIndex := range mcisPolicyTmp.Policy </span><span class="cov0" title="0">{
                                fmt.Println("\n[MCIS-Policy-StateMachine]")
                                common.PrintJsonPretty(mcisPolicyTmp.Policy[policyIndex])

                                switch </span>{
                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusReady:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + AutoStatusReady + "],[" + v + "]")
                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusChecking
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)

                                        fmt.Println("[Check MCIS Policy] " + mcisPolicyTmp.Id)
                                        check, _ := CheckMcis(nsId, mcisPolicyTmp.Id)
                                        fmt.Println("[Check existence of MCIS] " + mcisPolicyTmp.Id)
                                        //keyValueMcis, _ := common.CBStore.Get(common.GenMcisKey(nsId, mcisPolicyTmp.Id, ""))

                                        if !check </span><span class="cov0" title="0">{
                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                fmt.Println("[MCIS is not exist] " + mcisPolicyTmp.Id)
                                                break</span>
                                        } else<span class="cov0" title="0"> { // need to enhance : loop for each policies and realize metric

                                                //Checking (measuring)
                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusChecking
                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")

                                                fmt.Println("[MCIS is exist] " + mcisPolicyTmp.Id)
                                                content, err := GetMonitoringData(nsId, mcisPolicyTmp.Id, mcisPolicyTmp.Policy[policyIndex].AutoCondition.Metric)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        common.CBLog.Error(err)
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        break</span>
                                                }
                                                //common.PrintJsonPretty(content)

                                                //Statistic
                                                <span class="cov0" title="0">sumMcis := 0.0
                                                for _, monData := range content.McisMonitoring </span><span class="cov0" title="0">{
                                                        //fmt.Println("[monData.Value: ] " + monData.Value)
                                                        monDataValue, _ := strconv.ParseFloat(monData.Value, 64)
                                                        sumMcis += monDataValue
                                                }</span>
                                                <span class="cov0" title="0">averMcis := (sumMcis / float64(len(content.McisMonitoring)))
                                                fmt.Printf("[monData.Value] AverMcis: %f,  SumMcis: %f \n", averMcis, sumMcis)

                                                evaluationPeriod, _ := strconv.Atoi(mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationPeriod)
                                                evaluationValue := mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationValue
                                                evaluationValue = append([]string{fmt.Sprintf("%f", averMcis)}, evaluationValue...) // prepend current aver date
                                                mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationValue = evaluationValue

                                                sum := 0.0
                                                aver := -0.1
                                                // accumerate previous evaluation value
                                                fmt.Printf("[Evaluation History]\n")
                                                for evi, evv := range evaluationValue </span><span class="cov0" title="0">{
                                                        evvFloat, _ := strconv.ParseFloat(evv, 64)
                                                        sum += evvFloat
                                                        fmt.Printf("[%v] %f ", evi, evvFloat)
                                                        // break with outside evaluationValue
                                                        if evi &gt;= evaluationPeriod-1 </span><span class="cov0" title="0">{
                                                                break</span>
                                                        }
                                                }
                                                // average for evaluationPeriod (if data for the period is not enough, skip)
                                                <span class="cov0" title="0">if evaluationPeriod != 0 &amp;&amp; len(evaluationValue) &gt;= evaluationPeriod </span><span class="cov0" title="0">{
                                                        aver = sum / float64(evaluationPeriod)
                                                }</span>
                                                <span class="cov0" title="0">fmt.Printf("\n[Evaluation] Aver: %f,  Period: %v \n", aver, evaluationPeriod)

                                                //Detecting
                                                operator := mcisPolicyTmp.Policy[policyIndex].AutoCondition.Operator
                                                operand, _ := strconv.ParseFloat(mcisPolicyTmp.Policy[policyIndex].AutoCondition.Operand, 64)

                                                if evaluationPeriod == 0 </span><span class="cov0" title="0">{
                                                        fmt.Println("[Checking] Not available evaluationPeriod ")
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        break</span>
                                                }
                                                // not enough evaluationPeriod
                                                <span class="cov0" title="0">if aver == -0.1 </span><span class="cov0" title="0">{
                                                        fmt.Println("[Checking] Not enough evaluationPeriod ")
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">switch </span>{
                                                case operator == "&gt;=":<span class="cov0" title="0">
                                                        if aver &gt;= operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &gt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected
                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &gt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                case operator == "&gt;":<span class="cov0" title="0">
                                                        if aver &gt; operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &gt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &gt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                case operator == "&lt;=":<span class="cov0" title="0">
                                                        if aver &lt;= operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &lt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &lt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                case operator == "&lt;":<span class="cov0" title="0">
                                                        if aver &lt; operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &lt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &lt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                default:<span class="cov0" title="0">
                                                        fmt.Println("[Checking] Not available operator " + operator)
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError</span>
                                                }
                                        }
                                        <span class="cov0" title="0">UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusChecking:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>
                                        //mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusDetected:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")
                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusOperating
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")

                                        //Action
                                        /*
                                                // Actions for mcis automation
                                                const AutoActionScaleOut string = "ScaleOut"
                                                const AutoActionScaleIn string = "ScaleIn"
                                        */

                                        autoAction := mcisPolicyTmp.Policy[policyIndex].AutoAction
                                        fmt.Println("[autoAction] " + autoAction.ActionType)

                                        switch </span>{
                                        case autoAction.ActionType == AutoActionScaleOut:<span class="cov0" title="0">

                                                autoAction.Vm.Label = labelAutoGen
                                                // append UUID to given vm name to avoid duplicated vm ID.
                                                autoAction.Vm.Name = autoAction.Vm.Name + "-" + common.GenUuid()
                                                //vmReqTmp := autoAction.Vm

                                                if autoAction.PlacementAlgo == "random" </span><span class="cov0" title="0">{
                                                        fmt.Println("[autoAction.PlacementAlgo] " + autoAction.PlacementAlgo)
                                                        var vmTmpErr error
                                                        autoAction.Vm, vmTmpErr = GetVmTemplate(nsId, mcisPolicyTmp.Id, autoAction.PlacementAlgo)
                                                        if vmTmpErr != nil </span><span class="cov0" title="0">{
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        }</span>
                                                        <span class="cov0" title="0">autoAction.Vm.Name = autoAction.Vm.Name + "-Random"
                                                        autoAction.Vm.Label = labelAutoGen</span>
                                                }

                                                <span class="cov0" title="0">common.PrintJsonPretty(autoAction.Vm)
                                                fmt.Println("[Action] " + autoAction.ActionType)

                                                // ScaleOut MCIS according to the VM requirement.
                                                fmt.Println("[Generating VM]")
                                                result, vmCreateErr := CorePostMcisVm(nsId, mcisPolicyTmp.Id, &amp;autoAction.Vm)
                                                if vmCreateErr != nil </span><span class="cov0" title="0">{
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                }</span>
                                                <span class="cov0" title="0">common.PrintJsonPretty(*result)

                                                nullMcisCmdReq := McisCmdReq{}
                                                if autoAction.PostCommand != nullMcisCmdReq </span><span class="cov0" title="0">{
                                                        fmt.Println("[Post Command to VM] " + autoAction.PostCommand.Command)
                                                        _, cmdErr := CorePostCmdMcisVm(nsId, mcisPolicyTmp.Id, autoAction.Vm.Name, &amp;autoAction.PostCommand)
                                                        if cmdErr != nil </span><span class="cov0" title="0">{
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        }</span>
                                                }

                                        case autoAction.ActionType == AutoActionScaleIn:<span class="cov0" title="0">
                                                fmt.Println("[Action] " + autoAction.ActionType)

                                                // ScaleIn MCIS.
                                                fmt.Println("[Removing VM]")
                                                vmList, vmListErr := GetVmListByLabel(nsId, mcisPolicyTmp.Id, labelAutoGen)
                                                if vmListErr != nil </span><span class="cov0" title="0">{
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                }</span>
                                                <span class="cov0" title="0">if len(vmList) != 0 </span><span class="cov0" title="0">{
                                                        removeTargetVm := vmList[len(vmList)-1]
                                                        fmt.Println("[Removing VM ID] " + removeTargetVm)
                                                        delVmErr := DelMcisVm(nsId, mcisPolicyTmp.Id, removeTargetVm, "")
                                                        if delVmErr != nil </span><span class="cov0" title="0">{
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        }</span>
                                                }

                                        default:<span class="cov0" title="0"></span>
                                        }

                                        <span class="cov0" title="0">mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusStabilizing
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusStabilizing:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")

                                        //initialize Evaluation history so that controller does not act too early.
                                        //with this we can stablize MCIS by init previously measures.
                                        //Will invoke [Checking] Not enough evaluationPeriod
                                        mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationValue = nil

                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusOperating:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>
                                        //mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                        //UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusTimeout:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusError:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")
                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusSuspended:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                default:<span class="cov0" title="0"></span>
                                }
                        }

                }

        }

}

// UpdateMcisPolicyInfo updates McisPolicyInfo object in DB.
func UpdateMcisPolicyInfo(nsId string, mcisPolicyInfoData McisPolicyInfo) <span class="cov0" title="0">{
        key := common.GenMcisPolicyKey(nsId, mcisPolicyInfoData.Id, "")
        val, _ := json.Marshal(mcisPolicyInfoData)
        err := common.CBStore.Put(string(key), string(val))
        if err != nil &amp;&amp; !strings.Contains(err.Error(), common.CbStoreKeyNotFoundErrorString) </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
        }</span>
        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")
}

// CreateMcisPolicy create McisPolicyInfo object in DB according to user's requirements.
func CreateMcisPolicy(nsId string, mcisId string, u *McisPolicyInfo) (McisPolicyInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcisPolicy(nsId, mcisId)

        u.Name = mcisId
        u.Id = mcisId
        //u.Status = AutoStatusReady

        if check </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                err := fmt.Errorf("The MCIS Policy Obj " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov0" title="0">for policyIndex := range u.Policy </span><span class="cov0" title="0">{
                u.Policy[policyIndex].Status = AutoStatusReady
        }</span>

        <span class="cov0" title="0">content := *u

        // cb-store
        fmt.Println("=========================== PUT CreateMcisPolicy")
        Key := common.GenMcisPolicyKey(nsId, content.Id, "")
        Val, _ := json.Marshal(content)

        //fmt.Println("Key: ", Key)
        //fmt.Println("Val: ", Val)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov0" title="0">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;KEY&gt;\n" + keyValue.Key + "\n&lt;VAL&gt;\n" + keyValue.Value)
        fmt.Println("===========================")

        return content, nil</span>
}

// GetMcisPolicyObject returns McisPolicyInfo object.
func GetMcisPolicyObject(nsId string, mcisId string) (McisPolicyInfo, error) <span class="cov0" title="0">{
        fmt.Println("[GetMcisPolicyObject]" + mcisId)

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">key := common.GenMcisPolicyKey(nsId, mcisId, "")
        fmt.Println("Key: ", key)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return McisPolicyInfo{}, err
        }</span>
        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                return McisPolicyInfo{}, err
        }</span>

        <span class="cov0" title="0">fmt.Println("&lt;KEY&gt;\n" + keyValue.Key + "\n&lt;VAL&gt;\n" + keyValue.Value)

        mcisPolicyTmp := McisPolicyInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisPolicyTmp)
        return mcisPolicyTmp, nil</span>
}

// GetAllMcisPolicyObject returns all McisPolicyInfo objects.
func GetAllMcisPolicyObject(nsId string) ([]McisPolicyInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">Mcis := []McisPolicyInfo{}
        mcisList := ListMcisPolicyId(nsId)

        for _, v := range mcisList </span><span class="cov0" title="0">{

                key := common.GenMcisPolicyKey(nsId, v, "")
                keyValue, _ := common.CBStore.Get(key)
                if keyValue == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Cannot find " + key)
                }</span>
                <span class="cov0" title="0">mcisTmp := McisPolicyInfo{}
                json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
                Mcis = append(Mcis, mcisTmp)</span>
        }

        <span class="cov0" title="0">return Mcis, nil</span>
}

// ListMcisPolicyId returns a list of Ids for all McisPolicyInfo objects .
func ListMcisPolicyId(nsId string) []string <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil
        }</span>
        //fmt.Println("[Get MCIS Policy ID list]")
        <span class="cov0" title="0">key := "/ns/" + nsId + "/policy/mcis"
        keyValue, _ := common.CBStore.GetList(key, true)

        var mcisList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                if !strings.Contains(v.Key, "vm") </span><span class="cov0" title="0">{
                        mcisList = append(mcisList, strings.TrimPrefix(v.Key, "/ns/"+nsId+"/policy/mcis/"))
                }</span>
        }
        <span class="cov0" title="0">return mcisList</span>
}

// DelMcisPolicy deletes McisPolicyInfo object by mcisId.
func DelMcisPolicy(nsId string, mcisId string) error <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcisPolicy(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The mcis Policy" + mcisId + " does not exist.")
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Delete MCIS Policy] " + mcisId)

        key := common.GenMcisPolicyKey(nsId, mcisId, "")
        fmt.Println(key)

        // delete mcis Policy info
        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DelAllMcisPolicy deletes all McisPolicyInfo objects.
func DelAllMcisPolicy(nsId string) (string, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">mcisList := ListMcisPolicyId(nsId)
        if len(mcisList) == 0 </span><span class="cov0" title="0">{
                return "No MCIS Policy to delete", nil
        }</span>
        <span class="cov0" title="0">for _, v := range mcisList </span><span class="cov0" title="0">{
                err := DelMcisPolicy(nsId, v)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)

                        return "", fmt.Errorf("Failed to delete All MCIS Policies")
                }</span>
        }
        <span class="cov0" title="0">return "All MCIS Policies has been deleted", nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package mcis

import (
        "fmt"
        "math"
        "sort"
        "strconv"
        "strings"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// DeploymentPlan is struct for .
type DeploymentPlan struct {
        Filter   FilterInfo   `json:"filter"`
        Priority PriorityInfo `json:"priority"`
        Limit    string       `json:"limit" example:"5" enums:"1,2,...,30,..."`
}

// FilterInfo is struct for .
type FilterInfo struct {
        Policy []FilterCondition `json:"policy"`
}

// FilterCondition is struct for .
type FilterCondition struct {
        Metric    string      `json:"metric" example:"num_vCPU" enums:"num_vCPU,mem_GiB,Cost_per_hour"`
        Condition []Operation `json:"condition"`
}

// Operation is struct for .
type Operation struct {
        Operator string `json:"operator" example:"&gt;=" enums:"&gt;=,&lt;=,=="` // &gt;=, &lt;=, ==
        Operand  string `json:"operand" example:"4" enums:"4,8,.."`     // 10, 70, 80, 98, ...
}

// PriorityInfo is struct for .
type PriorityInfo struct {
        Policy []PriorityCondition `json:"policy"`
}

// FilterCondition is struct for .
type PriorityCondition struct {
        Metric    string            `json:"metric" example:"location" enums:"location,latency,cost"` // location,latency,cost
        Weight    string            `json:"weight" example:"0.3" enums:"0.1,0.2,..."`                // 0.3
        Parameter []ParameterKeyVal `json:"parameter"`
}

// Operation is struct for .
type ParameterKeyVal struct {
        Key string   `json:"key" example:"coordinateClose" enums:"coordinateClose,coordinateWithin,coordinateFair"` // coordinate
        Val []string `json:"val" example:"46.3772/2.3730"`                                                          // ["Latitude,Longitude","12,543",..,"31,433"]
}

///

//// Info manage for MCIS recommendation
func RecommendVm(nsId string, plan DeploymentPlan) ([]mcir.TbSpecInfo, error) <span class="cov0" title="0">{

        fmt.Println("RecommendVm")

        // Filtering first

        u := &amp;mcir.FilterSpecsByRangeRequest{}

        // veryLargeValue := float32(math.MaxFloat32)
        // verySmallValue := float32(0)

        // Filtering
        fmt.Println("[Filtering specs]")

        for _, v := range plan.Filter.Policy </span><span class="cov0" title="0">{
                metric := v.Metric
                conditions := v.Condition
                for _, condition := range conditions </span><span class="cov0" title="0">{

                        operand64, err := strconv.ParseFloat(condition.Operand, 32)
                        operand := float32(operand64)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return []mcir.TbSpecInfo{}, err
                        }</span>

                        <span class="cov0" title="0">switch condition.Operator </span>{
                        case "&lt;=":<span class="cov0" title="0">

                                switch metric </span>{
                                case "num_vCPU":<span class="cov0" title="0">
                                        u.Num_vCPU.Max = operand</span>
                                case "mem_GiB":<span class="cov0" title="0">
                                        u.Mem_GiB.Max = operand</span>
                                case "Cost_per_hour":<span class="cov0" title="0">
                                        u.Cost_per_hour.Max = operand</span>
                                default:<span class="cov0" title="0">
                                        fmt.Println("[Checking] Not available metric " + metric)</span>
                                }

                        case "&gt;=":<span class="cov0" title="0">

                                switch metric </span>{
                                case "num_vCPU":<span class="cov0" title="0">
                                        u.Num_vCPU.Min = operand</span>
                                case "mem_GiB":<span class="cov0" title="0">
                                        u.Mem_GiB.Min = operand</span>
                                case "Cost_per_hour":<span class="cov0" title="0">
                                        u.Cost_per_hour.Min = operand</span>
                                default:<span class="cov0" title="0">
                                        fmt.Println("[Checking] Not available metric " + metric)</span>
                                }

                        case "==":<span class="cov0" title="0">

                                switch metric </span>{
                                case "num_vCPU":<span class="cov0" title="0">
                                        u.Num_vCPU.Max = operand
                                        u.Num_vCPU.Min = operand</span>
                                case "mem_GiB":<span class="cov0" title="0">
                                        u.Mem_GiB.Max = operand
                                        u.Mem_GiB.Min = operand</span>
                                case "Cost_per_hour":<span class="cov0" title="0">
                                        u.Cost_per_hour.Max = operand
                                        u.Cost_per_hour.Min = operand</span>
                                default:<span class="cov0" title="0">
                                        fmt.Println("[Checking] Not available metric " + metric)</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">filteredSpecs, err := mcir.FilterSpecsByRange(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return []mcir.TbSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">if len(filteredSpecs) == 0 </span><span class="cov0" title="0">{
                return []mcir.TbSpecInfo{}, nil
        }</span>

        // Prioritizing
        <span class="cov0" title="0">fmt.Println("[Prioritizing specs]")
        prioritySpecs := []mcir.TbSpecInfo{}

        for _, v := range plan.Priority.Policy </span><span class="cov0" title="0">{
                metric := v.Metric

                switch metric </span>{
                case "location":<span class="cov0" title="0">
                        prioritySpecs, err = RecommendVmLocation(nsId, &amp;filteredSpecs, &amp;v.Parameter)</span>
                case "latency":<span class="cov0" title="0"></span>
                        //
                case "cost":<span class="cov0" title="0"></span>
                        //
                default:<span class="cov0" title="0"></span>
                        // fmt.Println("[Checking] Not available metric " + metric)
                }

        }

        // limit the number of items in result list
        <span class="cov0" title="0">result := []mcir.TbSpecInfo{}
        limitNum, err := strconv.Atoi(plan.Limit)
        if err != nil </span><span class="cov0" title="0">{
                limitNum = 65535
        }</span>
        <span class="cov0" title="0">for i, v := range prioritySpecs </span><span class="cov0" title="0">{
                result = append(result, v)
                if i == (limitNum - 1) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>

}

// RecommendVmLocation func prioritize specs based on given location
func RecommendVmLocation(nsId string, specList *[]mcir.TbSpecInfo, param *[]ParameterKeyVal) ([]mcir.TbSpecInfo, error) <span class="cov0" title="0">{

        result := []mcir.TbSpecInfo{}

        for _, v := range *param </span><span class="cov0" title="0">{

                switch v.Key </span>{
                case "coordinateClose":<span class="cov0" title="0">
                        //
                        coordinateStr := v.Val[0]

                        slice := strings.Split(coordinateStr, "/")
                        latitude, err := strconv.ParseFloat(slice[0], 32)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return []mcir.TbSpecInfo{}, err
                        }</span>
                        <span class="cov0" title="0">longitude, err := strconv.ParseFloat(slice[1], 32)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return []mcir.TbSpecInfo{}, err
                        }</span>

                        <span class="cov0" title="0">type distanceType struct {
                                distance      float64
                                index         int
                                priorityIndex int
                        }
                        distances := []distanceType{}

                        for i := range *specList </span><span class="cov0" title="0">{
                                distances = append(distances, distanceType{})
                                distances[i].distance, err = getDistance(latitude, longitude, (*specList)[i].ConnectionName)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return []mcir.TbSpecInfo{}, err
                                }</span>
                                <span class="cov0" title="0">distances[i].index = i</span>
                        }

                        <span class="cov0" title="0">sort.Slice(distances, func(i, j int) bool </span><span class="cov0" title="0">{
                                return distances[i].distance &lt; distances[j].distance
                        }</span>)
                        <span class="cov0" title="0">fmt.Printf("\n distances : %v \n", distances)

                        priorityCnt := 1
                        for i := range distances </span><span class="cov0" title="0">{

                                // priorityIndex++ if two distances are not equal (give the same priorityIndex if two variables are same)
                                if i != 0 </span><span class="cov0" title="0">{
                                        if distances[i].distance &gt; distances[i-1].distance </span><span class="cov0" title="0">{
                                                priorityCnt++
                                        }</span>
                                }
                                <span class="cov0" title="0">distances[i].priorityIndex = priorityCnt</span>

                        }

                        <span class="cov0" title="0">for i := range *specList </span><span class="cov0" title="0">{
                                // update OrderInFilteredResult based on calculated priorityIndex
                                (*specList)[distances[i].index].OrderInFilteredResult = uint16(distances[i].priorityIndex)
                                // assign nomalized priorityIdex value to EvaluationScore_01
                                (*specList)[distances[i].index].EvaluationScore_01 = float32(1 - (float32(distances[i].priorityIndex) / float32(len(*specList))))
                                (*specList)[distances[i].index].EvaluationScore_02 = float32(distances[i].distance)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("\n distances : %v \n", distances)</span>

                        //fmt.Printf("\n distances : %v \n", *specList)

                case "coordinateWithin":<span class="cov0" title="0"></span>
                        //
                case "coordinateFair":<span class="cov0" title="0"></span>
                        //
                default:<span class="cov0" title="0"></span>
                        // fmt.Println("[Checking] Not available metric " + metric)
                }

        }

        <span class="cov0" title="0">for i := range *specList </span><span class="cov0" title="0">{
                result = append(result, (*specList)[i])
                //result[i].OrderInFilteredResult = uint16(i + 1)
        }</span>

        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].OrderInFilteredResult &lt; result[j].OrderInFilteredResult
        }</span>)
        <span class="cov0" title="0">fmt.Printf("\n result : %v \n", result)

        // updatedSpec, err := mcir.UpdateSpec(nsId, *result)
        // content, err = mcir.SortSpecs(*specList, "mem_GiB", "descending")
        return result, nil</span>
}

// getDistance func get geographical distance between given coordinate and connectionConfig
func getDistance(latitude float64, longitude float64, ConnectionName string) (float64, error) <span class="cov0" title="0">{
        configTmp, _ := common.GetConnConfig(ConnectionName)
        regionTmp, _ := common.GetRegion(configTmp.RegionName)

        nativeRegion := ""
        for _, v := range regionTmp.KeyValueInfoList </span><span class="cov0" title="0">{
                if strings.ToLower(v.Key) == "region" || strings.ToLower(v.Key) == "location" </span><span class="cov0" title="0">{
                        nativeRegion = v.Value
                        break</span>
                }
        }
        <span class="cov0" title="0">Location := GetCloudLocation(strings.ToLower(configTmp.ProviderName), strings.ToLower(nativeRegion))

        cloudLatitude, err := strconv.ParseFloat(Location.Latitude, 32)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>
        <span class="cov0" title="0">cloudLongitude, err := strconv.ParseFloat(Location.Longitude, 32)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>

        // first := math.Pow(float64(cloudLatitude-latitude), 2)
        // second := math.Pow(float64(cloudLongitude-longitude), 2)
        // return math.Sqrt(first + second), nil
        <span class="cov0" title="0">return getHaversineDistance(cloudLatitude, cloudLongitude, latitude, longitude), nil</span>

}

// getHaversineDistance func return HaversineDistance
func getHaversineDistance(a1 float64, b1 float64, a2 float64, b2 float64) (distance float64) <span class="cov0" title="0">{
        deltaA := (a2 - a1) * (math.Pi / 180)
        deltaB := (b2 - b1) * (math.Pi / 180)

        a := math.Sin(deltaA/2)*math.Sin(deltaA/2) +
                math.Cos(a1*(math.Pi/180))*math.Cos(a2*(math.Pi/180))*math.Sin(deltaB/2)*math.Sin(deltaB/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        earthRadius := float64(6371)
        return (earthRadius * c)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package for VM's SSH and SCP of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.
// Imported from CB-Spider

package mcis

import (

        //"github.com/sirupsen/logrus"

        "fmt"
        "io"
        "net"
        "os"
        "strings"
        "time"

        "github.com/bramvdbogaerde/go-scp"
        "github.com/bramvdbogaerde/go-scp/auth"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "golang.org/x/crypto/ssh"
)

//var cblog *logrus.Logger

func init() {<span class="cov8" title="1">
        //cblog = config.Cblogger
}</span>

//====================================================================
type SSHInfo struct {
        UserName   string // ex) "root"
        PrivateKey []byte // ex)   []byte(`-----BEGIN RSA PRIVATE KEY-----
        //              MIIEoQIBAAKCAQEArVNOLwMIp5VmZ4VPZotcoCHdEzimKalAsz+ccLfvAA1Y2ELH
        //              ...`)
        ServerPort string // ex) "node12:22"
}

//====================================================================

func Connect(sshInfo SSHInfo) (scp.Client, error) <span class="cov0" title="0">{
        common.CBLog.Info("call Connect()")

        clientConfig, _ := getClientConfig(sshInfo.UserName, sshInfo.PrivateKey, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

//====================================================================
type SSHKeyPathInfo struct {
        UserName   string // ex) "root"
        KeyPath    string // ex) "/root/.ssh/id_rsa // You should use the full path.
        ServerPort string // ex) "node12:22"
}

//====================================================================

func ConnectKeyPath(sshKeyPathInfo SSHKeyPathInfo) (scp.Client, error) <span class="cov0" title="0">{
        common.CBLog.Info("call ConnectKeyPath()")

        clientConfig, _ := auth.PrivateKey(sshKeyPathInfo.UserName, sshKeyPathInfo.KeyPath, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshKeyPathInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

func getClientConfig(username string, privateKey []byte, keyCallBack ssh.HostKeyCallback) (ssh.ClientConfig, error) <span class="cov0" title="0">{

        signer, err := ssh.ParsePrivateKey(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return ssh.ClientConfig{}, err
        }</span>

        <span class="cov0" title="0">clientConfig := ssh.ClientConfig{
                User: username,
                Auth: []ssh.AuthMethod{
                        ssh.PublicKeys(signer),
                },
                HostKeyCallback: keyCallBack,
        }
        return clientConfig, nil</span>
}

func Close(client scp.Client) <span class="cov0" title="0">{
        common.CBLog.Info("call Close()")

        client.Close()
}</span>

func RunCommand(client scp.Client, cmd string) (string, error) <span class="cov0" title="0">{
        common.CBLog.Info("call RunCommand()")

        session := client.Session
        sshOut, err := session.StdoutPipe()
        session.Stderr = os.Stderr

        err = session.Run(cmd)
        //err = session.Start(cmd)

        return stdoutToString(sshOut), err
}</span>

func stdoutToString(sshOut io.Reader) string <span class="cov0" title="0">{
        buf := make([]byte, 1000)
        num, err := sshOut.Read(buf)
        outStr := ""
        if err == nil </span><span class="cov0" title="0">{
                outStr = string(buf[:num])
        }</span>
        <span class="cov0" title="0">for err == nil </span><span class="cov0" title="0">{
                num, err = sshOut.Read(buf)
                outStr += string(buf[:num])
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                        }</span>
                }

        }
        <span class="cov0" title="0">return strings.Trim(outStr, "\n")</span>
}

func Copy(client scp.Client, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        common.CBLog.Info("call Copy()")

        // Open a file
        file, _ := os.Open(sourcePath)
        defer file.Close()
        return client.CopyFile(file, remotePath, "0755")
}</span>

//=============== for One Call Service
func SSHRun(sshInfo SSHInfo, cmd string) (string, error) <span class="cov0" title="0">{
        common.CBLog.Info("call SSHRun()")

        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHRunByKeyPath(sshInfo SSHKeyPathInfo, cmd string) (string, error) <span class="cov0" title="0">{
        common.CBLog.Info("call SSHRunKeyPath()")

        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHCopy(sshInfo SSHInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        common.CBLog.Info("call SSHCopy()")

        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

func SSHCopyByKeyPath(sshInfo SSHKeyPathInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        common.CBLog.Info("call SSHCopyByKeyPath()")

        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

// CheckConnectivity func checks if given port is open and ready.
// For instance, ready for ssh port can be checkek.
func CheckConnectivity(host string, port string) error <span class="cov0" title="0">{

        deadline := 10
        timeout := time.Second * time.Duration(deadline)
        conn, err := net.DialTimeout("tcp", net.JoinHostPort(host, port), timeout)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("[CheckConnectivity]", host, ":", port, ". ERR:", err)
                return err
        }</span>
        <span class="cov0" title="0">if conn != nil </span><span class="cov0" title="0">{
                defer conn.Close()
                fmt.Println("[CheckConnectivity]", host, ":", port, ". Opened")
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package mcis

import (
        //"encoding/json"
        //uuid "github.com/google/uuid"
        "fmt"
        "strconv"
        "strings"
        "sync"

        //"fmt"
        //"net/http"
        //"io/ioutil"
        //"strconv"

        // CB-Store

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        //"github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"
        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcism"
        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"

        "github.com/go-resty/resty/v2"
)

// CB-Store
//var cblog *logrus.Logger
//var store icbs.Store

//var SPIDER_REST_URL string

func init() {<span class="cov8" title="1">
        //cblog = config.Cblogger
        //store = cbstore.GetStore()
        //SPIDER_REST_URL = os.Getenv("SPIDER_REST_URL")
}</span>

/*
func genUuid() string {
        return uuid.New().String()
}
*/

/*
type mcirIds struct {
        CspImageId           string
        CspImageName         string
        CspSshKeyName        string
        Name                 string // Spec
        CspVNetId            string
        CspVNetName          string
        CspSecurityGroupId   string
        CspSecurityGroupName string
        CspPublicIpId        string
        CspPublicIpName      string
        CspVNicId            string
        CspVNicName          string

        ConnectionName string
}
*/

func CheckMcis(nsId string, mcisId string) (bool, error) <span class="cov0" title="0">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov0" title="0"> if mcisId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; mcisId given is null.")
                return false, err
        }</span>

        <span class="cov0" title="0">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">fmt.Println("[Check mcis] " + mcisId)

        //key := "/ns/" + nsId + "/mcis/" + mcisId
        key := common.GenMcisKey(nsId, mcisId, "")
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        if keyValue != nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return false, nil</span>

}

func CheckVm(nsId string, mcisId string, vmId string) (bool, error) <span class="cov0" title="0">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckVm failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov0" title="0"> if mcisId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckVm failed; mcisId given is null.")
                return false, err
        }</span> else<span class="cov0" title="0"> if vmId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckVm failed; vmId given is null.")
                return false, err
        }</span>

        <span class="cov0" title="0">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">fmt.Println("[Check vm] " + mcisId + ", " + vmId)

        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        if keyValue != nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return false, nil</span>

}

func CheckMcisPolicy(nsId string, mcisId string) (bool, error) <span class="cov0" title="0">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov0" title="0"> if mcisId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; mcisId given is null.")
                return false, err
        }</span>

        <span class="cov0" title="0">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">fmt.Println("[Check McisPolicy] " + mcisId)

        //key := "/ns/" + nsId + "/mcis/" + mcisId
        key := common.GenMcisPolicyKey(nsId, mcisId, "")
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)

        if keyValue != nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return false, nil</span>

}

func RunSSH(vmIP string, sshPort string, userName string, privateKey string, cmd string) (*string, error) <span class="cov0" title="0">{

        // VM SSH   (  ,  , Private Key)
        serverEndpoint := fmt.Sprintf("%s:%s", vmIP, sshPort)
        sshInfo := SSHInfo{
                ServerPort: serverEndpoint,
                UserName:   userName,
                PrivateKey: []byte(privateKey),
        }

        // VM SSH  
        if result, err := SSHRun(sshInfo, cmd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov0" title="0"> {
                return &amp;result, nil
        }</span>
}

func RunSSHAsync(wg *sync.WaitGroup, vmID string, vmIP string, sshPort string, userName string, privateKey string, cmd string, returnResult *[]SshCmdResult) <span class="cov0" title="0">{

        defer wg.Done() //goroutin sync done

        // VM SSH   (  ,  , Private Key)
        serverEndpoint := fmt.Sprintf("%s:%s", vmIP, sshPort)
        sshInfo := SSHInfo{
                ServerPort: serverEndpoint,
                UserName:   userName,
                PrivateKey: []byte(privateKey),
        }

        // VM SSH  
        result, err := SSHRun(sshInfo, cmd)

        //wg.Done() //goroutin sync done

        sshResultTmp := SshCmdResult{}
        sshResultTmp.McisId = ""
        sshResultTmp.VmId = vmID
        sshResultTmp.VmIp = vmIP

        if err != nil </span><span class="cov0" title="0">{
                sshResultTmp.Result = err.Error()
                sshResultTmp.Err = err
                *returnResult = append(*returnResult, sshResultTmp)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("cmd result " + result)
                sshResultTmp.Result = result
                sshResultTmp.Err = nil
                *returnResult = append(*returnResult, sshResultTmp)
        }</span>

}

func TrimIP(sshAccessPoint string) (string, error) <span class="cov0" title="0">{
        splitted := strings.Split(sshAccessPoint, ":")
        if len(splitted) != 2 </span><span class="cov0" title="0">{
                err := fmt.Errorf("In TrimIP(), sshAccessPoint does not seem 8.8.8.8:22 form.")
                return strconv.Itoa(0), err
        }</span>
        <span class="cov0" title="0">port_string := splitted[1]
        port, err := strconv.Atoi(port_string)
        if err != nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("In TrimIP(), strconv.Atoi returned an error.")
                return strconv.Itoa(0), err
        }</span>
        <span class="cov0" title="0">if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov0" title="0">{ // valid port number
                return port_string, nil
        }</span> else<span class="cov0" title="0"> {
                err := fmt.Errorf("In TrimIP(), detected port number seems wrong: " + port_string)
                return strconv.Itoa(0), err
        }</span>
}

type SpiderNameIdSystemId struct {
        NameId   string
        SystemId string
}

type SpiderAllListWrapper struct {
        AllList SpiderAllList
}

type SpiderAllList struct {
        MappedList     []SpiderNameIdSystemId
        OnlySpiderList []SpiderNameIdSystemId
        OnlyCSPList    []SpiderNameIdSystemId
}

// Response struct for InspectResources
type TbInspectResourcesResponse struct {
        // ResourcesOnCsp       interface{} `json:"resourcesOnCsp"`
        // ResourcesOnSpider    interface{} `json:"resourcesOnSpider"`
        // ResourcesOnTumblebug interface{} `json:"resourcesOnTumblebug"`
        ResourcesOnCsp       []resourceOnCspOrSpider `json:"resourcesOnCsp"`
        ResourcesOnSpider    []resourceOnCspOrSpider `json:"resourcesOnSpider"`
        ResourcesOnTumblebug []resourceOnTumblebug   `json:"resourcesOnTumblebug"`
}

type resourceOnCspOrSpider struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
}

type resourceOnTumblebug struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
        NsId        string `json:"nsId"`
        McisId      string `json:"mcisId"`
        Type        string `json:"type"`
        ObjectKey   string `json:"objectKey"`
}

// InspectVMs returns the state list of TB VM objects of given connConfig
func InspectVMs(connConfig string) (interface{}, error) <span class="cov0" title="0">{

        nsList, err := common.ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err = fmt.Errorf("an error occurred while getting namespaces' list: " + err.Error())
                return nil, err
        }</span>
        // var TbResourceList []string
        <span class="cov0" title="0">var TbResourceList []resourceOnTumblebug
        for _, ns := range nsList </span><span class="cov0" title="0">{

                mcisListinNs, _ := ListMcisId(ns)
                if mcisListinNs == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, mcis := range mcisListinNs </span><span class="cov0" title="0">{
                        vmListInMcis, err := ListVmId(ns, mcis)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                err := fmt.Errorf("an error occurred while getting resource list")
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if vmListInMcis == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, vmId := range vmListInMcis </span><span class="cov0" title="0">{
                                vm, err := GetVmObject(ns, mcis, vmId)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        err := fmt.Errorf("an error occurred while getting resource list")
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">if vm.ConnectionName == connConfig </span><span class="cov0" title="0">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = vm.Id
                                        temp.CspNativeId = vm.CspViewVmDetail.IId.SystemId
                                        temp.NsId = ns
                                        temp.McisId = mcis
                                        temp.Type = "vm"
                                        temp.ObjectKey = common.GenMcisKey(ns, mcis, vm.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">client := resty.New().SetCloseConnection(true)
        client.SetAllowGetMethodPayload(true)

        // Create Req body
        type JsonTemplate struct {
                ConnectionName string
        }
        tempReq := JsonTemplate{}
        tempReq.ConnectionName = connConfig

        spiderRequestURL := common.SPIDER_REST_URL + "/allvm"

        resp, err := client.R().
                SetHeader("Content-Type", "application/json").
                SetBody(tempReq).
                SetResult(&amp;SpiderAllListWrapper{}). // or SetResult(AuthSuccess{}).
                //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                Get(spiderRequestURL)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
        switch </span>{
        case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                err := fmt.Errorf(string(resp.Body()))
                common.CBLog.Error(err)
                return nil, err</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">temp, _ := resp.Result().(*SpiderAllListWrapper) // type assertion

        result := TbInspectResourcesResponse{}

        /*
                // Implementation style 1
                if len(TbResourceList) &gt; 0 {
                        result.ResourcesOnTumblebug = TbResourceList
                } else {
                        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
                }
        */
        // Implementation style 2
        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
        result.ResourcesOnTumblebug = append(result.ResourcesOnTumblebug, TbResourceList...)

        // result.ResourcesOnCsp = append((*temp).AllList.MappedList, (*temp).AllList.OnlyCSPList...)
        // result.ResourcesOnSpider = append((*temp).AllList.MappedList, (*temp).AllList.OnlySpiderList...)
        result.ResourcesOnCsp = []resourceOnCspOrSpider{}
        result.ResourcesOnSpider = []resourceOnCspOrSpider{}

        for _, v := range (*temp).AllList.MappedList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov0" title="0">for _, v := range (*temp).AllList.OnlySpiderList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov0" title="0">for _, v := range (*temp).AllList.OnlyCSPList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
