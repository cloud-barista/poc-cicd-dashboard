
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/config.go (86.0%)</option>
				
				<option value="file1">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/connectinfo.go (46.2%)</option>
				
				<option value="file2">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/credential.go (46.2%)</option>
				
				<option value="file3">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/driver.go (46.2%)</option>
				
				<option value="file4">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/gclient.go (67.6%)</option>
				
				<option value="file5">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/image.go (73.5%)</option>
				
				<option value="file6">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/keypair.go (67.6%)</option>
				
				<option value="file7">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/mcis.go (71.7%)</option>
				
				<option value="file8">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/namespace.go (78.9%)</option>
				
				<option value="file9">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/network.go (76.5%)</option>
				
				<option value="file10">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/region.go (46.2%)</option>
				
				<option value="file11">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/root.go (100.0%)</option>
				
				<option value="file12">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/securitygroup.go (76.5%)</option>
				
				<option value="file13">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/spec.go (72.6%)</option>
				
				<option value="file14">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/tbutil.go (82.6%)</option>
				
				<option value="file15">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/version.go (66.7%)</option>
				
				<option value="file16">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/cmd/yamlproc.go (66.7%)</option>
				
				<option value="file17">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/proc/connectinfos.go (0.0%)</option>
				
				<option value="file18">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/proc/keypair.go (0.0%)</option>
				
				<option value="file19">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/proc/mcis.go (0.0%)</option>
				
				<option value="file20">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common/cbconnection.go (0.0%)</option>
				
				<option value="file21">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common/cbmessage.go (70.5%)</option>
				
				<option value="file22">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common/cbserver.go (34.8%)</option>
				
				<option value="file23">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common/grpcstatuserr.go (0.0%)</option>
				
				<option value="file24">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config/config.go (27.1%)</option>
				
				<option value="file25">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config/parser.go (37.5%)</option>
				
				<option value="file26">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/accesslog/client_interceptors.go (0.0%)</option>
				
				<option value="file27">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/accesslog/server_interceptors.go (55.0%)</option>
				
				<option value="file28">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/authjwt/auth.go (0.0%)</option>
				
				<option value="file29">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/authjwt/client_interceptors.go (0.0%)</option>
				
				<option value="file30">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/authjwt/server_interceptors.go (0.0%)</option>
				
				<option value="file31">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/jaegertracer/jaegertracer.go (0.0%)</option>
				
				<option value="file32">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger/logger.go (33.3%)</option>
				
				<option value="file33">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/common/config.go (77.1%)</option>
				
				<option value="file34">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/common/namespace.go (63.6%)</option>
				
				<option value="file35">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/common/utility.go (76.4%)</option>
				
				<option value="file36">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcir/common.go (75.0%)</option>
				
				<option value="file37">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcir/image.go (68.2%)</option>
				
				<option value="file38">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcir/securitygroup.go (75.0%)</option>
				
				<option value="file39">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcir/spec.go (64.3%)</option>
				
				<option value="file40">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcir/sshkey.go (75.0%)</option>
				
				<option value="file41">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcir/vnet.go (75.0%)</option>
				
				<option value="file42">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcirapi.go (76.9%)</option>
				
				<option value="file43">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcis/control.go (68.2%)</option>
				
				<option value="file44">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcis/monitor.go (75.0%)</option>
				
				<option value="file45">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcis/orchestration.go (75.0%)</option>
				
				<option value="file46">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcis/plan.go (0.0%)</option>
				
				<option value="file47">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcis/utility.go (75.0%)</option>
				
				<option value="file48">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcisapi.go (73.3%)</option>
				
				<option value="file49">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/nsapi.go (71.3%)</option>
				
				<option value="file50">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/tbutilapi.go (79.1%)</option>
				
				<option value="file51">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/common/config.go (82.4%)</option>
				
				<option value="file52">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/common/namespace.go (68.9%)</option>
				
				<option value="file53">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/common/utility.go (80.2%)</option>
				
				<option value="file54">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcir/common.go (81.6%)</option>
				
				<option value="file55">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcir/image.go (70.6%)</option>
				
				<option value="file56">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcir/securitygroup.go (82.3%)</option>
				
				<option value="file57">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcir/spec.go (65.6%)</option>
				
				<option value="file58">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcir/sshkey.go (82.3%)</option>
				
				<option value="file59">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcir/vnet.go (82.3%)</option>
				
				<option value="file60">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcis/control.go (71.2%)</option>
				
				<option value="file61">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcis/monitor.go (80.0%)</option>
				
				<option value="file62">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcis/orchestration.go (81.1%)</option>
				
				<option value="file63">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcis/plan.go (0.0%)</option>
				
				<option value="file64">github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/server/mcis/utility.go (85.7%)</option>
				
				<option value="file65">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/common/config.go (71.4%)</option>
				
				<option value="file66">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/common/namespace.go (60.3%)</option>
				
				<option value="file67">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/common/utility.go (71.1%)</option>
				
				<option value="file68">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/common.go (82.7%)</option>
				
				<option value="file69">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/image.go (57.3%)</option>
				
				<option value="file70">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/securitygroup.go (62.5%)</option>
				
				<option value="file71">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/spec.go (54.2%)</option>
				
				<option value="file72">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/sshkey.go (62.5%)</option>
				
				<option value="file73">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcir/vnet.go (62.5%)</option>
				
				<option value="file74">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/control.go (72.3%)</option>
				
				<option value="file75">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/monitor.go (90.5%)</option>
				
				<option value="file76">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/orchestration.go (83.3%)</option>
				
				<option value="file77">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/plan.go (0.0%)</option>
				
				<option value="file78">github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis/utility.go (81.0%)</option>
				
				<option value="file79">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/common.go (33.3%)</option>
				
				<option value="file80">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/config.go (58.4%)</option>
				
				<option value="file81">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/namespace.go (59.9%)</option>
				
				<option value="file82">github.com/cloud-barista/poc-cicd-tumblebug/src/core/common/utility.go (55.0%)</option>
				
				<option value="file83">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/common.go (63.3%)</option>
				
				<option value="file84">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/image.go (62.3%)</option>
				
				<option value="file85">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/securitygroup.go (67.4%)</option>
				
				<option value="file86">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/spec.go (47.8%)</option>
				
				<option value="file87">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/sshkey.go (65.9%)</option>
				
				<option value="file88">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir/vnet.go (68.2%)</option>
				
				<option value="file89">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/control.go (63.6%)</option>
				
				<option value="file90">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/monitor.go (29.1%)</option>
				
				<option value="file91">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/orchestration.go (28.2%)</option>
				
				<option value="file92">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/plan.go (0.0%)</option>
				
				<option value="file93">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/sshrun.go (0.0%)</option>
				
				<option value="file94">github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis/utility.go (63.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewConfigCmd : "cbadm config *" (for CB-Tumblebug)
func NewConfigCmd() *cobra.Command <span class="cov8" title="1">{

        configCmd := &amp;cobra.Command{
                Use:   "config",
                Short: "This is a manageable command for config",
                Long:  "This is a manageable command for config",
        }

        //  Adds the commands for application.
        configCmd.AddCommand(NewConfigCreateCmd())
        configCmd.AddCommand(NewConfigListCmd())
        configCmd.AddCommand(NewConfigGetCmd())
        configCmd.AddCommand(NewConfigInitCmd())
        configCmd.AddCommand(NewConfigInitAllCmd())

        return configCmd
}</span>

// NewConfigCreateCmd : "cbadm config create"
func NewConfigCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for config",
                Long:  "This is create command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewConfigListCmd : "cbadm config list"
func NewConfigListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for config",
                Long:  "This is list command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewConfigGetCmd : "cbadm config get"
func NewConfigGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for config",
                Long:  "This is get command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if configId == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--id parameter value : ", configId)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;configId, "id", "", "", "config id")

        return getCmd</span>
}

// NewConfigInitCmd : "cbadm config init"
func NewConfigInitCmd() *cobra.Command <span class="cov8" title="1">{

        initCmd := &amp;cobra.Command{
                Use:   "init",
                Short: "This is init command for config",
                Long:  "This is init command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if configId == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--id parameter value : ", configId)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">initCmd.PersistentFlags().StringVarP(&amp;configId, "id", "", "", "config id")

        return initCmd</span>
}

// NewConfigInitAllCmd : "cbadm config init-all"
func NewConfigInitAllCmd() *cobra.Command <span class="cov8" title="1">{

        initAllCmd := &amp;cobra.Command{
                Use:   "init-all",
                Short: "This is init all command for config",
                Long:  "This is init all command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{

                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return initAllCmd</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/cb-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewConnectInfosCmd : "cbadm connect-info *" (for CB-Spider)
func NewConnectInfosCmd() *cobra.Command <span class="cov8" title="1">{

        connectionCmd := &amp;cobra.Command{
                Use:   "connect-info",
                Short: "This is a manageable command for connection config",
                Long:  "This is a manageable command for connection config",
        }

        //  Adds the commands for application.
        connectionCmd.AddCommand(NewConnectInfosCreateCmd())
        connectionCmd.AddCommand(NewConnectInfosListCmd())
        connectionCmd.AddCommand(NewCConnectInfosGetCmd())
        connectionCmd.AddCommand(NewConnectInfosDeleteCmd())

        return connectionCmd
}</span>

// NewConnectInfosCreateCmd : "cbadm connect-info create"
func NewConnectInfosCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for connection config",
                Long:  "This is create command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewConnectInfosListCmd : "cbadm connect-info list"
func NewConnectInfosListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for connection config",
                Long:  "This is list command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewCConnectInfosGetCmd : "cbadm connect-info get"
func NewCConnectInfosGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for connection config",
                Long:  "This is get command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return getCmd</span>
}

// NewConnectInfosDeleteCmd : "cbadm connect-info delete"
func NewConnectInfosDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for connection config",
                Long:  "This is delete command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/cb-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCredentialCmd : "cbadm credential *" (for CB-Spider)
func NewCredentialCmd() *cobra.Command <span class="cov8" title="1">{

        credentialCmd := &amp;cobra.Command{
                Use:   "credential",
                Short: "This is a manageable command for credential",
                Long:  "This is a manageable command for credential",
        }

        //  Adds the commands for application.
        credentialCmd.AddCommand(NewCredentialCreateCmd())
        credentialCmd.AddCommand(NewCredentialListCmd())
        credentialCmd.AddCommand(NewCredentialGetCmd())
        credentialCmd.AddCommand(NewCredentialDeleteCmd())

        return credentialCmd
}</span>

// NewCredentialCreateCmd : "cbadm credential create"
func NewCredentialCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for credential",
                Long:  "This is create command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewCredentialListCmd : "cbadm credential list"
func NewCredentialListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for credential",
                Long:  "This is list command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewCredentialGetCmd : "cbadm credential get"
func NewCredentialGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for credential",
                Long:  "This is get command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return getCmd</span>
}

// NewCredentialDeleteCmd : "cbadm credential delete"
func NewCredentialDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for credential",
                Long:  "This is delete command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/cb-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewDriverCmd : "cbadm driver *" (for CB-Spider)
func NewDriverCmd() *cobra.Command <span class="cov8" title="1">{

        driverCmd := &amp;cobra.Command{
                Use:   "driver",
                Short: "This is a manageable command for cloud driver",
                Long:  "This is a manageable command for cloud driver",
        }

        //  Adds the commands for application.
        driverCmd.AddCommand(NewDriverCreateCmd())
        driverCmd.AddCommand(NewDriverListCmd())
        driverCmd.AddCommand(NewDriverGetCmd())
        driverCmd.AddCommand(NewDriverDeleteCmd())

        return driverCmd
}</span>

// NewDriverCreateCmd : "cbadm driver create"
func NewDriverCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for cloud driver",
                Long:  "This is create command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewDriverListCmd : "cbadm driver list"
func NewDriverListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud driver",
                Long:  "This is list command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewDriverGetCmd : "cbadm driver get"
func NewDriverGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for cloud driver",
                Long:  "This is get command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return getCmd</span>
}

// NewDriverDeleteCmd : "cbadm driver delete"
func NewDriverDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for cloud driver",
                Long:  "This is delete command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "io/ioutil"

        "github.com/spf13/cobra"

        sp_api "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/cbadm/proc"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        tb_api "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

func readInDataFromFile() <span class="cov8" title="1">{
        logger := logger.NewLogger()
        if inData == "" </span><span class="cov0" title="0">{
                if inFile != "" </span><span class="cov0" title="0">{
                        dat, err := ioutil.ReadFile(inFile)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to read file : ", inFile)
                                return
                        }</span>
                        <span class="cov0" title="0">inData = string(dat)</span>
                }
        }
}

// ===== [ Public Functions ] =====

// SetupAndRun : setup and run Cloud-Barista gRPC CLI
func SetupAndRun(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        var (
                result string
                err    error

                cim *sp_api.CIMApi

                ns     *tb_api.NSApi      = nil
                mcir   *tb_api.MCIRApi    = nil
                mcis   *tb_api.MCISApi    = nil
                tbutil *tb_api.UtilityApi = nil
        )

        // panic handling
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("tbctl is stopped : ", r)
                }</span>
        }()

        <span class="cov8" title="1">if cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" || cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connect-info" </span><span class="cov0" title="0">{
                // CIM API
                cim = sp_api.NewCloudInfoManager()
                err = cim.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov0" title="0">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("cim api open failed : ", err)
                        return
                }</span>
                <span class="cov0" title="0">defer cim.Close()</span>
        }

        <span class="cov8" title="1">if cmd.Parent().Name() == "namespace" </span><span class="cov8" title="1">{
                // NS API
                ns = tb_api.NewNSManager()
                err = ns.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = ns.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("namespace api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer ns.Close()</span>
        }

        <span class="cov8" title="1">if cmd.Parent().Name() == "image" || cmd.Parent().Name() == "network" || cmd.Parent().Name() == "securitygroup" || cmd.Parent().Name() == "keypair" || cmd.Parent().Name() == "spec" </span><span class="cov8" title="1">{
                // MCIR API
                mcir = tb_api.NewMCIRManager()
                err = mcir.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = mcir.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("namespace api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer mcir.Close()</span>
        }

        <span class="cov8" title="1">if cmd.Parent().Name() == "mcis" </span><span class="cov8" title="1">{
                // MCIS API
                mcis = tb_api.NewMCISManager()
                err = mcis.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = mcis.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("mcis api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer mcis.Close()</span>
        }

        <span class="cov8" title="1">if cmd.Parent().Name() == "util" || cmd.Parent().Name() == "config" </span><span class="cov8" title="1">{
                // Utility API
                tbutil = tb_api.NewUtilityManager()
                err = tbutil.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = tbutil.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("mcis api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer tbutil.Close()</span>
        }

        // Validate input parameters
        <span class="cov8" title="1">if outType != "json" &amp;&amp; outType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --output parameter : ", outType)
                return
        }</span>
        <span class="cov8" title="1">if inType != "json" &amp;&amp; inType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --input parameter : ", inType)
                return
        }</span>

        <span class="cov8" title="1">if cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" || cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connect-info" </span><span class="cov0" title="0">{
                cim.SetInType(inType)
                cim.SetOutType(outType)
        }</span>
        <span class="cov8" title="1">if cmd.Parent().Name() == "namespace" </span><span class="cov8" title="1">{
                ns.SetInType(inType)
                ns.SetOutType(outType)
        }</span>
        <span class="cov8" title="1">if cmd.Parent().Name() == "image" || cmd.Parent().Name() == "network" || cmd.Parent().Name() == "securitygroup" || cmd.Parent().Name() == "keypair" || cmd.Parent().Name() == "spec" </span><span class="cov8" title="1">{
                mcir.SetInType(inType)
                mcir.SetOutType(outType)
        }</span>
        <span class="cov8" title="1">if cmd.Parent().Name() == "mcis" </span><span class="cov8" title="1">{
                mcis.SetInType(inType)
                mcis.SetOutType(outType)
        }</span>
        <span class="cov8" title="1">if cmd.Parent().Name() == "util" || cmd.Parent().Name() == "config" </span><span class="cov8" title="1">{
                tbutil.SetInType(inType)
                tbutil.SetOutType(outType)
        }</span>

        <span class="cov8" title="1">logger.Debug("--input parameter value : ", inType)
        logger.Debug("--output parameter value : ", outType)

        result = ""
        err = nil

        switch cmd.Parent().Name() </span>{
        case "cbadm":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "apply":<span class="cov0" title="0">
                        fmt.Printf("yaml apply command is not implemented")</span>
                case "get":<span class="cov0" title="0">
                        fmt.Printf("yaml get command is not implemented")</span>
                case "list":<span class="cov0" title="0">
                        fmt.Printf("yaml list command is not implemented")</span>
                case "remove":<span class="cov0" title="0">
                        fmt.Printf("yaml remove command is not implemented")</span>
                }
        case "driver":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateCloudDriver(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = cim.ListCloudDriver()</span>
                case "get":<span class="cov0" title="0">
                        result, err = cim.GetCloudDriverByParam(driverName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteCloudDriverByParam(driverName)</span>
                }
        case "credential":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateCredential(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = cim.ListCredential()</span>
                case "get":<span class="cov0" title="0">
                        result, err = cim.GetCredentialByParam(credentialName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteCredentialByParam(credentialName)</span>
                }
        case "region":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateRegion(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = cim.ListRegion()</span>
                case "get":<span class="cov0" title="0">
                        result, err = cim.GetRegionByParam(regionName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteRegionByParam(regionName)</span>
                }
        case "connect-info":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateConnectionConfig(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = proc.ListConnectInfos(cim)</span>
                case "get":<span class="cov0" title="0">
                        result, err = proc.GetConnectInfos(cim, configName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteConnectionConfigByParam(configName)</span>
                }
        case "namespace":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ns.CreateNS(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ns.ListNS()</span>
                case "list-id":<span class="cov8" title="1">
                        result, err = ns.ListNSId()</span>
                case "get":<span class="cov8" title="1">
                        result, err = ns.GetNSByParam(nameSpaceID)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ns.DeleteNSByParam(nameSpaceID)</span>
                case "delete-all":<span class="cov8" title="1">
                        result, err = ns.DeleteAllNS()</span>
                case "check":<span class="cov0" title="0">
                        result, err = ns.CheckNSByParam(nameSpaceID)</span>
                }
        case "image":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcir.CreateImageWithInfo(inData)</span>
                case "create-id":<span class="cov8" title="1">
                        result, err = mcir.CreateImageWithID(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcir.ListImageByParam(nameSpaceID)</span>
                case "list-id":<span class="cov8" title="1">
                        result, err = mcir.ListImageIdByParam(nameSpaceID)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcir.GetImageByParam(nameSpaceID, resourceID)</span>
                case "list-csp":<span class="cov8" title="1">
                        result, err = mcir.ListLookupImageByParam(connConfigName)</span>
                case "get-csp":<span class="cov8" title="1">
                        result, err = mcir.GetLookupImageByParam(connConfigName, cspImageId)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = mcir.DeleteImageByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov8" title="1">
                        result, err = mcir.DeleteAllImageByParam(nameSpaceID, force)</span>
                case "fetch":<span class="cov8" title="1">
                        result, err = mcir.FetchImageByParam(connConfigName, nameSpaceID)</span>
                case "search":<span class="cov8" title="1">
                        result, err = mcir.SearchImage(inData)</span>
                }
        case "network":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = mcir.CreateVNet(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcir.ListVNetByParam(nameSpaceID)</span>
                case "list-id":<span class="cov8" title="1">
                        result, err = mcir.ListVNetIdByParam(nameSpaceID)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcir.GetVNetByParam(nameSpaceID, resourceID)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = mcir.DeleteVNetByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov8" title="1">
                        result, err = mcir.DeleteAllVNetByParam(nameSpaceID, force)</span>
                }
        case "securitygroup":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = mcir.CreateSecurityGroup(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcir.ListSecurityGroupByParam(nameSpaceID)</span>
                case "list-id":<span class="cov8" title="1">
                        result, err = mcir.ListSecurityGroupIdByParam(nameSpaceID)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcir.GetSecurityGroupByParam(nameSpaceID, resourceID)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = mcir.DeleteSecurityGroupByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov8" title="1">
                        result, err = mcir.DeleteAllSecurityGroupByParam(nameSpaceID, force)</span>
                }
        case "keypair":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = mcir.CreateSshKey(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcir.ListSshKeyByParam(nameSpaceID)</span>
                case "list-id":<span class="cov8" title="1">
                        result, err = mcir.ListSshKeyIdByParam(nameSpaceID)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcir.GetSshKeyByParam(nameSpaceID, resourceID)</span>
                case "save":<span class="cov0" title="0">
                        result, err = proc.SaveSshKey(mcir, nameSpaceID, resourceID, sshSaveFileName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = mcir.DeleteSshKeyByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov8" title="1">
                        result, err = mcir.DeleteAllSshKeyByParam(nameSpaceID, force)</span>
                }
        case "spec":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcir.CreateSpecWithInfo(inData)</span>
                case "create-id":<span class="cov8" title="1">
                        result, err = mcir.CreateSpecWithSpecName(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcir.ListSpecByParam(nameSpaceID)</span>
                case "list-id":<span class="cov8" title="1">
                        result, err = mcir.ListSpecIdByParam(nameSpaceID)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcir.GetSpecByParam(nameSpaceID, resourceID)</span>
                case "list-csp":<span class="cov8" title="1">
                        result, err = mcir.ListLookupSpecByParam(connConfigName)</span>
                case "get-csp":<span class="cov8" title="1">
                        result, err = mcir.GetLookupSpecByParam(connConfigName, cspSpecName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = mcir.DeleteSpecByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov8" title="1">
                        result, err = mcir.DeleteAllSpecByParam(nameSpaceID, force)</span>
                case "fetch":<span class="cov8" title="1">
                        result, err = mcir.FetchSpecByParam(connConfigName, nameSpaceID)</span>
                case "filter":<span class="cov8" title="1">
                        result, err = mcir.FilterSpec(inData)</span>
                case "filter-by-range":<span class="cov8" title="1">
                        result, err = mcir.FilterSpecsByRange(inData)</span>
                case "sort":<span class="cov0" title="0">
                        result, err = mcir.SortSpecs(inData)</span>
                case "update":<span class="cov8" title="1">
                        result, err = mcir.UpdateSpec(inData)</span>
                }
        case "mcis":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = mcis.CreateMcis(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcis.ListMcisByParam(nameSpaceID)</span>
                case "list-id":<span class="cov8" title="1">
                        result, err = mcis.ListMcisIdByParam(nameSpaceID)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcis.GetMcisInfoByParam(nameSpaceID, mcisID)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = mcis.DeleteMcisByParam(nameSpaceID, mcisID)</span>
                case "delete-all":<span class="cov8" title="1">
                        result, err = mcis.DeleteAllMcisByParam(nameSpaceID)</span>
                case "status-list":<span class="cov8" title="1">
                        result, err = mcis.ListMcisStatusByParam(nameSpaceID)</span>
                case "status":<span class="cov8" title="1">
                        result, err = mcis.GetMcisStatusByParam(nameSpaceID, mcisID)</span>
                case "suspend":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "suspend")</span>
                case "resume":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "resume")</span>
                case "reboot":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "reboot")</span>
                case "terminate":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "terminate")</span>
                case "add-vm":<span class="cov8" title="1">
                        result, err = mcis.CreateMcisVM(inData)</span>
                case "group-vm":<span class="cov8" title="1">
                        result, err = mcis.CreateMcisVMGroup(inData)</span>
                case "list-vm":<span class="cov0" title="0">
                        result, err = proc.ListMcisVM(mcis, nameSpaceID, mcisID)</span>
                case "list-vm-id":<span class="cov8" title="1">
                        result, err = mcis.ListMcisVmIdByParam(nameSpaceID, mcisID)</span>
                case "get-vm":<span class="cov8" title="1">
                        result, err = mcis.GetMcisVMInfoByParam(nameSpaceID, mcisID, vmID)</span>
                case "del-vm":<span class="cov8" title="1">
                        result, err = mcis.DeleteMcisVMByParam(nameSpaceID, mcisID, vmID)</span>
                case "status-vm":<span class="cov8" title="1">
                        result, err = mcis.GetMcisVMStatusByParam(nameSpaceID, mcisID, vmID)</span>
                case "suspend-vm":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "suspend")</span>
                case "resume-vm":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "resume")</span>
                case "reboot-vm":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "reboot")</span>
                case "terminate-vm":<span class="cov8" title="1">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "terminate")</span>
                case "command":<span class="cov8" title="1">
                        result, err = mcis.CmdMcis(inData)</span>
                case "command-vm":<span class="cov8" title="1">
                        result, err = mcis.CmdMcisVm(inData)</span>
                case "deploy-milkyway":<span class="cov0" title="0">
                        result, err = mcis.InstallAgentToMcis(inData)</span>
                case "access-vm":<span class="cov0" title="0">
                        fmt.Printf("mcis access-vm command is not implemented")</span>
                case "benchmark":<span class="cov8" title="1">
                        if action == "all" </span><span class="cov8" title="1">{
                                result, err = mcis.GetAllBenchmarkByParam(nameSpaceID, mcisID, host)
                        }</span> else<span class="cov8" title="1"> {
                                result, err = mcis.GetBenchmarkByParam(nameSpaceID, mcisID, action, host)
                        }</span>
                case "install-mon":<span class="cov8" title="1">
                        result, err = mcis.InstallMonitorAgentToMcis(inData)</span>
                case "get-mon":<span class="cov8" title="1">
                        result, err = mcis.GetMonitorDataByParam(nameSpaceID, mcisID, metric)</span>
                case "create-policy":<span class="cov8" title="1">
                        result, err = mcis.CreateMcisPolicy(inData)</span>
                case "list-policy":<span class="cov8" title="1">
                        result, err = mcis.ListMcisPolicyByParam(nameSpaceID)</span>
                case "get-policy":<span class="cov8" title="1">
                        result, err = mcis.GetMcisPolicyByParam(nameSpaceID, mcisID)</span>
                case "delete-policy":<span class="cov8" title="1">
                        result, err = mcis.DeleteMcisPolicyByParam(nameSpaceID, mcisID)</span>
                case "delete-all-policy":<span class="cov8" title="1">
                        result, err = mcis.DeleteAllMcisPolicyByParam(nameSpaceID)</span>
                case "recommend":<span class="cov0" title="0">
                        result, err = mcis.RecommendMcis(inData)</span>
                case "recommend-vm":<span class="cov0" title="0">
                        result, err = mcis.RecommendVM(inData)</span>
                }
        case "util":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "list-cc":<span class="cov8" title="1">
                        result, err = tbutil.ListConnConfig()</span>
                case "get-cc":<span class="cov8" title="1">
                        result, err = tbutil.GetConnConfigByParam(connConfigName)</span>
                case "list-region":<span class="cov8" title="1">
                        result, err = tbutil.ListRegion()</span>
                case "get-region":<span class="cov8" title="1">
                        result, err = tbutil.GetRegionByParam(regionName)</span>
                case "inspect-mcir":<span class="cov8" title="1">
                        result, err = tbutil.InspectMcirResourcesByParam(connConfigName, resourceType)</span>
                case "inspect-vm":<span class="cov8" title="1">
                        result, err = tbutil.InspectVmResourcesByParam(connConfigName)</span>
                case "list-obj":<span class="cov8" title="1">
                        result, err = tbutil.ListObjectByParam(objKey)</span>
                case "get-obj":<span class="cov8" title="1">
                        result, err = tbutil.GetObjectByParam(objKey)</span>
                case "delete-obj":<span class="cov8" title="1">
                        result, err = tbutil.DeleteObjectByParam(objKey)</span>
                case "delete-all-obj":<span class="cov8" title="1">
                        result, err = tbutil.DeleteAllObjectByParam(objKey)</span>
                }
        case "config":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = tbutil.CreateConfig(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = tbutil.ListConfig()</span>
                case "get":<span class="cov8" title="1">
                        result, err = tbutil.GetConfigByParam(configId)</span>
                case "init":<span class="cov8" title="1">
                        result, err = tbutil.InitConfigByParam(configId)</span>
                case "init-all":<span class="cov8" title="1">
                        result, err = tbutil.InitAllConfig()</span>
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if outType == "yaml" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "message: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(cmd.OutOrStdout(), "{\"message\": \"%v\"}\n", err)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", result)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewImageCmd : "cbadm image *" (for CB-Tumblebug)
func NewImageCmd() *cobra.Command <span class="cov8" title="1">{

        imageCmd := &amp;cobra.Command{
                Use:   "image",
                Short: "This is a manageable command for image",
                Long:  "This is a manageable command for image",
        }

        //  Adds the commands for application.
        imageCmd.AddCommand(NewImageCreateWithInfoCmd())
        imageCmd.AddCommand(NewImageCreateWithIdCmd())
        imageCmd.AddCommand(NewImageListCmd())
        imageCmd.AddCommand(NewImageListIdCmd())
        imageCmd.AddCommand(NewImageListCspCmd())
        imageCmd.AddCommand(NewImageGetCmd())
        imageCmd.AddCommand(NewImageGetCspCmd())
        imageCmd.AddCommand(NewImageDeleteCmd())
        imageCmd.AddCommand(NewImageDeleteAllCmd())
        imageCmd.AddCommand(NewImageFetchCmd())
        imageCmd.AddCommand(NewImageSearchCmd())

        return imageCmd
}</span>

// NewImageCreateWithInfoCmd : "cbadm image create"
func NewImageCreateWithInfoCmd() *cobra.Command <span class="cov8" title="1">{

        createWithInfoCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for image",
                Long:  "This is create command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createWithInfoCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithInfoCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithInfoCmd</span>
}

// NewImageCreateWithIdCmd : "cbadm image create-id"
func NewImageCreateWithIdCmd() *cobra.Command <span class="cov8" title="1">{

        createWithIdCmd := &amp;cobra.Command{
                Use:   "create-id",
                Short: "This is create-id command for image",
                Long:  "This is create-id command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createWithIdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithIdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithIdCmd</span>
}

// NewImageListCmd : "cbadm image list"
func NewImageListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for image",
                Long:  "This is list command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewImageListIdCmd : "cbadm image list-id"
func NewImageListIdCmd() *cobra.Command <span class="cov8" title="1">{

        listIdCmd := &amp;cobra.Command{
                Use:   "list-id",
                Short: "This is list-id command for image",
                Long:  "This is list-id command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listIdCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listIdCmd</span>
}

// NewImageListCspCmd : "cbadm image list-csp"
func NewImageListCspCmd() *cobra.Command <span class="cov8" title="1">{

        listCspCmd := &amp;cobra.Command{
                Use:   "list-csp",
                Short: "This is list-csp command for image",
                Long:  "This is list-csp command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")

        return listCspCmd</span>
}

// NewImageGetCmd : "cbadm image get"
func NewImageGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for image",
                Long:  "This is get command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "image id")

        return getCmd</span>
}

// NewImageGetCspCmd : "cbadm image get-csp"
func NewImageGetCspCmd() *cobra.Command <span class="cov8" title="1">{

        getCspCmd := &amp;cobra.Command{
                Use:   "get-csp",
                Short: "This is get-csp command for image",
                Long:  "This is get-csp command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspImageId == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --image parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--image parameter value : ", cspImageId)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        getCspCmd.PersistentFlags().StringVarP(&amp;cspImageId, "image", "", "", "csp image id")

        return getCspCmd</span>
}

// NewImageDeleteCmd : "cbadm image delete"
func NewImageDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for image",
                Long:  "This is delete command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "image id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewImageDeleteAllCmd : "cbadm image delete-all"
func NewImageDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for image",
                Long:  "This is delete-all command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}

// NewImageFetchCmd : "cbadm image fetch"
func NewImageFetchCmd() *cobra.Command <span class="cov8" title="1">{

        fetchCmd := &amp;cobra.Command{
                Use:   "fetch",
                Short: "This is fetch command for image",
                Long:  "This is fetch command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">fetchCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        fetchCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return fetchCmd</span>
}

// NewImageSearchCmd : "cbadm image search"
func NewImageSearchCmd() *cobra.Command <span class="cov8" title="1">{

        searchCmd := &amp;cobra.Command{
                Use:   "search",
                Short: "This is search command for image",
                Long:  "This is search command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">searchCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        searchCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return searchCmd</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewKeypairCmd : "cbadm keypair *" (for CB-Tumblebug)
func NewKeypairCmd() *cobra.Command <span class="cov8" title="1">{

        keypairCmd := &amp;cobra.Command{
                Use:   "keypair",
                Short: "This is a manageable command for keypair",
                Long:  "This is a manageable command for keypair",
        }

        //  Adds the commands for application.
        keypairCmd.AddCommand(NewKeypairCreateCmd())
        keypairCmd.AddCommand(NewKeypairListCmd())
        keypairCmd.AddCommand(NewKeypairListIdCmd())
        keypairCmd.AddCommand(NewKeypairGetCmd())
        keypairCmd.AddCommand(NewKeypairSaveCmd())
        keypairCmd.AddCommand(NewKeypairDeleteCmd())
        keypairCmd.AddCommand(NewKeypairDeleteAllCmd())

        return keypairCmd
}</span>

// NewKeypairCreateCmd : "cbadm keypair create"
func NewKeypairCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for keypair",
                Long:  "This is create command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewKeypairListCmd : "cbadm keypair list"
func NewKeypairListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for keypair",
                Long:  "This is list command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewKeypairListIdCmd : "cbadm keypair list-id"
func NewKeypairListIdCmd() *cobra.Command <span class="cov8" title="1">{

        listIdCmd := &amp;cobra.Command{
                Use:   "list-id",
                Short: "This is list-id command for keypair",
                Long:  "This is list-id command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listIdCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listIdCmd</span>
}

// NewKeypairGetCmd : "cbadm keypair get"
func NewKeypairGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for keypair",
                Long:  "This is get command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "keypair id")

        return getCmd</span>
}

// NewKeypairSaveCmd : "cbadm keypair save"
func NewKeypairSaveCmd() *cobra.Command <span class="cov8" title="1">{

        saveCmd := &amp;cobra.Command{
                Use:   "save",
                Short: "This is save command for keypair",
                Long:  "This is save command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if sshSaveFileName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --fn parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--fn parameter value : ", sshSaveFileName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">saveCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        saveCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "keypair id")
        saveCmd.PersistentFlags().StringVarP(&amp;sshSaveFileName, "fn", "", "", "ssh key save file name")

        return saveCmd</span>
}

// NewKeypairDeleteCmd : "cbadm keypair delete"
func NewKeypairDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for keypair",
                Long:  "This is delete command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "keypair id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewKeypairDeleteAllCmd : "cbadm keypair delete-all"
func NewKeypairDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for keypair",
                Long:  "This is delete-all command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewMcisCmd : "cbadm mcis *" (for CB-Tumblebug)
func NewMcisCmd() *cobra.Command <span class="cov8" title="1">{

        mcisCmd := &amp;cobra.Command{
                Use:   "mcis",
                Short: "This is a manageable command for mcis",
                Long:  "This is a manageable command for mcis",
        }

        //  Adds the commands for application.
        mcisCmd.AddCommand(NewMcisCreateCmd())
        mcisCmd.AddCommand(NewMcisListCmd())
        mcisCmd.AddCommand(NewMcisListIdCmd())
        mcisCmd.AddCommand(NewMcisGetCmd())
        mcisCmd.AddCommand(NewMcisDeleteCmd())
        mcisCmd.AddCommand(NewMcisDeleteAllCmd())
        mcisCmd.AddCommand(NewMcisStatusListCmd())
        mcisCmd.AddCommand(NewMcisStatusCmd())
        mcisCmd.AddCommand(NewMcisSuspendCmd())
        mcisCmd.AddCommand(NewMcisResumeCmd())
        mcisCmd.AddCommand(NewMcisRebootCmd())
        mcisCmd.AddCommand(NewMcisTerminateCmd())

        mcisCmd.AddCommand(NewMcisVmAddCmd())
        mcisCmd.AddCommand(NewMcisVmGroupCmd())
        mcisCmd.AddCommand(NewMcisVmListCmd())
        mcisCmd.AddCommand(NewMcisVmListIdCmd())
        mcisCmd.AddCommand(NewMcisVmGetCmd())
        mcisCmd.AddCommand(NewMcisVmDeleteCmd())
        mcisCmd.AddCommand(NewMcisVmStatusCmd())
        mcisCmd.AddCommand(NewMcisVmSuspendCmd())
        mcisCmd.AddCommand(NewMcisVmResumeCmd())
        mcisCmd.AddCommand(NewMcisVmRebootCmd())
        mcisCmd.AddCommand(NewMcisVmTerminateCmd())

        mcisCmd.AddCommand(NewMcisRecommendCmd())
        mcisCmd.AddCommand(NewMcisRecommendVmCmd())

        mcisCmd.AddCommand(NewCmdMcisCmd())
        mcisCmd.AddCommand(NewCmdMcisVmCmd())

        mcisCmd.AddCommand(NewDeployMilkywayCmd())

        mcisCmd.AddCommand(NewAccessVmCmd())
        mcisCmd.AddCommand(NewBenchmarkCmd())

        mcisCmd.AddCommand(NewInstallMonAgentCmd())
        mcisCmd.AddCommand(NewGetMonDataCmd())

        mcisCmd.AddCommand(NewMcisCreatePolicyCmd())
        mcisCmd.AddCommand(NewMcisListPolicyCmd())
        mcisCmd.AddCommand(NewMcisGetPolicyCmd())
        mcisCmd.AddCommand(NewMcisDeletePolicyCmd())
        mcisCmd.AddCommand(NewMcisDeleteAllPolicyCmd())

        return mcisCmd
}</span>

// NewMcisCreateCmd : "cbadm mcis create"
func NewMcisCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for mcis",
                Long:  "This is create command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewMcisListCmd : "cbadm mcis list"
func NewMcisListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for mcis",
                Long:  "This is list command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewMcisListIdCmd : "cbadm mcis list-id"
func NewMcisListIdCmd() *cobra.Command <span class="cov8" title="1">{

        listIdCmd := &amp;cobra.Command{
                Use:   "list-id",
                Short: "This is list-id command for mcis",
                Long:  "This is list-id command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listIdCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listIdCmd</span>
}

// NewMcisGetCmd : "cbadm mcis get"
func NewMcisGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for mcis",
                Long:  "This is get command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return getCmd</span>
}

// NewMcisDeleteCmd : "cbadm mcis delete"
func NewMcisDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for mcis",
                Long:  "This is delete command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return deleteCmd</span>
}

// NewMcisDeleteAllCmd : "cbadm mcis delete-all"
func NewMcisDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for mcis",
                Long:  "This is delete-all command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return deleteAllCmd</span>
}

// NewMcisStatusListCmd : "cbadm mcis status-list"
func NewMcisStatusListCmd() *cobra.Command <span class="cov8" title="1">{

        statusListCmd := &amp;cobra.Command{
                Use:   "status-list",
                Short: "This is status-list command for mcis",
                Long:  "This is status-list command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">statusListCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return statusListCmd</span>
}

// NewMcisStatusCmd : "cbadm mcis status"
func NewMcisStatusCmd() *cobra.Command <span class="cov8" title="1">{

        statusCmd := &amp;cobra.Command{
                Use:   "status",
                Short: "This is status command for mcis",
                Long:  "This is status command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">statusCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        statusCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return statusCmd</span>
}

// NewMcisSuspendCmd : "cbadm mcis suspend"
func NewMcisSuspendCmd() *cobra.Command <span class="cov8" title="1">{

        suspendCmd := &amp;cobra.Command{
                Use:   "suspend",
                Short: "This is suspend command for mcis",
                Long:  "This is suspend command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">suspendCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        suspendCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return suspendCmd</span>
}

// NewMcisResumeCmd : "cbadm mcis resume"
func NewMcisResumeCmd() *cobra.Command <span class="cov8" title="1">{

        resumeCmd := &amp;cobra.Command{
                Use:   "resume",
                Short: "This is resume command for mcis",
                Long:  "This is resume command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">resumeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        resumeCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return resumeCmd</span>
}

// NewMcisRebootCmd : "cbadm mcis reboot"
func NewMcisRebootCmd() *cobra.Command <span class="cov8" title="1">{

        rebootCmd := &amp;cobra.Command{
                Use:   "reboot",
                Short: "This is reboot command for mcis",
                Long:  "This is reboot command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">rebootCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        rebootCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return rebootCmd</span>
}

// NewMcisTerminateCmd : "cbadm mcis terminate"
func NewMcisTerminateCmd() *cobra.Command <span class="cov8" title="1">{

        terminateCmd := &amp;cobra.Command{
                Use:   "terminate",
                Short: "This is terminate command for mcis",
                Long:  "This is terminate command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">terminateCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        terminateCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return terminateCmd</span>
}

// NewMcisVmAddCmd : "cbadm mcis add-vm"
func NewMcisVmAddCmd() *cobra.Command <span class="cov8" title="1">{

        vmAddCmd := &amp;cobra.Command{
                Use:   "add-vm",
                Short: "This is add-vm command for mcis",
                Long:  "This is add-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmAddCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        vmAddCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return vmAddCmd</span>
}

// NewMcisVmGroupCmd : "cbadm mcis group-vm"
func NewMcisVmGroupCmd() *cobra.Command <span class="cov8" title="1">{

        vmGroupCmd := &amp;cobra.Command{
                Use:   "group-vm",
                Short: "This is group-vm command for mcis",
                Long:  "This is group-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmGroupCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        vmGroupCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return vmGroupCmd</span>
}

// NewMcisVmListCmd : "cbadm mcis list-vm"
func NewMcisVmListCmd() *cobra.Command <span class="cov8" title="1">{

        vmListCmd := &amp;cobra.Command{
                Use:   "list-vm",
                Short: "This is list-vm command for mcis",
                Long:  "This is list-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmListCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmListCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return vmListCmd</span>
}

// NewMcisVmListIdCmd : "cbadm mcis list-vm-id"
func NewMcisVmListIdCmd() *cobra.Command <span class="cov8" title="1">{

        vmListIdCmd := &amp;cobra.Command{
                Use:   "list-vm-id",
                Short: "This is list-vm-id command for mcis",
                Long:  "This is list-vm-id command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmListIdCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmListIdCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return vmListIdCmd</span>
}

// NewMcisVmGetCmd : "cbadm mcis get-vm"
func NewMcisVmGetCmd() *cobra.Command <span class="cov8" title="1">{

        vmGetCmd := &amp;cobra.Command{
                Use:   "get-vm",
                Short: "This is get-vm command for mcis",
                Long:  "This is get-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmGetCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmGetCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmGetCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmGetCmd</span>
}

// NewMcisVmDeleteCmd : "cbadm mcis del-vm"
func NewMcisVmDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        vmDeleteCmd := &amp;cobra.Command{
                Use:   "del-vm",
                Short: "This is del-vm command for mcis",
                Long:  "This is del-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmDeleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmDeleteCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmDeleteCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmDeleteCmd</span>
}

// NewMcisVmStatusCmd : "cbadm mcis status-vm"
func NewMcisVmStatusCmd() *cobra.Command <span class="cov8" title="1">{

        vmStatusCmd := &amp;cobra.Command{
                Use:   "status-vm",
                Short: "This is status-vm command for mcis",
                Long:  "This is status-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmStatusCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmStatusCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmStatusCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmStatusCmd</span>
}

// NewMcisVmSuspendCmd : "cbadm mcis suspend-vm"
func NewMcisVmSuspendCmd() *cobra.Command <span class="cov8" title="1">{

        vmSuspendCmd := &amp;cobra.Command{
                Use:   "suspend-vm",
                Short: "This is suspend-vm command for mcis",
                Long:  "This is suspend-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmSuspendCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmSuspendCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmSuspendCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmSuspendCmd</span>
}

// NewMcisVmResumeCmd : "cbadm mcis resume-vm"
func NewMcisVmResumeCmd() *cobra.Command <span class="cov8" title="1">{

        vmResumeCmd := &amp;cobra.Command{
                Use:   "resume-vm",
                Short: "This is resume-vm command for mcis",
                Long:  "This is resume-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmResumeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmResumeCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmResumeCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmResumeCmd</span>
}

// NewMcisVmRebootCmd : "cbadm mcis reboot-vm"
func NewMcisVmRebootCmd() *cobra.Command <span class="cov8" title="1">{

        vmRebootCmd := &amp;cobra.Command{
                Use:   "reboot-vm",
                Short: "This is reboot-vm command for mcis",
                Long:  "This is reboot-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmRebootCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmRebootCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmRebootCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmRebootCmd</span>
}

// NewMcisVmTerminateCmd : "cbadm mcis terminate-vm"
func NewMcisVmTerminateCmd() *cobra.Command <span class="cov8" title="1">{

        vmTerminateCmd := &amp;cobra.Command{
                Use:   "terminate-vm",
                Short: "This is terminate-vm command for mcis",
                Long:  "This is terminate-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmTerminateCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmTerminateCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmTerminateCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmTerminateCmd</span>
}

// NewMcisRecommendCmd : "cbadm mcis recommend"
func NewMcisRecommendCmd() *cobra.Command <span class="cov8" title="1">{

        recommendCmd := &amp;cobra.Command{
                Use:   "recommend",
                Short: "This is recommend command for mcis",
                Long:  "This is recommend command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">recommendCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        recommendCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return recommendCmd</span>
}

// NewMcisRecommendVmCmd : "cbadm mcis recommend-vm"
func NewMcisRecommendVmCmd() *cobra.Command <span class="cov8" title="1">{

        recommendVmCmd := &amp;cobra.Command{
                Use:   "recommend-vm",
                Short: "This is recommend-vm command for mcis",
                Long:  "This is recommend-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">recommendVmCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        recommendVmCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return recommendVmCmd</span>
}

// NewCmdMcisCmd : "cbadm mcis command"
func NewCmdMcisCmd() *cobra.Command <span class="cov8" title="1">{

        mcisCmdCmd := &amp;cobra.Command{
                Use:   "command",
                Short: "This is execution command for mcis",
                Long:  "This is execution command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">mcisCmdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        mcisCmdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return mcisCmdCmd</span>
}

// NewCmdMcisVmCmd : "cbadm mcis command-vm"
func NewCmdMcisVmCmd() *cobra.Command <span class="cov8" title="1">{

        vmCmdCmd := &amp;cobra.Command{
                Use:   "command-vm",
                Short: "This is command-vm command for mcis",
                Long:  "This is command-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">vmCmdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        vmCmdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return vmCmdCmd</span>
}

// NewDeployMilkywayCmd : "cbadm mcis deploy-milkyway"
func NewDeployMilkywayCmd() *cobra.Command <span class="cov8" title="1">{

        deployMilkywayCmd := &amp;cobra.Command{
                Use:   "deploy-milkyway",
                Short: "This is deploy-milkyway command for mcis",
                Long:  "This is deploy-milkyway command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deployMilkywayCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        deployMilkywayCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return deployMilkywayCmd</span>
}

// NewAccessVmCmd : "cbadm mcis access-vm"
func NewAccessVmCmd() *cobra.Command <span class="cov8" title="1">{

        accessVmCmd := &amp;cobra.Command{
                Use:   "access-vm",
                Short: "This is access-vm command for mcis",
                Long:  "This is access-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return accessVmCmd</span>
}

// NewBenchmarkCmd : "cbadm mcis benchmark"
func NewBenchmarkCmd() *cobra.Command <span class="cov8" title="1">{

        benchmarkCmd := &amp;cobra.Command{
                Use:   "benchmark",
                Short: "This is benchmark command for mcis",
                Long:  "This is benchmark command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--action parameter value : ", action)
                        logger.Debug("--host parameter value : ", host)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">benchmarkCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        benchmarkCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        benchmarkCmd.PersistentFlags().StringVarP(&amp;action, "action", "", "all", "action name")
        benchmarkCmd.PersistentFlags().StringVarP(&amp;host, "host", "", "localhost", "target host ip address")

        return benchmarkCmd</span>
}

// NewInstallMonAgentCmd : "cbadm mcis install-mon"
func NewInstallMonAgentCmd() *cobra.Command <span class="cov8" title="1">{

        installMonCmd := &amp;cobra.Command{
                Use:   "install-mon",
                Short: "This is install-mon command for mcis",
                Long:  "This is install-mon command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">installMonCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        installMonCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return installMonCmd</span>
}

// NewGetMonDataCmd : "cbadm mcis get-mon"
func NewGetMonDataCmd() *cobra.Command <span class="cov8" title="1">{

        getMonCmd := &amp;cobra.Command{
                Use:   "get-mon",
                Short: "This is get-mon command for mcis",
                Long:  "This is get-mon command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if metric == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --metric parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--metric parameter value : ", metric)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getMonCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getMonCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        getMonCmd.PersistentFlags().StringVarP(&amp;metric, "metric", "", "", "metric")

        return getMonCmd</span>
}

// NewMcisCreatePolicyCmd : "cbadm mcis create-policy"
func NewMcisCreatePolicyCmd() *cobra.Command <span class="cov8" title="1">{

        createPolicyCmd := &amp;cobra.Command{
                Use:   "create-policy",
                Short: "This is create-policy command for mcis",
                Long:  "This is create-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createPolicyCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createPolicyCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createPolicyCmd</span>
}

// NewMcisListPolicyCmd : "cbadm mcis list-policy"
func NewMcisListPolicyCmd() *cobra.Command <span class="cov8" title="1">{

        listPolicyCmd := &amp;cobra.Command{
                Use:   "list-policy",
                Short: "This is list-policy command for mcis",
                Long:  "This is list-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>

                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listPolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listPolicyCmd</span>
}

// NewMcisGetPolicyCmd : "cbadm mcis get-policy"
func NewMcisGetPolicyCmd() *cobra.Command <span class="cov8" title="1">{

        getPolicyCmd := &amp;cobra.Command{
                Use:   "get-policy",
                Short: "This is get-policy command for mcis",
                Long:  "This is get-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getPolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getPolicyCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return getPolicyCmd</span>
}

// NewMcisDeletePolicyCmd : "cbadm mcis delete-policy"
func NewMcisDeletePolicyCmd() *cobra.Command <span class="cov8" title="1">{

        deletePolicyCmd := &amp;cobra.Command{
                Use:   "delete-policy",
                Short: "This is delete-policy command for mcis",
                Long:  "This is delete-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deletePolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deletePolicyCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return deletePolicyCmd</span>
}

// NewMcisDeleteAllPolicyCmd : "cbadm mcis delete-all-policy"
func NewMcisDeleteAllPolicyCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllPolicyCmd := &amp;cobra.Command{
                Use:   "delete-all-policy",
                Short: "This is delete-all-policy command for mcis",
                Long:  "This is delete-all-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllPolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return deleteAllPolicyCmd</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewNameSpaceCmd : "cbadm namespace *" (for CB-Tumblebug)
func NewNameSpaceCmd() *cobra.Command <span class="cov8" title="1">{

        nameSpaceCmd := &amp;cobra.Command{
                Use:     "namespace",
                Aliases: []string{"ns"},
                Short:   "This is a manageable command for namespace",
                Long:    "This is a manageable command for namespace",
        }

        //  Adds the commands for application.
        nameSpaceCmd.AddCommand(NewNameSpaceCreateCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceListCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceListIdCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceGetCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceDeleteCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceDeleteAllCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceCheckCmd())

        return nameSpaceCmd
}</span>

// NewNameSpaceCreateCmd : "cbadm namespace create"
func NewNameSpaceCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for namespace",
                Long:  "This is create command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewNameSpaceListCmd : "cbadm namespace list"
func NewNameSpaceListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for namespace",
                Long:  "This is list command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewNameSpaceListIdCmd : "cbadm namespace list-id"
func NewNameSpaceListIdCmd() *cobra.Command <span class="cov8" title="1">{

        listIdCmd := &amp;cobra.Command{
                Use:   "list-id",
                Short: "This is list-id command for namespace",
                Long:  "This is list-id command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listIdCmd</span>
}

// NewNameSpaceGetCmd : "cbadm namespace get"
func NewNameSpaceGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for namespace",
                Long:  "This is get command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return getCmd</span>
}

// NewNameSpaceDeleteCmd : "cbadm namespace delete"
func NewNameSpaceDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for namespace",
                Long:  "This is delete command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return deleteCmd</span>
}

// NewNameSpaceDeleteAllCmd : "cbadm namespace delete-all"
func NewNameSpaceDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for namespace",
                Long:  "This is delete-all command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return deleteAllCmd</span>
}

// NewNameSpaceCheckCmd : "cbadm namespace check"
func NewNameSpaceCheckCmd() *cobra.Command <span class="cov8" title="1">{

        checkCmd := &amp;cobra.Command{
                Use:   "check",
                Short: "This is check command for namespace",
                Long:  "This is check command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">checkCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return checkCmd</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewNetworkCmd : "cbadm network *" (for CB-Tumblebug)
func NewNetworkCmd() *cobra.Command <span class="cov8" title="1">{

        networkCmd := &amp;cobra.Command{
                Use:     "network",
                Short:   "This is a manageable command for network",
                Long:    "This is a manageable command for network",
                Aliases: []string{"vnet", "net", "vpc"},
        }

        //  Adds the commands for application.
        networkCmd.AddCommand(NewNetworkCreateCmd())
        networkCmd.AddCommand(NewNetworkListCmd())
        networkCmd.AddCommand(NewNetworkListIdCmd())
        networkCmd.AddCommand(NewNetworkGetCmd())
        networkCmd.AddCommand(NewNetworkDeleteCmd())
        networkCmd.AddCommand(NewNetworkDeleteAllCmd())

        return networkCmd
}</span>

// NewNetworkCreateCmd : "cbadm network create"
func NewNetworkCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for network",
                Long:  "This is create command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewNetworkListCmd : "cbadm network list"
func NewNetworkListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for network",
                Long:  "This is list command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewNetworkListIdCmd : "cbadm network list-id"
func NewNetworkListIdCmd() *cobra.Command <span class="cov8" title="1">{

        listIdCmd := &amp;cobra.Command{
                Use:   "list-id",
                Short: "This is list-id command for network",
                Long:  "This is list-id command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listIdCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listIdCmd</span>
}

// NewNetworkGetCmd : "cbadm network get"
func NewNetworkGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for network",
                Long:  "This is get command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "network id")

        return getCmd</span>
}

// NewNetworkDeleteCmd : "cbadm network delete"
func NewNetworkDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for network",
                Long:  "This is delete command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "network id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewNetworkDeleteAllCmd : "cbadm network delete-all"
func NewNetworkDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for network",
                Long:  "This is delete-all command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/cb-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRegionCmd : "cbadm region *" (for CB-Spider)
func NewRegionCmd() *cobra.Command <span class="cov8" title="1">{

        regionCmd := &amp;cobra.Command{
                Use:   "region",
                Short: "This is a manageable command for region",
                Long:  "This is a manageable command for region",
        }

        //  Adds the commands for application.
        regionCmd.AddCommand(NewRegionCreateCmd())
        regionCmd.AddCommand(NewRegionListCmd())
        regionCmd.AddCommand(NewRegionGetCmd())
        regionCmd.AddCommand(NewRegionDeleteCmd())

        return regionCmd
}</span>

// NewRegionCreateCmd : "cbadm region create"
func NewRegionCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for region",
                Long:  "This is create command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewRegionListCmd : "cbadm region list"
func NewRegionListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for region",
                Long:  "This is list command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewRegionGetCmd : "cbadm region get"
func NewRegionGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for region",
                Long:  "This is get command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return getCmd</span>
}

// NewRegionDeleteCmd : "cbadm region delete"
func NewRegionDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for region",
                Long:  "This is delete command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

const (
        // CLIVersion : version of cbadm cli
        CLIVersion = "1.0"
)

var (
        configFile string
        inData     string
        inFile     string
        inType     string
        outType    string

        driverName     string
        credentialName string
        regionName     string
        configName     string

        nameSpaceID     string
        resourceID      string
        force           string
        sshSaveFileName string

        option string
        mcisID string
        vmID   string

        connConfigName string

        resourceType string
        cspSpecName  string
        cspImageId   string
        host         string
        action       string
        metric       string

        configId string
        objKey   string

        parser config.Parser
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRootCmd : Create Root Cobra Command
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{

        rootCmd := &amp;cobra.Command{
                Use:   "cbadm",
                Short: "cbadm is a lightweight grpc cli tool",
                Long:  "This is a lightweight grpc cli tool for Cloud-Barista",
        }

        // Option flags
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "./grpc_conf.yaml", "config file")
        rootCmd.PersistentFlags().StringVarP(&amp;inType, "input", "i", "yaml", "input format (json/yaml)")
        rootCmd.PersistentFlags().StringVarP(&amp;outType, "output", "o", "yaml", "output format (json/yaml)")

        // Make new config parser (which uses Viper)
        parser = config.MakeParser()

        //  Add subcommands for application.
        rootCmd.AddCommand(NewVersionCmd())

        rootCmd.AddCommand(NewDriverCmd())
        rootCmd.AddCommand(NewCredentialCmd())
        rootCmd.AddCommand(NewRegionCmd())
        rootCmd.AddCommand(NewConnectInfosCmd())

        rootCmd.AddCommand(NewNameSpaceCmd())
        rootCmd.AddCommand(NewImageCmd())
        rootCmd.AddCommand(NewNetworkCmd())
        rootCmd.AddCommand(NewSecurityCmd())
        rootCmd.AddCommand(NewKeypairCmd())
        rootCmd.AddCommand(NewSpecCmd())
        rootCmd.AddCommand(NewMcisCmd())

        rootCmd.AddCommand(NewYamlApplyCmd())
        rootCmd.AddCommand(NewYamlGetCmd())
        rootCmd.AddCommand(NewYamlListCmd())
        rootCmd.AddCommand(NewYamlRemoveCmd())

        rootCmd.AddCommand(NewUtilCmd())
        rootCmd.AddCommand(NewConfigCmd())

        return rootCmd
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSecurityCmd : "cbadm securitygroup *" (for CB-Tumblebug)
func NewSecurityCmd() *cobra.Command <span class="cov8" title="1">{

        securityCmd := &amp;cobra.Command{
                Use:     "securitygroup",
                Aliases: []string{"sg"},
                Short:   "This is a manageable command for securitygroup",
                Long:    "This is a manageable command for securitygroup",
        }

        //  Adds the commands for application.
        securityCmd.AddCommand(NewSecurityCreateCmd())
        securityCmd.AddCommand(NewSecurityListCmd())
        securityCmd.AddCommand(NewSecurityListIdCmd())
        securityCmd.AddCommand(NewSecurityGetCmd())
        securityCmd.AddCommand(NewSecurityDeleteCmd())
        securityCmd.AddCommand(NewSecurityDeleteAllCmd())

        return securityCmd
}</span>

// NewSecurityCreateCmd : "cbadm securitygroup create"
func NewSecurityCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for securitygroup",
                Long:  "This is create command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewSecurityListCmd : "cbadm securitygroup list"
func NewSecurityListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for securitygroup",
                Long:  "This is list command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewSecurityListIdCmd : "cbadm securitygroup list-id"
func NewSecurityListIdCmd() *cobra.Command <span class="cov8" title="1">{

        listIdCmd := &amp;cobra.Command{
                Use:   "list-id",
                Short: "This is list-id command for securitygroup",
                Long:  "This is list-id command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listIdCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listIdCmd</span>
}

// NewSecurityGetCmd : "cbadm securitygroup get"
func NewSecurityGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for securitygroup",
                Long:  "This is get command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "security id")

        return getCmd</span>
}

// NewSecurityDeleteCmd : "cbadm securitygroup delete"
func NewSecurityDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for securitygroup",
                Long:  "This is delete command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "security id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewSecurityDeleteAllCmd : "cbadm securitygroup delete-all"
func NewSecurityDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for securitygroup",
                Long:  "This is delete-all command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSpecCmd : "cbadm spec *" (for CB-Tumblebug)
func NewSpecCmd() *cobra.Command <span class="cov8" title="1">{

        specCmd := &amp;cobra.Command{
                Use:   "spec",
                Short: "This is a manageable command for spec",
                Long:  "This is a manageable command for spec",
        }

        //  Adds the commands for application.
        specCmd.AddCommand(NewSpecWithInfoCreateCmd())
        specCmd.AddCommand(NewSpecWithIdCreateCmd())
        specCmd.AddCommand(NewSpecListCmd())
        specCmd.AddCommand(NewSpecListIdCmd())
        specCmd.AddCommand(NewSpecListCspCmd())
        specCmd.AddCommand(NewSpecGetCmd())
        specCmd.AddCommand(NewSpecGetCspCmd())
        specCmd.AddCommand(NewSpecDeleteCmd())
        specCmd.AddCommand(NewSpecDeleteAllCmd())
        specCmd.AddCommand(NewSpecFetchCmd())
        specCmd.AddCommand(NewSpecFilterCmd())
        specCmd.AddCommand(NewSpecFilterByRangeCmd())
        specCmd.AddCommand(NewSpecSortCmd())
        specCmd.AddCommand(NewSpecUpdateCmd())

        return specCmd
}</span>

// NewSpecWithInfoCreateCmd : "cbadm spec create"
func NewSpecWithInfoCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createWithInfoCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for spec",
                Long:  "This is create command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createWithInfoCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithInfoCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithInfoCmd</span>
}

// NewSpecWithIdCreateCmd : "cbadm spec create-id"
func NewSpecWithIdCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createWithIdCmd := &amp;cobra.Command{
                Use:   "create-id",
                Short: "This is create-id command for spec",
                Long:  "This is create-id command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createWithIdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithIdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithIdCmd</span>
}

// NewSpecListCmd : "cbadm spec list"
func NewSpecListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for spec",
                Long:  "This is list command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewSpecListIdCmd : "cbadm spec list-id"
func NewSpecListIdCmd() *cobra.Command <span class="cov8" title="1">{

        listIdCmd := &amp;cobra.Command{
                Use:   "list-id",
                Short: "This is list-id command for spec",
                Long:  "This is list-id command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listIdCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listIdCmd</span>
}

// NewSpecListCspCmd : "cbadm spec list-csp"
func NewSpecListCspCmd() *cobra.Command <span class="cov8" title="1">{

        listCspCmd := &amp;cobra.Command{
                Use:   "list-csp",
                Short: "This is list-csp command for spec",
                Long:  "This is list-csp command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")

        return listCspCmd</span>
}

// NewSpecGetCmd : "cbadm spec get"
func NewSpecGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for spec",
                Long:  "This is get command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "spec id")

        return getCmd</span>
}

// NewSpecGetCspCmd : "cbadm spec get-csp"
func NewSpecGetCspCmd() *cobra.Command <span class="cov8" title="1">{

        getCspCmd := &amp;cobra.Command{
                Use:   "get-csp",
                Short: "This is get-csp command for spec",
                Long:  "This is get-csp command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspSpecName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --spec parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--spec parameter value : ", cspSpecName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        getCspCmd.PersistentFlags().StringVarP(&amp;cspSpecName, "spec", "", "", "csp spec name")

        return getCspCmd</span>
}

// NewSpecDeleteCmd : "cbadm spec delete"
func NewSpecDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for spec",
                Long:  "This is delete command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "spec id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewSpecDeleteAllCmd : "cbadm spec delete-all"
func NewSpecDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for spec",
                Long:  "This is delete-all command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}

// NewSpecFetchCmd : "cbadm spec fetch"
func NewSpecFetchCmd() *cobra.Command <span class="cov8" title="1">{

        fetchCmd := &amp;cobra.Command{
                Use:   "fetch",
                Short: "This is fetch command for spec",
                Long:  "This is fetch command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">fetchCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        fetchCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return fetchCmd</span>
}

// NewSpecFilterCmd : "cbadm spec filter"
func NewSpecFilterCmd() *cobra.Command <span class="cov8" title="1">{

        filterCmd := &amp;cobra.Command{
                Use:   "filter",
                Short: "This is filter command for spec",
                Long:  "This is filter command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //filterCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov8" title="1">filterCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        filterCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return filterCmd</span>
}

// NewSpecFilterByRangeCmd : "cbadm spec filter-by-range"
func NewSpecFilterByRangeCmd() *cobra.Command <span class="cov8" title="1">{

        filterByRangeCmd := &amp;cobra.Command{
                Use:   "filter-by-range",
                Short: "This is filter-by-range command for spec",
                Long:  "This is filter-by-range command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //filterByRangeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov8" title="1">filterByRangeCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        filterByRangeCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return filterByRangeCmd</span>
}

// NewSpecSortCmd : "cbadm spec sort"
func NewSpecSortCmd() *cobra.Command <span class="cov8" title="1">{

        sortCmd := &amp;cobra.Command{
                Use:   "sort",
                Short: "This is sort command for spec",
                Long:  "This is sort command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //sortCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov8" title="1">sortCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        sortCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return sortCmd</span>
}

// NewSpecUpdateCmd : "cbadm spec update"
func NewSpecUpdateCmd() *cobra.Command <span class="cov8" title="1">{

        updateCmd := &amp;cobra.Command{
                Use:   "update",
                Short: "This is update command for spec",
                Long:  "This is update command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //updateCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov8" title="1">updateCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        updateCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return updateCmd</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewUtilCmd : "cbadm util *" (for CB-Tumblebug)
func NewUtilCmd() *cobra.Command <span class="cov8" title="1">{

        utilCmd := &amp;cobra.Command{
                Use:   "util",
                Short: "This is a manageable command for tumblebug utility",
                Long:  "This is a manageable command for tumblebug utility",
        }

        //  Adds the commands for application.
        utilCmd.AddCommand(NewConnConfigListCmd())
        utilCmd.AddCommand(NewConnConfigGetCmd())

        utilCmd.AddCommand(NewRegionSpiderListCmd())
        utilCmd.AddCommand(NewRegionSpiderGetCmd())

        utilCmd.AddCommand(NewMcirResourcesInspectCmd())
        utilCmd.AddCommand(NewVmResourcesInspectCmd())

        utilCmd.AddCommand(NewObjectListCmd())
        utilCmd.AddCommand(NewObjectGetCmd())
        utilCmd.AddCommand(NewObjectDeleteCmd())
        utilCmd.AddCommand(NewObjectDeleteAllCmd())

        return utilCmd
}</span>

// NewConnConfigListCmd : "cbadm util list-cc"
func NewConnConfigListCmd() *cobra.Command <span class="cov8" title="1">{

        listCCCmd := &amp;cobra.Command{
                Use:   "list-cc",
                Short: "This is list-cc command for tumblebug utility",
                Long:  "This is list-cc command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCCCmd</span>
}

// NewConnConfigGetCmd : "cbadm util get-cc"
func NewConnConfigGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCCCmd := &amp;cobra.Command{
                Use:   "get-cc",
                Short: "This is get-cc command for tumblebug utility",
                Long:  "This is get-cc command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCCCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection config name")

        return getCCCmd</span>
}

// NewRegionSpiderListCmd : "cbadm util list-region"
func NewRegionSpiderListCmd() *cobra.Command <span class="cov8" title="1">{

        listRegionCmd := &amp;cobra.Command{
                Use:   "list-region",
                Short: "This is list-region command for tumblebug utility",
                Long:  "This is list-region command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listRegionCmd</span>
}

// NewRegionSpiderGetCmd : "cbadm util get-region"
func NewRegionSpiderGetCmd() *cobra.Command <span class="cov8" title="1">{

        getRegionCmd := &amp;cobra.Command{
                Use:   "get-region",
                Short: "This is get-region command for tumblebug utility",
                Long:  "This is get-region command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --region parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--region parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getRegionCmd.PersistentFlags().StringVarP(&amp;regionName, "region", "", "", "region name")

        return getRegionCmd</span>
}

// NewMcirResourcesInspectCmd : "cbadm util inspect-mcir"
func NewMcirResourcesInspectCmd() *cobra.Command <span class="cov8" title="1">{

        inspectMcirCmd := &amp;cobra.Command{
                Use:   "inspect-mcir",
                Short: "This is inspect-mcir command for tumblebug utility",
                Long:  "This is inspect-mcir command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if resourceType == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --type parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--type parameter value : ", resourceType)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">inspectMcirCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        inspectMcirCmd.PersistentFlags().StringVarP(&amp;resourceType, "type", "", "", "resource type")

        return inspectMcirCmd</span>
}

// NewVmResourcesInspectCmd : "cbadm util inspect-vm"
func NewVmResourcesInspectCmd() *cobra.Command <span class="cov8" title="1">{

        inspectVmCmd := &amp;cobra.Command{
                Use:   "inspect-vm",
                Short: "This is inspect-vm command for tumblebug utility",
                Long:  "This is inspect-vm command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">inspectVmCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")

        return inspectVmCmd</span>
}

// NewObjectListCmd : "cbadm util list-obj"
func NewObjectListCmd() *cobra.Command <span class="cov8" title="1">{

        listObjCmd := &amp;cobra.Command{
                Use:   "list-obj",
                Short: "This is list-obj command for tumblebug utility",
                Long:  "This is list-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()

                        logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">listObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return listObjCmd</span>
}

// NewObjectGetCmd : "cbadm util get-obj"
func NewObjectGetCmd() *cobra.Command <span class="cov8" title="1">{

        getObjCmd := &amp;cobra.Command{
                Use:   "get-obj",
                Short: "This is get-obj command for tumblebug utility",
                Long:  "This is get-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if objKey == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --key parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return getObjCmd</span>
}

// NewObjectDeleteCmd : "cbadm util delete-obj"
func NewObjectDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteObjCmd := &amp;cobra.Command{
                Use:   "delete-obj",
                Short: "This is delete-obj command for tumblebug utility",
                Long:  "This is delete-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if objKey == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --key parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return deleteObjCmd</span>
}

// NewObjectDeleteAllCmd : "cbadm util delete-all-obj"
func NewObjectDeleteAllCmd() *cobra.Command <span class="cov8" title="1">{

        deleteAllObjCmd := &amp;cobra.Command{
                Use:   "delete-all-obj",
                Short: "This is delete-all-obj command for tumblebug utility",
                Long:  "This is delete-all-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if objKey == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --key parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteAllObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return deleteAllObjCmd</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVersionCmd : "cbadm version"
func NewVersionCmd() *cobra.Command <span class="cov8" title="1">{

        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "This is a version command for cbadm",
                Long:  "This is a version command for cbadm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("cbadm cli version %s\n", CLIVersion)
                }</span>,
        }

        <span class="cov8" title="1">return versionCmd</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewYamlApplyCmd : "cbadm apply" (create/update objects according to YAML description)
func NewYamlApplyCmd() *cobra.Command <span class="cov8" title="1">{

        yamlApplyCmd := &amp;cobra.Command{
                Use:   "apply",
                Short: "This is a apply command for yaml",
                Long:  "This is a apply command for yaml",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return yamlApplyCmd</span>
}

// NewYamlGetCmd : "cbadm get" (get objects according to YAML description)
func NewYamlGetCmd() *cobra.Command <span class="cov8" title="1">{

        yamlGetCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is a get command for yaml",
                Long:  "This is a get command for yaml",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return yamlGetCmd</span>
}

// NewYamlListCmd : "cbadm list" (list objects according to YAML description)
func NewYamlListCmd() *cobra.Command <span class="cov8" title="1">{

        yamlListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is a list command for yaml",
                Long:  "This is a list command for yaml",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return yamlListCmd</span>
}

// NewYamlRemoveCmd : "cbadm remove" (remove objects according to YAML description)
func NewYamlRemoveCmd() *cobra.Command <span class="cov8" title="1">{

        yamlRemoveCmd := &amp;cobra.Command{
                Use:     "remove",
                Aliases: []string{"rm", "delete"},
                Short:   "This is a remove command for yaml",
                Long:    "This is a remove command for yaml",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return yamlRemoveCmd</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package proc

import (
        "encoding/json"
        "fmt"

        sp_api "github.com/cloud-barista/cb-spider/interface/api"
        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
)

// ===== [ Constants and Variables ] =====

const (
        // ConfigVersion - version of config structs
        ConfigVersion = 1
)

// ===== [ Types ] =====

// ConnectInfosConfig
type ConnectInfosConfig struct {
        Version         int           `yaml:"Version" json:"Version"`
        ConnectInfoList []ConnectInfo `yaml:"ConnectInfos" json:"ConnectInfos"`
}

// ConnectInfo
type ConnectInfo struct {
        ConfigName   string         `yaml:"ConfigName" json:"ConfigName"`
        ProviderName string         `yaml:"ProviderName" json:"ProviderName"`
        Driver       DriverInfo     `yaml:"Driver" json:"Driver"`
        Credential   CredentialInfo `yaml:"Credential" json:"Credential"`
        Region       RegionInfo     `yaml:"Region" json:"Region"`
}

// DriverInfo
type DriverInfo struct {
        DriverName        string `yaml:"DriverName" json:"DriverName"`
        DriverLibFileName string `yaml:"DriverLibFileName" json:"DriverLibFileName"`
}

// CredentialInfo
type CredentialInfo struct {
        CredentialName   string         `yaml:"CredentialName" json:"CredentialName"`
        KeyValueInfoList []KeyValueInfo `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// RegionInfo
type RegionInfo struct {
        RegionName       string         `yaml:"RegionName" json:"RegionName"`
        KeyValueInfoList []KeyValueInfo `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// KeyValueInfo (Key-Value pair)
type KeyValueInfo struct {
        Key   string `yaml:"Key" json:"Key"`
        Value string `yaml:"Value" json:"Value"`
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ListConnectInfos : List Connection Infos recursively
func ListConnectInfos(cim *sp_api.CIMApi) (string, error) <span class="cov0" title="0">{

        holdType, _ := cim.GetOutType()
        cim.SetOutType("json")
        defer cim.SetOutType(holdType)

        result, err := cim.ListConnectionConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectConfigList := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;connectConfigList)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfoList := []ConnectInfo{}
        if connectConfigList["connectionconfig"] != nil </span><span class="cov0" title="0">{
                for _, m := range connectConfigList["connectionconfig"].([]interface{}) </span><span class="cov0" title="0">{

                        connectConfig := m.(map[string]interface{})

                        connectInfo := ConnectInfo{}
                        connectInfo.ConfigName = fmt.Sprintf("%v", connectConfig["ConfigName"])
                        connectInfo.ProviderName = fmt.Sprintf("%v", connectConfig["ProviderName"])

                        result, err := cim.GetCloudDriverByParam(fmt.Sprintf("%v", connectConfig["DriverName"]))
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">driverItem := make(map[string]interface{})
                        err = json.Unmarshal([]byte(result), &amp;driverItem)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfo.Driver.DriverName = fmt.Sprintf("%v", driverItem["DriverName"])
                        connectInfo.Driver.DriverLibFileName = fmt.Sprintf("%v", driverItem["DriverLibFileName"])

                        result, err = cim.GetCredentialByParam(fmt.Sprintf("%v", connectConfig["CredentialName"]))
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">credentialItem := make(map[string]interface{})
                        err = json.Unmarshal([]byte(result), &amp;credentialItem)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfo.Credential.CredentialName = fmt.Sprintf("%v", credentialItem["CredentialName"])
                        err = gc.CopySrcToDest(credentialItem["KeyValueInfoList"], &amp;connectInfo.Credential.KeyValueInfoList)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">result, err = cim.GetRegionByParam(fmt.Sprintf("%v", connectConfig["RegionName"]))
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">regionItem := make(map[string]interface{})
                        err = json.Unmarshal([]byte(result), &amp;regionItem)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfo.Region.RegionName = fmt.Sprintf("%v", regionItem["RegionName"])
                        err = gc.CopySrcToDest(regionItem["KeyValueInfoList"], &amp;connectInfo.Region.KeyValueInfoList)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfoList = append(connectInfoList, connectInfo)</span>
                }
        }

        <span class="cov0" title="0">var cfg ConnectInfosConfig
        cfg.Version = ConfigVersion
        cfg.ConnectInfoList = connectInfoList

        return gc.ConvertToOutput(holdType, &amp;cfg)</span>
}

// GetConnectInfos : Get Connection Info recursively
func GetConnectInfos(cim *sp_api.CIMApi, configName string) (string, error) <span class="cov0" title="0">{

        holdType, _ := cim.GetOutType()
        cim.SetOutType("json")
        defer cim.SetOutType(holdType)

        result, err := cim.GetConnectionConfigByParam(configName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectConfig := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;connectConfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfoList := []ConnectInfo{}

        connectInfo := ConnectInfo{}
        connectInfo.ConfigName = fmt.Sprintf("%v", connectConfig["ConfigName"])
        connectInfo.ProviderName = fmt.Sprintf("%v", connectConfig["ProviderName"])

        result, err = cim.GetCloudDriverByParam(fmt.Sprintf("%v", connectConfig["DriverName"]))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">driverItem := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;driverItem)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfo.Driver.DriverName = fmt.Sprintf("%v", driverItem["DriverName"])
        connectInfo.Driver.DriverLibFileName = fmt.Sprintf("%v", driverItem["DriverLibFileName"])

        result, err = cim.GetCredentialByParam(fmt.Sprintf("%v", connectConfig["CredentialName"]))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">credentialItem := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;credentialItem)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfo.Credential.CredentialName = fmt.Sprintf("%v", credentialItem["CredentialName"])
        err = gc.CopySrcToDest(credentialItem["KeyValueInfoList"], &amp;connectInfo.Credential.KeyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">result, err = cim.GetRegionByParam(fmt.Sprintf("%v", connectConfig["RegionName"]))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">regionItem := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;regionItem)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfo.Region.RegionName = fmt.Sprintf("%v", regionItem["RegionName"])
        err = gc.CopySrcToDest(regionItem["KeyValueInfoList"], &amp;connectInfo.Region.KeyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfoList = append(connectInfoList, connectInfo)

        var cfg ConnectInfosConfig
        cfg.Version = ConfigVersion
        cfg.ConnectInfoList = connectInfoList

        return gc.ConvertToOutput(holdType, &amp;cfg)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package proc

import (
        "encoding/json"
        "fmt"
        "io/ioutil"

        tb_api "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request"
)

// ===== [ Constants and Variables ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// SaveSshKey : Write keypair to file
func SaveSshKey(mcir *tb_api.MCIRApi, nameSpaceID string, resourceID string, sshSaveFileName string) (string, error) <span class="cov0" title="0">{

        holdType, _ := mcir.GetOutType()
        mcir.SetOutType("json")

        result, err := mcir.GetSshKeyByParam(nameSpaceID, resourceID)
        mcir.SetOutType(holdType)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">jsonMap := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">privateKey := fmt.Sprintf("%v", jsonMap["privateKey"])
        err = ioutil.WriteFile(sshSaveFileName, []byte(privateKey), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return "ssh key file saved", nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package proc

import (
        "encoding/json"
        "fmt"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        tb_api "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request"
)

// ===== [ Constants and Variables ] =====

// VMListInfo
type VMListInfo struct {
        Id   string   `yaml:"id" json:"id"`
        Name string   `yaml:"name" json:"name"`
        Vm   []string `yaml:"vm" json:"vm"`
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ListMcisVM
func ListMcisVM(mcis *tb_api.MCISApi, nameSpaceID string, mcisID string) (string, error) <span class="cov0" title="0">{

        holdType, _ := mcis.GetOutType()
        mcis.SetOutType("json")
        defer mcis.SetOutType(holdType)

        result, err := mcis.GetMcisInfoByParam(nameSpaceID, mcisID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">jsonMap := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">vmList := []string{}
        for _, m := range jsonMap["vm"].([]interface{}) </span><span class="cov0" title="0">{
                item := m.(map[string]interface{})
                vmList = append(vmList, fmt.Sprintf("%v", item["id"]))
        }</span>

        <span class="cov0" title="0">vmListInfo := VMListInfo{}
        vmListInfo.Id = fmt.Sprintf("%v", jsonMap["id"])
        vmListInfo.Name = fmt.Sprintf("%v", jsonMap["name"])
        vmListInfo.Vm = vmList

        outType, _ := mcis.GetOutType()
        return gc.ConvertToOutput(outType, &amp;vmListInfo)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package common

import (
        "errors"
        "io"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/jaegertracer"
        "github.com/opentracing/opentracing-go"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBConnection - CB-GRPC에서 사용하는 grpc 클라이언트를 위한 Wrapper 구조
type CBConnection struct {
        Conn *grpc.ClientConn
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBConnection - 초기화된 grpc 클라이언트의 인스턴스 생성
func NewCBConnection(gConf *config.GrpcClientConfig) (*CBConnection, io.Closer, error) <span class="cov0" title="0">{

        var (
                tracer opentracing.Tracer = nil
                closer io.Closer          = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc connection config is null")
        }</span>

        <span class="cov0" title="0">if gConf.ServerAddr == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("server addr is empty")
        }</span>

        <span class="cov0" title="0">opts := []grpc.DialOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewClientTLSFromFile(gConf.TLS.TLSCA, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov0" title="0"> {
                opts = append(opts, grpc.WithInsecure())
        }</span>

        // 인터셉터 설정
        <span class="cov0" title="0">unaryIntercepters := []grpc.UnaryClientInterceptor{}
        streamIntercepters := []grpc.StreamClientInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryClientInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamClientInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                        tracingOpts := []grpc_opentracing.Option{}
                        tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                        unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryClientInterceptor(tracingOpts...))
                        streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamClientInterceptor(tracingOpts...))
                }</span>

        }

        <span class="cov0" title="0">opts = append(opts, grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(unaryIntercepters...)))
        opts = append(opts, grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(streamIntercepters...)))

        maxSizeOption := grpc.MaxCallRecvMsgSize(1024 * 1024 * 1024) // 1 GB
        opts = append(opts, grpc.WithDefaultCallOptions(maxSizeOption))

        conn, err := grpc.Dial(gConf.ServerAddr, opts...)

        return &amp;CBConnection{Conn: conn}, closer, err</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package common

import (
        "encoding/json"
        "strings"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"

        "gopkg.in/yaml.v2"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====s

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvertToMessage - 입력 데이터를 grpc 메시지로 변환
func ConvertToMessage(inType string, inData string, obj interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if inType == "yaml" </span><span class="cov8" title="1">{
                err := yaml.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">if inType == "json" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("json Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertToOutput - grpc 메시지를 출력포맷으로 변환
func ConvertToOutput(outType string, obj interface{}) (string, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if outType == "yaml" </span><span class="cov8" title="1">{
                // 메시지 포맷에서 불필요한 필드(XXX_로 시작하는 필드)를 제거하기 위해 json 태그를 이용하여 마샬링
                j, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // yaml 에서 지원하지 않는 control character 제거
                <span class="cov8" title="1">cleanStr := strings.Map(func(value rune) rune </span><span class="cov8" title="1">{
                        switch </span>{
                        case value == 0x09:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0A:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0D:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x20 &amp;&amp; value &lt;= 0x7E:<span class="cov8" title="1">
                                return value</span>
                        case value == 0x85:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xA0 &amp;&amp; value &lt;= 0xD7FF:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xE000 &amp;&amp; value &lt;= 0xFFFD:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x10000 &amp;&amp; value &lt;= 0x10FFFF:<span class="cov0" title="0">
                                return value</span>
                        default:<span class="cov0" title="0">
                                return -1</span> // control characters are not allowed
                        }
                }, string(j))

                // 필드를 소팅하지 않고 지정된 순서대로 출력하기 위해 MapSlice 이용
                <span class="cov8" title="1">jsonObj := yaml.MapSlice{}
                err2 := yaml.Unmarshal([]byte(cleanStr), &amp;jsonObj)
                if err2 != nil </span><span class="cov0" title="0">{
                        return "", err2
                }</span>

                // yaml 마샬링
                <span class="cov8" title="1">y, err3 := yaml.Marshal(jsonObj)
                if err3 != nil </span><span class="cov0" title="0">{
                        return "", err3
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Marshal: \n", string(y))

                return string(y), nil</span>
        }

        <span class="cov8" title="1">if outType == "json" </span><span class="cov8" title="1">{
                j, err := json.MarshalIndent(obj, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">outStr := string(j)

                // json.Marshal 함수는  &lt;,&gt;, &amp; 문자를 escape 함.. 다시 원래대로 변환
                outStr = strings.Replace(outStr, "\\u003c", "&lt;", -1)
                outStr = strings.Replace(outStr, "\\u003e", "&gt;", -1)
                outStr = strings.Replace(outStr, "\\u0026", "&amp;", -1)

                logger.Debug("json Marshal: \n", outStr)
                return outStr, nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// CopySrcToDest - 소스에서 타켓으로 데이터 복사
func CopySrcToDest(src interface{}, dest interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        j, err := json.MarshalIndent(src, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("source value : \n", string(j))

        err = json.Unmarshal(j, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">j, err = json.MarshalIndent(dest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("target value : \n", string(j))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package common

import (
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/jaegertracer"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        opentracing "github.com/opentracing/opentracing-go"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBServer - CB-GRPC에서 사용하는 grpc 서버를 위한 Wrapper 구조
type CBServer struct {
        Server *grpc.Server
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBServer - 초기화된 grpc 서버의 인스턴스 생성
func NewCBServer(gConf *config.GrpcServerConfig) (*CBServer, io.Closer, error) <span class="cov8" title="1">{

        var (
                tracer      opentracing.Tracer             = nil
                closer      io.Closer                      = nil
                reg         *prometheus.Registry           = nil
                grpcMetrics *grpc_prometheus.ServerMetrics = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc server config is null")
        }</span>

        <span class="cov8" title="1">opts := []grpc.ServerOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(gConf.TLS.TLSCert, gConf.TLS.TLSKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        // 인터셉터 설정
        <span class="cov8" title="1">unaryIntercepters := []grpc.UnaryServerInterceptor{}
        streamIntercepters := []grpc.StreamServerInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamServerInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if gConf.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                                tracingOpts := []grpc_opentracing.Option{}
                                tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                                unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryServerInterceptor(tracingOpts...))
                                streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamServerInterceptor(tracingOpts...))
                        }</span>
                }

                // Prometheus Metrics 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{
                        grpcMetrics = grpc_prometheus.NewServerMetrics()
                        grpcMetrics.EnableHandlingTimeHistogram()

                        reg = prometheus.NewRegistry()
                        reg.MustRegister(grpcMetrics)
                        reg.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))
                        reg.MustRegister(prometheus.NewGoCollector())

                        unaryIntercepters = append(unaryIntercepters, grpcMetrics.UnaryServerInterceptor())
                        streamIntercepters = append(streamIntercepters, grpcMetrics.StreamServerInterceptor())
                }</span>

        }

        // recovery 인터셉터 기본 설정
        <span class="cov8" title="1">unaryIntercepters = append(unaryIntercepters, grpc_recovery.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_recovery.StreamServerInterceptor())

        opts = append(opts, grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(unaryIntercepters...)))
        opts = append(opts, grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(streamIntercepters...)))
        gs := grpc.NewServer(opts...)

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{
                if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{

                        // Create a HTTP server for prometheus.
                        httpServer := &amp;http.Server{
                                Handler: promhttp.HandlerFor(reg, promhttp.HandlerOpts{}),
                                Addr:    fmt.Sprintf("0.0.0.0:%d", gConf.Interceptors.PrometheusMetrics.ListenPort),
                        }
                        // Initialize all metrics.
                        grpcMetrics.InitializeMetrics(gs)
                        // Start your http server for prometheus.
                        go func() </span><span class="cov0" title="0">{
                                if err := httpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                                        log.Fatal("Unable to start a http server for prometheus.")
                                }</span>
                        }()

                }
        }

        <span class="cov8" title="1">return &amp;CBServer{Server: gs}, closer, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package common

import (
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvGrpcStatusErr - GRPC 상태 코드 에러로 변환
func ConvGrpcStatusErr(err error, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        if err != nil </span><span class="cov0" title="0">{
                if errStatus, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        logger.Error(tag, " error while calling ", method, " method: ", errStatus.Message())
                        return status.Errorf(errStatus.Code(), "%s error while calling %s method: %v ", tag, method, errStatus.Message())
                }</span>
                <span class="cov0" title="0">logger.Error(tag, " error while calling ", method, " method: ", err)
                return status.Errorf(codes.Internal, "%s error while calling %s method: %v ", tag, method, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewGrpcStatusErr - GRPC 상태 코드 에러 생성
func NewGrpcStatusErr(msg string, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Error(tag, " error while calling ", method, " method: ", msg)
        return status.Errorf(codes.Internal, "%s error while calling %s method: %s ", tag, method, msg)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package config - Configuration for Cloud-Barista's GRPC and provides the required process
package config

import (
        "fmt"
        "log"
        "os"
        "strings"
        "time"
)

// ===== [ Constants and Variables ] =====

const (
        // ConfigVersion - 설정 구조에 대한 버전
        ConfigVersion = 1
)

// ===== [ Types ] =====

// GrpcConfig - CB-GRPC 서비스 설정 구조
type GrpcConfig struct {
        Version int             `mapstructure:"version"`
        GSL     GrpcServiceList `mapstructure:"grpc"`
}

// GrpcServiceList - CB-GRPC 서비스 목록
type GrpcServiceList struct {
        TumblebugSrv *GrpcServerConfig `mapstructure:"tumblebugsrv"`
        TumblebugCli *GrpcClientConfig `mapstructure:"tumblebugcli"`
        SpiderCli    *GrpcClientConfig `mapstructure:"spidercli"`
}

// GrpcServerConfig - CB-GRPC 서버 설정 구조
type GrpcServerConfig struct {
        Addr         string              `mapstructure:"addr"`
        Reflection   string              `mapstructure:"reflection"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// GrpcClientConfig - CB-GRPC 클라이언트 설정 구조
type GrpcClientConfig struct {
        ServerAddr   string              `mapstructure:"server_addr"`
        Timeout      time.Duration       `mapstructure:"timeout"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// TLSConfig - TLS 설정 구조
type TLSConfig struct {
        TLSCert string `mapstructure:"tls_cert"`
        TLSKey  string `mapstructure:"tls_key"`
        TLSCA   string `mapstructure:"tls_ca"`
}

// InterceptorsConfig - GRPC 인터셉터 설정 구조
type InterceptorsConfig struct {
        AuthJWT           *AuthJWTConfig           `mapstructure:"auth_jwt"`
        PrometheusMetrics *PrometheusMetricsConfig `mapstructure:"prometheus_metrics"`
        Opentracing       *OpentracingConfig       `mapstructure:"opentracing"`
}

// AuthJWTConfig - AuthJWT 설정 구조
type AuthJWTConfig struct {
        JWTKey   string `mapstructure:"jwt_key"`
        JWTToken string `mapstructure:"jwt_token"`
}

// PrometheusMetricsConfig - Prometheus Metrics 설정 구조
type PrometheusMetricsConfig struct {
        ListenPort int `mapstructure:"listen_port"`
}

// OpentracingConfig - Opentracing 설정 구조
type OpentracingConfig struct {
        Jaeger *JaegerClientConfig `mapstructure:"jaeger"`
}

// JaegerClientConfig - Jaeger Client 설정 구조
type JaegerClientConfig struct {
        Endpoint    string  `mapstructure:"endpoint"`
        ServiceName string  `mapstructure:"service_name"`
        SampleRate  float64 `mapstructure:"sample_rate"`
}

// UnsupportedVersionError - 설정 초기화 과정에서 버전 검증을 통해 반환할 오류 구조
type UnsupportedVersionError struct {
        Have int
        Want int
}

// ===== [ Implementations ] =====

// Init - 설정에 대한 검사 및 초기화
func (gConf *GrpcConfig) Init() error <span class="cov8" title="1">{
        // 설정 파일 버전 검증
        if gConf.Version != ConfigVersion </span><span class="cov0" title="0">{
                return &amp;UnsupportedVersionError{
                        Have: gConf.Version,
                        Want: ConfigVersion,
                }
        }</span>
        // 전역변수 초기화
        <span class="cov8" title="1">gConf.initGlobalParams()

        return nil</span>
}

// initGlobalParams - 전역 설정 초기화
func (gConf *GrpcConfig) initGlobalParams() <span class="cov8" title="1">{

        if gConf.GSL.TumblebugSrv != nil </span><span class="cov8" title="1">{

                if gConf.GSL.TumblebugSrv.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.TumblebugSrv.TLS.TLSCert != "" </span><span class="cov0" title="0">{
                                gConf.GSL.TumblebugSrv.TLS.TLSCert = ReplaceEnvPath(gConf.GSL.TumblebugSrv.TLS.TLSCert)
                        }</span>
                        <span class="cov0" title="0">if gConf.GSL.TumblebugSrv.TLS.TLSKey != "" </span><span class="cov0" title="0">{
                                gConf.GSL.TumblebugSrv.TLS.TLSKey = ReplaceEnvPath(gConf.GSL.TumblebugSrv.TLS.TLSKey)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.TumblebugSrv.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.TumblebugSrv.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.TumblebugSrv.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.TumblebugSrv.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.TumblebugSrv.Interceptors.Opentracing.Jaeger.ServiceName = "tumblebug grpc server"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.TumblebugSrv.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.TumblebugSrv.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

        <span class="cov8" title="1">if gConf.GSL.TumblebugCli != nil </span><span class="cov8" title="1">{

                if gConf.GSL.TumblebugCli.Timeout == 0 </span><span class="cov8" title="1">{
                        gConf.GSL.TumblebugCli.Timeout = 90 * time.Second
                }</span>

                <span class="cov8" title="1">if gConf.GSL.TumblebugCli.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.TumblebugCli.TLS.TLSCA != "" </span><span class="cov0" title="0">{
                                gConf.GSL.TumblebugCli.TLS.TLSCA = ReplaceEnvPath(gConf.GSL.TumblebugCli.TLS.TLSCA)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.TumblebugCli.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.TumblebugCli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.TumblebugCli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.TumblebugCli.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.TumblebugCli.Interceptors.Opentracing.Jaeger.ServiceName = "tumblebug grpc client"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.TumblebugCli.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.TumblebugCli.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

        <span class="cov8" title="1">if gConf.GSL.SpiderCli != nil </span><span class="cov8" title="1">{

                if gConf.GSL.SpiderCli.Timeout == 0 </span><span class="cov8" title="1">{
                        gConf.GSL.SpiderCli.Timeout = 90 * time.Second
                }</span>

                <span class="cov8" title="1">if gConf.GSL.SpiderCli.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderCli.TLS.TLSCA != "" </span><span class="cov0" title="0">{
                                gConf.GSL.SpiderCli.TLS.TLSCA = ReplaceEnvPath(gConf.GSL.SpiderCli.TLS.TLSCA)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.SpiderCli.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderCli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.ServiceName = "grpc spider client"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

}

// Error - 비 호환 버전에 대한 오류 문자열 반환
func (u *UnsupportedVersionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Unsupported version: %d (wanted: %d)", u.Have, u.Want)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ReplaceEnvPath - $ABC/def ==&gt; /abc/def
func ReplaceEnvPath(str string) string <span class="cov0" title="0">{
        if strings.Index(str, "$") == -1 </span><span class="cov0" title="0">{
                return str
        }</span>

        // ex) input "$CBSTORE_ROOT/meta_db/dat"
        <span class="cov0" title="0">strList := strings.Split(str, "/")
        for n, one := range strList </span><span class="cov0" title="0">{
                if strings.Index(one, "$") != -1 </span><span class="cov0" title="0">{
                        cbstoreRootPath := os.Getenv(strings.Trim(one, "$"))
                        if cbstoreRootPath == "" </span><span class="cov0" title="0">{
                                log.Fatal(one + " is not set!")
                        }</span>
                        <span class="cov0" title="0">strList[n] = cbstoreRootPath</span>
                }
        }

        <span class="cov0" title="0">var resultStr string
        for _, one := range strList </span><span class="cov0" title="0">{
                resultStr = resultStr + one + "/"
        }</span>
        // ex) "/root/go/src/github.com/cloud-barista/cb-spider/meta_db/dat/"
        <span class="cov0" title="0">resultStr = strings.TrimRight(resultStr, "/")
        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        return resultStr</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package config

import (
        "fmt"
        "os"
        "reflect"
        "unsafe"

        "github.com/spf13/viper"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Parser - Viper lib를 활용하기 위한 Parser 정의 구조 형식
type Parser struct {
        viper *viper.Viper
}

// ===== [ Implementations ] =====

// GrpcParse - Viper lib를 이용해서 지정된 CB-GRPC configuration 정보 파싱
func (p Parser) GrpcParse(configFile string) (GrpcConfig, error) <span class="cov8" title="1">{
        p.viper.SetConfigFile(configFile)
        p.viper.AutomaticEnv()
        p.viper.SetConfigType("yaml")

        var cfg GrpcConfig

        // Reading
        if err := p.viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Unmarshal to struct
        <span class="cov8" title="1">if err := p.viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Initialize
        <span class="cov8" title="1">if err := cfg.Init(); err != nil </span><span class="cov0" title="0">{
                return cfg, CheckErr(err, configFile)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// ===== [ Private Functions ] =====

// checkErr - Viper lib 처리에서 발생한 오류 반환 (Nested call)
func checkErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case viper.ConfigParseError:<span class="cov0" title="0">
                var subErr error
                re := reflect.ValueOf(&amp;e).Elem()
                rf := re.Field(0)
                rse := reflect.ValueOf(&amp;subErr).Elem()
                rf = reflect.NewAt(rf.Type(), unsafe.Pointer(rf.UnsafeAddr())).Elem()
                rse.Set(rf)
                return checkErr(subErr, configFile)</span>
        default:<span class="cov0" title="0">
                return CheckErr(err, configFile)</span>
        }
}

// ===== [ Public Functions ] =====

// CheckErr - 검증된 오류 정보 반환
func CheckErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case *os.PathError:<span class="cov0" title="0">
                return fmt.Errorf("'%s' (%s): %s", configFile, e.Op, e.Err.Error())</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("'%s': %v", configFile, err)</span>
        }
}

// MakeParser - Viber lib를 활용하는 설정 Parser 생성
func MakeParser() Parser <span class="cov8" title="1">{
        return Parser{viper.New()}
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - rpc unary call 정보를 기록하는 클라이언트 인터셉터
func UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := invoker(ctx, method, req, reply, cc, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client unary call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return err
        }</span>
}

// StreamClientInterceptor - rpc stream call 정보를 기록하는 클라이언트 인터셉터
func StreamClientInterceptor() grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                clientStream, err := streamer(ctx, desc, cc, method, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client stream call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return clientStream, err
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/peer"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - rpc unary receive 정보를 기록하는 서버 인터셉터
func UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                startTime := time.Now()
                resp, err := handler(ctx, req)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(ctx); ok </span><span class="cov8" title="1">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov8" title="1">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server unary received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return resp, err</span>
        }
}

// StreamServerInterceptor - rpc stream receive 정보를 기록하는 서버 인터셉터
func StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov8" title="1">{
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := handler(srv, stream)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(stream.Context()); ok </span><span class="cov0" title="0">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov0" title="0">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server stream received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package authjwt

import (
        "context"
        "fmt"
        "time"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        "github.com/golang-jwt/jwt/v4"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

func validateToken(ctx context.Context) (bool, error) <span class="cov0" title="0">{

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.InvalidArgument, "Retrieving metadata is failed")
        }</span>

        <span class="cov0" title="0">authHeader, ok := md["authorization"]
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Authorization jwt token is not supplied")
        }</span>

        <span class="cov0" title="0">tokenStr := authHeader[0]

        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(jwtKey), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Parsing jwt token is failed")
        }</span>

        <span class="cov0" title="0">if token.Valid </span><span class="cov0" title="0">{
                logger := logger.NewLogger()
                var tokenInfo string = "{"
                for key, val := range claims </span><span class="cov0" title="0">{
                        if key == "expire" </span><span class="cov0" title="0">{

                                if getTokenRemainingValidity(val) &lt; 0 </span><span class="cov0" title="0">{
                                        return false, status.Errorf(codes.Unauthenticated, "token is expired")
                                }</span>

                                <span class="cov0" title="0">var timestamp interface{} = val
                                t := time.Unix(int64(timestamp.(float64)), 0)
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %d-%02d-%02dT%02d:%02d:%02d, remainder seconds: %d,", key,
                                        t.Year(), t.Month(), t.Day(),
                                        t.Hour(), t.Minute(), t.Second(),
                                        getTokenRemainingValidity(val),
                                )</span>

                        } else<span class="cov0" title="0"> {
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %v,", key, val)
                        }</span>
                }
                <span class="cov0" title="0">tokenInfo = tokenInfo + " }"
                logger.Debug("token parsing result : ", tokenInfo)

                return true, nil</span>
        }

        <span class="cov0" title="0">return false, status.Errorf(codes.Unauthenticated, "Authorization is failed")</span>
}

func getTokenRemainingValidity(timestamp interface{}) int <span class="cov0" title="0">{
        if validity, ok := timestamp.(float64); ok </span><span class="cov0" title="0">{
                tm := time.Unix(int64(validity), 0)
                remainder := tm.Sub(time.Now())

                return int(remainder.Seconds())
        }</span>
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtToken = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - JWT 토큰을 전달하는 Unary 클라이언트 인터셉터
func UnaryClientInterceptor(token string) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return invoker(ctx, method, req, reply, cc, opts...)</span>
        }
}

// StreamClientInterceptor - JWT 토큰을 전달하는 Stream 클라이언트 인터셉터
func StreamClientInterceptor(token string) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return streamer(ctx, desc, cc, method, opts...)</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtKey = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - authentication 을 처리하는 Unary 서버 인터셉터
func UnaryServerInterceptor(key string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// StreamServerInterceptor - authentication 을 처리하는 Stream 서버 인터셉터
func StreamServerInterceptor(key string) grpc.StreamServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(stream.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return handler(srv, stream)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package jaegertracer

import (
        "fmt"
        "io"

        opentracing "github.com/opentracing/opentracing-go"
        jaeger "github.com/uber/jaeger-client-go"
        config "github.com/uber/jaeger-client-go/config"

        grpcconfig "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
)

// InitJaeger - Jaeger Tracer 초기화
func InitJaeger(jcConf *grpcconfig.JaegerClientConfig) (opentracing.Tracer, io.Closer) <span class="cov0" title="0">{
        cfg := &amp;config.Configuration{
                Sampler: &amp;config.SamplerConfig{
                        Type:  "probabilistic",
                        Param: jcConf.SampleRate,
                },
                Reporter: &amp;config.ReporterConfig{
                        LocalAgentHostPort: jcConf.Endpoint,
                },
        }
        tracer, closer, err := cfg.New(jcConf.ServiceName, config.Logger(jaeger.NullLogger))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))</span>
        }
        <span class="cov0" title="0">return tracer, closer</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package logger

import (
        "io"
        "io/ioutil"
        "os"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Logger - CB-LOG에서 사용하는 "logrus" Logger를 위한 Wrapper 구조
type Logger struct {
        *logrus.Logger
}

// ===== [ Implementations ] =====

// SetOutput - 로그 출력기 설정
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.Logger.Out = w
}</span>

// DisableOutput - 로그 출력 비활성화
func (l *Logger) DisableOutput() <span class="cov0" title="0">{
        l.SetOutput(ioutil.Discard)
}</span>

// SetFormatter - 로그 포맷터 설정
func (l *Logger) SetFormatter(f logrus.Formatter) <span class="cov0" title="0">{
        l.Logger.Formatter = f
}</span>

// SetLogLevel - 로그 레벨 설정
func (l *Logger) SetLogLevel(lv logrus.Level) <span class="cov0" title="0">{
        l.Logger.SetLevel(lv)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewLogger - 초기화된 Logger의 인스턴스 생성
func NewLogger() *Logger <span class="cov8" title="1">{
        // CBLOG_ROOT 환경변수가 설정되어 있지 않으면 현재 경로로 환경변수 설정)
        env := os.Getenv("CBLOG_ROOT")
        if env == "" </span><span class="cov0" title="0">{
                if dir, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                        os.Setenv("CBLOG_ROOT", dir)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Logger{
                Logger: cblog.GetLogger("CB-GRPC"),
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package common

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateConfig - Config 생성
func (r *UtilityRequest) CreateConfig() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ConfigReq
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateConfig(ctx, &amp;pb.ConfigCreateRequest{Item: &amp;item})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListConfig - Config 목록
func (r *UtilityRequest) ListConfig() (string, error) <span class="cov8" title="1">{

        // Request to server
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListConfig(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetConfig - Config 조회
func (r *UtilityRequest) GetConfig() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ConfigQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetConfig(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// InitConfig
func (r *UtilityRequest) InitConfig() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ConfigQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.InitConfig(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// InitAllConfig - Config 전체 삭제
func (r *UtilityRequest) InitAllConfig() (string, error) <span class="cov8" title="1">{

        // Request to server
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.InitAllConfig(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file34" style="display: none">package common

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateNS - Namespace 생성
func (r *NSRequest) CreateNS() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.NsReq
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateNS(ctx, &amp;pb.NSCreateRequest{Item: &amp;item})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListNS - Namespace 목록
func (r *NSRequest) ListNS() (string, error) <span class="cov8" title="1">{
        // Request to server
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListNS(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListNSId
func (r *NSRequest) ListNSId() (string, error) <span class="cov8" title="1">{
        // Request to server
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListNSId(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetNS - Namespace 조회
func (r *NSRequest) GetNS() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.NSQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetNS(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteNS - Namespace 삭제
func (r *NSRequest) DeleteNS() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.NSQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteNS(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllNS - Namespace 전체 삭제
func (r *NSRequest) DeleteAllNS() (string, error) <span class="cov8" title="1">{
        // Request to server
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllNS(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// CheckNS - Namespace 체크
func (r *NSRequest) CheckNS() (string, error) <span class="cov0" title="0">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov0" title="0">var item pb.NSQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CheckNS(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file35" style="display: none">package common

import (
        "context"
        "encoding/json"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListConnConfig
func (r *UtilityRequest) ListConnConfig() (string, error) <span class="cov8" title="1">{
        // Request to server
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListConnConfig(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetConnConfig
func (r *UtilityRequest) GetConnConfig() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ConnConfigQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetConnConfig(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListRegion
func (r *UtilityRequest) ListRegion() (string, error) <span class="cov8" title="1">{
        // Request to server
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListRegion(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetRegion
func (r *UtilityRequest) GetRegion() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.RegionQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetRegion(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// InspectMcirResources
func (r *UtilityRequest) InspectMcirResources() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.InspectQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.InspectMcirResources(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// InspectVmResources
func (r *UtilityRequest) InspectVmResources() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.InspectQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.InspectVmResources(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListObject
func (r *UtilityRequest) ListObject() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ObjectQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListObject(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetObject
func (r *UtilityRequest) GetObject() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ObjectQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetObject(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var contentJSON map[string]interface{}
        json.Unmarshal([]byte(resp.Item), &amp;contentJSON)

        // Marshal (Response -&gt; json/yaml)
        return gc.ConvertToOutput(r.OutType, &amp;contentJSON)</span>
}

// DeleteObject
func (r *UtilityRequest) DeleteObject() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ObjectQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteObject(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllObject
func (r *UtilityRequest) DeleteAllObject() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ObjectQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllObject(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file36" style="display: none">package mcir

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CheckResource - Check whether Resource exists or not
func (r *MCIRRequest) CheckResource() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CheckResource(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file37" style="display: none">package mcir

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateImageWithInfo
func (r *MCIRRequest) CreateImageWithInfo() (string, error) <span class="cov0" title="0">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov0" title="0">var item pb.TbImageInfoRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateImageWithInfo(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// CreateImageWithID
func (r *MCIRRequest) CreateImageWithID() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbImageCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateImageWithID(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListImage
func (r *MCIRRequest) ListImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListImageId
func (r *MCIRRequest) ListImageId() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListImageId(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetImage
func (r *MCIRRequest) GetImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteImage
func (r *MCIRRequest) DeleteImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllImage
func (r *MCIRRequest) DeleteAllImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// FetchImage
func (r *MCIRRequest) FetchImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.FetchImageQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.FetchImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// SearchImage
func (r *MCIRRequest) SearchImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.SearchImageQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.SearchImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListLookupImage - LookupImages
func (r *MCIRRequest) ListLookupImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.LookupImageListQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListLookupImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetLookupImage - LookupImage
func (r *MCIRRequest) GetLookupImage() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.LookupImageQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetLookupImage(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file38" style="display: none">package mcir

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSecurityGroup
func (r *MCIRRequest) CreateSecurityGroup() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbSecurityGroupCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateSecurityGroup(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListSecurityGroup
func (r *MCIRRequest) ListSecurityGroup() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSecurityGroup(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListSecurityGroupId
func (r *MCIRRequest) ListSecurityGroupId() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSecurityGroupId(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetSecurityGroup
func (r *MCIRRequest) GetSecurityGroup() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetSecurityGroup(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteSecurityGroup
func (r *MCIRRequest) DeleteSecurityGroup() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteSecurityGroup(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllSecurityGroup
func (r *MCIRRequest) DeleteAllSecurityGroup() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllSecurityGroup(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file39" style="display: none">package mcir

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSpecWithInfo
func (r *MCIRRequest) CreateSpecWithInfo() (string, error) <span class="cov0" title="0">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov0" title="0">var item pb.TbSpecInfoRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateSpecWithInfo(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// CreateSpecWithSpecName
func (r *MCIRRequest) CreateSpecWithSpecName() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbSpecCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateSpecWithSpecName(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListSpec
func (r *MCIRRequest) ListSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListSpecId
func (r *MCIRRequest) ListSpecId() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSpecId(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetSpec
func (r *MCIRRequest) GetSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteSpec
func (r *MCIRRequest) DeleteSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllSpec
func (r *MCIRRequest) DeleteAllSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// FetchSpec
func (r *MCIRRequest) FetchSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.FetchSpecQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.FetchSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// FilterSpec
func (r *MCIRRequest) FilterSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbSpecInfoRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.FilterSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// FilterSpecsByRange
func (r *MCIRRequest) FilterSpecsByRange() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.FilterSpecsByRangeRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.FilterSpecsByRange(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// SortSpecs
func (r *MCIRRequest) SortSpecs() (string, error) <span class="cov0" title="0">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov0" title="0">var item pb.SortSpecsRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.SortSpecs(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// UpdateSpec
func (r *MCIRRequest) UpdateSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbSpecInfoRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.UpdateSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListLookupSpec - LookupSpecs
func (r *MCIRRequest) ListLookupSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.LookupSpecListQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListLookupSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetLookupSpec - LookupSpec
func (r *MCIRRequest) GetLookupSpec() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.LookupSpecQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetLookupSpec(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file40" style="display: none">package mcir

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSshKey
func (r *MCIRRequest) CreateSshKey() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbSshKeyCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateSshKey(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListSshKey
func (r *MCIRRequest) ListSshKey() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSshKey(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListSshKeyId
func (r *MCIRRequest) ListSshKeyId() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSshKeyId(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetSshKey
func (r *MCIRRequest) GetSshKey() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetSshKey(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteSshKey
func (r *MCIRRequest) DeleteSshKey() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteSshKey(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllSshKey
func (r *MCIRRequest) DeleteAllSshKey() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllSshKey(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file41" style="display: none">package mcir

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateVNet
func (r *MCIRRequest) CreateVNet() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVNetCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateVNet(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListVNet
func (r *MCIRRequest) ListVNet() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListVNet(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListVNetId
func (r *MCIRRequest) ListVNetId() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListVNetId(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVNet
func (r *MCIRRequest) GetVNet() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetVNet(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteVNet
func (r *MCIRRequest) DeleteVNet() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteVNet(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllVNet
func (r *MCIRRequest) DeleteAllVNet() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.ResourceAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllVNet(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file42" style="display: none">package request

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcir"

        core_mcir "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"

        "google.golang.org/grpc"
)

// ===== [ Comtants and Variables ] =====

// ===== [ Types ] =====

// MCIRApi
type MCIRApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientMCIR   pb.MCIRClient
        requestMCIR  *mcir.MCIRRequest
        inType       string
        outType      string
}

// KeyValue
type KeyValue struct {
        Key   string `yaml:"Key" json:"Key"`
        Value string `yaml:"Value" json:"Value"`
}

// IID - Defined by &amp; used for CB-Spider
type IID struct {
        NameId   string `yaml:"NameId" json:"NameId"`
        SystemId string `yaml:"SystemId" json:"SystemId"`
}

// TbImageCreateRequest - Wrapper struct
type TbImageCreateRequest struct {
        NsId string               `yaml:"nsId" json:"nsId"`
        Item core_mcir.TbImageReq `yaml:"image" json:"image"`
}

// TbImageReq
// type TbImageReq struct {
//         Name           string `yaml:"name" json:"name"`
//         ConnectionName string `yaml:"connectionName" json:"connectionName"`
//         CspImageId     string `yaml:"cspImageId" json:"cspImageId"`
//         Description    string `yaml:"description" json:"description"`
// }

// TbImageInfoRequest - Wrapper struct
type TbImageInfoRequest struct {
        NsId string                `yaml:"nsId" json:"nsId"`
        Item core_mcir.TbImageInfo `yaml:"image" json:"image"`
}

// TbImageInfo
// type TbImageInfo struct {
//         Id                   string     `yaml:"id" json:"id"`
//         Name                 string     `yaml:"name" json:"name"`
//         ConnectionName       string     `yaml:"connectionName" json:"connectionName"`
//         CspImageId           string     `yaml:"cspImageId" json:"cspImageId"`
//         CspImageName         string     `yaml:"cspImageName" json:"cspImageName"`
//         Description          string     `yaml:"description" json:"description"`
//         CreationDate         string     `yaml:"creationDate" json:"creationDate"`
//         GuestOS              string     `yaml:"guestOS" json:"guestOS"`
//         Status               string     `yaml:"status" json:"status"`
//         KeyValueList         []KeyValue `yaml:"keyValueList" json:"keyValueList"`
//         AssociatedObjectList []string   `yaml:"associatedObjectList" json:"associatedObjectList"`
//         IsAutoGenerated      bool       `yaml:"isAutoGenerated" json:"isAutoGenerated"`
// }

// SearchImageQryRequest - Wrapper struct
type SearchImageQryRequest struct {
        NsId     string   `yaml:"nsId" json:"nsId"`
        Keywords []string `yaml:"keywords" json:"keywords"`
}

// TbSecurityGroupCreateRequest - Wrapper struct
type TbSecurityGroupCreateRequest struct {
        NsId string                       `yaml:"nsId" json:"nsId"`
        Item core_mcir.TbSecurityGroupReq `yaml:"securityGroup" json:"securityGroup"`
}

// TbSecurityGroupReq
// type TbSecurityGroupReq struct { // Tumblebug
//         Name           string                    `yaml:"name" json:"name"`
//         ConnectionName string                    `yaml:"connectionName" json:"connectionName"`
//         VNetId         string                    `yaml:"vNetId" json:"vNetId"`
//         Description    string                    `yaml:"description" json:"description"`
//         FirewallRules  *[]SpiderSecurityRuleInfo `yaml:"firewallRules" json:"firewallRules"`
// }

// SpiderSecurityRuleInfo
// type SpiderSecurityRuleInfo struct { // Spider
//         FromPort   string `yaml:"fromPort" json:"fromPort"`
//         ToPort     string `yaml:"toPort" json:"toPort"`
//         IPProtocol string `yaml:"ipProtocol" json:"ipProtocol"`
//         Direction  string `yaml:"direction" json:"direction"`
//         CIDR       string `yaml:"cidr" json:"cidr"`
// }

// TbSpecCreateRequest - Wrapper struct
type TbSpecCreateRequest struct {
        NsId string              `yaml:"nsId" json:"nsId"`
        Item core_mcir.TbSpecReq `yaml:"spec" json:"spec"`
}

// TbSpecReq
// type TbSpecReq struct { // Tumblebug
//         Name           string `yaml:"name" json:"name"`
//         ConnectionName string `yaml:"connectionName" json:"connectionName"`
//         CspSpecName    string `yaml:"cspSpecName" json:"cspSpecName"`
//         Description    string `yaml:"description" json:"description"`
// }

// TbSpecInfoRequest - Wrapper struct
type TbSpecInfoRequest struct {
        NsId string               `yaml:"nsId" json:"nsId"`
        Item core_mcir.TbSpecInfo `yaml:"spec" json:"spec"`
}

// TbSpecInfo
// type TbSpecInfo struct { // Tumblebug
//         Id                    string   `yaml:"id" json:"id"`
//         Name                  string   `yaml:"name" json:"name"`
//         ConnectionName        string   `yaml:"connectionName" json:"connectionName"`
//         CspSpecName           string   `yaml:"cspSpecName" json:"cspSpecName"`
//         Os_type               string   `yaml:"os_type" json:"os_type"`
//         Num_vCPU              uint16   `yaml:"num_vCPU" json:"num_vCPU"`
//         Num_core              uint16   `yaml:"num_core" json:"num_core"`
//         Mem_GiB               uint16   `yaml:"mem_GiB" json:"mem_GiB"`
//         Storage_GiB           uint32   `yaml:"storage_GiB" json:"storage_GiB"`
//         Description           string   `yaml:"description" json:"description"`
//         Cost_per_hour         float32  `yaml:"cost_per_hour" json:"cost_per_hour"`
//         Num_storage           uint8    `yaml:"num_storage" json:"num_storage"`
//         Max_num_storage       uint8    `yaml:"max_num_storage" json:"max_num_storage"`
//         Max_total_storage_TiB uint16   `yaml:"max_total_storage_TiB" json:"max_total_storage_TiB"`
//         Net_bw_Gbps           uint16   `yaml:"net_bw_Gbps" json:"net_bw_Gbps"`
//         Ebs_bw_Mbps           uint32   `yaml:"ebs_bw_Mbps" json:"ebs_bw_Mbps"`
//         Gpu_model             string   `yaml:"gpu_model" json:"gpu_model"`
//         Num_gpu               uint8    `yaml:"num_gpu" json:"num_gpu"`
//         Gpumem_GiB            uint16   `yaml:"gpumem_GiB" json:"gpumem_GiB"`
//         Gpu_p2p               string   `yaml:"gpu_p2p" json:"gpu_p2p"`
//         OrderInFilteredResult uint16   `yaml:"orderInFilteredResult" json:"orderInFilteredResult"`
//         EvaluationStatus      string   `yaml:"evaluationStatus" json:"evaluationStatus"`
//         EvaluationScore_01    float32  `yaml:"evaluationScore_01" json:"evaluationScore_01"`
//         EvaluationScore_02    float32  `yaml:"evaluationScore_02" json:"evaluationScore_02"`
//         EvaluationScore_03    float32  `yaml:"evaluationScore_03" json:"evaluationScore_03"`
//         EvaluationScore_04    float32  `yaml:"evaluationScore_04" json:"evaluationScore_04"`
//         EvaluationScore_05    float32  `yaml:"evaluationScore_05" json:"evaluationScore_05"`
//         EvaluationScore_06    float32  `yaml:"evaluationScore_06" json:"evaluationScore_06"`
//         EvaluationScore_07    float32  `yaml:"evaluationScore_07" json:"evaluationScore_07"`
//         EvaluationScore_08    float32  `yaml:"evaluationScore_08" json:"evaluationScore_08"`
//         EvaluationScore_09    float32  `yaml:"evaluationScore_09" json:"evaluationScore_09"`
//         EvaluationScore_10    float32  `yaml:"evaluationScore_10" json:"evaluationScore_10"`
//         AssociatedObjectList  []string `yaml:"associatedObjectList" json:"associatedObjectList"`
//         IsAutoGenerated       bool     `yaml:"isAutoGenerated" json:"isAutoGenerated"`
// }

// TbSshKeyCreateRequest - Wrapper struct
type TbSshKeyCreateRequest struct {
        NsId string                `yaml:"nsId" json:"nsId"`
        Item core_mcir.TbSshKeyReq `yaml:"sshKey" json:"sshKey"`
}

// TbSshKeyReq
// type TbSshKeyReq struct {
//         Name           string `yaml:"name" json:"name"`
//         ConnectionName string `yaml:"connectionName" json:"connectionName"`
//         Description    string `yaml:"description" json:"description"`
// }

// TbVNetCreateRequest - Wrapper struct
type TbVNetCreateRequest struct {
        NsId string              `yaml:"nsId" json:"nsId"`
        Item core_mcir.TbVNetReq `yaml:"vNet" json:"vNet"`
}

// TbVNetReq
// type TbVNetReq struct { // Tumblebug
//         Name           string                `yaml:"name" json:"name"`
//         ConnectionName string                `yaml:"connectionName" json:"connectionName"`
//         CidrBlock      string                `yaml:"cidrBlock" json:"cidrBlock"`
//         SubnetInfoList []SpiderSubnetReqInfo `yaml:"subnetInfoList" json:"subnetInfoList"`
//         Description    string                `yaml:"description" json:"description"`
// }

// SpiderSubnetReqInfo
// type SpiderSubnetReqInfo struct { // Spider
//         Name         string     `yaml:"Name" json:"Name"`
//         IPv4_CIDR    string     `yaml:"IPv4_CIDR" json:"IPv4_CIDR"`
//         KeyValueList []KeyValue `yaml:"KeyValueList" json:"KeyValueList"`
// }

// ===== [ Implementatiom ] =====

// SetServerAddr - Set Tumblebug server address
func (m *MCIRApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.TumblebugCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Get Tumblebug server address
func (m *MCIRApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return m.gConf.GSL.TumblebugCli.ServerAddr, nil
}</span>

// SetTLSCA - Set TLS CA
func (m *MCIRApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov8" title="1">{
                m.gConf.GSL.TumblebugCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.TumblebugCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - Get TLS CA
func (m *MCIRApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if m.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return m.gConf.GSL.TumblebugCli.TLS.TLSCA, nil</span>
}

// SetTimeout
func (m *MCIRApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        m.gConf.GSL.TumblebugCli.Timeout = timeout
        return nil
}</span>

// GetTimeout
func (m *MCIRApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return m.gConf.GSL.TumblebugCli.Timeout, nil
}</span>

// SetJWTToken - Set JWT auth token
func (m *MCIRApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov8" title="1">{
                m.gConf.GSL.TumblebugCli.Interceptors = &amp;config.InterceptorsConfig{}
                m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - Get JWT auth token
func (m *MCIRApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if m.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath
func (m *MCIRApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Make new config parser that uses Viper library
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // Check input data
        <span class="cov8" title="1">tumblebugcli := gConf.GSL.TumblebugCli

        if tumblebugcli == nil </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.Timeout == 0 </span><span class="cov0" title="0">{
                tumblebugcli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if tumblebugcli.TLS != nil </span><span class="cov0" title="0">{
                if tumblebugcli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("tumblebugcli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if tumblebugcli.Interceptors != nil </span><span class="cov0" title="0">{
                if tumblebugcli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("tumblebugcli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if tumblebugcli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if tumblebugcli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("tumblebugcli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">m.gConf = &amp;gConf
        return nil</span>
}

// Open - Open new connection
func (m *MCIRApi) Open() error <span class="cov8" title="1">{

        tumblebugcli := m.gConf.GSL.TumblebugCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(tumblebugcli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                m.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">m.conn = cbconn.Conn

        // grpc 클라이언트 생성
        m.clientMCIR = pb.NewMCIRClient(m.conn)

        // grpc 호출 Wrapper
        m.requestMCIR = &amp;mcir.MCIRRequest{Client: m.clientMCIR, Timeout: tumblebugcli.Timeout, InType: m.inType, OutType: m.outType}

        return nil</span>
}

// Close - Close connection
func (m *MCIRApi) Close() <span class="cov8" title="1">{
        if m.conn != nil </span><span class="cov8" title="1">{
                m.conn.Close()
        }</span>
        <span class="cov8" title="1">if m.jaegerCloser != nil </span><span class="cov0" title="0">{
                m.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">m.jaegerCloser = nil
        m.conn = nil
        m.clientMCIR = nil
        m.requestMCIR = nil</span>
}

// SetInType - Set input doc type (json/yaml)
func (m *MCIRApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                m.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                m.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if m.requestMCIR != nil </span><span class="cov8" title="1">{
                m.requestMCIR.InType = m.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType - Get input doc type (json/yaml)
func (m *MCIRApi) GetInType() (string, error) <span class="cov8" title="1">{
        return m.inType, nil
}</span>

// SetOutType - Set output doc type (json/yaml)
func (m *MCIRApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                m.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                m.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if m.requestMCIR != nil </span><span class="cov8" title="1">{
                m.requestMCIR.OutType = m.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType - Get output doc type (json/yaml)
func (m *MCIRApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return m.outType, nil
}</span>

// CreateImageWithInfo
func (m *MCIRApi) CreateImageWithInfo(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCIR.InData = doc
        return m.requestMCIR.CreateImageWithInfo()</span>
}

// CreateImageWithInfoByParam
func (m *MCIRApi) CreateImageWithInfoByParam(req *TbImageInfoRequest) (string, error) <span class="cov0" title="0">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.CreateImageWithInfo()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateImageWithID
func (m *MCIRApi) CreateImageWithID(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.CreateImageWithID()</span>
}

// CreateImageWithIDByParam
func (m *MCIRApi) CreateImageWithIDByParam(req *TbImageCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.CreateImageWithID()
        m.SetInType(holdType)

        return result, err</span>
}

// ListImage
func (m *MCIRApi) ListImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListImage()</span>
}

// ListImageByParam
func (m *MCIRApi) ListImageByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"image"}`
        result, err := m.requestMCIR.ListImage()
        m.SetInType(holdType)

        return result, err</span>
}

// ListImageId
func (m *MCIRApi) ListImageId(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListImageId()</span>
}

// ListImageIdByParam
func (m *MCIRApi) ListImageIdByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"image"}`
        result, err := m.requestMCIR.ListImageId()
        m.SetInType(holdType)

        return result, err</span>
}

// GetImage
func (m *MCIRApi) GetImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.GetImage()</span>
}

// GetImageByParam
func (m *MCIRApi) GetImageByParam(nameSpaceID string, resourceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"image", "resourceId":"` + resourceID + `"}`
        result, err := m.requestMCIR.GetImage()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteImage
func (m *MCIRApi) DeleteImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteImage()</span>
}

// DeleteImageByParam
func (m *MCIRApi) DeleteImageByParam(nameSpaceID string, resourceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"image", "resourceId":"` + resourceID + `", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteImage()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteAllImage
func (m *MCIRApi) DeleteAllImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteAllImage()</span>
}

// DeleteAllImageByParam
func (m *MCIRApi) DeleteAllImageByParam(nameSpaceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"image", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteAllImage()
        m.SetInType(holdType)

        return result, err</span>
}

// FetchImage
func (m *MCIRApi) FetchImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.FetchImage()</span>
}

// FetchImageByParam
func (m *MCIRApi) FetchImageByParam(connConfigName string, nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"ConnectionName":"` + connConfigName + `", "nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIR.FetchImage()
        m.SetInType(holdType)

        return result, err</span>
}

// SearchImage
func (m *MCIRApi) SearchImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.SearchImage()</span>
}

// SearchImageByParam
func (m *MCIRApi) SearchImageByParam(req *SearchImageQryRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.SearchImage()
        m.SetInType(holdType)

        return result, err</span>
}

// ListLookupImage - LookupImages
func (m *MCIRApi) ListLookupImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListLookupImage()</span>
}

// ListLookupImageByParam - LookupImages
func (m *MCIRApi) ListLookupImageByParam(connConfigName string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"ConnectionName":"` + connConfigName + `"}`
        result, err := m.requestMCIR.ListLookupImage()
        m.SetInType(holdType)

        return result, err</span>
}

// GetLookupImage - LookupImage
func (m *MCIRApi) GetLookupImage(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.GetLookupImage()</span>
}

// GetLookupImageByParam - LookupImage
func (m *MCIRApi) GetLookupImageByParam(connConfigName string, cspImageId string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"ConnectionName":"` + connConfigName + `", "cspImageId": "` + cspImageId + `"}`
        result, err := m.requestMCIR.GetLookupImage()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateSecurityGroup
func (m *MCIRApi) CreateSecurityGroup(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.CreateSecurityGroup()</span>
}

// CreateSecurityGroupByParam
func (m *MCIRApi) CreateSecurityGroupByParam(req *TbSecurityGroupCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.CreateSecurityGroup()
        m.SetInType(holdType)

        return result, err</span>
}

// ListSecurityGroup
func (m *MCIRApi) ListSecurityGroup(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListSecurityGroup()</span>
}

// ListSecurityGroupByParam
func (m *MCIRApi) ListSecurityGroupByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"securityGroup"}`
        result, err := m.requestMCIR.ListSecurityGroup()
        m.SetInType(holdType)

        return result, err</span>
}

// ListSecurityGroupId
func (m *MCIRApi) ListSecurityGroupId(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListSecurityGroupId()</span>
}

// ListSecurityGroupIdByParam
func (m *MCIRApi) ListSecurityGroupIdByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"securityGroup"}`
        result, err := m.requestMCIR.ListSecurityGroupId()
        m.SetInType(holdType)

        return result, err</span>
}

// GetSecurityGroup
func (m *MCIRApi) GetSecurityGroup(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.GetSecurityGroup()</span>
}

// GetSecurityGroupByParam
func (m *MCIRApi) GetSecurityGroupByParam(nameSpaceID string, resourceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"securityGroup", "resourceId":"` + resourceID + `"}`
        result, err := m.requestMCIR.GetSecurityGroup()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteSecurityGroup
func (m *MCIRApi) DeleteSecurityGroup(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteSecurityGroup()</span>
}

// DeleteSecurityGroupByParam
func (m *MCIRApi) DeleteSecurityGroupByParam(nameSpaceID string, resourceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"securityGroup", "resourceId":"` + resourceID + `", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteSecurityGroup()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteAllSecurityGroup
func (m *MCIRApi) DeleteAllSecurityGroup(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteAllSecurityGroup()</span>
}

// DeleteAllSecurityGroupByParam
func (m *MCIRApi) DeleteAllSecurityGroupByParam(nameSpaceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"securityGroup", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteAllImage()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateSpecWithInfo
func (m *MCIRApi) CreateSpecWithInfo(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCIR.InData = doc
        return m.requestMCIR.CreateSpecWithInfo()</span>
}

// CreateSpecWithInfoByParam
func (m *MCIRApi) CreateSpecWithInfoByParam(req *TbSpecInfoRequest) (string, error) <span class="cov0" title="0">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.CreateSpecWithInfo()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateSpecWithSpecName
func (m *MCIRApi) CreateSpecWithSpecName(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.CreateSpecWithSpecName()</span>
}

// CreateSpecWithSpecNameByParam
func (m *MCIRApi) CreateSpecWithSpecNameByParam(req *TbSpecCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.CreateSpecWithSpecName()
        m.SetInType(holdType)

        return result, err</span>
}

// ListSpec
func (m *MCIRApi) ListSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListSpec()</span>
}

// ListSpecByParam
func (m *MCIRApi) ListSpecByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"spec"}`
        result, err := m.requestMCIR.ListSpec()
        m.SetInType(holdType)

        return result, err</span>
}

// ListSpecId
func (m *MCIRApi) ListSpecId(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListSpecId()</span>
}

// ListSpecIdByParam
func (m *MCIRApi) ListSpecIdByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"spec"}`
        result, err := m.requestMCIR.ListSpecId()
        m.SetInType(holdType)

        return result, err</span>
}

// GetSpec
func (m *MCIRApi) GetSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.GetSpec()</span>
}

// GetSpecByParam
func (m *MCIRApi) GetSpecByParam(nameSpaceID string, resourceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"spec", "resourceId":"` + resourceID + `"}`
        result, err := m.requestMCIR.GetSpec()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteSpec
func (m *MCIRApi) DeleteSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteSpec()</span>
}

// DeleteSpecByParam
func (m *MCIRApi) DeleteSpecByParam(nameSpaceID string, resourceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"spec", "resourceId":"` + resourceID + `", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteSpec()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteAllSpec
func (m *MCIRApi) DeleteAllSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteAllSpec()</span>
}

// DeleteAllSpecByParam
func (m *MCIRApi) DeleteAllSpecByParam(nameSpaceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"spec", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteAllSpec()
        m.SetInType(holdType)

        return result, err</span>
}

// FetchSpec
func (m *MCIRApi) FetchSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.FetchSpec()</span>
}

// FetchSpecByParam
func (m *MCIRApi) FetchSpecByParam(connConfigName string, nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"ConnectionName":"` + connConfigName + `", "nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIR.FetchSpec()
        m.SetInType(holdType)

        return result, err</span>
}

// FilterSpec
func (m *MCIRApi) FilterSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.FilterSpec()</span>
}

// FilterSpecsByRange
func (m *MCIRApi) FilterSpecsByRange(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.FilterSpecsByRange()</span>
}

// SortSpecs
func (m *MCIRApi) SortSpecs(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCIR.InData = doc
        return m.requestMCIR.SortSpecs()</span>
}

// UpdateSpec
func (m *MCIRApi) UpdateSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.UpdateSpec()</span>
}

// ListLookupSpec - LookupSpecs
func (m *MCIRApi) ListLookupSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListLookupSpec()</span>
}

// ListLookupSpecByParam - LookupSpecs
func (m *MCIRApi) ListLookupSpecByParam(connConfigName string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"ConnectionName":"` + connConfigName + `"}`
        result, err := m.requestMCIR.ListLookupSpec()
        m.SetInType(holdType)

        return result, err</span>
}

// GetLookupSpec - LookupSpec
func (m *MCIRApi) GetLookupSpec(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.GetLookupSpec()</span>
}

// GetLookupSpecByParam - LookupSpec
func (m *MCIRApi) GetLookupSpecByParam(connConfigName string, cspSpecName string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"ConnectionName":"` + connConfigName + `", "cspSpecName": "` + cspSpecName + `"}`
        result, err := m.requestMCIR.GetLookupSpec()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateSshKey
func (m *MCIRApi) CreateSshKey(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.CreateSshKey()</span>
}

// CreateSshKeyByParam
func (m *MCIRApi) CreateSshKeyByParam(req *TbSshKeyCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.CreateSshKey()
        m.SetInType(holdType)

        return result, err</span>
}

// ListSshKey
func (m *MCIRApi) ListSshKey(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListSshKey()</span>
}

// ListSshKeyByParam
func (m *MCIRApi) ListSshKeyByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"sshKey"}`
        result, err := m.requestMCIR.ListSshKey()
        m.SetInType(holdType)

        return result, err</span>
}

// ListSshKeyId
func (m *MCIRApi) ListSshKeyId(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListSshKeyId()</span>
}

// ListSshKeyIdByParam
func (m *MCIRApi) ListSshKeyIdByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"sshKey"}`
        result, err := m.requestMCIR.ListSshKeyId()
        m.SetInType(holdType)

        return result, err</span>
}

// GetSshKey
func (m *MCIRApi) GetSshKey(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.GetSshKey()</span>
}

// GetSshKeyByParam
func (m *MCIRApi) GetSshKeyByParam(nameSpaceID string, resourceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"sshKey", "resourceId":"` + resourceID + `"}`
        result, err := m.requestMCIR.GetSshKey()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteSshKey
func (m *MCIRApi) DeleteSshKey(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteSshKey()</span>
}

// DeleteSshKeyByParam
func (m *MCIRApi) DeleteSshKeyByParam(nameSpaceID string, resourceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"sshKey", "resourceId":"` + resourceID + `", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteSshKey()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteAllSshKey
func (m *MCIRApi) DeleteAllSshKey(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteAllSshKey()</span>
}

// DeleteAllSshKeyByParam
func (m *MCIRApi) DeleteAllSshKeyByParam(nameSpaceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"sshKey", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteAllSshKey()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateVNet
func (m *MCIRApi) CreateVNet(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.CreateVNet()</span>
}

// CreateVNetByParam
func (m *MCIRApi) CreateVNetByParam(req *TbVNetCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIR.InData = string(j)
        result, err := m.requestMCIR.CreateVNet()
        m.SetInType(holdType)

        return result, err</span>
}

// ListVNet
func (m *MCIRApi) ListVNet(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListVNet()</span>
}

// ListVNetByParam
func (m *MCIRApi) ListVNetByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"vNet"}`
        result, err := m.requestMCIR.ListVNet()
        m.SetInType(holdType)

        return result, err</span>
}

// ListVNetId
func (m *MCIRApi) ListVNetId(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.ListVNetId()</span>
}

// ListVNetIdByParam
func (m *MCIRApi) ListVNetIdByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"vNet"}`
        result, err := m.requestMCIR.ListVNetId()
        m.SetInType(holdType)

        return result, err</span>
}

// GetVNet
func (m *MCIRApi) GetVNet(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.GetVNet()</span>
}

// GetVNetByParam
func (m *MCIRApi) GetVNetByParam(nameSpaceID string, resourceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"vNet", "resourceId":"` + resourceID + `"}`
        result, err := m.requestMCIR.GetVNet()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteVNet
func (m *MCIRApi) DeleteVNet(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteVNet()</span>
}

// DeleteVNetByParam
func (m *MCIRApi) DeleteVNetByParam(nameSpaceID string, resourceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"vNet", "resourceId":"` + resourceID + `", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteVNet()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteAllVNet
func (m *MCIRApi) DeleteAllVNet(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.DeleteAllVNet()</span>
}

// DeleteAllVNetByParam
func (m *MCIRApi) DeleteAllVNetByParam(nameSpaceID string, force string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"vNet", "force":"` + force + `"}`
        result, err := m.requestMCIR.DeleteAllVNet()
        m.SetInType(holdType)

        return result, err</span>
}

// CheckResource - Check whether Resource exists or not
func (m *MCIRApi) CheckResource(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIR.InData = doc
        return m.requestMCIR.CheckResource()</span>
}

// CheckResourceByParam - Check whether Resource exists or not
func (m *MCIRApi) CheckResourceByParam(nameSpaceID string, resourceID string, resourceType string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIR.InData = `{"nsId":"` + nameSpaceID + `", "resourceType":"vNet", "resourceId":"` + resourceID + `", "resourceType":"` + resourceType + `"}`
        result, err := m.requestMCIR.CheckResource()
        m.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functiom ] =====

// ===== [ Public Functiom ] =====

// NewMCIRManager - Create new MCIR API object
func NewMCIRManager() (m *MCIRApi) <span class="cov8" title="1">{

        m = &amp;MCIRApi{}
        m.gConf = &amp;config.GrpcConfig{}
        m.gConf.GSL.TumblebugCli = &amp;config.GrpcClientConfig{}

        m.jaegerCloser = nil
        m.conn = nil
        m.clientMCIR = nil
        m.requestMCIR = nil

        m.inType = "json"
        m.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package mcis

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateMcis
func (r *MCISRequest) CreateMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListMcis
func (r *MCISRequest) ListMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListMcisId
func (r *MCISRequest) ListMcisId() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListMcisId(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ControlMcis - Control MCIS's lifecycle
func (r *MCISRequest) ControlMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisActionRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ControlMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListMcisStatus
func (r *MCISRequest) ListMcisStatus() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListMcisStatus(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetMcisStatus
func (r *MCISRequest) GetMcisStatus() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetMcisStatus(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetMcisInfo
func (r *MCISRequest) GetMcisInfo() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetMcisInfo(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListMcisVmId
func (r *MCISRequest) ListMcisVmId() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListMcisVmId(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteMcis
func (r *MCISRequest) DeleteMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllMcis
func (r *MCISRequest) DeleteAllMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// CreateMcisVM
func (r *MCISRequest) CreateMcisVM() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVmCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateMcisVM(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// CreateMcisVMGroup
func (r *MCISRequest) CreateMcisVMGroup() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVmGroupCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateMcisVMGroup(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ControlMcisVM - Control MCIS VM's lifecycle
func (r *MCISRequest) ControlMcisVM() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVmActionRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ControlMcisVM(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetMcisVMStatus
func (r *MCISRequest) GetMcisVMStatus() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVmQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetMcisVMStatus(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// GetMcisVMInfo
func (r *MCISRequest) GetMcisVMInfo() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVmQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetMcisVMInfo(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteMcisVM
func (r *MCISRequest) DeleteMcisVM() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVmQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteMcisVM(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// RecommendMcis
func (r *MCISRequest) RecommendMcis() (string, error) <span class="cov0" title="0">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov0" title="0">var item pb.McisRecommendCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.RecommendMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// CmdMcis - Send a command to execute to MCIS
func (r *MCISRequest) CmdMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisCmdCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CmdMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// CmdMcisVm - Send a command to execute to MCIS VM
func (r *MCISRequest) CmdMcisVm() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisCmdVmCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CmdMcisVm(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// InstallAgentToMcis - Install CB-Tumblebug benchmarking agent (cb-milkyway), which will be deprecated
func (r *MCISRequest) InstallAgentToMcis() (string, error) <span class="cov0" title="0">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov0" title="0">var item pb.McisCmdCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.InstallAgentToMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetBenchmark - Get benchmark result
func (r *MCISRequest) GetBenchmark() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.BmQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetBenchmark(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetAllBenchmark - List benchmark results
func (r *MCISRequest) GetAllBenchmark() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.BmQryAllRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetAllBenchmark(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file44" style="display: none">package mcis

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// InstallMonitorAgentToMcis
func (r *MCISRequest) InstallMonitorAgentToMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisCmdCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.InstallMonitorAgentToMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetMonitorData
func (r *MCISRequest) GetMonitorData() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.MonitorQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetMonitorData(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file45" style="display: none">package mcis

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateMcisPolicy
func (r *MCISRequest) CreateMcisPolicy() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisPolicyCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateMcisPolicy(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListMcisPolicy
func (r *MCISRequest) ListMcisPolicy() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisPolicyAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListMcisPolicy(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetMcisPolicy
func (r *MCISRequest) GetMcisPolicy() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisPolicyQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetMcisPolicy(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteMcisPolicy
func (r *MCISRequest) DeleteMcisPolicy() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisPolicyQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteMcisPolicy(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteAllMcisPolicy
func (r *MCISRequest) DeleteAllMcisPolicy() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.McisPolicyAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteAllMcisPolicy(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file46" style="display: none">package mcis

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// RecommendVM
func (r *MCISRequest) RecommendVM() (string, error) <span class="cov0" title="0">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov0" title="0">var item pb.McisRecommendVmCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.RecommendVM(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp.Items)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file47" style="display: none">package mcis

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CheckMcis - Check whether MCIS exists or not
func (r *MCISRequest) CheckMcis() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbMcisQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CheckMcis(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// CheckVm - Check whether MCIS VM exists or not
func (r *MCISRequest) CheckVm() (string, error) <span class="cov8" title="1">{
        // Check input data
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // Unmarshal (json/yaml -&gt; Request Input)
        <span class="cov8" title="1">var item pb.TbVmQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Request to server
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CheckVm(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Marshal (Response -&gt; json/yaml)
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file48" style="display: none">package request

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/mcis"

        core_mcis "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"

        "google.golang.org/grpc"
)

// ===== [ Comtants and Variables ] =====

// ===== [ Types ] =====

// MCISApi - MCIS API 구조 정의
type MCISApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientMCIS   pb.MCISClient
        requestMCIS  *mcis.MCISRequest
        inType       string
        outType      string
}

// TbMcisCreateRequest - MCIS 생성 요청 구조 Wrapper 정의
type TbMcisCreateRequest struct {
        NsId string              `yaml:"nsId" json:"nsId"`
        Item core_mcis.TbMcisReq `yaml:"mcis" json:"mcis"`
}

// TbMcisReq - MCIS 생성 요청 구조 정의
// type TbMcisReq struct {
//         Name            string    `yaml:"name" json:"name"`
//         InstallMonAgent string    `yaml:"installMonAgent" json:"installMonAgent"`
//         Label           string    `yaml:"label" json:"label"`
//         PlacementAlgo   string    `yaml:"placementAlgo" json:"placementAlgo"`
//         Description     string    `yaml:"description" json:"description"`
//         Vm              []TbVmReq `yaml:"vm" json:"vm"`
// }

// TbVmReq - MCIS VM 생성 요청 구조 정의
// type TbVmReq struct {
//         Name             string   `yaml:"name" json:"name"`
//         VmGroupSize      string   `yaml:"vmGroupSize" json:"vmGroupSize"`
//         Label            string   `yaml:"label" json:"label"`
//         Description      string   `yaml:"description" json:"description"`
//         ConnectionName   string   `yaml:"connectionName" json:"connectionName"`
//         SpecId           string   `yaml:"specId" json:"specId"`
//         ImageId          string   `yaml:"imageId" json:"imageId"`
//         VNetId           string   `yaml:"vNetId" json:"vNetId"`
//         SubnetId         string   `yaml:"subnetId" json:"subnetId"`
//         SecurityGroupIds []string `yaml:"securityGroupIds" json:"securityGroupIds"`
//         SshKeyId         string   `yaml:"sshKeyId" json:"sshKeyId"`
//         VmUserAccount    string   `yaml:"vmUserAccount" json:"vmUserAccount"`
//         VmUserPassword   string   `yaml:"vmUserPassword" json:"vmUserPassword"`
// }

// TbVmCreateRequest - MCIS VM 생성 요청 구조 Wrapper 정의
type TbVmCreateRequest struct {
        NsId   string   `yaml:"nsId" json:"nsId"`
        McisId string   `yaml:"mcisId" json:"mcisId"`
        Item   TbVmInfo `yaml:"mcisvm" json:"mcisvm"`
}

// TbVmGroupCreateRequest - MCIS VM 그룹 생성 요청 구조 Wrapper 정의
type TbVmGroupCreateRequest struct {
        NsId   string            `yaml:"nsId" json:"nsId"`
        McisId string            `yaml:"mcisId" json:"mcisId"`
        Item   core_mcis.TbVmReq `yaml:"groupvm" json:"groupvm"`
}

// TbVmInfo - MCIS VM 구조 정의
type TbVmInfo struct {
        Id               string                `yaml:"id" json:"id"`
        Name             string                `yaml:"name" json:"name"`
        VmGroupId        string                `yaml:"vmGroupId" json:"vmGroupId"`
        Location         core_mcis.GeoLocation `yaml:"location" json:"location"`
        Status           string                `yaml:"status" json:"status"`
        TargetStatus     string                `yaml:"targetStatus" json:"targetStatus"`
        TargetAction     string                `yaml:"targetAction" json:"targetAction"`
        MonAgentStatus   string                `yaml:"monAgentStatus" json:"monAgentStatus"`
        SystemMessage    string                `yaml:"systemMessage" json:"systemMessage"`
        CreatedTime      string                `yaml:"createdTime" json:"createdTime"`
        Label            string                `yaml:"label" json:"label"`
        Description      string                `yaml:"description" json:"description"`
        Region           core_mcis.RegionInfo  `yaml:"region" json:"region"`
        PublicIP         string                `yaml:"publicIP" json:"publicIP"`
        SSHPort          string                `yaml:"sshPort" json:"sshPort"`
        PublicDNS        string                `yaml:"publicDNS" json:"publicDNS"`
        PrivateIP        string                `yaml:"privateIP" json:"privateIP"`
        PrivateDNS       string                `yaml:"privateDNS" json:"privateDNS"`
        VMBootDisk       string                `yaml:"vmBootDisk" json:"vmBootDisk"`
        VMBlockDisk      string                `yaml:"vmBlockDisk" json:"vmBlockDisk"`
        ConnectionName   string                `yaml:"connectionName" json:"connectionName"`
        SpecId           string                `yaml:"specId" json:"specId"`
        ImageId          string                `yaml:"imageId" json:"imageId"`
        VNetId           string                `yaml:"vNetId" json:"vNetId"`
        SubnetId         string                `yaml:"subnetId" json:"subnetId"`
        SecurityGroupIds []string              `yaml:"securityGroupIds" json:"securityGroupIds"`
        SshKeyId         string                `yaml:"sshKeyId" json:"sshKeyId"`
        VmUserAccount    string                `yaml:"vmUserAccount" json:"vmUserAccount"`
        VmUserPassword   string                `yaml:"vmUserPassword" json:"vmUserPassword"`

        // StartTime 필드가 공백일 경우 json 객체 복사할 때 time format parsing 에러 방지
        // CspViewVmDetail  SpiderVMInfo `yaml:"cspViewVmDetail" json:"cspViewVmDetail"`
}

// GeoLocation - 위치 정보 구조 정의
// type GeoLocation struct {
//         Latitude     string `yaml:"latitude" json:"latitude"`
//         Longitude    string `yaml:"longitude" json:"longitude"`
//         BriefAddr    string `yaml:"briefAddr" json:"briefAddr"`
//         CloudType    string `yaml:"cloudType" json:"cloudType"`
//         NativeRegion string `yaml:"nativeRegion" json:"nativeRegion"`
// }

// RegionInfo - Region 정보 구조 정의
// type RegionInfo struct { // Spider
//         Region string `yaml:"Region" json:"Region"`
//         Zone   string `yaml:"Zone" json:"Zone"`
// }

// SpiderVMInfo - VM 정보 구조 정의
// type SpiderVMInfo struct { // Spider
//         // Fields for request
//         Name               string   `yaml:"Name" json:"Name"`
//         ImageName          string   `yaml:"ImageName" json:"ImageName"`
//         VPCName            string   `yaml:"VPCName" json:"VPCName"`
//         SubnetName         string   `yaml:"SubnetName" json:"SubnetName"`
//         SecurityGroupNames []string `yaml:"SecurityGroupNames" json:"SecurityGroupNames"`
//         KeyPairName        string   `yaml:"KeyPairName" json:"KeyPairName"`

//         // Fields for both request and response
//         VMSpecName   string `yaml:"VMSpecName" json:"VMSpecName"`
//         VMUserId     string `yaml:"VMUserId" json:"VMUserId"`
//         VMUserPasswd string `yaml:"VMUserPasswd" json:"VMUserPasswd"`

//         // Fields for response
//         IId               IID        `yaml:"IId" json:"IId"`
//         ImageIId          IID        `yaml:"ImageIId" json:"ImageIId"`
//         VpcIID            IID        `yaml:"VpcIID" json:"VpcIID"`
//         SubnetIID         IID        `yaml:"SubnetIID" json:"SubnetIID"`
//         SecurityGroupIIds []IID      `yaml:"SecurityGroupIIds" json:"SecurityGroupIIds"`
//         KeyPairIId        IID        `yaml:"KeyPairIId" json:"KeyPairIId"`
//         StartTime         string     `yaml:"StartTime" json:"StartTime"`
//         Region            RegionInfo `yaml:"Region" json:"Region"`
//         NetworkInterface  string     `yaml:"NetworkInterface" json:"NetworkInterface"`
//         PublicIP          string     `yaml:"PublicIP" json:"PublicIP"`
//         PublicDNS         string     `yaml:"PublicDNS" json:"PublicDNS"`
//         PrivateIP         string     `yaml:"PrivateIP" json:"PrivateIP"`
//         PrivateDNS        string     `yaml:"PrivateDNS" json:"PrivateDNS"`
//         VMBootDisk        string     `yaml:"VMBootDisk" json:"VMBootDisk"`
//         VMBlockDisk       string     `yaml:"VMBlockDisk" json:"VMBlockDisk"`
//         SSHAccessPoint    string     `yaml:"SSHAccessPoint" json:"SSHAccessPoint"`
//         KeyValueList      []KeyValue `yaml:"KeyValueList" json:"KeyValueList"`
// }

// McisRecommendCreateRequest - MCIS 추천 요청 구조 Wrapper 정의
type McisRecommendCreateRequest struct {
        NsId string                     `yaml:"nsId" json:"nsId"`
        Item core_mcis.McisRecommendReq `yaml:"recommend" json:"recommend"`
}

// McisRecommendReq - MCIS 추천 요청 구조 정의
// type McisRecommendReq struct {
//         VmReq          []TbVmRecommendReq `yaml:"vmReq" json:"vmReq"`
//         PlacementAlgo  string             `yaml:"placementAlgo" json:"placementAlgo"`
//         PlacementParam []KeyValue         `yaml:"placementParam" json:"placementParam"`
//         MaxResultNum   string             `yaml:"maxResultNum" json:"maxResultNum"`
// }

// McisRecommendReq - MCIS VM 추천 요청 구조 정의
// type TbVmRecommendReq struct {
//         RequestName  string `yaml:"requestName" json:"requestName"`
//         MaxResultNum string `yaml:"maxResultNum" json:"maxResultNum"`

//         VcpuSize   string `yaml:"vcpuSize" json:"vcpuSize"`
//         MemorySize string `yaml:"memorySize" json:"memorySize"`
//         DiskSize   string `yaml:"diskSize" json:"diskSize"`

//         PlacementAlgo  string     `yaml:"placementAlgo" json:"placementAlgo"`
//         PlacementParam []KeyValue `yaml:"placementParam" json:"placementParam"`
// }

// McisCmdCreateRequest - MCIS 명령 실행 요청 구조 Wrapper 정의
type McisCmdCreateRequest struct {
        NsId   string               `yaml:"nsId" json:"nsId"`
        McisId string               `yaml:"mcisId" json:"mcisId"`
        Item   core_mcis.McisCmdReq `yaml:"cmd" json:"cmd"`
}

// McisCmdReq - MCIS 명령 실행 요청 구조 정의
// type McisCmdReq struct {
//         McisId   string `yaml:"mcisId" json:"mcisId"`
//         VmId     string `yaml:"vmId" json:"vmId"`
//         Ip       string `yaml:"ip" json:"ip"`
//         UserName string `yaml:"userName" json:"userName"`
//         SshKey   string `yaml:"sshKey" json:"sshKey"`
//         Command  string `yaml:"command" json:"command"`
// }

// McisCmdVmCreateRequest - MCIS VM 명령 실행 요청 구조 Wrapper 정의
type McisCmdVmCreateRequest struct {
        NsId   string               `yaml:"nsId" json:"nsId"`
        McisId string               `yaml:"mcisId" json:"mcisId"`
        VmId   string               `yaml:"vmId" json:"vmId"`
        Item   core_mcis.McisCmdReq `yaml:"cmd" json:"cmd"`
}

// McisPolicyCreateRequest - MCIS Policy 생성 요청 구조 Wrapper 정의
type McisPolicyCreateRequest struct {
        NsId   string                   `yaml:"nsId" json:"nsId"`
        McisId string                   `yaml:"mcisId" json:"mcisId"`
        Item   core_mcis.McisPolicyInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// AutoCondition - MCIS AutoCondition 요청 구조 정의
// type AutoCondition struct {
//         Metric           string   `yaml:"metric" json:"metric"`
//         Operator         string   `yaml:"operator" json:"operator"`
//         Operand          string   `yaml:"operand" json:"operand"`
//         EvaluationPeriod string   `yaml:"evaluationPeriod" json:"evaluationPeriod"`
//         EvaluationValue  []string `yaml:"evaluationValue" json:"evaluationValue"`
// }

// AutoAction - MCIS AutoAction 요청 구조 정의
// type AutoAction struct {
//         ActionType    string     `yaml:"actionType" json:"actionType"`
//         Vm            TbVmInfo   `yaml:"vm" json:"vm"`
//         PostCommand   McisCmdReq `yaml:"postCommand" json:"postCommand"`
//         PlacementAlgo string     `yaml:"placementAlgo" json:"placementAlgo"`
// }

// Policy - MCIS Policy 요청 구조 정의
// type Policy struct {
//         AutoCondition AutoCondition `yaml:"autoCondition" json:"autoCondition"`
//         AutoAction    AutoAction    `yaml:"autoAction" json:"autoAction"`
//         Status        string        `yaml:"status" json:"status"`
// }

// McisPolicyInfo - MCIS Policy 정보 구조 정의
// type McisPolicyInfo struct {
//         Name   string   `yaml:"Name" json:"Name"`
//         Id     string   `yaml:"Id" json:"Id"`
//         Policy []Policy `yaml:"policy" json:"policy"`

//         ActionLog   string `yaml:"actionLog" json:"actionLog"`
//         Description string `yaml:"description" json:"description"`
// }

// McisRecommendVmCreateRequest - MCIS VM 추천 요청 구조 Wrapper 정의
type McisRecommendVmCreateRequest struct {
        NsId string                   `yaml:"nsId" json:"nsId"`
        Item core_mcis.DeploymentPlan `yaml:"plan" json:"plan"`
}

// DeploymentPlan - DeploymentPlan 요청 구조 정의
// type DeploymentPlan struct {
//         Filter   FilterInfo   `yaml:"filter" json:"filter"`
//         Priority PriorityInfo `yaml:"priority" json:"priority"`
//         Limit    string       `yaml:"limit" json:"limit"`
// }

// FilterInfo - FilterInfo 요청 구조 정의
// type FilterInfo struct {
//         Policy []FilterCondition `yaml:"policy" json:"policy"`
// }

// FilterCondition - FilterCondition 요청 구조 정의
// type FilterCondition struct {
//         Metric    string      `yaml:"metric" json:"metric"`
//         Condition []Operation `yaml:"condition" json:"condition"`
// }

// Operation - Operation 요청 구조 정의
// type Operation struct {
//         Operator string `yaml:"operator" json:"operator"`
//         Operand  string `yaml:"operand" json:"operand"`
// }

// PriorityInfo - PriorityInfo 요청 구조 정의
// type PriorityInfo struct {
//         Policy []PriorityCondition `yaml:"policy" json:"policy"`
// }

// PriorityCondition - PriorityCondition 요청 구조 정의
// type PriorityCondition struct {
//         Metric    string            `yaml:"metric" json:"metric"`
//         Weight    string            `yaml:"weight" json:"weight"`
//         Parameter []ParameterKeyVal `yaml:"parameter" json:"parameter"`
// }

// ParameterKeyVal - ParameterKeyVal 요청 구조 정의
// type ParameterKeyVal struct {
//         Key string   `yaml:"key" json:"key"`
//         Val []string `yaml:"val" json:"val"`
// }

// ===== [ Implementatiom ] =====

// SetServerAddr - Tumblebug 서버 주소 설정
func (m *MCISApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.TumblebugCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Tumblebug 서버 주소 값 조회
func (m *MCISApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return m.gConf.GSL.TumblebugCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 설정
func (m *MCISApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov8" title="1">{
                m.gConf.GSL.TumblebugCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.TumblebugCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA 값 조회
func (m *MCISApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if m.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return m.gConf.GSL.TumblebugCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 설정
func (m *MCISApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        m.gConf.GSL.TumblebugCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout 값 조회
func (m *MCISApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return m.gConf.GSL.TumblebugCli.Timeout, nil
}</span>

// SetJWTToken - JWT 인증 토큰 설정
func (m *MCISApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov8" title="1">{
                m.gConf.GSL.TumblebugCli.Interceptors = &amp;config.InterceptorsConfig{}
                m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT 인증 토큰 값 조회
func (m *MCISApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if m.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return m.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath - 환경설정 파일 설정
func (m *MCISApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Make new config parser that uses Viper library
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // TUMBLEBUG CLIENT 필수 입력 항목 체크
        <span class="cov8" title="1">tumblebugcli := gConf.GSL.TumblebugCli

        if tumblebugcli == nil </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.Timeout == 0 </span><span class="cov0" title="0">{
                tumblebugcli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if tumblebugcli.TLS != nil </span><span class="cov0" title="0">{
                if tumblebugcli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("tumblebugcli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if tumblebugcli.Interceptors != nil </span><span class="cov0" title="0">{
                if tumblebugcli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("tumblebugcli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if tumblebugcli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if tumblebugcli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("tumblebugcli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">m.gConf = &amp;gConf
        return nil</span>
}

// Open - 연결 설정
func (m *MCISApi) Open() error <span class="cov8" title="1">{

        tumblebugcli := m.gConf.GSL.TumblebugCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(tumblebugcli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                m.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">m.conn = cbconn.Conn

        // grpc 클라이언트 생성
        m.clientMCIS = pb.NewMCISClient(m.conn)

        // grpc 호출 Wrapper
        m.requestMCIS = &amp;mcis.MCISRequest{Client: m.clientMCIS, Timeout: tumblebugcli.Timeout, InType: m.inType, OutType: m.outType}

        return nil</span>
}

// Close - 연결 종료
func (m *MCISApi) Close() <span class="cov8" title="1">{
        if m.conn != nil </span><span class="cov8" title="1">{
                m.conn.Close()
        }</span>
        <span class="cov8" title="1">if m.jaegerCloser != nil </span><span class="cov0" title="0">{
                m.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">m.jaegerCloser = nil
        m.conn = nil
        m.clientMCIS = nil
        m.requestMCIS = nil</span>
}

// SetInType - 입력 문서 타입 설정 (json/yaml)
func (m *MCISApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                m.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                m.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if m.requestMCIS != nil </span><span class="cov8" title="1">{
                m.requestMCIS.InType = m.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType - 입력 문서 타입 값 조회
func (m *MCISApi) GetInType() (string, error) <span class="cov8" title="1">{
        return m.inType, nil
}</span>

// SetOutType - 출력 문서 타입 설정 (json/yaml)
func (m *MCISApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                m.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                m.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if m.requestMCIS != nil </span><span class="cov8" title="1">{
                m.requestMCIS.OutType = m.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType - 출력 문서 타입 값 조회
func (m *MCISApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return m.outType, nil
}</span>

// CreateMcis - MCIS 생성
func (m *MCISApi) CreateMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CreateMcis()</span>
}

// CreateMcisByParam - MCIS 생성
func (m *MCISApi) CreateMcisByParam(req *TbMcisCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.CreateMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// ListMcis - MCIS 목록
func (m *MCISApi) ListMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.ListMcis()</span>
}

// ListMcisByParam - MCIS 목록
func (m *MCISApi) ListMcisByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIS.ListMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// ListMcisId - MCIS 목록
func (m *MCISApi) ListMcisId(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.ListMcisId()</span>
}

// ListMcisIdByParam - MCIS 목록
func (m *MCISApi) ListMcisIdByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIS.ListMcisId()
        m.SetInType(holdType)

        return result, err</span>
}

// ControlMcis - MCIS 제어
func (m *MCISApi) ControlMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.ControlMcis()</span>
}

// ControlMcisByParam - MCIS 제어
func (m *MCISApi) ControlMcisByParam(nameSpaceID string, mcisID string, action string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "action":"` + action + `"}`
        result, err := m.requestMCIS.ControlMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// ListMcisStatus - MCIS 상태 목록
func (m *MCISApi) ListMcisStatus(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.ListMcisStatus()</span>
}

// ListMcisStatusByParam - MCIS 상태 목록
func (m *MCISApi) ListMcisStatusByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIS.ListMcisStatus()
        m.SetInType(holdType)

        return result, err</span>
}

// GetMcisStatus - MCIS 상태 조회
func (m *MCISApi) GetMcisStatus(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetMcisStatus()</span>
}

// GetMcisStatusByParam - MCIS 상태 조회
func (m *MCISApi) GetMcisStatusByParam(nameSpaceID string, mcisID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `"}`
        result, err := m.requestMCIS.GetMcisStatus()
        m.SetInType(holdType)

        return result, err</span>
}

// GetMcisInfo - MCIS 정보 조회
func (m *MCISApi) GetMcisInfo(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetMcisInfo()</span>
}

// GetMcisInfoByParam - MCIS 정보 조회
func (m *MCISApi) GetMcisInfoByParam(nameSpaceID string, mcisID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `"}`
        result, err := m.requestMCIS.GetMcisInfo()
        m.SetInType(holdType)

        return result, err</span>
}

// ListMcisVmId - MCIS 정보 조회
func (m *MCISApi) ListMcisVmId(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.ListMcisVmId()</span>
}

// ListMcisVmIdByParam - MCIS 정보 조회
func (m *MCISApi) ListMcisVmIdByParam(nameSpaceID string, mcisID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `"}`
        result, err := m.requestMCIS.ListMcisVmId()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteMcis - MCIS 삭제
func (m *MCISApi) DeleteMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.DeleteMcis()</span>
}

// DeleteMcisByParam - MCIS 삭제
func (m *MCISApi) DeleteMcisByParam(nameSpaceID string, mcisID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `"}`
        result, err := m.requestMCIS.DeleteMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteAllMcis - MCIS 전체 삭제
func (m *MCISApi) DeleteAllMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.DeleteAllMcis()</span>
}

// DeleteAllMcisByParam - MCIS 전체 삭제
func (m *MCISApi) DeleteAllMcisByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIS.DeleteAllMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateMcisVM - MCIS VM 생성
func (m *MCISApi) CreateMcisVM(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CreateMcisVM()</span>
}

// CreateMcisVMByParam - MCIS VM 생성
func (m *MCISApi) CreateMcisVMByParam(req *TbVmCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.CreateMcisVM()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateMcisVMGroup - MCIS VM 그룹 생성
func (m *MCISApi) CreateMcisVMGroup(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CreateMcisVMGroup()</span>
}

// CreateMcisVMGroupByParam - MCIS VM 생성
func (m *MCISApi) CreateMcisVMGroupByParam(req *TbVmGroupCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.CreateMcisVMGroup()
        m.SetInType(holdType)

        return result, err</span>
}

// ControlMcisVM - MCIS VM 제어
func (m *MCISApi) ControlMcisVM(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.ControlMcisVM()</span>
}

// ControlMcisVMByParam - MCIS VM 제어
func (m *MCISApi) ControlMcisVMByParam(nameSpaceID string, mcisID string, vmID string, action string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "vmId":"` + vmID + `", "action":"` + action + `"}`
        result, err := m.requestMCIS.ControlMcisVM()
        m.SetInType(holdType)

        return result, err</span>
}

// GetMcisVMStatus - MCIS VM 상태 조회
func (m *MCISApi) GetMcisVMStatus(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetMcisVMStatus()</span>
}

// GetMcisVMStatusByParam - MCIS VM 상태 조회
func (m *MCISApi) GetMcisVMStatusByParam(nameSpaceID string, mcisID string, vmID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "vmId":"` + vmID + `"}`
        result, err := m.requestMCIS.GetMcisVMStatus()
        m.SetInType(holdType)

        return result, err</span>
}

// GetMcisVMInfo - MCIS VM 정보 조회
func (m *MCISApi) GetMcisVMInfo(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetMcisVMInfo()</span>
}

// GetMcisVMInfoByParam - MCIS VM 정보 조회
func (m *MCISApi) GetMcisVMInfoByParam(nameSpaceID string, mcisID string, vmID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "vmId":"` + vmID + `"}`
        result, err := m.requestMCIS.GetMcisVMInfo()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteMcisVM - MCIS VM 삭제
func (m *MCISApi) DeleteMcisVM(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCIS.InData = doc
        return m.requestMCIS.DeleteMcisVM()</span>
}

// DeleteMcisVMByParam - MCIS VM 삭제
func (m *MCISApi) DeleteMcisVMByParam(nameSpaceID string, mcisID string, vmID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "vmId":"` + vmID + `"}`
        result, err := m.requestMCIS.DeleteMcisVM()
        m.SetInType(holdType)

        return result, err</span>
}

// RecommendMcis - MCIS 추천
func (m *MCISApi) RecommendMcis(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCIS.InData = doc
        return m.requestMCIS.RecommendMcis()</span>
}

// RecommendMcisByParam - MCIS 추천
func (m *MCISApi) RecommendMcisByParam(req *McisRecommendCreateRequest) (string, error) <span class="cov0" title="0">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.RecommendMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// RecommendVM - MCIS VM 추천
func (m *MCISApi) RecommendVM(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCIS.InData = doc
        return m.requestMCIS.RecommendVM()</span>
}

// RecommendVMByParam - MCIS VM 추천
func (m *MCISApi) RecommendVMByParam(req *McisRecommendVmCreateRequest) (string, error) <span class="cov0" title="0">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.RecommendVM()
        m.SetInType(holdType)

        return result, err</span>
}

// CmdMcis - MCIS 명령 실행
func (m *MCISApi) CmdMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CmdMcis()</span>
}

// CmdMcisByParam - MCIS 명령 실행
func (m *MCISApi) CmdMcisByParam(req *McisCmdCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.CmdMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// CmdMcisVm - MCIS VM 명령 실행
func (m *MCISApi) CmdMcisVm(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CmdMcisVm()</span>
}

// CmdMcisVmByParam - MCIS VM 명령 실행
func (m *MCISApi) CmdMcisVmByParam(req *McisCmdVmCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.CmdMcisVm()
        m.SetInType(holdType)

        return result, err</span>
}

// InstallAgentToMcis -  MCIS Agent 설치
func (m *MCISApi) InstallAgentToMcis(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCIS.InData = doc
        return m.requestMCIS.InstallAgentToMcis()</span>
}

// InstallAgentToMcisByParam - MCIS Agent 설치
func (m *MCISApi) InstallAgentToMcisByParam(req *McisCmdCreateRequest) (string, error) <span class="cov0" title="0">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.InstallAgentToMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// InstallMonitorAgentToMcis - MCIS Monitor Agent 설치
func (m *MCISApi) InstallMonitorAgentToMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.InstallMonitorAgentToMcis()</span>
}

// InstallMonitorAgentToMcisByParam - MCIS Monitor Agent 설치
func (m *MCISApi) InstallMonitorAgentToMcisByParam(req *McisCmdCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.InstallMonitorAgentToMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// GetMonitorData - MCIS Monitor 정보 조회
func (m *MCISApi) GetMonitorData(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetMonitorData()</span>
}

// GetMonitorDataByParam - MCIS Monitor 정보 조회
func (m *MCISApi) GetMonitorDataByParam(nameSpaceID string, mcisID string, metric string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "metric": "` + metric + `"}`
        result, err := m.requestMCIS.GetMonitorData()
        m.SetInType(holdType)

        return result, err</span>
}

// GetBenchmark - Benchmark 조회
func (m *MCISApi) GetBenchmark(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetBenchmark()</span>
}

// GetBenchmarkByParam - Benchmark 조회
func (m *MCISApi) GetBenchmarkByParam(nameSpaceID string, mcisID string, action string, host string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "action": "` + action + `", "bm": {"host":"` + host + `"} }`
        result, err := m.requestMCIS.GetBenchmark()
        m.SetInType(holdType)

        return result, err</span>
}

// GetAllBenchmark - Benchmark 목록
func (m *MCISApi) GetAllBenchmark(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetAllBenchmark()</span>
}

// GetAllBenchmarkByParam - Benchmark 목록
func (m *MCISApi) GetAllBenchmarkByParam(nameSpaceID string, mcisID string, host string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "bm": {"host":"` + host + `"} }`
        result, err := m.requestMCIS.GetAllBenchmark()
        m.SetInType(holdType)

        return result, err</span>
}

// CheckMcis - MCIS 체크
func (m *MCISApi) CheckMcis(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CheckMcis()</span>
}

// CheckMcisByParam - MCIS 체크
func (m *MCISApi) CheckMcisByParam(nameSpaceID string, mcisID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `"}`
        result, err := m.requestMCIS.CheckMcis()
        m.SetInType(holdType)

        return result, err</span>
}

// CheckVm - MCIS VM 체크
func (m *MCISApi) CheckVm(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CheckVm()</span>
}

// CheckVmByParam - MCIS VM 체크
func (m *MCISApi) CheckVmByParam(nameSpaceID string, mcisID string, vmID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `", "vmId":"` + vmID + `"}`
        result, err := m.requestMCIS.CheckVm()
        m.SetInType(holdType)

        return result, err</span>
}

// CreateMcisPolicy - Policy 생성
func (m *MCISApi) CreateMcisPolicy(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.CreateMcisPolicy()</span>
}

// CreateMcisPolicyByParam - Policy 생성
func (m *MCISApi) CreateMcisPolicyByParam(req *McisPolicyCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCIS.InData = string(j)
        result, err := m.requestMCIS.CreateMcisPolicy()
        m.SetInType(holdType)

        return result, err</span>
}

// ListMcisPolicy - Policy 목록
func (m *MCISApi) ListMcisPolicy(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.ListMcisPolicy()</span>
}

// ListMcisPolicyByParam - Policy 목록
func (m *MCISApi) ListMcisPolicyByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIS.ListMcisPolicy()
        m.SetInType(holdType)

        return result, err</span>
}

// GetMcisPolicy - Policy 조회
func (m *MCISApi) GetMcisPolicy(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.GetMcisPolicy()</span>
}

// GetMcisPolicyByParam - Policy 조회
func (m *MCISApi) GetMcisPolicyByParam(nameSpaceID string, mcisID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `"}`
        result, err := m.requestMCIS.GetMcisPolicy()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteMcisPolicy - Policy 삭제
func (m *MCISApi) DeleteMcisPolicy(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.DeleteMcisPolicy()</span>
}

// DeleteMcisPolicyByParam - Policy 삭제
func (m *MCISApi) DeleteMcisPolicyByParam(nameSpaceID string, mcisID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `", "mcisId":"` + mcisID + `"}`
        result, err := m.requestMCIS.DeleteMcisPolicy()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteAllMcisPolicy - Policy 전체 삭제
func (m *MCISApi) DeleteAllMcisPolicy(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCIS.InData = doc
        return m.requestMCIS.DeleteAllMcisPolicy()</span>
}

// DeleteAllMcisPolicyByParam - Policy 전체 삭제
func (m *MCISApi) DeleteAllMcisPolicyByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if m.requestMCIS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCIS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := m.requestMCIS.DeleteAllMcisPolicy()
        m.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functiom ] =====

// ===== [ Public Functiom ] =====

// NewMCISManager - MCIS API 객체 생성
func NewMCISManager() (m *MCISApi) <span class="cov8" title="1">{

        m = &amp;MCISApi{}
        m.gConf = &amp;config.GrpcConfig{}
        m.gConf.GSL.TumblebugCli = &amp;config.GrpcClientConfig{}

        m.jaegerCloser = nil
        m.conn = nil
        m.clientMCIS = nil
        m.requestMCIS = nil

        m.inType = "json"
        m.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package request

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/common"

        core_common "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"

        "google.golang.org/grpc"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// NSApi - NS API 구조 정의
type NSApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientNS     pb.NSClient
        requestNS    *common.NSRequest
        inType       string
        outType      string
}

// NsReq - Namespace 정보 생성 요청 구조 정의
// type NsReq struct {
//         Name        string `yaml:"name" json:"name"`
//         Description string `yaml:"description" json:"description"`
// }

// ===== [ Implementations ] =====

// SetServerAddr - Tumblebug 서버 주소 설정
func (ns *NSApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">ns.gConf.GSL.TumblebugCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Tumblebug 서버 주소 값 조회
func (ns *NSApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return ns.gConf.GSL.TumblebugCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 설정
func (ns *NSApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if ns.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov8" title="1">{
                ns.gConf.GSL.TumblebugCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">ns.gConf.GSL.TumblebugCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA 값 조회
func (ns *NSApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if ns.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return ns.gConf.GSL.TumblebugCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 설정
func (ns *NSApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        ns.gConf.GSL.TumblebugCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout 값 조회
func (ns *NSApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return ns.gConf.GSL.TumblebugCli.Timeout, nil
}</span>

// SetJWTToken - JWT 인증 토큰 설정
func (ns *NSApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if ns.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov8" title="1">{
                ns.gConf.GSL.TumblebugCli.Interceptors = &amp;config.InterceptorsConfig{}
                ns.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if ns.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                ns.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">ns.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT 인증 토큰 값 조회
func (ns *NSApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if ns.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if ns.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return ns.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath - 환경설정 파일 설정
func (ns *NSApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Make new config parser that uses Viper library
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // TUMBLEBUG CLIENT 필수 입력 항목 체크
        <span class="cov8" title="1">tumblebugcli := gConf.GSL.TumblebugCli

        if tumblebugcli == nil </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.Timeout == 0 </span><span class="cov0" title="0">{
                tumblebugcli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if tumblebugcli.TLS != nil </span><span class="cov0" title="0">{
                if tumblebugcli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("tumblebugcli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if tumblebugcli.Interceptors != nil </span><span class="cov0" title="0">{
                if tumblebugcli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("tumblebugcli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if tumblebugcli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if tumblebugcli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("tumblebugcli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">ns.gConf = &amp;gConf
        return nil</span>
}

// Open - 연결 설정
func (ns *NSApi) Open() error <span class="cov8" title="1">{

        tumblebugcli := ns.gConf.GSL.TumblebugCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(tumblebugcli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                ns.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">ns.conn = cbconn.Conn

        // grpc 클라이언트 생성
        ns.clientNS = pb.NewNSClient(ns.conn)

        // grpc 호출 Wrapper
        ns.requestNS = &amp;common.NSRequest{Client: ns.clientNS, Timeout: tumblebugcli.Timeout, InType: ns.inType, OutType: ns.outType}

        return nil</span>
}

// Close - 연결 종료
func (ns *NSApi) Close() <span class="cov8" title="1">{
        if ns.conn != nil </span><span class="cov8" title="1">{
                ns.conn.Close()
        }</span>
        <span class="cov8" title="1">if ns.jaegerCloser != nil </span><span class="cov0" title="0">{
                ns.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">ns.jaegerCloser = nil
        ns.conn = nil
        ns.clientNS = nil
        ns.requestNS = nil</span>
}

// SetInType - 입력 문서 타입 설정 (json/yaml)
func (ns *NSApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                ns.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                ns.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if ns.requestNS != nil </span><span class="cov8" title="1">{
                ns.requestNS.InType = ns.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType - 입력 문서 타입 값 조회
func (ns *NSApi) GetInType() (string, error) <span class="cov8" title="1">{
        return ns.inType, nil
}</span>

// SetOutType - 출력 문서 타입 설정 (json/yaml)
func (ns *NSApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                ns.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                ns.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if ns.requestNS != nil </span><span class="cov8" title="1">{
                ns.requestNS.OutType = ns.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType - 출력 문서 타입 값 조회
func (ns *NSApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return ns.outType, nil
}</span>

// CreateNS - Namespace 생성
func (ns *NSApi) CreateNS(doc string) (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ns.requestNS.InData = doc
        return ns.requestNS.CreateNS()</span>
}

// CreateNSByParam - Namespace 생성
func (ns *NSApi) CreateNSByParam(req *core_common.NsReq) (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ns.GetInType()
        ns.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ns.requestNS.InData = string(j)
        result, err := ns.requestNS.CreateNS()
        ns.SetInType(holdType)

        return result, err</span>
}

// ListNS - Namespace 목록
func (ns *NSApi) ListNS() (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return ns.requestNS.ListNS()</span>
}

// ListNSId
func (ns *NSApi) ListNSId() (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return ns.requestNS.ListNSId()</span>
}

// GetNS - Namespace 조회
func (ns *NSApi) GetNS(doc string) (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ns.requestNS.InData = doc
        return ns.requestNS.GetNS()</span>
}

// GetNSByParam - Namespace 조회
func (ns *NSApi) GetNSByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ns.GetInType()
        ns.SetInType("json")
        ns.requestNS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := ns.requestNS.GetNS()
        ns.SetInType(holdType)

        return result, err</span>
}

// DeleteNS - Namespace 삭제
func (ns *NSApi) DeleteNS(doc string) (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ns.requestNS.InData = doc
        return ns.requestNS.DeleteNS()</span>
}

// DeleteNSByParam - Namespace 삭제
func (ns *NSApi) DeleteNSByParam(nameSpaceID string) (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ns.GetInType()
        ns.SetInType("json")
        ns.requestNS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := ns.requestNS.DeleteNS()
        ns.SetInType(holdType)

        return result, err</span>
}

// DeleteAllNS - Namespace 전체 삭제
func (ns *NSApi) DeleteAllNS() (string, error) <span class="cov8" title="1">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return ns.requestNS.DeleteAllNS()</span>
}

// CheckNS - Namespace 체크
func (ns *NSApi) CheckNS(doc string) (string, error) <span class="cov0" title="0">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">ns.requestNS.InData = doc
        return ns.requestNS.CheckNS()</span>
}

// CheckNSByParam - Namespace 체크
func (ns *NSApi) CheckNSByParam(nameSpaceID string) (string, error) <span class="cov0" title="0">{
        if ns.requestNS == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := ns.GetInType()
        ns.SetInType("json")
        ns.requestNS.InData = `{"nsId":"` + nameSpaceID + `"}`
        result, err := ns.requestNS.CheckNS()
        ns.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewNSManager - NS API 객체 생성
func NewNSManager() (ns *NSApi) <span class="cov8" title="1">{

        ns = &amp;NSApi{}
        ns.gConf = &amp;config.GrpcConfig{}
        ns.gConf.GSL.TumblebugCli = &amp;config.GrpcClientConfig{}

        ns.jaegerCloser = nil
        ns.conn = nil
        ns.clientNS = nil
        ns.requestNS = nil

        ns.inType = "json"
        ns.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package request

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/config"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/request/common"

        core_common "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"

        "google.golang.org/grpc"
)

// ===== [ Coutants and Variables ] =====

// ===== [ Types ] =====

// UtilityApi - Utility API 구조 정의
type UtilityApi struct {
        gConf          *config.GrpcConfig
        conn           *grpc.ClientConn
        jaegerCloser   io.Closer
        clientUtility  pb.UtilityClient
        requestUtility *common.UtilityRequest
        inType         string
        outType        string
}

// ConfigReq - Config 정보 생성 요청 구조 정의
// type ConfigReq struct {
//         Name  string `yaml:"name" json:"name"`
//         Value string `yaml:"value" json:"value"`
// }

// ===== [ Implementatiou ] =====

// SetServerAddr - Tumblebug 서버 주소 설정
func (u *UtilityApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">u.gConf.GSL.TumblebugCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Tumblebug 서버 주소 값 조회
func (u *UtilityApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return u.gConf.GSL.TumblebugCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 설정
func (u *UtilityApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if u.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov8" title="1">{
                u.gConf.GSL.TumblebugCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">u.gConf.GSL.TumblebugCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA 값 조회
func (u *UtilityApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if u.gConf.GSL.TumblebugCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return u.gConf.GSL.TumblebugCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 설정
func (u *UtilityApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        u.gConf.GSL.TumblebugCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout 값 조회
func (u *UtilityApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return u.gConf.GSL.TumblebugCli.Timeout, nil
}</span>

// SetJWTToken - JWT 인증 토큰 설정
func (u *UtilityApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if u.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov8" title="1">{
                u.gConf.GSL.TumblebugCli.Interceptors = &amp;config.InterceptorsConfig{}
                u.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if u.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                u.gConf.GSL.TumblebugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">u.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT 인증 토큰 값 조회
func (u *UtilityApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if u.gConf.GSL.TumblebugCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if u.gConf.GSL.TumblebugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return u.gConf.GSL.TumblebugCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath - 환경설정 파일 설정
func (u *UtilityApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Make new config parser that uses Viper library
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // TUMBLEBUG CLIENT 필수 입력 항목 체크
        <span class="cov8" title="1">tumblebugcli := gConf.GSL.TumblebugCli

        if tumblebugcli == nil </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("tumblebugcli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if tumblebugcli.Timeout == 0 </span><span class="cov0" title="0">{
                tumblebugcli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if tumblebugcli.TLS != nil </span><span class="cov0" title="0">{
                if tumblebugcli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("tumblebugcli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if tumblebugcli.Interceptors != nil </span><span class="cov0" title="0">{
                if tumblebugcli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("tumblebugcli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if tumblebugcli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if tumblebugcli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if tumblebugcli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("tumblebugcli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">u.gConf = &amp;gConf
        return nil</span>
}

// Open - 연결 설정
func (u *UtilityApi) Open() error <span class="cov8" title="1">{

        tumblebugcli := u.gConf.GSL.TumblebugCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(tumblebugcli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                u.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">u.conn = cbconn.Conn

        // grpc 클라이언트 생성
        u.clientUtility = pb.NewUtilityClient(u.conn)

        // grpc 호출 Wrapper
        u.requestUtility = &amp;common.UtilityRequest{Client: u.clientUtility, Timeout: tumblebugcli.Timeout, InType: u.inType, OutType: u.outType}

        return nil</span>
}

// Close - 연결 종료
func (u *UtilityApi) Close() <span class="cov8" title="1">{
        if u.conn != nil </span><span class="cov8" title="1">{
                u.conn.Close()
        }</span>
        <span class="cov8" title="1">if u.jaegerCloser != nil </span><span class="cov0" title="0">{
                u.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">u.jaegerCloser = nil
        u.conn = nil
        u.clientUtility = nil
        u.requestUtility = nil</span>
}

// SetInType - 입력 문서 타입 설정 (json/yaml)
func (u *UtilityApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                u.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                u.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if u.requestUtility != nil </span><span class="cov8" title="1">{
                u.requestUtility.InType = u.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType - 입력 문서 타입 값 조회
func (u *UtilityApi) GetInType() (string, error) <span class="cov8" title="1">{
        return u.inType, nil
}</span>

// SetOutType - 출력 문서 타입 설정 (json/yaml)
func (u *UtilityApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                u.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                u.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if u.requestUtility != nil </span><span class="cov8" title="1">{
                u.requestUtility.OutType = u.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType - 출력 문서 타입 값 조회
func (u *UtilityApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return u.outType, nil
}</span>

// ListConnConfig - Connection Config 목록
func (u *UtilityApi) ListConnConfig() (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return u.requestUtility.ListConnConfig()</span>
}

// GetConnConfig - Connection Config 조회
func (u *UtilityApi) GetConnConfig(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.GetConnConfig()</span>
}

// GetConnConfigByParam - Connection Config 조회
func (u *UtilityApi) GetConnConfigByParam(connConfigName string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"connConfigName":"` + connConfigName + `"}`
        result, err := u.requestUtility.GetConnConfig()
        u.SetInType(holdType)

        return result, err</span>
}

// ListRegion - Region 목록
func (u *UtilityApi) ListRegion() (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return u.requestUtility.ListRegion()</span>
}

// GetRegion - Region 조회
func (u *UtilityApi) GetRegion(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.GetRegion()</span>
}

// GetRegionByParam - Region 조회
func (u *UtilityApi) GetRegionByParam(regionName string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"regionName":"` + regionName + `"}`
        result, err := u.requestUtility.GetRegion()
        u.SetInType(holdType)

        return result, err</span>
}

// CreateConfig - Config 생성
func (u *UtilityApi) CreateConfig(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.CreateConfig()</span>
}

// CreateConfigByParam - Config 생성
func (u *UtilityApi) CreateConfigByParam(req *core_common.ConfigReq) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">u.requestUtility.InData = string(j)
        result, err := u.requestUtility.CreateConfig()
        u.SetInType(holdType)

        return result, err</span>
}

// ListConfig - Config 목록
func (u *UtilityApi) ListConfig() (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return u.requestUtility.ListConfig()</span>
}

// GetConfig - Config 조회
func (u *UtilityApi) GetConfig(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.GetConfig()</span>
}

// GetConfigByParam - Config 조회
func (u *UtilityApi) GetConfigByParam(configId string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"configId":"` + configId + `"}`
        result, err := u.requestUtility.GetConfig()
        u.SetInType(holdType)

        return result, err</span>
}

// InitConfig - Config 조회
func (u *UtilityApi) InitConfig(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.InitConfig()</span>
}

// InitConfigByParam - Config 조회
func (u *UtilityApi) InitConfigByParam(configId string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"configId":"` + configId + `"}`
        result, err := u.requestUtility.InitConfig()
        u.SetInType(holdType)

        return result, err</span>
}

// InitAllConfig - Config 전체 삭제
func (u *UtilityApi) InitAllConfig() (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return u.requestUtility.InitAllConfig()</span>
}

// InspectMcirResources - MCIR 리소스 점검
func (u *UtilityApi) InspectMcirResources(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.InspectMcirResources()</span>
}

// InspectMcirResourcesByParam - MCIR 리소스 점검
func (u *UtilityApi) InspectMcirResourcesByParam(connectionName string, mcirType string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"connectionName":"` + connectionName + `", "type":"` + mcirType + `"}`
        result, err := u.requestUtility.InspectMcirResources()
        u.SetInType(holdType)

        return result, err</span>
}

// InspectVmResources - VM 리소스 점검
func (u *UtilityApi) InspectVmResources(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.InspectVmResources()</span>
}

// InspectVmResourcesByParam - VM 리소스 점검
func (u *UtilityApi) InspectVmResourcesByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"connectionName":"` + connectionName + `"}`
        result, err := u.requestUtility.InspectVmResources()
        u.SetInType(holdType)

        return result, err</span>
}

// ListObject - 객체 목록
func (u *UtilityApi) ListObject(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.ListObject()</span>
}

// ListObjectByParam - 객체 목록
func (u *UtilityApi) ListObjectByParam(key string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"key":"` + key + `"}`
        result, err := u.requestUtility.ListObject()
        u.SetInType(holdType)

        return result, err</span>
}

// GetObject - 객체 조회
func (u *UtilityApi) GetObject(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.GetObject()</span>
}

// GetObjectByParam - 객체 조회
func (u *UtilityApi) GetObjectByParam(key string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"key":"` + key + `"}`
        result, err := u.requestUtility.GetObject()
        u.SetInType(holdType)

        return result, err</span>
}

// DeleteObject - 객체 삭제
func (u *UtilityApi) DeleteObject(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.DeleteObject()</span>
}

// DeleteObjectByParam - 객체 삭제
func (u *UtilityApi) DeleteObjectByParam(key string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"key":"` + key + `"}`
        result, err := u.requestUtility.DeleteObject()
        u.SetInType(holdType)

        return result, err</span>
}

// DeleteAllObject - 객체 전체 삭제
func (u *UtilityApi) DeleteAllObject(doc string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">u.requestUtility.InData = doc
        return u.requestUtility.DeleteAllObject()</span>
}

// DeleteAllObjectByParam - 객체 전체 삭제
func (u *UtilityApi) DeleteAllObjectByParam(key string) (string, error) <span class="cov8" title="1">{
        if u.requestUtility == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := u.GetInType()
        u.SetInType("json")
        u.requestUtility.InData = `{"key":"` + key + `"}`
        result, err := u.requestUtility.DeleteAllObject()
        u.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functiou ] =====

// ===== [ Public Functiou ] =====

// NewUtilityManager - Utility API 객체 생성
func NewUtilityManager() (u *UtilityApi) <span class="cov8" title="1">{

        u = &amp;UtilityApi{}
        u.gConf = &amp;config.GrpcConfig{}
        u.gConf.GSL.TumblebugCli = &amp;config.GrpcClientConfig{}

        u.jaegerCloser = nil
        u.conn = nil
        u.clientUtility = nil
        u.requestUtility = nil

        u.inType = "json"
        u.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package common

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateConfig
func (s *UtilityService) CreateConfig(ctx context.Context, req *pb.ConfigCreateRequest) (*pb.ConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.CreateConfig()")

        // Copy gRPC message to 'common' object
        var commObj common.ConfigReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;commObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.CreateConfig()")
        }</span>

        <span class="cov8" title="1">content, err := common.UpdateConfig(&amp;commObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.CreateConfig()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.ConfigInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.CreateConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ConfigInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListConfig
func (s *UtilityService) ListConfig(ctx context.Context, req *pb.Empty) (*pb.ListConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.ListConfig()")

        configList, err := common.ListConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.ListConfig()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj []*pb.ConfigInfo
        err = gc.CopySrcToDest(&amp;configList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.ListConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListConfigInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetConfig
func (s *UtilityService) GetConfig(ctx context.Context, req *pb.ConfigQryRequest) (*pb.ConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.GetConfig()")

        res, err := common.GetConfig(req.ConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.GetConfig()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.ConfigInfo
        err = gc.CopySrcToDest(&amp;res, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.GetConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ConfigInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// InitConfig
func (s *UtilityService) InitConfig(ctx context.Context, req *pb.ConfigQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.InitConfig()")

        err := common.InitConfig(req.ConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.InitConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The config " + req.ConfigId + " has been initialized."}
        return resp, nil</span>
}

// InitAllConfig
func (s *UtilityService) InitAllConfig(ctx context.Context, req *pb.Empty) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.InitAllConfig()")

        err := common.InitAllConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.InitAllConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "All configs have been initialized."}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file52" style="display: none">package common

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateNS - Namespace 생성
func (s *NSService) CreateNS(ctx context.Context, req *pb.NSCreateRequest) (*pb.NSInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling NSService.CreateNS()")

        // GRPC 메시지에서 NS 객체로 복사
        var nsObj common.NsReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;nsObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.CreateNS()")
        }</span>

        <span class="cov8" title="1">content, err := common.CreateNs(&amp;nsObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.CreateNS()")
        }</span>

        // NS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.NSInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.CreateNS()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.NSInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListNS - Namespace 목록
func (s *NSService) ListNS(ctx context.Context, req *pb.Empty) (*pb.ListNSInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling NSService.ListNS()")

        nsList, err := common.ListNs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.ListNS()")
        }</span>

        // NS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.NSInfo
        err = gc.CopySrcToDest(&amp;nsList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.ListNS()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListNSInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ListNSId
func (s *NSService) ListNSId(ctx context.Context, req *pb.Empty) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling NSService.ListNSId()")

        nsList, err := common.ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.ListNSId()")
        }</span>

        // NS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;nsList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.ListNSId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// GetNS - Namespace 조회
func (s *NSService) GetNS(ctx context.Context, req *pb.NSQryRequest) (*pb.NSInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling NSService.GetNS()")

        res, err := common.GetNs(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.GetNS()")
        }</span>

        // NS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.NSInfo
        err = gc.CopySrcToDest(&amp;res, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.GetNS()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.NSInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteNS - Namespace 삭제
func (s *NSService) DeleteNS(ctx context.Context, req *pb.NSQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling NSService.DeleteNS()")

        err := common.DelNs(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.DeleteNS()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The ns has been deleted"}
        return resp, nil</span>
}

// DeleteAllNS - Namespace 전체 삭제
func (s *NSService) DeleteAllNS(ctx context.Context, req *pb.Empty) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling NSService.DeleteAllNS()")

        err := common.DelAllNs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "NSService.DeleteAllNS()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "All namespaces has been deleted"}
        return resp, nil</span>
}

// CheckNS - Namespace 체크
func (s *NSService) CheckNS(ctx context.Context, req *pb.NSQryRequest) (*pb.ExistsResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling NSService.CheckNS()")

        err := common.CheckString(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                resp := &amp;pb.ExistsResponse{Exists: false}
                common.CBLog.Error(err)
                return resp, err
        }</span>
        <span class="cov0" title="0">exists, err := common.CheckNs(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug(err)
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.ExistsResponse{Exists: exists}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file53" style="display: none">package common

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListConnConfig
func (s *UtilityService) ListConnConfig(ctx context.Context, req *pb.Empty) (*pb.ListConnConfigResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.ListConnConfig()")

        content, err := common.GetConnConfigList()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.ListConnConfig()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.ListConnConfigResponse
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.ListConnConfig()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetConnConfig
func (s *UtilityService) GetConnConfig(ctx context.Context, req *pb.ConnConfigQryRequest) (*pb.ConnConfigResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.GetConnConfig()")

        content, err := common.GetConnConfig(req.ConnConfigName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.GetConnConfig()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.ConnConfig
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.GetConnConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ConnConfigResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListRegion
func (s *UtilityService) ListRegion(ctx context.Context, req *pb.Empty) (*pb.ListRegionResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.ListRegion()")

        content, err := common.GetRegionList()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.ListRegion()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.ListRegionResponse
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.ListRegion()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetRegion
func (s *UtilityService) GetRegion(ctx context.Context, req *pb.RegionQryRequest) (*pb.RegionResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.GetRegion()")

        content, err := common.GetRegion(req.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.GetRegion()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.Region
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.GetRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.RegionResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// InspectMcirResources
func (s *UtilityService) InspectMcirResources(ctx context.Context, req *pb.InspectQryRequest) (*pb.InspectMcirInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.InspectMcirResources()")

        content, err := mcir.InspectResources(req.ConnectionName, req.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.InspectMcirResources()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.InspectMcirInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.InspectMcirResources()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.InspectMcirInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// InspectVmResources
func (s *UtilityService) InspectVmResources(ctx context.Context, req *pb.InspectQryRequest) (*pb.InspectVmInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.InspectVmResources()")

        content, err := mcis.InspectVMs(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.InspectVmResources()")
        }</span>

        // Copy 'common' object to gRPC message
        <span class="cov8" title="1">var grpcObj pb.InspectVmInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.InspectVmResources()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.InspectVmInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListObject
func (s *UtilityService) ListObject(ctx context.Context, req *pb.ObjectQryRequest) (*pb.ListObjectInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.ListObject()")

        content := common.GetObjectList(req.Key)

        resp := &amp;pb.ListObjectInfoResponse{Items: content}
        return resp, nil
}</span>

// GetObject
func (s *UtilityService) GetObject(ctx context.Context, req *pb.ObjectQryRequest) (*pb.ObjectInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.GetObject()")

        content, err := common.GetObjectValue(req.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "UtilityService.GetObject()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ObjectInfoResponse{Item: content}
        return resp, nil</span>
}

// DeleteObject
func (s *UtilityService) DeleteObject(ctx context.Context, req *pb.ObjectQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.DeleteObject()")

        content, err := common.GetObjectValue(req.Key)
        if err != nil || content == "" </span><span class="cov0" title="0">{
                resp := &amp;pb.MessageResponse{Message: "Cannot find [" + req.Key + "] object"}
                return resp, nil
        }</span>

        <span class="cov8" title="1">err = common.DeleteObject(req.Key)
        if err != nil </span><span class="cov0" title="0">{
                resp := &amp;pb.MessageResponse{Message: "Cannot delete [" + req.Key + "] object"}
                return resp, nil
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The object has been deleted"}
        return resp, nil</span>
}

// DeleteAllObject
func (s *UtilityService) DeleteAllObject(ctx context.Context, req *pb.ObjectQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling UtilityService.DeleteAllObject()")

        err := common.DeleteObjects(req.Key)
        if err != nil </span><span class="cov0" title="0">{
                resp := &amp;pb.MessageResponse{Message: "Cannot delete  objects"}
                return resp, nil
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "Objects have been deleted"}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file54" style="display: none">package mcir

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CheckResource - Resource 체크
func (s *MCIRService) CheckResource(ctx context.Context, req *pb.ResourceQryRequest) (*pb.ExistsResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CheckResource()")

        exists, err := mcir.CheckResource(req.NsId, req.ResourceType, req.ResourceId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Debug(err)
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ExistsResponse{Exists: exists}
        return resp, nil</span>
}

// ListLookupSpec - Spec 목록
func (s *MCIRService) ListLookupSpec(ctx context.Context, req *pb.LookupSpecListQryRequest) (*pb.ListSpiderSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListLookupSpec()")

        content, err := mcir.LookupSpecList(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListLookupSpec()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListSpiderSpecInfoResponse
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListLookupSpec()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetLookupSpec - Spec 조회
func (s *MCIRService) GetLookupSpec(ctx context.Context, req *pb.LookupSpecQryRequest) (*pb.SpiderSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.GetLookupSpec()")

        content, err := mcir.LookupSpec(req.ConnectionName, req.CspSpecName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetLookupSpec()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.SpiderSpecInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetLookupSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.SpiderSpecInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListLookupImage - Image 목록
func (s *MCIRService) ListLookupImage(ctx context.Context, req *pb.LookupImageListQryRequest) (*pb.ListSpiderImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListLookupImage()")

        content, err := mcir.LookupImageList(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListLookupImage()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListSpiderImageInfoResponse
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListLookupImage()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetLookupImage - Image 조회
func (s *MCIRService) GetLookupImage(ctx context.Context, req *pb.LookupImageQryRequest) (*pb.SpiderImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.GetLookupImage()")

        content, err := mcir.LookupImage(req.ConnectionName, req.CspImageId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetLookupImage()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.SpiderImageInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetLookupImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.SpiderImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file55" style="display: none">package mcir

import (
        "context"
        "fmt"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateImageWithInfo - Image 생성
func (s *MCIRService) CreateImageWithInfo(ctx context.Context, req *pb.TbImageInfoRequest) (*pb.TbImageInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CreateImageWithInfo()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbImageInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateImageWithInfo()")
        }</span>

        <span class="cov0" title="0">content, err := mcir.RegisterImageWithInfo(req.NsId, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateImageWithInfo()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.TbImageInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateImageWithInfo()")
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.TbImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// CreateImageWithID - Image 생성
func (s *MCIRService) CreateImageWithID(ctx context.Context, req *pb.TbImageCreateRequest) (*pb.TbImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CreateImageWithID()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbImageReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateImageWithID()")
        }</span>

        <span class="cov8" title="1">content, err := mcir.RegisterImageWithId(req.NsId, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateImageWithID()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbImageInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateImageWithID()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListImage - Image 목록
func (s *MCIRService) ListImage(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListTbImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListImage()")

        resourceList, err := mcir.ListResource(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListImage()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbImageInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbImageInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ListImageId
func (s *MCIRService) ListImageId(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListImageId()")

        resourceList, err := mcir.ListResourceId(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListImageId()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListImageId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// GetImage - Image 조회
func (s *MCIRService) GetImage(ctx context.Context, req *pb.ResourceQryRequest) (*pb.TbImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.GetImage()")

        res, err := mcir.GetResource(req.NsId, req.ResourceType, req.ResourceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetImage()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbImageInfo
        err = gc.CopySrcToDest(&amp;res, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteImage - Image 삭제
func (s *MCIRService) DeleteImage(ctx context.Context, req *pb.ResourceQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteImage()")

        err := mcir.DelResource(req.NsId, req.ResourceType, req.ResourceId, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The " + req.ResourceType + " " + req.ResourceId + " has been deleted"}
        return resp, nil</span>
}

// DeleteAllImage - Image 전체 삭제
func (s *MCIRService) DeleteAllImage(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteAllImage()")

        err := mcir.DelAllResources(req.NsId, req.ResourceType, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteAllImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "All " + req.ResourceType + "s has been deleted"}
        return resp, nil</span>
}

// FetchImage - Image 가져오기
func (s *MCIRService) FetchImage(ctx context.Context, req *pb.FetchImageQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.FetchImage()")

        var connConfigCount, imageCount uint
        var err error

        if req.ConnectionName == "!all" </span><span class="cov8" title="1">{
                connConfigCount, imageCount, err = mcir.FetchImagesForAllConnConfigs(req.NsId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FetchImage()")
                }</span>
        } else<span class="cov8" title="1"> {
                connConfigCount = 1
                imageCount, err = mcir.FetchImagesForConnConfig(req.ConnectionName, req.NsId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FetchImage()")
                }</span>
        }

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "Fetched " + fmt.Sprint(imageCount) + " images (from " + fmt.Sprint(connConfigCount) + " connConfigs)"}
        return resp, nil</span>
}

// SearchImage - Image 검색
func (s *MCIRService) SearchImage(ctx context.Context, req *pb.SearchImageQryRequest) (*pb.ListTbImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.SearchImage()")

        content, err := mcir.SearchImage(req.NsId, req.Keywords...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.SearchImage()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbImageInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.SearchImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbImageInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file56" style="display: none">package mcir

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSecurityGroup - Security Group 생성
func (s *MCIRService) CreateSecurityGroup(ctx context.Context, req *pb.TbSecurityGroupCreateRequest) (*pb.TbSecurityGroupInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CreateSecurityGroup()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbSecurityGroupReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSecurityGroup()")
        }</span>

        <span class="cov8" title="1">content, err := mcir.CreateSecurityGroup(req.NsId, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSecurityGroup()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbSecurityGroupInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSecurityGroup()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbSecurityGroupInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListSecurityGroup - Security Group 목록
func (s *MCIRService) ListSecurityGroup(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListTbSecurityGroupInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListSecurityGroup()")

        resourceList, err := mcir.ListResource(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSecurityGroup()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbSecurityGroupInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSecurityGroup()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbSecurityGroupInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ListSecurityGroupId
func (s *MCIRService) ListSecurityGroupId(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListSecurityGroupId()")

        resourceList, err := mcir.ListResourceId(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSecurityGroupId()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSecurityGroupId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// GetSecurityGroup - Security Group 조회
func (s *MCIRService) GetSecurityGroup(ctx context.Context, req *pb.ResourceQryRequest) (*pb.TbSecurityGroupInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.GetSecurityGroup()")

        res, err := mcir.GetResource(req.NsId, req.ResourceType, req.ResourceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetSecurityGroup()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbSecurityGroupInfo
        err = gc.CopySrcToDest(&amp;res, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetSecurityGroup()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbSecurityGroupInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteSecurityGroup - Security Group 삭제
func (s *MCIRService) DeleteSecurityGroup(ctx context.Context, req *pb.ResourceQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteSecurityGroup()")

        err := mcir.DelResource(req.NsId, req.ResourceType, req.ResourceId, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteSecurityGroup()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The " + req.ResourceType + " " + req.ResourceId + " has been deleted"}
        return resp, nil</span>
}

// DeleteAllSecurityGroup - Security Group 전체 삭제
func (s *MCIRService) DeleteAllSecurityGroup(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteAllSecurityGroup()")

        err := mcir.DelAllResources(req.NsId, req.ResourceType, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteAllSecurityGroup()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "All " + req.ResourceType + "s has been deleted"}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file57" style="display: none">package mcir

import (
        "context"
        "fmt"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSpecWithInfo - Spec 생성
func (s *MCIRService) CreateSpecWithInfo(ctx context.Context, req *pb.TbSpecInfoRequest) (*pb.TbSpecInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CreateSpecWithInfo()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbSpecInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSpecWithInfo()")
        }</span>

        <span class="cov0" title="0">content, err := mcir.RegisterSpecWithInfo(req.NsId, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSpecWithInfo()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSpecWithInfo()")
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.TbSpecInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// CreateSpecWithSpecName - Spec 생성
func (s *MCIRService) CreateSpecWithSpecName(ctx context.Context, req *pb.TbSpecCreateRequest) (*pb.TbSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CreateSpecWithSpecName()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbSpecReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSpecWithSpecName()")
        }</span>

        <span class="cov8" title="1">content, err := mcir.RegisterSpecWithCspSpecName(req.NsId, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSpecWithSpecName()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSpecWithSpecName()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbSpecInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListSpec - Spec 목록
func (s *MCIRService) ListSpec(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListTbSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListSpec()")

        resourceList, err := mcir.ListResource(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSpec()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbSpecInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ListSpecId
func (s *MCIRService) ListSpecId(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListSpecId()")

        resourceIdList, err := mcir.ListResourceId(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSpecId()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;resourceIdList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSpecId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// GetSpec - Spec 조회
func (s *MCIRService) GetSpec(ctx context.Context, req *pb.ResourceQryRequest) (*pb.TbSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.GetSpec()")

        res, err := mcir.GetResource(req.NsId, req.ResourceType, req.ResourceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetSpec()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;res, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbSpecInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteSpec - Spec 삭제
func (s *MCIRService) DeleteSpec(ctx context.Context, req *pb.ResourceQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteSpec()")

        err := mcir.DelResource(req.NsId, req.ResourceType, req.ResourceId, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The " + req.ResourceType + " " + req.ResourceId + " has been deleted"}
        return resp, nil</span>
}

// DeleteAllSpec - Spec 전체 삭제
func (s *MCIRService) DeleteAllSpec(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteAllSpec()")

        err := mcir.DelAllResources(req.NsId, req.ResourceType, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteAllSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "All " + req.ResourceType + "s has been deleted"}
        return resp, nil</span>
}

// FetchSpec - Spec 가져오기
func (s *MCIRService) FetchSpec(ctx context.Context, req *pb.FetchSpecQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.FetchSpec()")

        // connConfigCount, specCount, err := mcir.FetchSpecsForAllConnConfigs(req.NsId)
        // if err != nil {
        //         return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FetchSpec()")
        // }

        var connConfigCount, specCount uint
        var err error

        if req.ConnectionName == "!all" </span><span class="cov8" title="1">{
                connConfigCount, specCount, err = mcir.FetchSpecsForAllConnConfigs(req.NsId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FetchSpec()")
                }</span>
        } else<span class="cov8" title="1"> {
                connConfigCount = 1
                specCount, err = mcir.FetchSpecsForConnConfig(req.ConnectionName, req.NsId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FetchSpec()")
                }</span>
        }

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "Fetched " + fmt.Sprint(specCount) + " specs (from " + fmt.Sprint(connConfigCount) + " connConfigs)"}
        return resp, nil</span>
}

// FilterSpec
func (s *MCIRService) FilterSpec(ctx context.Context, req *pb.TbSpecInfoRequest) (*pb.ListTbSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.FilterSpec()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbSpecInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FilterSpec()")
        }</span>

        <span class="cov8" title="1">resourceList, err := mcir.FilterSpecs(req.NsId, mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FilterSpec()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FilterSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbSpecInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// FilterSpecsByRange
func (s *MCIRService) FilterSpecsByRange(ctx context.Context, req *pb.FilterSpecsByRangeRequest) (*pb.ListTbSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.FilterSpecsByRange()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var filter mcir.FilterSpecsByRangeRequest
        err := gc.CopySrcToDest(&amp;req.Filter, &amp;filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FilterSpecsByRange()")
        }</span>

        <span class="cov8" title="1">resourceList, err := mcir.FilterSpecsByRange(req.NsId, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FilterSpecsByRange()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.FilterSpecsByRange()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbSpecInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// SortSpecs
func (s *MCIRService) SortSpecs(ctx context.Context, req *pb.SortSpecsRequest) (*pb.ListTbSpecInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.SortSpecs()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var specList []mcir.TbSpecInfo
        err := gc.CopySrcToDest(&amp;req.Items, &amp;specList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.SortSpecs()")
        }</span>

        <span class="cov0" title="0">resourceList, err := mcir.SortSpecs(specList, req.OrderBy, req.Direction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.SortSpecs()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj []*pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.SortSpecs()")
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.ListTbSpecInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// UpdateSpec
func (s *MCIRService) UpdateSpec(ctx context.Context, req *pb.TbSpecInfoRequest) (*pb.TbSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.UpdateSpec()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbSpecInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.UpdateSpec()")
        }</span>

        <span class="cov8" title="1">content, err := mcir.UpdateSpec(req.NsId, mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.UpdateSpec()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.UpdateSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbSpecInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file58" style="display: none">package mcir

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSshKey - KeyPair 생성
func (s *MCIRService) CreateSshKey(ctx context.Context, req *pb.TbSshKeyCreateRequest) (*pb.TbSshKeyInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CreateSshKey()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbSshKeyReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSshKey()")
        }</span>

        <span class="cov8" title="1">content, err := mcir.CreateSshKey(req.NsId, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSshKey()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbSshKeyInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateSshKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbSshKeyInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListSshKey - KeyPair 목록
func (s *MCIRService) ListSshKey(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListTbSshKeyInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListSshKey()")

        resourceList, err := mcir.ListResource(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSshKey()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbSshKeyInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSshKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbSshKeyInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ListSshKeyId
func (s *MCIRService) ListSshKeyId(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListSshKeyId()")

        resourceList, err := mcir.ListResourceId(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSshKeyId()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListSshKeyId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// GetSshKey - KeyPair 조회
func (s *MCIRService) GetSshKey(ctx context.Context, req *pb.ResourceQryRequest) (*pb.TbSshKeyInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.GetSshKey()")

        res, err := mcir.GetResource(req.NsId, req.ResourceType, req.ResourceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetSshKey()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbSshKeyInfo
        err = gc.CopySrcToDest(&amp;res, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetSshKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbSshKeyInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteSshKey - KeyPair 삭제
func (s *MCIRService) DeleteSshKey(ctx context.Context, req *pb.ResourceQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteSshKey()")

        err := mcir.DelResource(req.NsId, req.ResourceType, req.ResourceId, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteSshKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The " + req.ResourceType + " " + req.ResourceId + " has been deleted"}
        return resp, nil</span>
}

// DeleteAllSshKey - KeyPair 전체 삭제
func (s *MCIRService) DeleteAllSshKey(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteAllSshKey()")

        err := mcir.DelAllResources(req.NsId, req.ResourceType, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteAllSshKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "All " + req.ResourceType + "s has been deleted"}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file59" style="display: none">package mcir

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateVNet - VNet 생성
func (s *MCIRService) CreateVNet(ctx context.Context, req *pb.TbVNetCreateRequest) (*pb.TbVNetInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.CreateVNet()")

        // GRPC 메시지에서 MCIR 객체로 복사
        var mcirObj mcir.TbVNetReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateVNet()")
        }</span>

        <span class="cov8" title="1">content, err := mcir.CreateVNet(req.NsId, &amp;mcirObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateVNet()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbVNetInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.CreateVNet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbVNetInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListVNet - VNet 목록
func (s *MCIRService) ListVNet(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListTbVNetInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListVNet()")

        resourceList, err := mcir.ListResource(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListVNet()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbVNetInfo
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListVNet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbVNetInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ListVNetId
func (s *MCIRService) ListVNetId(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.ListVNetId()")

        resourceList, err := mcir.ListResourceId(req.NsId, req.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListVNetId()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;resourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.ListVNetId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// GetVNet - VNet 조회
func (s *MCIRService) GetVNet(ctx context.Context, req *pb.ResourceQryRequest) (*pb.TbVNetInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.GetVNet()")

        res, err := mcir.GetResource(req.NsId, req.ResourceType, req.ResourceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetVNet()")
        }</span>

        // MCIR 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbVNetInfo
        err = gc.CopySrcToDest(&amp;res, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.GetVNet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbVNetInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteVNet - VNet 삭제
func (s *MCIRService) DeleteVNet(ctx context.Context, req *pb.ResourceQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteVNet()")

        err := mcir.DelResource(req.NsId, req.ResourceType, req.ResourceId, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteVNet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "The " + req.ResourceType + " " + req.ResourceId + " has been deleted"}
        return resp, nil</span>
}

// DeleteAllVNet - VNet 전체 삭제
func (s *MCIRService) DeleteAllVNet(ctx context.Context, req *pb.ResourceAllQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCIRService.DeleteAllVNet()")

        err := mcir.DelAllResources(req.NsId, req.ResourceType, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCIRService.DeleteAllVNet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "All " + req.ResourceType + "s has been deleted"}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file60" style="display: none">package mcis

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        rest_mcis "github.com/cloud-barista/poc-cicd-tumblebug/src/api/rest/server/mcis"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateMcis - MCIS 생성
func (s *MCISService) CreateMcis(ctx context.Context, req *pb.TbMcisCreateRequest) (*pb.TbMcisInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CreateMcis()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.TbMcisReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcis()")
        }</span>

        <span class="cov8" title="1">result, err := mcis.CreateMcis(req.NsId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcis()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbMcisInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcis()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbMcisInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListMcis - MCIS 목록
func (s *MCISService) ListMcis(ctx context.Context, req *pb.TbMcisAllQryRequest) (*pb.ListTbMcisInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.ListMcis()")

        result, err := mcis.CoreGetAllMcis(req.NsId, "status")
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcis()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.TbMcisInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcis()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbMcisInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ListMcisId
func (s *MCISService) ListMcisId(ctx context.Context, req *pb.TbMcisAllQryRequest) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.ListMcisId()")

        result, err := mcis.ListMcisId(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisId()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// ControlMcis - MCIS 제어
func (s *MCISService) ControlMcis(ctx context.Context, req *pb.TbMcisActionRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.ControlMcis()")

        result, err := mcis.HandleMcisAction(req.NsId, req.McisId, req.Action)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ControlMcis()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: result}
        return resp, nil</span>
}

// ListMcisStatus - MCIS 상태 목록
func (s *MCISService) ListMcisStatus(ctx context.Context, req *pb.TbMcisAllQryRequest) (*pb.ListTbMcisStatusInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.ListMcisStatus()")

        result, err := mcis.GetMcisStatusAll(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisStatus()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.McisStatusInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisStatus()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListTbMcisStatusInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetMcisStatus - MCIS 상태 조회
func (s *MCISService) GetMcisStatus(ctx context.Context, req *pb.TbMcisQryRequest) (*pb.TbMcisStatusInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetMcisStatus()")

        result, err := mcis.GetMcisStatus(req.NsId, req.McisId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisStatus()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.McisStatusInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisStatus()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbMcisStatusInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// GetMcisInfo - MCIS 정보 조회
func (s *MCISService) GetMcisInfo(ctx context.Context, req *pb.TbMcisQryRequest) (*pb.TbMcisInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetMcisInfo()")

        result, err := mcis.GetMcisInfo(req.NsId, req.McisId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisInfo()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbMcisInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisInfo()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbMcisInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListMcisVmId
func (s *MCISService) ListMcisVmId(ctx context.Context, req *pb.TbMcisQryRequest) (*pb.ListIdResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.ListMcisVmId()")

        result, err := mcis.ListVmId(req.NsId, req.McisId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisVmId()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []string
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisVmId()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListIdResponse{IdList: grpcObj}
        return resp, nil</span>
}

// DeleteMcis - MCIS 삭제
func (s *MCISService) DeleteMcis(ctx context.Context, req *pb.TbMcisQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.DeleteMcis()")

        err := mcis.DelMcis(req.NsId, req.McisId, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.DeleteMcis()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "Deleting the MCIS " + req.McisId}
        return resp, nil</span>
}

// DeleteAllMcis - MCIS 전체 삭제
func (s *MCISService) DeleteAllMcis(ctx context.Context, req *pb.TbMcisAllQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.DeleteAllMcis()")

        result, err := mcis.CoreDelAllMcis(req.NsId, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.DeleteAllMcis()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: result}
        return resp, nil</span>
}

// CreateMcisVM - MCIS VM 생성
func (s *MCISService) CreateMcisVM(ctx context.Context, req *pb.TbVmCreateRequest) (*pb.TbVmInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CreateMcisVM()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.TbVmInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisVM()")
        }</span>

        <span class="cov8" title="1">result, err := mcis.CorePostMcisVm(req.NsId, req.McisId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisVM()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbVmInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbVmInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// CreateMcisVMGroup - MCIS VM 그룹 생성
func (s *MCISService) CreateMcisVMGroup(ctx context.Context, req *pb.TbVmGroupCreateRequest) (*pb.TbMcisInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CreateMcisVMGroup()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.TbVmReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisVMGroup()")
        }</span>

        <span class="cov8" title="1">result, err := mcis.CorePostMcisGroupVm(req.NsId, req.McisId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisVMGroup()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbMcisInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisVMGroup()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbMcisInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ControlMcisVM - MCIS VM 제어
func (s *MCISService) ControlMcisVM(ctx context.Context, req *pb.TbVmActionRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.ControlMcisVM()")

        result, err := mcis.CoreGetMcisVmAction(req.NsId, req.McisId, req.VmId, req.Action)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ControlMcisVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: result}
        return resp, nil</span>
}

// GetMcisVMStatus - MCIS VM 상태 조회
func (s *MCISService) GetMcisVMStatus(ctx context.Context, req *pb.TbVmQryRequest) (*pb.TbVmStatusInfoesponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetMcisVMStatus()")

        result, err := mcis.CoreGetMcisVmStatus(req.NsId, req.McisId, req.VmId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisVMStatus()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbVmStatusInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisVMStatus()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbVmStatusInfoesponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// GetMcisVMInfo - MCIS VM 정보 조회
func (s *MCISService) GetMcisVMInfo(ctx context.Context, req *pb.TbVmQryRequest) (*pb.TbVmInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetMcisVMInfo()")

        result, err := mcis.CoreGetMcisVmInfo(req.NsId, req.McisId, req.VmId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisVMInfo()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.TbVmInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisVMInfo()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.TbVmInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteMcisVM - MCIS VM 삭제
func (s *MCISService) DeleteMcisVM(ctx context.Context, req *pb.TbVmQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.DeleteMcisVM()")

        err := mcis.DelMcisVm(req.NsId, req.McisId, req.VmId, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.DeleteMcisVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "Deleting the VM info"}
        return resp, nil</span>
}

// RecommendMcis - MCIS 추천
func (s *MCISService) RecommendMcis(ctx context.Context, req *pb.McisRecommendCreateRequest) (*pb.McisRecommendInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.RecommendMcis()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.McisRecommendReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.RecommendMcis()")
        }</span>

        <span class="cov0" title="0">result, err := mcis.CorePostMcisRecommend(req.NsId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcis()")
        }</span>

        <span class="cov0" title="0">content := rest_mcis.RestPostMcisRecommendResponse{}
        content.Vm_recommend = result
        content.PlacementAlgo = mcisObj.PlacementAlgo
        content.PlacementParam = mcisObj.PlacementParam

        // MCIS 객체에서 GRPC 메시지로 복사
        var grpcObj pb.McisRecommendInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.RecommendMcis()")
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.McisRecommendInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// CmdMcis - MCIS 명령 실행
func (s *MCISService) CmdMcis(ctx context.Context, req *pb.McisCmdCreateRequest) (*pb.ListCmdMcisResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CmdMcis()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.McisCmdReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CmdMcis()")
        }</span>

        <span class="cov8" title="1">result, err := mcis.CorePostCmdMcis(req.NsId, req.McisId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CmdMcis()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.CmdMcisResult
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CmdMcis()")
        }</span>

        <span class="cov8" title="1">for _, v := range grpcObj </span><span class="cov8" title="1">{
                v.McisId = req.McisId
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListCmdMcisResponse{Items: grpcObj}
        return resp, nil</span>
}

// CmdMcisVm - MCIS VM 명령 실행
func (s *MCISService) CmdMcisVm(ctx context.Context, req *pb.McisCmdVmCreateRequest) (*pb.StringResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CmdMcisVm()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.McisCmdReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CmdMcisVm()")
        }</span>

        <span class="cov8" title="1">result, err := mcis.CorePostCmdMcisVm(req.NsId, req.McisId, req.VmId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CmdMcisVm()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StringResponse{Result: result}
        return resp, nil</span>
}

// InstallAgentToMcis - MCIS Agent 설치
func (s *MCISService) InstallAgentToMcis(ctx context.Context, req *pb.McisCmdCreateRequest) (*pb.ListAgentInstallResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.InstallAgentToMcis()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.McisCmdReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.InstallAgentToMcis()")
        }</span>

        <span class="cov0" title="0">content, err := mcis.InstallAgentToMcis(req.NsId, req.McisId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.InstallAgentToMcis()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.ListAgentInstallResponse
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.InstallAgentToMcis()")
        }</span>

        <span class="cov0" title="0">return &amp;grpcObj, nil</span>
}

// GetBenchmark - Benchmark 조회
func (s *MCISService) GetBenchmark(ctx context.Context, req *pb.BmQryRequest) (*pb.ListBenchmarkInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetBenchmark()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj rest_mcis.RestGetBenchmarkRequest
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetBenchmark()")
        }</span>

        <span class="cov8" title="1">result, err := mcis.CoreGetBenchmark(req.NsId, req.McisId, req.Action, mcisObj.Host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetBenchmark()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListBenchmarkInfoResponse
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetBenchmark()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetAllBenchmark - Benchmark 목록
func (s *MCISService) GetAllBenchmark(ctx context.Context, req *pb.BmQryAllRequest) (*pb.ListBenchmarkInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetAllBenchmark()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj rest_mcis.RestGetAllBenchmarkRequest
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetAllBenchmark()")
        }</span>

        <span class="cov8" title="1">result, err := mcis.CoreGetAllBenchmark(req.NsId, req.McisId, mcisObj.Host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetAllBenchmark()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListBenchmarkInfoResponse
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetAllBenchmark()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file61" style="display: none">package mcis

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// InstallMonitorAgentToMcis - MCIS Monitor Agent 설치
func (s *MCISService) InstallMonitorAgentToMcis(ctx context.Context, req *pb.McisCmdCreateRequest) (*pb.ListAgentInstallResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.InstallMonitorAgentToMcis()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.McisCmdReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.InstallMonitorAgentToMcis()")
        }</span>

        <span class="cov8" title="1">content, err := mcis.InstallMonitorAgentToMcis(req.NsId, req.McisId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.InstallMonitorAgentToMcis()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListAgentInstallResponse
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.InstallMonitorAgentToMcis()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetMonitorData - MCIS Monitor 정보 조회
func (s *MCISService) GetMonitorData(ctx context.Context, req *pb.MonitorQryRequest) (*pb.MonitorResultSimpleResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetMonitorData()")

        content, err := mcis.GetMonitoringData(req.NsId, req.McisId, req.Metric)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMonitorData()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.MonResultSimpleInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMonitorData()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MonitorResultSimpleResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file62" style="display: none">package mcis

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateMcisPolicy - Policy 생성
func (s *MCISService) CreateMcisPolicy(ctx context.Context, req *pb.McisPolicyCreateRequest) (*pb.McisPolicyInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CreateMcisPolicy()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.McisPolicyInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisPolicy()")
        }</span>

        <span class="cov8" title="1">content, err := mcis.CreateMcisPolicy(req.NsId, req.McisId, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisPolicy()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.McisPolicyInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.CreateMcisPolicy()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.McisPolicyInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListMcisPolicy - Policy 목록
func (s *MCISService) ListMcisPolicy(ctx context.Context, req *pb.McisPolicyAllQryRequest) (*pb.ListMcisPolicyInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.ListMcisPolicy()")

        result, err := mcis.GetAllMcisPolicyObject(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisPolicy()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.McisPolicyInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.ListMcisPolicy()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListMcisPolicyInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetMcisPolicy - Policy 조회
func (s *MCISService) GetMcisPolicy(ctx context.Context, req *pb.McisPolicyQryRequest) (*pb.McisPolicyInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.GetMcisPolicy()")

        result, err := mcis.GetMcisPolicyObject(req.NsId, req.McisId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisPolicy()")
        }</span>

        <span class="cov8" title="1">if result.Id == "" </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr("Failed to find McisPolicyObject : "+req.McisId, "", "MCISService.GetMcisPolicy()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.McisPolicyInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.GetMcisPolicy()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.McisPolicyInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteMcisPolicy - Policy 삭제
func (s *MCISService) DeleteMcisPolicy(ctx context.Context, req *pb.McisPolicyQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.DeleteMcisPolicy()")

        err := mcis.DelMcisPolicy(req.NsId, req.McisId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.DeleteMcisPolicy()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: "Deleting the MCIS Policy info"}
        return resp, nil</span>
}

// DeleteAllMcisPolicy - Policy 전체 삭제
func (s *MCISService) DeleteAllMcisPolicy(ctx context.Context, req *pb.McisPolicyAllQryRequest) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.DeleteAllMcisPolicy()")

        result, err := mcis.DelAllMcisPolicy(req.NsId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.DeleteAllMcisPolicy()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.MessageResponse{Message: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file63" style="display: none">package mcis

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// RecommendVM - MCIS VM 추천
func (s *MCISService) RecommendVM(ctx context.Context, req *pb.McisRecommendVmCreateRequest) (*pb.ListTbSpecInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.RecommendVM()")

        // GRPC 메시지에서 MCIS 객체로 복사
        var mcisObj mcis.DeploymentPlan
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.RecommendVM()")
        }</span>

        <span class="cov0" title="0">content, err := mcis.RecommendVm(req.NsId, mcisObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.RecommendVM()")
        }</span>

        // MCIS 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj []*pb.TbSpecInfo
        err = gc.CopySrcToDest(&amp;content, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCISService.RecommendVM()")
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.ListTbSpecInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file64" style="display: none">package mcis

import (
        "context"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/logger"
        pb "github.com/cloud-barista/poc-cicd-tumblebug/src/api/grpc/protobuf/cbtumblebug"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CheckMcis - MCIS 체크
func (s *MCISService) CheckMcis(ctx context.Context, req *pb.TbMcisQryRequest) (*pb.ExistsResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CheckMcis()")

        exists, err := mcis.CheckMcis(req.NsId, req.McisId)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug(err)
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ExistsResponse{Exists: exists}
        return resp, nil</span>
}

// CheckVm - MCIS VM 체크
func (s *MCISService) CheckVm(ctx context.Context, req *pb.TbVmQryRequest) (*pb.ExistsResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCISService.CheckVm()")

        exists, err := mcis.CheckVm(req.NsId, req.McisId, req.VmId)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug(err)
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ExistsResponse{Exists: exists}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file65" style="display: none">package common

import (
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// RestInitConfig godoc
// @Summary Init config
// @Description Init config
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Param configId path string true "Config ID"
// @Success 200 {object} common.ConfigInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config/{configId} [delete]
func RestInitConfig(c echo.Context) error <span class="cov8" title="1">{
        //id := c.Param("configId")
        if err := Validate(c, []string{"configId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">err := common.InitConfig(c.Param("configId"))
        if err != nil </span><span class="cov0" title="0">{
                //mapA := common.SimpleMsg{"Failed to find the config " + id}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to init the config "+c.Param("configId"))
        }</span> else<span class="cov8" title="1"> {
                //return c.JSON(http.StatusOK, &amp;res)
                return SendMessage(c, http.StatusOK, "The config "+c.Param("configId")+" has been initialized.")
        }</span>
}

// RestGetConfig godoc
// @Summary Get config
// @Description Get config
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Param configId path string true "Config ID"
// @Success 200 {object} common.ConfigInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config/{configId} [get]
func RestGetConfig(c echo.Context) error <span class="cov8" title="1">{
        //id := c.Param("configId")
        if err := Validate(c, []string{"configId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">res, err := common.GetConfig(c.Param("configId"))
        if err != nil </span><span class="cov8" title="1">{
                //mapA := common.SimpleMsg{"Failed to find the config " + id}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to find the config "+c.Param("configId"))
        }</span> else<span class="cov8" title="1"> {
                //return c.JSON(http.StatusOK, &amp;res)
                return Send(c, http.StatusOK, res)
        }</span>
}

// Response structure for RestGetAllConfig
type RestGetAllConfigResponse struct {
        //Name string     `json:"name"`
        Config []common.ConfigInfo `json:"config"`
}

// RestGetAllConfig godoc
// @Summary List all configs
// @Description List all configs
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Success 200 {object} RestGetAllConfigResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config [get]
func RestGetAllConfig(c echo.Context) error <span class="cov8" title="1">{

        var content RestGetAllConfigResponse

        configList, err := common.ListConfig()
        if err != nil </span><span class="cov0" title="0">{
                //mapA := common.SimpleMsg{"Failed to list configs."}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to list configs.")
        }</span>

        <span class="cov8" title="1">if configList == nil </span><span class="cov8" title="1">{
                //return c.JSON(http.StatusOK, &amp;content)
                return Send(c, http.StatusOK, content)
        }</span>

        // When err == nil &amp;&amp; resourceList != nil
        <span class="cov8" title="1">content.Config = configList
        //return c.JSON(http.StatusOK, &amp;content)
        return Send(c, http.StatusOK, content)</span>

}

// RestPostConfig godoc
// @Summary Create or Update config
// @Description Create or Update config (SPIDER_REST_URL, DRAGONFLY_REST_URL, ...)
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Param config body common.ConfigReq true "Key and Value for configuration"
// @Success 200 {object} common.ConfigInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /config [post]
func RestPostConfig(c echo.Context) error <span class="cov8" title="1">{

        u := &amp;common.ConfigReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                //return err
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">fmt.Println("[Creating or Updating Config]")
        content, err := common.UpdateConfig(u)
        if err != nil </span><span class="cov0" title="0">{
                //common.CBLog.Error(err)
                ////mapA := common.SimpleMsg{"Failed to create the config " + u.Name}
                //mapA := common.SimpleMsg{err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>
        //return c.JSON(http.StatusCreated, content)
        <span class="cov8" title="1">return Send(c, http.StatusOK, content)</span>

}

// RestInitAllConfig godoc
// @Summary Init all configs
// @Description Init all configs
// @Tags [Admin] System environment
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /config [delete]
func RestInitAllConfig(c echo.Context) error <span class="cov8" title="1">{

        err := common.InitAllConfig()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return SendMessage(c, http.StatusOK, "All configs has been initialized.")</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package common

import (
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

func RestCheckNs(c echo.Context) error <span class="cov0" title="0">{

        /*
                nsId := c.Param("nsId")

                exists, err := common.CheckNs(nsId)

                type JsonTemplate struct {
                        Exists bool `json:"exists"`
                }
                content := JsonTemplate{}
                content.Exists = exists

                if err != nil {
                        common.CBLog.Error(err)
                        //mapA := common.SimpleMsg{err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return c.JSON(http.StatusNotFound, &amp;content)
                }

                return c.JSON(http.StatusOK, &amp;content)
        */

        if err := Validate(c, []string{"nsId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">nsId := c.Param("nsId")
        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">exists, err := common.CheckNs(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">return SendExistence(c, http.StatusOK, exists)</span>
}

// RestDelAllNs godoc
// @Summary Delete all namespaces
// @Description Delete all namespaces
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns [delete]
func RestDelAllNs(c echo.Context) error <span class="cov8" title="1">{

        /*
                err := common.DelAllNs()
                if err != nil {
                        common.CBLog.Error(err)
                        mapA := common.SimpleMsg{err.Error()}
                        return c.JSON(http.StatusConflict, &amp;mapA)
                }

                mapA := common.SimpleMsg{"All namespaces has been deleted"}
                return c.JSON(http.StatusOK, &amp;mapA)
        */

        err := common.DelAllNs()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return SendMessage(c, http.StatusOK, "All namespaces has been deleted")</span>
}

// RestDelNs godoc
// @Summary Delete namespace
// @Description Delete namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId} [delete]
func RestDelNs(c echo.Context) error <span class="cov8" title="1">{

        /*
                id := c.Param("nsId")

                err := common.DelNs(id)
                if err != nil {
                        common.CBLog.Error(err)
                        mapA := common.SimpleMsg{err.Error()}
                        return c.JSON(http.StatusFailedDependency, &amp;mapA)
                }

                mapA := common.SimpleMsg{"The ns has been deleted"}
                return c.JSON(http.StatusOK, &amp;mapA)
        */

        if err := Validate(c, []string{"nsId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">err := common.DelNs(c.Param("nsId"))
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return SendMessage(c, http.StatusOK, "The ns "+c.Param("nsId")+" has been deleted")</span>
}

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

// Response structure for RestGetAllNs
type RestGetAllNsResponse struct {
        //Name string     `json:"name"`
        Ns []common.NsInfo `json:"ns"`
}

// RestGetAllNs godoc
// @Summary List all namespaces or namespaces' ID
// @Description List all namespaces or namespaces' ID
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllNsResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns [get]
func RestGetAllNs(c echo.Context) error <span class="cov8" title="1">{

        optionFlag := c.QueryParam("option")

        var content RestGetAllNsResponse
        if optionFlag == "id" </span><span class="cov8" title="1">{
                content := common.IdList{}

                var err error
                content.IdList, err = common.ListNsId()
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := common.SimpleMsg{"Failed to list namespaces."}
                        //return c.JSON(http.StatusNotFound, &amp;mapA)
                        return SendMessage(c, http.StatusOK, "Failed to list namespaces' ID: "+err.Error())
                }</span>

                <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov8" title="1"> {
                nsList, err := common.ListNs()
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := common.SimpleMsg{"Failed to list namespaces."}
                        //return c.JSON(http.StatusNotFound, &amp;mapA)
                        return SendMessage(c, http.StatusOK, "Failed to list namespaces.")
                }</span>

                <span class="cov8" title="1">if nsList == nil </span><span class="cov8" title="1">{
                        //return c.JSON(http.StatusOK, &amp;content)
                        return Send(c, http.StatusOK, content)
                }</span>

                // When err == nil &amp;&amp; resourceList != nil
                <span class="cov8" title="1">content.Ns = nsList
                //return c.JSON(http.StatusOK, &amp;content)
                return Send(c, http.StatusOK, content)</span>
        }
}

// RestGetNs godoc
// @Summary Get namespace
// @Description Get namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.NsInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId} [get]
func RestGetNs(c echo.Context) error <span class="cov8" title="1">{
        //id := c.Param("nsId")
        if err := Validate(c, []string{"nsId"}); err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">res, err := common.GetNs(c.Param("nsId"))
        if err != nil </span><span class="cov8" title="1">{
                //mapA := common.SimpleMsg{"Failed to find the namespace " + id}
                //return c.JSON(http.StatusNotFound, &amp;mapA)
                return SendMessage(c, http.StatusOK, "Failed to find the namespace "+c.Param("nsId"))
        }</span> else<span class="cov8" title="1"> {
                //return c.JSON(http.StatusOK, &amp;res)
                return Send(c, http.StatusOK, res)
        }</span>
}

// RestPostNs godoc
// @Summary Create namespace
// @Description Create namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param nsReq body common.NsReq true "Details for a new namespace"
// @Success 200 {object} common.NsInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns [post]
func RestPostNs(c echo.Context) error <span class="cov8" title="1">{

        u := &amp;common.NsReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                //return err
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">fmt.Println("[Creating Ns]")
        content, err := common.CreateNs(u)
        if err != nil </span><span class="cov8" title="1">{
                //common.CBLog.Error(err)
                ////mapA := common.SimpleMsg{"Failed to create the ns " + u.Name}
                //mapA := common.SimpleMsg{err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>
        //return c.JSON(http.StatusCreated, content)
        <span class="cov8" title="1">return Send(c, http.StatusOK, content)</span>

}

/* function RestPutNs not yet implemented
// RestPutNs godoc
// @Summary Update namespace
// @Description Update namespace
// @Tags [Namespace] Namespace management
// @Accept  json
// @Produce  json
// @Param namespace body common.NsInfo true "Details to update existing namespace"
// @Success 200 {object} common.NsInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId} [put]
*/
func RestPutNs(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package common

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "os"

        "github.com/beego/beego/v2/core/validation"
        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
)

type TbConnectionName struct {
        ConnectionName string `json:"connectionName"`
}

type Existence struct {
        Exists bool `json:"exists"`
}

func SendExistence(c echo.Context, httpCode int, existence bool) error <span class="cov0" title="0">{
        return c.JSON(httpCode, Existence{Exists: existence})
}</span>

type Status struct {
        Message string `json:"message"`
}

func SendMessage(c echo.Context, httpCode int, msg string) error <span class="cov8" title="1">{
        return c.JSON(httpCode, Status{Message: msg})
}</span>

func Send(c echo.Context, httpCode int, json interface{}) error <span class="cov8" title="1">{
        return c.JSON(httpCode, json)
}</span>

func Validate(c echo.Context, params []string) error <span class="cov8" title="1">{
        valid := validation.Validation{}

        for _, name := range params </span><span class="cov8" title="1">{
                valid.Required(c.Param(name), name)
        }</span>

        <span class="cov8" title="1">if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RestGetHealth func is for checking Tumblebug server health.
// RestGetHealth godoc
// @Summary Check Tumblebug is alive
// @Description Check Tumblebug is alive
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /health [get]
func RestGetHealth(c echo.Context) error <span class="cov8" title="1">{
        okMessage := common.SimpleMsg{}
        okMessage.Message = "API server of CB-Tumblebug is alive"

        return c.JSON(http.StatusOK, &amp;okMessage)
}</span>

// RestGetSwagger func is to get API document web.
// RestGetSwagger godoc
// @Summary Get API document web
// @Description Get API document web
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /swaggerActive [get]
func RestGetSwagger(c echo.Context) error <span class="cov0" title="0">{
        docFile := os.Getenv("API_DOC_PATH")

        f, err := os.Open(docFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        dec := json.NewDecoder(f)
        data := make(map[string]interface{}, 0)
        if err := dec.Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">data["host"] = os.Getenv("SELF_ENDPOINT")
        return c.JSON(http.StatusOK, data)</span>
}

// RestGetConnConfig func is a rest api wrapper for GetConnConfig.
// RestGetConnConfig godoc
// @Summary Get registered ConnConfig info
// @Description Get registered ConnConfig info
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param connConfigName path string true "Name of connection config (cloud config)"
// @Success 200 {object} common.ConnConfig
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /connConfig/{connConfigName} [get]
func RestGetConnConfig(c echo.Context) error <span class="cov8" title="1">{

        connConfigName := c.Param("connConfigName")

        fmt.Println("[Get ConnConfig for name]" + connConfigName)
        content, err := common.GetConnConfig(connConfigName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>
        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestGetConnConfigList func is a rest api wrapper for GetConnConfigList.
// RestGetConnConfigList godoc
// @Summary List all registered ConnConfig
// @Description List all registered ConnConfig
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.ConnConfigList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /connConfig [get]
func RestGetConnConfigList(c echo.Context) error <span class="cov8" title="1">{

        fmt.Println("[Get ConnConfig List]")
        content, err := common.GetConnConfigList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestGetRegion func is a rest api wrapper for GetRegion.
// RestGetRegion godoc
// @Summary Get registered region info
// @Description Get registered region info
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param regionName path string true "Name of region to retrieve"
// @Success 200 {object} common.Region
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /region/{regionName} [get]
func RestGetRegion(c echo.Context) error <span class="cov8" title="1">{

        regionName := c.Param("regionName")

        fmt.Println("[Get Region for name]" + regionName)
        content, err := common.GetRegion(regionName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestGetRegionList func is a rest api wrapper for GetRegionList.
// RestGetRegionList godoc
// @Summary List all registered regions
// @Description List all registered regions
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Success 200 {object} common.RegionList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /region [get]
func RestGetRegionList(c echo.Context) error <span class="cov8" title="1">{

        fmt.Println("[Get Region List]")
        content, err := common.GetRegionList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// ObjectList struct consists of object IDs
type ObjectList struct {
        Object []string `json:"object"`
}

// func RestGetObjects is a rest api wrapper for GetObjectList.
// RestGetObjects godoc
// @Summary List all objects for a given key
// @Description List all objects for a given key
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "retrieve objects by key"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /objects [get]
func RestGetObjects(c echo.Context) error <span class="cov8" title="1">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Get Tumblebug Object List] with Key: %s \n", parentKey)

        content := common.GetObjectList(parentKey)

        objectList := ObjectList{}
        for i, v := range content </span><span class="cov8" title="1">{
                fmt.Printf("[Obj: %d] %s \n", i, v)
                objectList.Object = append(objectList.Object, v)
        }</span>
        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;objectList)</span>
}

// func RestGetObject is a rest api wrapper for GetObject.
// RestGetObject godoc
// @Summary Get value of an object
// @Description Get value of an object
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "get object value by key"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /object [get]
func RestGetObject(c echo.Context) error <span class="cov8" title="1">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Get Tumblebug Object Value] with Key: %s \n", parentKey)

        content, err := common.GetObjectValue(parentKey)
        if err != nil || content == "" </span><span class="cov8" title="1">{
                return SendMessage(c, http.StatusOK, "Cannot find ["+parentKey+"] object")
        }</span>

        <span class="cov8" title="1">var contentJSON map[string]interface{}
        json.Unmarshal([]byte(content), &amp;contentJSON)

        return c.JSON(http.StatusOK, &amp;contentJSON)</span>
}

// func RestDeleteObject is a rest api wrapper for DeleteObject.
// RestDeleteObject godoc
// @Summary Delete an object
// @Description Delete an object
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "delete object value by key"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /object [delete]
func RestDeleteObject(c echo.Context) error <span class="cov8" title="1">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Delete Tumblebug Object] with Key: %s \n", parentKey)

        content, err := common.GetObjectValue(parentKey)
        if err != nil || content == "" </span><span class="cov8" title="1">{
                return SendMessage(c, http.StatusOK, "Cannot find ["+parentKey+"] object")
        }</span>

        <span class="cov8" title="1">err = common.DeleteObject(parentKey)
        if err != nil </span><span class="cov0" title="0">{
                return SendMessage(c, http.StatusOK, "Cannot delete ["+parentKey+"] object")
        }</span>

        <span class="cov8" title="1">return SendMessage(c, http.StatusOK, "The object has been deleted")</span>
}

// func RestDeleteObjects is a rest api wrapper for DeleteObjects.
// RestDeleteObjects godoc
// @Summary Delete child objects along with the given object
// @Description Delete child objects along with the given object
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param key query string true "Delete child objects based on the given key string"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /objects [delete]
func RestDeleteObjects(c echo.Context) error <span class="cov8" title="1">{
        parentKey := c.QueryParam("key")
        fmt.Printf("[Delete Tumblebug child Objects] with Key: %s \n", parentKey)

        err := common.DeleteObjects(parentKey)
        if err != nil </span><span class="cov0" title="0">{
                return SendMessage(c, http.StatusOK, "Cannot delete  objects")
        }</span>

        <span class="cov8" title="1">return SendMessage(c, http.StatusOK, "Objects have been deleted")</span>
}

// Request struct for RestInspectResources
type RestInspectResourcesRequest struct {
        ConnectionName string `json:"connectionName"`
        Type           string `json:"type" example:"vNet" enums:"vNet,securityGroup,sshKey,vm"`
}

// RestInspectResources godoc
// @Summary Inspect Resources (vNet, securityGroup, sshKey, vm) registered in CB-Tumblebug, CB-Spider, CSP
// @Description Inspect Resources (vNet, securityGroup, sshKey, vm) registered in CB-Tumblebug, CB-Spider, CSP
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param connectionName body RestInspectResourcesRequest true "Specify connectionName and resource type"
// @Success 200 {object} mcis.TbInspectResourcesResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /inspectResources [post]
func RestInspectResources(c echo.Context) error <span class="cov8" title="1">{

        fmt.Println("RestInspectResources called;") // for debug

        u := &amp;RestInspectResourcesRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Printf("[List Resource Status: %s]", u.Type)
        var content interface{}
        var err error
        if u.Type == common.StrVNet || u.Type == common.StrSecurityGroup || u.Type == common.StrSSHKey </span><span class="cov8" title="1">{
                content, err = mcir.InspectResources(u.ConnectionName, u.Type)
        }</span> else<span class="cov8" title="1"> if u.Type == "vm" </span><span class="cov8" title="1">{
                content, err = mcis.InspectVMs(u.ConnectionName)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}
</pre>
		
		<pre class="file" id="file68" style="display: none">package mcir

import (
        "net/http"
        "strings"

        "github.com/labstack/echo/v4"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestDelAllResources(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        forceFlag := c.QueryParam("force")

        err := mcir.DelAllResources(nsId, resourceType, forceFlag)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusConflict, &amp;mapA)
        }</span>

        <span class="cov8" title="1">mapA := map[string]string{"message": "All " + resourceType + "s has been deleted"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestDelResource(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        resourceId := c.Param("resourceId")

        forceFlag := c.QueryParam("force")

        err := mcir.DelResource(nsId, resourceType, resourceId, forceFlag)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">mapA := map[string]string{"message": "The " + resourceType + " " + resourceId + " has been deleted"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestGetAllResources(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        optionFlag := c.QueryParam("option")

        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        if optionFlag == "id" </span><span class="cov8" title="1">{
                content := common.IdList{}
                var err error
                content.IdList, err = mcir.ListResourceId(nsId, resourceType)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": "Failed to list " + resourceType + "s' ID; " + err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov8" title="1"> {

                resourceList, err := mcir.ListResource(nsId, resourceType)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": "Failed to list " + resourceType + "s; " + err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                <span class="cov8" title="1">switch resourceType </span>{
                case common.StrImage:<span class="cov8" title="1">
                        var content struct {
                                Image []mcir.TbImageInfo `json:"image"`
                        }

                        if resourceList == nil </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov8" title="1">content.Image = resourceList.([]mcir.TbImageInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrSecurityGroup:<span class="cov8" title="1">
                        var content struct {
                                SecurityGroup []mcir.TbSecurityGroupInfo `json:"securityGroup"`
                        }

                        if resourceList == nil </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov8" title="1">content.SecurityGroup = resourceList.([]mcir.TbSecurityGroupInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrSpec:<span class="cov8" title="1">
                        var content struct {
                                Spec []mcir.TbSpecInfo `json:"spec"`
                        }

                        if resourceList == nil </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov8" title="1">content.Spec = resourceList.([]mcir.TbSpecInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrSSHKey:<span class="cov8" title="1">
                        var content struct {
                                SshKey []mcir.TbSshKeyInfo `json:"sshKey"`
                        }

                        if resourceList == nil </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov8" title="1">content.SshKey = resourceList.([]mcir.TbSshKeyInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                case common.StrVNet:<span class="cov8" title="1">
                        var content struct {
                                VNet []mcir.TbVNetInfo `json:"vNet"`
                        }

                        if resourceList == nil </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusOK, &amp;content)
                        }</span>

                        // When err == nil &amp;&amp; resourceList != nil
                        <span class="cov8" title="1">content.VNet = resourceList.([]mcir.TbVNetInfo) // type assertion (interface{} -&gt; array)
                        return c.JSON(http.StatusOK, &amp;content)</span>
                default:<span class="cov0" title="0">
                        return c.JSON(http.StatusBadRequest, nil)</span>

                }
                // return c.JSON(http.StatusBadRequest, nil)
        }
}

// Dummy functions for Swagger exist in [mcir/*.go]
func RestGetResource(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/resources/spec/:specId

        resourceId := c.Param("resourceId")

        res, err := mcir.GetResource(nsId, resourceType, resourceId)
        if err != nil </span><span class="cov8" title="1">{
                mapA := map[string]string{"message": "Failed to find " + resourceType + " " + resourceId}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span> else<span class="cov8" title="1"> {
                return c.JSON(http.StatusOK, &amp;res)
        }</span>
}

// RestCheckResource godoc
// @Summary Check resources' existence
// @Description Check resources' existence
// @Tags [Admin] System management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param resourceType path string true "Resource Type"
// @Param resourceId path string true "Resource ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /{nsId}/checkResource/{resourceType}/{resourceId} [get]
func RestCheckResource(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        exists, err := mcir.CheckResource(nsId, resourceType, resourceId)

        type JsonTemplate struct {
                Exists bool `json:"exists"`
        }
        content := JsonTemplate{}
        content.Exists = exists

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //mapA := map[string]string{"message": err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return c.JSON(http.StatusNotFound, &amp;content)
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>
}

// RestTestAddObjectAssociation is a REST API call handling function
// to test "mcir.UpdateAssociatedObjectList" function with "add" argument.
func RestTestAddObjectAssociation(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        //resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/testAddObjectAssociation/:resourceType/:resourceId
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        vmKeyList, err := mcir.UpdateAssociatedObjectList(nsId, resourceType, resourceId, common.StrAdd, "/test/vm/key")

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        //mapA := map[string]int8{"inUseCount": inUseCount}
        <span class="cov8" title="1">return c.JSON(http.StatusOK, vmKeyList)</span>
}

// RestTestDeleteObjectAssociation is a REST API call handling function
// to test "mcir.UpdateAssociatedObjectList" function with "delete" argument.
func RestTestDeleteObjectAssociation(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        //resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/testDeleteObjectAssociation/:resourceType/:resourceId
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        vmKeyList, err := mcir.UpdateAssociatedObjectList(nsId, resourceType, resourceId, common.StrDelete, "/test/vm/key")

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        //mapA := map[string]int8{"inUseCount": inUseCount}
        <span class="cov8" title="1">return c.JSON(http.StatusOK, vmKeyList)</span>
}

// RestTestGetAssociatedObjectCount is a REST API call handling function
// to test "mcir.GetAssociatedObjectCount" function.
func RestTestGetAssociatedObjectCount(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        //resourceType := strings.Split(c.Path(), "/")[5]
        // c.Path(): /tumblebug/ns/:nsId/testGetAssociatedObjectCount/:resourceType/:resourceId
        resourceType := c.Param("resourceType")
        resourceId := c.Param("resourceId")

        associatedObjectCount, err := mcir.GetAssociatedObjectCount(nsId, resourceType, resourceId)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">mapA := map[string]int{"associatedObjectCount": associatedObjectCount}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostImage godoc
// @Summary Register image
// @Description Register image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param registeringMethod query string true "registerWithInfo or registerWithId"
// @Param nsId path string true "Namespace ID"
// @Param imageInfo body mcir.TbImageInfo false "Details for an image object"
// @Param imageId body mcir.TbImageReq false "name, connectionName and cspImageId"
// @Success 200 {object} mcir.TbImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image [post]
func RestPostImage(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        action := c.QueryParam("action")
        fmt.Println("[POST Image] (action: " + action + ")")
        /*
                if action == "create" {
                        fmt.Println("[Creating Image]")
                        content, _ := createImage(nsId, u)
                        return c.JSON(http.StatusCreated, content)

                } else */
        if action == "registerWithInfo" </span><span class="cov0" title="0">{
                fmt.Println("[Registering Image with info]")
                u := &amp;mcir.TbImageInfo{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">content, err := mcir.RegisterImageWithInfo(nsId, u)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>
        } else<span class="cov8" title="1"> if action == "registerWithId" </span><span class="cov8" title="1">{
                fmt.Println("[Registering Image with ID]")
                u := &amp;mcir.TbImageReq{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //content, responseCode, body, err := RegisterImageWithId(nsId, u)
                <span class="cov8" title="1">content, err := mcir.RegisterImageWithId(nsId, u)
                if err != nil </span><span class="cov8" title="1">{
                        common.CBLog.Error(err)
                        //fmt.Println("body: ", string(body))
                        //return c.JSONBlob(responseCode, body)
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov8" title="1">return c.JSON(http.StatusCreated, content)</span>
        } else<span class="cov0" title="0"> {
                mapA := map[string]string{"message": "You must specify: action=registerWithInfo or action=registerWithId"}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

}

/* function RestPutImage not yet implemented
// RestPutImage godoc
// @Summary Update image
// @Description Update image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param imageInfo body mcir.TbImageInfo true "Details for an image object"
// @Success 200 {object} mcir.TbImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image/{imageId} [put]
*/
func RestPutImage(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// Request structure for RestLookupImage
type RestLookupImageRequest struct {
        ConnectionName string `json:"connectionName"`
        CspImageId     string `json:"cspImageId"`
}

// RestLookupImage godoc
// @Summary Lookup image
// @Description Lookup image
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupImageReq body RestLookupImageRequest true "Specify connectionName &amp; cspImageId"
// @Success 200 {object} mcir.SpiderImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupImage [get]
func RestLookupImage(c echo.Context) error <span class="cov8" title="1">{

        u := &amp;RestLookupImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Lookup image]: " + u.CspImageId)
        content, err := mcir.LookupImage(u.ConnectionName, u.CspImageId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestLookupImageList godoc
// @Summary Lookup image list
// @Description Lookup image list
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupImagesReq body common.TbConnectionName true "Specify connectionName"
// @Success 200 {object} mcir.SpiderImageList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupImages [get]
func RestLookupImageList(c echo.Context) error <span class="cov8" title="1">{

        //type JsonTemplate struct {
        //        ConnectionName string
        //}

        u := &amp;RestLookupImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Lookup images]")
        content, err := mcir.LookupImageList(u.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestFetchImages godoc
// @Summary Fetch images
// @Description Fetch images
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/fetchImages [post]
func RestFetchImages(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        // connConfigCount, imageCount, err := mcir.FetchImages(nsId)
        // if err != nil {
        //         common.CBLog.Error(err)
        //         mapA := map[string]string{
        //                 "message": err.Error()}
        //         return c.JSON(http.StatusInternalServerError, &amp;mapA)
        // }

        u := &amp;RestLookupImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var connConfigCount, imageCount uint
        var err error

        if u.ConnectionName == "" </span><span class="cov8" title="1">{
                connConfigCount, imageCount, err = mcir.FetchImagesForAllConnConfigs(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        } else<span class="cov8" title="1"> {
                connConfigCount = 1
                imageCount, err = mcir.FetchImagesForConnConfig(u.ConnectionName, nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        }

        <span class="cov8" title="1">mapA := map[string]string{
                "message": "Fetched " + fmt.Sprint(imageCount) + " images (from " + fmt.Sprint(connConfigCount) + " connConfigs)"}
        return c.JSON(http.StatusCreated, &amp;mapA)</span> //content)
}

// RestGetImage godoc
// @Summary Get image
// @Description Get image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param imageId path string true "Image ID"
// @Success 200 {object} mcir.TbImageInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image/{imageId} [get]
func RestGetImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllImage
type RestGetAllImageResponse struct {
        Image []mcir.TbImageInfo `json:"image"`
}

// RestGetAllImage godoc
// @Summary List all images or images' ID
// @Description List all images or images' ID
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllImageResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image [get]
func RestGetAllImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelImage godoc
// @Summary Delete image
// @Description Delete image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param imageId path string true "Image ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image/{imageId} [delete]
func RestDelImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllImage godoc
// @Summary Delete all images
// @Description Delete all images
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/image [delete]
func RestDelAllImage(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestSearchImage
type RestSearchImageRequest struct {
        Keywords []string `json:"keywords"`
}

// RestSearchImage godoc
// @Summary Search image
// @Description Search image
// @Tags [MCIR] Image management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param keywords body RestSearchImageRequest true "Keywords"
// @Success 200 {object} RestGetAllImageResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/searchImage [post]
func RestSearchImage(c echo.Context) error <span class="cov8" title="1">{
        nsId := c.Param("nsId")

        u := &amp;RestSearchImageRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //fmt.Println("RestSearchImage called; keywords: ") // for debug
        //fmt.Println(u.Keywords) // for debug

        <span class="cov8" title="1">content, err := mcir.SearchImage(nsId, u.Keywords...)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{
                        "message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">result := RestGetAllImageResponse{}
        result.Image = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostSecurityGroup godoc
// @Summary Create Security Group
// @Description Create Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param securityGroupReq body mcir.TbSecurityGroupReq true "Details for an securityGroup object"
// @Success 200 {object} mcir.TbSecurityGroupInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup [post]
func RestPostSecurityGroup(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSecurityGroupReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[POST SecurityGroup")
        //fmt.Println("[Creating SecurityGroup]")
        //content, responseCode, _, err := CreateSecurityGroup(nsId, u)
        content, err := mcir.CreateSecurityGroup(nsId, u)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                /*
                        mapA := map[string]string{
                                "message": "Failed to create a SecurityGroup"}
                */
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">return c.JSON(http.StatusCreated, content)</span>
}

/* function RestPutSecurityGroup not yet implemented
// RestPutSecurityGroup godoc
// @Summary Update Security Group
// @Description Update Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param securityGroupInfo body mcir.TbSecurityGroupInfo true "Details for an securityGroup object"
// @Success 200 {object} mcir.TbSecurityGroupInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup/{securityGroupId} [put]
*/
func RestPutSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// RestGetSecurityGroup godoc
// @Summary Get Security Group
// @Description Get Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param securityGroupId path string true "Security Group ID"
// @Success 200 {object} mcir.TbSecurityGroupInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup/{securityGroupId} [get]
func RestGetSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllSecurityGroup
type RestGetAllSecurityGroupResponse struct {
        SecurityGroup []mcir.TbSecurityGroupInfo `json:"securityGroup"`
}

// RestGetAllSecurityGroup godoc
// @Summary List all Security Groups or Security Groups' ID
// @Description List all Security Groups or Security Groups' ID
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllSecurityGroupResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup [get]
func RestGetAllSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelSecurityGroup godoc
// @Summary Delete Security Group
// @Description Delete Security Group
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param securityGroupId path string true "Security Group ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup/{securityGroupId} [delete]
func RestDelSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllSecurityGroup godoc
// @Summary Delete all Security Groups
// @Description Delete all Security Groups
// @Tags [MCIR] Security group management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/securityGroup [delete]
func RestDelAllSecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostSpec godoc
// @Summary Register spec
// @Description Register spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param registeringMethod query string true "registerWithInfo or else"
// @Param nsId path string true "Namespace ID"
// @Param specInfo body mcir.TbSpecInfo false "Details for an spec object"
// @Param specName body mcir.TbSpecReq false "name, connectionName and cspSpecName"
// @Success 200 {object} mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec [post]
func RestPostSpec(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        action := c.QueryParam("action")
        fmt.Println("[POST Spec] (action: " + action + ")")

        if action == "registerWithInfo" </span><span class="cov0" title="0">{ // `RegisterSpecWithInfo` will be deprecated in Cappuccino.
                fmt.Println("[Registering Spec with info]")
                u := &amp;mcir.TbSpecInfo{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">content, err := mcir.RegisterSpecWithInfo(nsId, u)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusCreated, content)</span>

        } else<span class="cov8" title="1"> { // if action == "registerWithCspSpecName" { // The default mode.
                fmt.Println("[Registering Spec with CspSpecName]")
                u := &amp;mcir.TbSpecReq{}
                if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">content, err := mcir.RegisterSpecWithCspSpecName(nsId, u)
                if err != nil </span><span class="cov8" title="1">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
                <span class="cov8" title="1">return c.JSON(http.StatusCreated, content)</span>

        } /* else {
                mapA := map[string]string{"message": "LookupSpec(specRequest) failed."}
                return c.JSON(http.StatusFailedDependency, &amp;mapA)
        } */

}

// RestPutSpec godoc
// @Summary Update spec
// @Description Update spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param specInfo body mcir.TbSpecInfo true "Details for an spec object"
// @Param nsId path string true "Namespace ID"
// @Param specId path string true "Spec ID"
// @Success 200 {object} mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec/{specId} [put]
func RestPutSpec(c echo.Context) error <span class="cov8" title="1">{
        nsId := c.Param("nsId")
        specId := c.Param("specId")
        fmt.Printf("RestPutSpec called; nsId: %s, specId: %s \n", nsId, specId) // for debug

        u := &amp;mcir.TbSpecInfo{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        /*
                if specId != u.Id {
                        err := fmt.Errorf("URL param " + specId + " and JSON param " + u.Id + " does not match.")
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusBadRequest, &amp;mapA)
                }
        */

        <span class="cov8" title="1">updatedSpec, err := mcir.UpdateSpec(nsId, *u)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{
                        "message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">return c.JSON(http.StatusOK, updatedSpec)</span>
}

// Request structure for RestLookupSpec
type RestLookupSpecRequest struct {
        ConnectionName string `json:"connectionName"`
        CspSpecName    string `json:"cspSpecName"`
}

// RestLookupSpec godoc
// @Summary Lookup spec
// @Description Lookup spec
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupSpecReq body RestLookupSpecRequest true "Specify connectionName &amp; cspSpecName"
// @Success 200 {object} mcir.SpiderSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupSpec [get]
func RestLookupSpec(c echo.Context) error <span class="cov8" title="1">{
        u := &amp;RestLookupSpecRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Lookup spec]: " + u.CspSpecName)
        content, err := mcir.LookupSpec(u.ConnectionName, u.CspSpecName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestLookupSpecList godoc
// @Summary Lookup spec list
// @Description Lookup spec list
// @Tags [Admin] Cloud environment management
// @Accept  json
// @Produce  json
// @Param lookupSpecsReq body common.TbConnectionName true "Specify connectionName"
// @Success 200 {object} mcir.SpiderSpecList
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /lookupSpecs [get]
func RestLookupSpecList(c echo.Context) error <span class="cov8" title="1">{

        //type JsonTemplate struct {
        //        ConnectionName string
        //}

        u := &amp;RestLookupSpecRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Lookup specs]")
        content, err := mcir.LookupSpecList(u.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>

}

// RestFetchSpecs godoc
// @Summary Fetch specs
// @Description Fetch specs
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/fetchSpecs [post]
func RestFetchSpecs(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        u := &amp;RestLookupSpecRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var connConfigCount, specCount uint
        var err error

        if u.ConnectionName == "" </span><span class="cov8" title="1">{
                connConfigCount, specCount, err = mcir.FetchSpecsForAllConnConfigs(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        } else<span class="cov8" title="1"> {
                connConfigCount = 1
                specCount, err = mcir.FetchSpecsForConnConfig(u.ConnectionName, nsId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{
                                "message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>
        }

        <span class="cov8" title="1">mapA := map[string]string{
                "message": "Fetched " + fmt.Sprint(specCount) + " specs (from " + fmt.Sprint(connConfigCount) + " connConfigs)"}
        return c.JSON(http.StatusCreated, &amp;mapA)</span> //content)
}

// RestFilterSpecsResponse is Response structure for RestFilterSpecs
type RestFilterSpecsResponse struct {
        Spec []mcir.TbSpecInfo `json:"spec"`
}

// RestFilterSpecs godoc
// @Summary Filter specs
// @Description Filter specs
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specFilter body mcir.TbSpecInfo false "Filter for filtering specs"
// @Success 200 {object} RestFilterSpecsResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/filterSpecs [post]
func RestFilterSpecs(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSpecInfo{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Filter specs]")
        content, err := mcir.FilterSpecs(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">result := RestFilterSpecsResponse{}
        result.Spec = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}

// RestFilterSpecsByRange godoc
// @Summary Filter specs by range
// @Description Filter specs by range
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specRangeFilter body mcir.FilterSpecsByRangeRequest false "Filter for range-filtering specs"
// @Success 200 {object} RestFilterSpecsResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/filterSpecsByRange [post]
func RestFilterSpecsByRange(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        u := &amp;mcir.FilterSpecsByRangeRequest{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Filter specs]")
        content, err := mcir.FilterSpecsByRange(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov8" title="1">result := RestFilterSpecsResponse{}
        result.Spec = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}

func RestTestSortSpecs(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSpecInfo{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("[Filter specs]")
        content, err := mcir.FilterSpecs(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">content, err = mcir.SortSpecs(content, "mem_GiB", "descending")
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        <span class="cov0" title="0">result := RestFilterSpecsResponse{}
        result.Spec = content
        return c.JSON(http.StatusOK, &amp;result)</span>
}

// RestGetSpec godoc
// @Summary Get spec
// @Description Get spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specId path string true "Spec ID"
// @Success 200 {object} mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec/{specId} [get]
func RestGetSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllSpec
type RestGetAllSpecResponse struct {
        Spec []mcir.TbSpecInfo `json:"spec"`
}

// RestGetAllSpec godoc
// @Summary List all specs or specs' ID
// @Description List all specs or specs' ID
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllSpecResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec [get]
func RestGetAllSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelSpec godoc
// @Summary Delete spec
// @Description Delete spec
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param specId path string true "Spec ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec/{specId} [delete]
func RestDelSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllSpec godoc
// @Summary Delete all specs
// @Description Delete all specs
// @Tags [MCIR] Spec management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/spec [delete]
func RestDelAllSpec(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostSshKey godoc
// @Summary Create SSH Key
// @Description Create SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param sshKeyInfo body mcir.TbSshKeyReq true "Details for an SSH Key object"
// @Success 200 {object} mcir.TbSshKeyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey [post]
func RestPostSshKey(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbSshKeyReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[POST SshKey")
        //fmt.Println("[Creating SshKey]")
        //content, responseCode, _, err := CreateSshKey(nsId, u)
        content, err := mcir.CreateSshKey(nsId, u)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">return c.JSON(http.StatusCreated, content)</span>
}

/* function RestPutSshKey not yet implemented
// RestPutSshKey godoc
// @Summary Update SSH Key
// @Description Update SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param sshKeyInfo body mcir.TbSshKeyInfo true "Details for an SSH Key object"
// @Success 200 {object} mcir.TbSshKeyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey/{sshKeyId} [put]
*/
func RestPutSshKey(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// RestGetSshKey godoc
// @Summary Get SSH Key
// @Description Get SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param sshKeyId path string true "SSH Key ID"
// @Success 200 {object} mcir.TbSshKeyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey/{sshKeyId} [get]
func RestGetSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response struct for RestGetAllSshKey
type RestGetAllSshKeyResponse struct {
        SshKey []mcir.TbSshKeyInfo `json:"sshKey"`
}

// RestGetAllSshKey godoc
// @Summary List all SSH Keys or SSH Keys' ID
// @Description List all SSH Keys or SSH Keys' ID
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllSshKeyResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey [get]
func RestGetAllSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelSshKey godoc
// @Summary Delete SSH Key
// @Description Delete SSH Key
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param sshKeyId path string true "SSH Key ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey/{sshKeyId} [delete]
func RestDelSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllSshKey godoc
// @Summary Delete all SSH Keys
// @Description Delete all SSH Keys
// @Tags [MCIR] Access key management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/sshKey [delete]
func RestDelAllSshKey(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package mcir

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        "github.com/labstack/echo/v4"
)

// RestPostVNet godoc
// @Summary Create VNet
// @Description Create VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param vNetReq body mcir.TbVNetReq true "Details for an VNet object"
// @Success 200 {object} mcir.TbVNetInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet [post]
func RestPostVNet(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        u := &amp;mcir.TbVNetReq{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[POST VNet]")
        //fmt.Println("[Creating VNet]")
        //content, responseCode, body, err := CreateVNet(nsId, u)
        content, err := mcir.CreateVNet(nsId, u)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                /*
                        mapA := map[string]string{
                                "message": "Failed to create a vNet"}
                */
                //return c.JSONBlob(responseCode, body)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">return c.JSON(http.StatusCreated, content)</span>
}

/* function RestPutVNet not yet implemented
// RestPutVNet godoc
// @Summary Update VNet
// @Description Update VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param vNetInfo body mcir.TbVNetInfo true "Details for an VNet object"
// @Success 200 {object} mcir.TbVNetInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet/{vNetId} [put]
*/
func RestPutVNet(c echo.Context) error <span class="cov0" title="0">{
        //nsId := c.Param("nsId")

        return nil
}</span>

// RestGetVNet godoc
// @Summary Get VNet
// @Description Get VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param vNetId path string true "VNet ID"
// @Success 200 {object} mcir.TbVNetInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet/{vNetId} [get]
func RestGetVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// Response structure for RestGetAllVNet
type RestGetAllVNetResponse struct {
        VNet []mcir.TbVNetInfo `json:"vNet"`
}

// RestGetAllVNet godoc
// @Summary List all VNets or VNets' ID
// @Description List all VNets or VNets' ID
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllVNetResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet [get]
func RestGetAllVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelVNet godoc
// @Summary Delete VNet
// @Description Delete VNet
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param vNetId path string true "VNet ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet/{vNetId} [delete]
func RestDelVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>

// RestDelAllVNet godoc
// @Summary Delete all VNets
// @Description Delete all VNets
// @Tags [MCIR] Network management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/resources/vNet [delete]
func RestDelAllVNet(c echo.Context) error <span class="cov0" title="0">{
        // This is a dummy function for Swagger.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package mcis

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestPostMcis godoc
// @Summary Create MCIS
// @Description Create MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisReq body TbMcisReq true "Details for an MCIS object"
// @Success 200 {object} TbMcisInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis [post]
func RestPostMcis(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")

        req := &amp;mcis.TbMcisReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">result, err := mcis.CreateMcis(nsId, req)
        if err != nil </span><span class="cov8" title="1">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        //fmt.Printf("%+v\n", *result)
        <span class="cov8" title="1">common.PrintJsonPretty(*result)

        return c.JSON(http.StatusCreated, result)</span>
}

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

func RestTestListVmId(c echo.Context) error <span class="cov0" title="0">{ // for debug
        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        vmList, err := mcis.ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        // mapA := map[string]string{"message": result}
        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;vmList)</span>
}

// TODO: swag does not support multiple response types (success 200) in an API.
// Annotation for API documention Need to be revised.

// RestGetMcis godoc
// @Summary Get MCIS, Action to MCIS (status, suspend, resume, reboot, terminate, refine), or Get VMs' ID
// @Description Get MCIS, Action to MCIS (status, suspend, resume, reboot, terminate, refine), or Get VMs' ID
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param action query string false "Action to MCIS" Enums(status, suspend, resume, reboot, terminate, refine)
// @Param option query string false "Option" Enums(id)
// @success 200 {object} JSONResult{[DEFAULT]=mcis.TbMcisInfo,[STATUS]=mcis.McisStatusInfo,[CONTROL]=common.SimpleMsg,[ID]=common.IdList} "Different return structures by the given action param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId} [get]
func RestGetMcis(c echo.Context) error <span class="cov8" title="1">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        action := c.QueryParam("action")
        option := c.QueryParam("option")

        if option == "id" </span><span class="cov8" title="1">{
                content := common.IdList{}
                var err error
                content.IdList, err = mcis.ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov8" title="1"> if action == "suspend" || action == "resume" || action == "reboot" || action == "terminate" || action == "refine" </span><span class="cov8" title="1">{

                result, err := mcis.HandleMcisAction(nsId, mcisId, action)
                if err != nil </span><span class="cov8" title="1">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov8" title="1">mapA := map[string]string{"message": result}
                return c.JSON(http.StatusOK, &amp;mapA)</span>

        } else<span class="cov8" title="1"> if action == "status" </span><span class="cov8" title="1">{

                result, err := mcis.GetMcisStatus(nsId, mcisId)
                if err != nil </span><span class="cov8" title="1">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov8" title="1">var content struct {
                        Result *mcis.McisStatusInfo `json:"status"`
                }
                content.Result = result

                //fmt.Printf("%+v\n", content)
                common.PrintJsonPretty(content)

                return c.JSON(http.StatusOK, &amp;content)</span>

        } else<span class="cov8" title="1"> {

                result, err := mcis.GetMcisInfo(nsId, mcisId)
                if err != nil </span><span class="cov8" title="1">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                //fmt.Printf("%+v\n", *result)
                <span class="cov8" title="1">common.PrintJsonPretty(*result)
                //return by string
                //return c.String(http.StatusOK, keyValue.Value)
                return c.JSON(http.StatusOK, result)</span>

        }
}

// Response structure for RestGetAllMcis
type RestGetAllMcisResponse struct {
        Mcis []mcis.TbMcisInfo `json:"mcis"`
}

// Response structure for RestGetAllMcisStatus
type RestGetAllMcisStatusResponse struct {
        Mcis []mcis.McisStatusInfo `json:"mcis"`
}

// RestGetAllMcis godoc
// @Summary List all MCISs or MCISs' ID
// @Description List all MCISs or MCISs' ID
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option" Enums(id)
// @Success 200 {object} JSONResult{[DEFAULT]=RestGetAllMcisResponse,[ID]=common.IdList} "Different return structures by the given option param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis [get]
func RestGetAllMcis(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        option := c.QueryParam("option")
        fmt.Println("[Get MCIS List requested with option: " + option)

        if option == "id" </span><span class="cov8" title="1">{
                content := common.IdList{}
                var err error
                content.IdList, err = mcis.ListMcisId(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov8" title="1"> if option == "status" </span><span class="cov8" title="1">{
                result, err := mcis.GetMcisStatusAll(nsId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>
                <span class="cov8" title="1">content := RestGetAllMcisStatusResponse{}
                content.Mcis = result
                common.PrintJsonPretty(content)
                return c.JSON(http.StatusOK, &amp;content)</span>
        } else<span class="cov8" title="1"> {
                // mcis in detail (with status information)
                detail := "status"

                result, err := mcis.CoreGetAllMcis(nsId, detail)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>
                <span class="cov8" title="1">content := RestGetAllMcisResponse{}
                content.Mcis = result
                common.PrintJsonPretty(content)
                return c.JSON(http.StatusOK, &amp;content)</span>
        }
}

/* function RestPutMcis not yet implemented
// RestPutMcis godoc
// @Summary Update MCIS
// @Description Update MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param mcisInfo body TbMcisInfo true "Details for an MCIS object"
// @Success 200 {object} TbMcisInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId} [put]
*/
func RestPutMcis(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// RestDelMcis godoc
// @Summary Delete MCIS
// @Description Delete MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param option query string false "Option for delete MCIS (support force delete)" Enums(force)
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId} [delete]
func RestDelMcis(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        option := c.QueryParam("option")

        err := mcis.DelMcis(nsId, mcisId, option)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">mapA := map[string]string{"message": "Deleting the MCIS " + mcisId}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// RestDelAllMcis godoc
// @Summary Delete all MCISs
// @Description Delete all MCISs
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param option query string false "Option for delete MCIS (support force delete)" Enums(force)
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis [delete]
func RestDelAllMcis(c echo.Context) error <span class="cov8" title="1">{
        nsId := c.Param("nsId")
        option := c.QueryParam("option")

        result, err := mcis.CoreDelAllMcis(nsId, option)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">mapA := map[string]string{"message": result}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

type RestPostMcisRecommendResponse struct {
        //VmReq          []TbVmRecommendReq    `json:"vmReq"`
        Vm_recommend   []mcis.TbVmRecommendInfo `json:"vm_recommend"`
        PlacementAlgo  string                   `json:"placementAlgo"`
        PlacementParam []common.KeyValue        `json:"placementParam"`
}

// RestPostMcisRecommend godoc
// @Summary Get MCIS recommendation
// @Description Get MCIS recommendation
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisRecommendReq body mcis.McisRecommendReq true "Details for an MCIS object"
// @Success 200 {object} RestPostMcisRecommendResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/recommend [post]
// @Deprecated
func RestPostMcisRecommend(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        req := &amp;mcis.McisRecommendReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result, err := mcis.CorePostMcisRecommend(nsId, req)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov0" title="0">content := RestPostMcisRecommendResponse{}
        content.Vm_recommend = result
        content.PlacementAlgo = req.PlacementAlgo
        content.PlacementParam = req.PlacementParam

        //fmt.Printf("%+v\n", content)
        common.PrintJsonPretty(content)

        return c.JSON(http.StatusCreated, content)</span>
}

type RestPostCmdMcisVmResponse struct {
        Result string `json:"result"`
}

// RestPostCmdMcisVm godoc
// @Summary Send a command to specified VM
// @Description Send a command to specified VM
// @Tags [MCIS] Remote command
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param mcisCmdReq body mcis.McisCmdReq true "MCIS Command Request"
// @Success 200 {object} RestPostCmdMcisVmResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/cmd/mcis/{mcisId}/vm/{vmId} [post]
func RestPostCmdMcisVm(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">result, err := mcis.CorePostCmdMcisVm(nsId, mcisId, vmId, req)
        if err != nil </span><span class="cov8" title="1">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">response := RestPostCmdMcisVmResponse{Result: result}
        return c.JSON(http.StatusOK, response)</span>
}

type RestPostCmdMcisResponse struct {
        McisId string `json:"mcisId"`
        VmId   string `json:"vmId"`
        VmIp   string `json:"vmIp"`
        Result string `json:"result"`
}

type RestPostCmdMcisResponseWrapper struct {
        Result_array []RestPostCmdMcisResponse `json:"result_array"`
}

// RestPostCmdMcis godoc
// @Summary Send a command to specified MCIS
// @Description Send a command to specified MCIS
// @Tags [MCIS] Remote command
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisCmdReq body mcis.McisCmdReq true "MCIS Command Request"
// @Success 200 {object} RestPostCmdMcisResponseWrapper
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/cmd/mcis/{mcisId} [post]
func RestPostCmdMcis(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">resultArray, err := mcis.CorePostCmdMcis(nsId, mcisId, req)
        if err != nil </span><span class="cov8" title="1">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">content := RestPostCmdMcisResponseWrapper{}

        for _, v := range resultArray </span><span class="cov8" title="1">{

                resultTmp := RestPostCmdMcisResponse{}
                resultTmp.McisId = mcisId
                resultTmp.VmId = v.VmId
                resultTmp.VmIp = v.VmIp
                resultTmp.Result = v.Result
                content.Result_array = append(content.Result_array, resultTmp)
                //fmt.Println("result from goroutin " + v)
        }</span>

        //fmt.Printf("%+v\n", content)
        <span class="cov8" title="1">common.PrintJsonPretty(content)

        return c.JSON(http.StatusOK, content)</span>

}

// RestPostInstallAgentToMcis godoc
// @Summary Install the benchmark agent to specified MCIS
// @Description Install the benchmark agent to specified MCIS
// @Tags [MCIS] Performance benchmarking (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisCmdReq body mcis.McisCmdReq true "MCIS Command Request"
// @Success 200 {object} mcis.AgentInstallContentWrapper
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/install/mcis/{mcisId} [post]
func RestPostInstallAgentToMcis(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := mcis.InstallAgentToMcis(nsId, mcisId, req)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, content)</span>
}

// RestPostMcisVm godoc
// @Summary Create VM in specified MCIS
// @Description Create VM in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmReq body mcis.TbVmReq true "Details for an VM object"
// @Success 200 {object} mcis.TbVmInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm [post]
func RestPostMcisVm(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        vmInfoData := &amp;mcis.TbVmInfo{}
        if err := c.Bind(vmInfoData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">common.PrintJsonPretty(*vmInfoData)

        result, err := mcis.CorePostMcisVm(nsId, mcisId, vmInfoData)
        if err != nil </span><span class="cov8" title="1">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">common.PrintJsonPretty(*result)

        return c.JSON(http.StatusCreated, result)</span>
}

// RestPostMcisVmGroup godoc
// @Summary Create multiple VMs by VM group in specified MCIS
// @Description Create multiple VMs by VM group in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmReq body mcis.TbVmReq true "Details for VM Group"
// @Success 200 {object} mcis.TbMcisInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vmgroup [post]
func RestPostMcisVmGroup(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        vmInfoData := &amp;mcis.TbVmReq{}
        if err := c.Bind(vmInfoData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">common.PrintJsonPretty(*vmInfoData)

        result, err := mcis.CorePostMcisGroupVm(nsId, mcisId, vmInfoData)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">common.PrintJsonPretty(*result)

        return c.JSON(http.StatusCreated, result)</span>
}

// TODO: swag does not support multiple response types (success 200) in an API.
// Annotation for API documention Need to be revised.

// RestGetMcisVm godoc
// @Summary Get VM in specified MCIS
// @Description Get VM in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param action query string false "Action to MCIS" Enums(status, suspend, resume, reboot, terminate)
// @success 200 {object} JSONResult{[DEFAULT]=mcis.TbVmInfo,[STATUS]=mcis.TbVmStatusInfo,[CONTROL]=common.SimpleMsg} "Different return structures by the given action param"
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm/{vmId} [get]
func RestGetMcisVm(c echo.Context) error <span class="cov8" title="1">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")

        action := c.QueryParam("action")

        if action == "suspend" || action == "resume" || action == "reboot" || action == "terminate" </span><span class="cov8" title="1">{

                result, err := mcis.CoreGetMcisVmAction(nsId, mcisId, vmId, action)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                <span class="cov8" title="1">mapA := map[string]string{"message": result}
                return c.JSON(http.StatusOK, &amp;mapA)</span>

        } else<span class="cov8" title="1"> if action == "status" </span><span class="cov8" title="1">{

                result, err := mcis.CoreGetMcisVmStatus(nsId, mcisId, vmId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusInternalServerError, &amp;mapA)
                }</span>

                //fmt.Printf("%+v\n", *result)
                <span class="cov8" title="1">common.PrintJsonPretty(*result)

                return c.JSON(http.StatusOK, result)</span>

        } else<span class="cov8" title="1"> {

                result, err := mcis.CoreGetMcisVmInfo(nsId, mcisId, vmId)
                if err != nil </span><span class="cov0" title="0">{
                        mapA := map[string]string{"message": err.Error()}
                        return c.JSON(http.StatusNotFound, &amp;mapA)
                }</span>

                //fmt.Printf("%+v\n", *result)
                <span class="cov8" title="1">common.PrintJsonPretty(*result)

                //return by string
                //return c.String(http.StatusOK, keyValue.Value)
                return c.JSON(http.StatusOK, result)</span>

        }
}

/* RestPutMcisVm function not yet implemented
// RestPutSshKey godoc
// @Summary Update MCIS
// @Description Update MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param vmInfo body mcis.TbVmInfo true "Details for an VM object"
// @Success 200 {object} mcis.TbVmInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm/{vmId} [put]
*/
func RestPutMcisVm(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// RestDelMcisVm godoc
// @Summary Delete VM in specified MCIS
// @Description Delete VM in specified MCIS
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param vmId path string true "VM ID"
// @Param option query string false "Option for delete VM (support force delete)" Enums(force)
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/mcis/{mcisId}/vm/{vmId} [delete]
func RestDelMcisVm(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")
        option := c.QueryParam("option")

        err := mcis.DelMcisVm(nsId, mcisId, vmId, option)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": "Failed to delete the VM info"}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">mapA := map[string]string{"message": "Deleting the VM info"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// Request struct for RestGetAllBenchmark
type RestGetAllBenchmarkRequest struct {
        Host string `json:"host"`
}

// RestGetAllBenchmark godoc
// @Summary Run MCIS benchmark for all performance metrics and return results
// @Description Run MCIS benchmark for all performance metrics and return results
// @Tags [MCIS] Performance benchmarking (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param hostIP body RestGetAllBenchmarkRequest true "Host IP address to benchmark"
// @Success 200 {object} mcis.BenchmarkInfoArray
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/benchmarkall/mcis/{mcisId} [post]
func RestGetAllBenchmark(c echo.Context) error <span class="cov8" title="1">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        /*
                type bmReq struct {
                        Host string `json:"host"`
                }
                req := &amp;bmReq{}
        */
        req := &amp;RestGetAllBenchmarkRequest{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">result, err := mcis.CoreGetAllBenchmark(nsId, mcisId, req.Host)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">common.PrintJsonPretty(*result)
        return c.JSON(http.StatusOK, result)</span>
}

type RestGetBenchmarkRequest struct {
        Host string `json:"host"`
}

// RestGetBenchmark godoc
// @Summary Run MCIS benchmark for a single performance metric and return results
// @Description Run MCIS benchmark for a single performance metric and return results
// @Tags [MCIS] Performance benchmarking (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param hostIP body RestGetBenchmarkRequest true "Host IP address to benchmark"
// @Param action query string true "Benchmark Action to MCIS" Enums(install, init, cpus, cpum, memR, memW, fioR, fioW, dbR, dbW, rtt, mrtt, clean)
// @Success 200 {object} mcis.BenchmarkInfoArray
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/benchmark/mcis/{mcisId} [post]
func RestGetBenchmark(c echo.Context) error <span class="cov8" title="1">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        action := c.QueryParam("action")

        /*
                type bmReq struct {
                        Host string `json:"host"`
                }
                req := &amp;bmReq{}
        */
        req := &amp;RestGetBenchmarkRequest{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">result, err := mcis.CoreGetBenchmark(nsId, mcisId, action, req.Host)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">common.PrintJsonPretty(*result)
        return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package mcis

import (
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestPostInstallMonitorAgentToMcis godoc
// @Summary Install monitoring agent (CB-Dragonfly agent) to MCIS
// @Description Install monitoring agent (CB-Dragonfly agent) to MCIS
// @Tags [MCIS] Resource monitor (Developer)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisInfo body mcis.McisCmdReq true "Details for an MCIS object"
// @Success 200 {object} mcis.AgentInstallContentWrapper
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/monitoring/install/mcis/{mcisId} [post]
func RestPostInstallMonitorAgentToMcis(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">content, err := mcis.InstallMonitorAgentToMcis(nsId, mcisId, req)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, content)</span>
}

// RestGetMonitorData godoc
// @Summary Get monitoring data of specified MCIS for specified monitoring metric (cpu, memory, disk, network)
// @Description Get monitoring data of specified MCIS for specified monitoring metric (cpu, memory, disk, network)
// @Tags [MCIS] Resource monitor (Developer)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param metric path string true "Metric type: cpu, memory, disk, network"
// @Success 200 {object} mcis.MonResultSimpleResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/monitoring/mcis/{mcisId}/metric/{metric} [get]
func RestGetMonitorData(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        metric := c.Param("metric")

        req := &amp;mcis.McisCmdReq{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">content, err := mcis.GetMonitoringData(nsId, mcisId, metric)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, content)</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package mcis

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestPostMcisPolicy godoc
// @Summary Create MCIS Automation policy
// @Description Create MCIS Automation policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Param mcisInfo body mcis.McisPolicyInfo true "Details for an MCIS object"
// @Success 200 {object} mcis.McisPolicyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [post]
func RestPostMcisPolicy(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        req := &amp;mcis.McisPolicyInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">content, err := mcis.CreateMcisPolicy(nsId, mcisId, req)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, content)</span>
}

// RestGetMcisPolicy godoc
// @Summary Get MCIS Policy
// @Description Get MCIS Policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Success 200 {object} mcis.McisPolicyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [get]
func RestGetMcisPolicy(c echo.Context) error <span class="cov8" title="1">{
        //id, _ := strconv.Atoi(c.Param("id"))

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        result, err := mcis.GetMcisPolicyObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": "Error to find McisPolicyObject : " + mcisId + "ERROR : " + err.Error()}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span>

        <span class="cov8" title="1">if result.Id == "" </span><span class="cov8" title="1">{
                mapA := map[string]string{"message": "Failed to find McisPolicyObject : " + mcisId}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span>

        <span class="cov8" title="1">common.PrintJsonPretty(result)
        return c.JSON(http.StatusOK, result)</span>

}

// Response structure for RestGetAllMcisPolicy
type RestGetAllMcisPolicyResponse struct {
        McisPolicy []mcis.McisPolicyInfo `json:"mcisPolicy"`
}

// RestGetAllMcisPolicy godoc
// @Summary List all MCIS policies
// @Description List all MCIS policies
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} RestGetAllMcisPolicyResponse
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis [get]
func RestGetAllMcisPolicy(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        fmt.Println("[Get MCIS Policy List]")

        result, err := mcis.GetAllMcisPolicyObject(nsId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusNotFound, &amp;mapA)
        }</span>

        <span class="cov8" title="1">content := RestGetAllMcisPolicyResponse{}
        content.McisPolicy = result

        //fmt.Printf("content %+v\n", content)
        common.PrintJsonPretty(content)

        return c.JSON(http.StatusOK, &amp;content)</span>

}

/* function RestPutMcisPolicy not yet implemented
// RestPutMcisPolicy godoc
// @Summary Update MCIS Policy
// @Description Update MCIS Policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param mcisInfo body McisPolicyInfo true "Details for an MCIS Policy object"
// @Success 200 {object} McisPolicyInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [put]
*/
func RestPutMcisPolicy(c echo.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// DelMcisPolicy godoc
// @Summary Delete MCIS Policy
// @Description Delete MCIS Policy
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param mcisId path string true "MCIS ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis/{mcisId} [delete]
func RestDelMcisPolicy(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        err := mcis.DelMcisPolicy(nsId, mcisId)
        if err != nil </span><span class="cov8" title="1">{
                common.CBLog.Error(err)
                mapA := map[string]string{"message": "Failed to delete the MCIS Policy"}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>

        <span class="cov8" title="1">mapA := map[string]string{"message": "Deleting the MCIS Policy info"}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}

// RestDelAllMcisPolicy godoc
// @Summary Delete all MCIS policies
// @Description Delete all MCIS policies
// @Tags [MCIS] Auto control policy management (WIP)
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Success 200 {object} common.SimpleMsg
// @Failure 404 {object} common.SimpleMsg
// @Router /ns/{nsId}/policy/mcis [delete]
func RestDelAllMcisPolicy(c echo.Context) error <span class="cov8" title="1">{
        nsId := c.Param("nsId")
        result, err := mcis.DelAllMcisPolicy(nsId)
        if err != nil </span><span class="cov0" title="0">{
                mapA := map[string]string{"message": err.Error()}
                return c.JSON(http.StatusInternalServerError, &amp;mapA)
        }</span>
        <span class="cov8" title="1">mapA := map[string]string{"message": result}
        return c.JSON(http.StatusOK, &amp;mapA)</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package mcis

import (
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

// RestRecommendVm godoc
// @Summary Recommend MCIS plan (filter and priority)
// @Description Recommend MCIS plan (filter and priority)
// @Tags [MCIS] Provisioning management
// @Accept  json
// @Produce  json
// @Param nsId path string true "Namespace ID"
// @Param deploymentPlan body mcis.DeploymentPlan false "Recommend MCIS plan (filter and priority)"
// @Success 200 {object} []mcir.TbSpecInfo
// @Failure 404 {object} common.SimpleMsg
// @Failure 500 {object} common.SimpleMsg
// @Router /ns/{nsId}/testRecommendVm [post]
func RestRecommendVm(c echo.Context) error <span class="cov0" title="0">{

        nsId := c.Param("nsId")

        u := &amp;mcis.DeploymentPlan{}
        if err := c.Bind(u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := mcis.RecommendVm(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return c.JSONBlob(http.StatusNotFound, []byte(err.Error()))
        }</span>

        // result := RestFilterSpecsResponse{}
        // result.Spec = content
        <span class="cov0" title="0">return c.JSON(http.StatusOK, &amp;content)</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package mcis

import (
        "net/http"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"
)

func RestCheckMcis(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")

        exists, err := mcis.CheckMcis(nsId, mcisId)

        type JsonTemplate struct {
                Exists bool `json:"exists"`
        }
        content := JsonTemplate{}
        content.Exists = exists

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //mapA := map[string]string{"message": err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return c.JSON(http.StatusNotFound, &amp;content)
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>
}

func RestCheckVm(c echo.Context) error <span class="cov8" title="1">{

        nsId := c.Param("nsId")
        mcisId := c.Param("mcisId")
        vmId := c.Param("vmId")

        exists, err := mcis.CheckVm(nsId, mcisId, vmId)

        type JsonTemplate struct {
                Exists bool `json:"exists"`
        }
        content := JsonTemplate{}
        content.Exists = exists

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //mapA := map[string]string{"message": err.Error()}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return c.JSON(http.StatusNotFound, &amp;content)
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;content)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package common

import (
        "database/sql"
        "time"

        cbstore "github.com/cloud-barista/cb-store"
        "github.com/cloud-barista/cb-store/config"
        icbs "github.com/cloud-barista/cb-store/interfaces"
        "github.com/sirupsen/logrus"
        "xorm.io/xorm"
)

type KeyValue struct {
        Key   string
        Value string
}

type IdList struct {
        IdList []string `json:"idList"`
}

// CB-Store
var CBLog *logrus.Logger
var CBStore icbs.Store

var SPIDER_REST_URL string
var DRAGONFLY_REST_URL string
var DB_URL string
var DB_DATABASE string
var DB_USER string
var DB_PASSWORD string
var AUTOCONTROL_DURATION_MS string
var MYDB *sql.DB
var err error
var ORM *xorm.Engine

const (
        StrSPIDER_REST_URL            string = "SPIDER_REST_URL"
        StrDRAGONFLY_REST_URL         string = "DRAGONFLY_REST_URL"
        StrDB_URL                     string = "DB_URL"
        StrDB_DATABASE                string = "DB_DATABASE"
        StrDB_USER                    string = "DB_USER"
        StrDB_PASSWORD                string = "DB_PASSWORD"
        StrAUTOCONTROL_DURATION_MS    string = "AUTOCONTROL_DURATION_MS"
        CbStoreKeyNotFoundErrorString string = "key not found"
        StrAdd                        string = "add"
        StrDelete                     string = "delete"
        StrSSHKey                     string = "sshKey"
        StrImage                      string = "image"
        StrSecurityGroup              string = "securityGroup"
        StrSpec                       string = "spec"
        StrVNet                       string = "vNet"
)

var StartTime string

func init() <span class="cov8" title="1">{
        CBLog = config.Cblogger
        CBStore = cbstore.GetStore()

        StartTime = time.Now().Format("2006.01.02 15:04:05 Mon")
}</span>

// Spider 2020-03-30 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/IId.go
type IID struct {
        NameId   string // NameID by user
        SystemId string // SystemID by CloudOS
}

type SpiderConnectionName struct {
        ConnectionName string `json:"ConnectionName"`
}

func OpenSQL(path string) error <span class="cov0" title="0">{
        /*
                common.MYDB, err = sql.Open("mysql", //"root:pwd@tcp(127.0.0.1:3306)/testdb")
                        common.DB_USER+":"+
                                common.DB_PASSWORD+"@tcp("+
                                common.DB_URL+")/"+
                                common.DB_DATABASE)
        */

        fullPathString := "file:" + path
        MYDB, err = sql.Open("sqlite3", fullPathString)
        return err
}</span>

func SelectDatabase(database string) error <span class="cov0" title="0">{
        query := "USE " + database + ";"
        _, err = MYDB.Exec(query)
        return err
}</span>

/*
func CreateSpecTable() error {
        stmt, err := MYDB.Prepare("CREATE Table IF NOT EXISTS spec(" +
                "namespace varchar(50) NOT NULL," +
                "id varchar(50) NOT NULL," +
                "connectionName varchar(50) NOT NULL," +
                "cspSpecName varchar(50) NOT NULL," +
                "name varchar(50)," +
                "os_type varchar(50)," +
                "num_vCPU SMALLINT," + // SMALLINT: -32768 ~ 32767
                "num_core SMALLINT," + // SMALLINT: -32768 ~ 32767
                "mem_GiB SMALLINT," + // SMALLINT: -32768 ~ 32767
                "storage_GiB MEDIUMINT," + // MEDIUMINT: -8388608 to 8388607
                "description varchar(50)," +
                "cost_per_hour FLOAT," +
                "num_storage SMALLINT," + // SMALLINT: -32768 ~ 32767
                "max_num_storage SMALLINT," + // SMALLINT: -32768 ~ 32767
                "max_total_storage_TiB SMALLINT," + // SMALLINT: -32768 ~ 32767
                "net_bw_Gbps SMALLINT," + // SMALLINT: -32768 ~ 32767
                "ebs_bw_Mbps MEDIUMINT," + // MEDIUMINT: -8388608 to 8388607
                "gpu_model varchar(50)," +
                "num_gpu SMALLINT," + // SMALLINT: -32768 ~ 32767
                "gpumem_GiB SMALLINT," + // SMALLINT: -32768 ~ 32767
                "gpu_p2p varchar(50)," +
                "orderInFilteredResult SMALLINT," + // SMALLINT: -32768 ~ 32767
                "evaluationStatus varchar(50)," +
                "evaluationScore_01 FLOAT," +
                "evaluationScore_02 FLOAT," +
                "evaluationScore_03 FLOAT," +
                "evaluationScore_04 FLOAT," +
                "evaluationScore_05 FLOAT," +
                "evaluationScore_06 FLOAT," +
                "evaluationScore_07 FLOAT," +
                "evaluationScore_08 FLOAT," +
                "evaluationScore_09 FLOAT," +
                "evaluationScore_10 FLOAT," +
                "CONSTRAINT PK_Spec PRIMARY KEY (namespace, id));")
        if err != nil {
                fmt.Println(err.Error())
        }
        _, err = stmt.Exec()

        return err
}

func CreateImageTable() error {
        stmt, err := MYDB.Prepare("CREATE Table IF NOT EXISTS image(" +
                "namespace varchar(50) NOT NULL," +
                "id varchar(50) NOT NULL," +
                "name varchar(50)," +
                "connectionName varchar(50) NOT NULL," +
                "cspImageId varchar(400) NOT NULL," +
                "cspImageName varchar(400) NOT NULL," +
                "creationDate varchar(50) NOT NULL," +
                "description varchar(400) NOT NULL," +
                "guestOS varchar(50) NOT NULL," +
                "status varchar(50) NOT NULL," +
                "CONSTRAINT PK_Image PRIMARY KEY (namespace, id));")
        if err != nil {
                fmt.Println(err.Error())
        }
        _, err = stmt.Exec()

        return err
}
*/
</pre>
		
		<pre class="file" id="file80" style="display: none">package common

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        cbstore_utils "github.com/cloud-barista/cb-store/utils"
)

// swagger:request ConfigReq
type ConfigReq struct {
        Name  string `json:"name" example:"SPIDER_REST_URL"`
        Value string `json:"value" example:"http://localhost:1024/spider"`
}

// swagger:response ConfigInfo
type ConfigInfo struct {
        Id    string `json:"id" example:"SPIDER_REST_URL"`
        Name  string `json:"name" example:"SPIDER_REST_URL"`
        Value string `json:"value" example:"http://localhost:1024/spider"`
}

func UpdateConfig(u *ConfigReq) (ConfigInfo, error) <span class="cov8" title="1">{

        if u.Name == "" </span><span class="cov0" title="0">{
                temp := ConfigInfo{}
                err := fmt.Errorf("The provided name is empty.")
                return temp, err
        }</span>

        <span class="cov8" title="1">content := ConfigInfo{}
        content.Id = u.Name
        content.Name = u.Name
        content.Value = u.Value

        key := "/config/" + content.Id
        //mapA := map[string]string{"name": content.Name, "description": content.Description}
        val, _ := json.Marshal(content)
        err = CBStore.Put(string(key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := CBStore.Get(string(key))
        fmt.Println("UpdateConfig(); ===========================")
        fmt.Println("UpdateConfig(); Key: " + keyValue.Key + "\nValue: " + keyValue.Value)
        fmt.Println("UpdateConfig(); ===========================")

        UpdateGlobalVariable(content.Id)

        return content, nil</span>
}

func UpdateGlobalVariable(id string) error <span class="cov8" title="1">{

        /*
                common.SPIDER_REST_URL = common.NVL(os.Getenv("SPIDER_REST_URL"), "http://localhost:1024/spider")
                common.DRAGONFLY_REST_URL = common.NVL(os.Getenv("DRAGONFLY_REST_URL"), "http://localhost:9090/dragonfly")
                common.DB_URL = common.NVL(os.Getenv("DB_URL"), "localhost:3306")
                common.DB_DATABASE = common.NVL(os.Getenv("DB_DATABASE"), "cb_tumblebug")
                common.DB_USER = common.NVL(os.Getenv("DB_USER"), "cb_tumblebug")
                common.DB_PASSWORD = common.NVL(os.Getenv("DB_PASSWORD"), "cb_tumblebug")
        */

        configInfo, err := GetConfig(id)
        if err != nil </span><span class="cov8" title="1">{
                //CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">switch id </span>{
        case StrSPIDER_REST_URL:<span class="cov0" title="0">
                SPIDER_REST_URL = configInfo.Value
                fmt.Println("&lt;SPIDER_REST_URL&gt; " + SPIDER_REST_URL)</span>
        case StrDRAGONFLY_REST_URL:<span class="cov0" title="0">
                DRAGONFLY_REST_URL = configInfo.Value
                fmt.Println("&lt;DRAGONFLY_REST_URL&gt; " + DRAGONFLY_REST_URL)</span>
        case StrDB_URL:<span class="cov0" title="0">
                DB_URL = configInfo.Value
                fmt.Println("&lt;DB_URL&gt; " + DB_URL)</span>
        case StrDB_DATABASE:<span class="cov0" title="0">
                DB_DATABASE = configInfo.Value
                fmt.Println("&lt;DB_DATABASE&gt; " + DB_DATABASE)</span>
        case StrDB_USER:<span class="cov0" title="0">
                DB_USER = configInfo.Value
                fmt.Println("&lt;DB_USER&gt; " + DB_USER)</span>
        case StrDB_PASSWORD:<span class="cov0" title="0">
                DB_PASSWORD = configInfo.Value
                fmt.Println("&lt;DB_PASSWORD&gt; " + DB_PASSWORD)</span>
        case StrAUTOCONTROL_DURATION_MS:<span class="cov0" title="0">
                AUTOCONTROL_DURATION_MS = configInfo.Value
                fmt.Println("&lt;AUTOCONTROL_DURATION_MS&gt; " + AUTOCONTROL_DURATION_MS)</span>
        default:<span class="cov8" title="1"></span>

        }

        <span class="cov8" title="1">return nil</span>
}

func InitConfig(id string) error <span class="cov8" title="1">{

        switch id </span>{
        case StrSPIDER_REST_URL:<span class="cov0" title="0">
                SPIDER_REST_URL = NVL(os.Getenv("SPIDER_REST_URL"), "http://localhost:1024/spider")
                fmt.Println("&lt;SPIDER_REST_URL&gt; " + SPIDER_REST_URL)</span>
        case StrDRAGONFLY_REST_URL:<span class="cov0" title="0">
                DRAGONFLY_REST_URL = NVL(os.Getenv("DRAGONFLY_REST_URL"), "http://localhost:9090/dragonfly")
                fmt.Println("&lt;DRAGONFLY_REST_URL&gt; " + DRAGONFLY_REST_URL)</span>
        case StrDB_URL:<span class="cov0" title="0">
                DB_URL = NVL(os.Getenv("DB_URL"), "localhost:3306")
                fmt.Println("&lt;DB_URL&gt; " + DB_URL)</span>
        case StrDB_DATABASE:<span class="cov0" title="0">
                DB_DATABASE = NVL(os.Getenv("DB_DATABASE"), "cb_tumblebug")
                fmt.Println("&lt;DB_DATABASE&gt; " + DB_DATABASE)</span>
        case StrDB_USER:<span class="cov0" title="0">
                DB_USER = NVL(os.Getenv("DB_USER"), "cb_tumblebug")
                fmt.Println("&lt;DB_USER&gt; " + DB_USER)</span>
        case StrDB_PASSWORD:<span class="cov0" title="0">
                DB_PASSWORD = NVL(os.Getenv("DB_PASSWORD"), "cb_tumblebug")
                fmt.Println("&lt;DB_PASSWORD&gt; " + DB_PASSWORD)</span>
        case StrAUTOCONTROL_DURATION_MS:<span class="cov0" title="0">
                AUTOCONTROL_DURATION_MS = NVL(os.Getenv("AUTOCONTROL_DURATION_MS"), "10000")
                fmt.Println("&lt;AUTOCONTROL_DURATION_MS&gt; " + AUTOCONTROL_DURATION_MS)</span>
        default:<span class="cov8" title="1"></span>

        }

        <span class="cov8" title="1">check, err := CheckConfig(id)

        if check &amp;&amp; err == nil </span><span class="cov0" title="0">{
                fmt.Println("[Init config] " + id)
                key := "/config/" + id
                //fmt.Println(key)

                CBStore.Delete(key)
                // if err != nil {
                //         CBLog.Error(err)
                //         return err
                // }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetConfig(id string) (ConfigInfo, error) <span class="cov8" title="1">{

        res := ConfigInfo{}

        check, err := CheckConfig(id)

        if !check </span><span class="cov8" title="1">{
                errString := "The config " + id + " does not exist."
                err := fmt.Errorf(errString)
                return res, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := ConfigInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Get config] " + id)
        key := "/config/" + id
        //fmt.Println(key)

        keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>

        <span class="cov8" title="1">fmt.Println("&lt;" + keyValue.Key + "&gt; " + keyValue.Value)
        //fmt.Println("===============================================")

        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

func ListConfig() ([]ConfigInfo, error) <span class="cov8" title="1">{
        fmt.Println("[List config]")
        key := "/config"
        fmt.Println(key)

        keyValue, err := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                res := []ConfigInfo{}
                for _, v := range keyValue </span><span class="cov8" title="1">{
                        tempObj := ConfigInfo{}
                        err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                        if err != nil </span><span class="cov0" title="0">{
                                CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">res = append(res, tempObj)</span>
                }
                <span class="cov8" title="1">return res, nil</span>
                //return true, nil
        }
        <span class="cov8" title="1">return nil, nil</span> // When err == nil &amp;&amp; keyValue == nil
}

func ListConfigId() []string <span class="cov8" title="1">{

        fmt.Println("[List config]")
        key := "/config"
        fmt.Println(key)

        keyValue, _ := CBStore.GetList(key, true)

        var configList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                configList = append(configList, strings.TrimPrefix(v.Key, "/config/"))
        }</span>
        <span class="cov8" title="1">for _, v := range configList </span><span class="cov0" title="0">{
                fmt.Println("&lt;" + v + "&gt; \n")
        }</span>
        <span class="cov8" title="1">fmt.Println("===============================================")
        return configList</span>

}

/*
func DelAllConfig() error {
        fmt.Printf("DelAllConfig() called;")

        key := "/config"
        fmt.Println(key)
        keyValue, _ := CBStore.GetList(key, true)

        if len(keyValue) == 0 {
                return nil
        }

        for _, v := range keyValue {
                err = CBStore.Delete(v.Key)
                if err != nil {
                        return err
                }
        }
        return nil
}
*/

func InitAllConfig() error <span class="cov8" title="1">{
        fmt.Printf("InitAllConfig() called;")

        configIdList := ListConfigId()

        for _, v := range configIdList </span><span class="cov0" title="0">{
                InitConfig(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func CheckConfig(id string) (bool, error) <span class="cov8" title="1">{

        if id == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckConfig failed; configId given is null.")
                return false, err
        }</span>

        <span class="cov8" title="1">key := "/config/" + id
        //fmt.Println(key)

        keyValue, _ := CBStore.Get(key)
        if keyValue != nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package common

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"
        "github.com/labstack/echo/v4"

        cbstore_utils "github.com/cloud-barista/cb-store/utils"
)

type NsReq struct {
        Name        string `json:"name"`
        Description string `json:"description"`
}

// swagger:response NsInfo
type NsInfo struct {
        Id          string `json:"id" example:"namespaceid01"`
        Name        string `json:"name" example:"namespacename01"`
        Description string `json:"description" example:"Description for this namespace"`
}

func NsValidation() echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        fmt.Printf("%v\n", "[Handle API Request]")
                        nsId := c.Param("nsId")
                        if nsId == "" </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov0" title="0">err := CheckString(nsId)
                        if err != nil </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusNotFound, "The first character of name must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.")
                        }</span>

                        <span class="cov0" title="0">check, err := CheckNs(nsId)

                        if !check || err != nil </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusNotFound, "Not valid namespace")
                        }</span>
                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

func CreateNs(u *NsReq) (NsInfo, error) <span class="cov8" title="1">{
        err := CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">check, err := CheckNs(u.Name)

        if check </span><span class="cov8" title="1">{
                temp := NsInfo{}
                err := fmt.Errorf("CreateNs(); The namespace " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">content := NsInfo{}
        //content.Id = GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.Description = u.Description

        // TODO here: implement the logic

        fmt.Println("CreateNs();")
        Key := "/ns/" + content.Id
        //mapA := map[string]string{"name": content.Name, "description": content.Description}
        Val, _ := json.Marshal(content)
        err = CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := CBStore.Get(string(Key))
        fmt.Println("CreateNs(); ===========================")
        fmt.Println("CreateNs(); Key: " + keyValue.Key + "\nValue: " + keyValue.Value)
        fmt.Println("CreateNs(); ===========================")
        return content, nil</span>
}

func GetNs(id string) (NsInfo, error) <span class="cov8" title="1">{

        res := NsInfo{}

        err := CheckString(id)
        if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, err := CheckNs(id)

        if !check </span><span class="cov8" title="1">{
                errString := "The namespace " + id + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return res, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := NsInfo{}
                CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Get namespace] " + id)
        key := "/ns/" + id
        fmt.Println(key)

        keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>

        <span class="cov8" title="1">fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===============================================")

        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return res, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

func ListNs() ([]NsInfo, error) <span class="cov8" title="1">{
        fmt.Println("[List namespace]")
        key := "/ns"
        fmt.Println(key)

        keyValue, err := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                res := []NsInfo{}
                for _, v := range keyValue </span><span class="cov8" title="1">{
                        tempObj := NsInfo{}
                        err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                        if err != nil </span><span class="cov0" title="0">{
                                CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">res = append(res, tempObj)</span>
                }
                <span class="cov8" title="1">return res, nil</span>
                //return true, nil
        }
        <span class="cov8" title="1">return nil, nil</span> // When err == nil &amp;&amp; keyValue == nil
}

func AppendIfMissing(slice []string, i string) []string <span class="cov0" title="0">{
        for _, ele := range slice </span><span class="cov0" title="0">{
                if ele == i </span><span class="cov0" title="0">{
                        return slice
                }</span>
        }
        <span class="cov0" title="0">return append(slice, i)</span>
}

func ListNsId() ([]string, error) <span class="cov8" title="1">{

        //fmt.Println("[List ns]")
        key := "/ns"
        //fmt.Println(key)

        var nsList []string

        // Implementation Option 1
        // keyValue, _ := CBStore.GetList(key, true)

        // r, _ := regexp.Compile("/ns/[a-z]([-a-z0-9]*[a-z0-9])?$")

        // for _, v := range keyValue {

        //         if v.Key == "" {
        //                 continue
        //         }

        //         filtered := r.FindString(v.Key)

        //         if filtered != v.Key {
        //                 continue
        //         } else {
        //                 trimmedString := strings.TrimPrefix(v.Key, "/ns/")
        //                 nsList = AppendIfMissing(nsList, trimmedString)
        //         }
        // }
        // EOF of Implementation Option 1

        // Implementation Option 2
        keyValue, err := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                for _, v := range keyValue </span><span class="cov8" title="1">{
                        trimmedString := strings.TrimPrefix(v.Key, "/ns/")
                        nsList = append(nsList, trimmedString)
                }</span>
        }
        // EOF of Implementation Option 2

        //for _, v := range nsList {
        //        fmt.Println("&lt;" + v + "&gt; \n")
        //}
        //fmt.Println("===============================================")
        <span class="cov8" title="1">return nsList, nil</span>

}

func DelNs(id string) error <span class="cov8" title="1">{

        err := CheckString(id)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">check, err := CheckNs(id)

        if !check </span><span class="cov8" title="1">{
                errString := "The namespace " + id + " does not exist."
                err := fmt.Errorf(errString)
                return err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Delete ns] " + id)
        key := "/ns/" + id
        fmt.Println(key)

        mcisList := GetChildIdList(key + "/mcis")
        imageList := GetChildIdList(key + "/resources/image")
        vNetList := GetChildIdList(key + "/resources/vNet")
        //subnetList := GetChildIdList(key + "/resources/subnet")
        //publicIpList := GetChildIdList(key + "/resources/publicIp")
        securityGroupList := GetChildIdList(key + "/resources/securityGroup")
        specList := GetChildIdList(key + "/resources/spec")
        sshKeyList := GetChildIdList(key + "/resources/sshKey")
        //vNicList := GetChildIdList(key + "/resources/vNic")

        if len(mcisList)+
                len(imageList)+
                len(vNetList)+
                //len(subnetList)
                len(securityGroupList)+
                len(specList)+
                len(sshKeyList) &gt; 0 </span><span class="cov0" title="0">{
                errString := "Cannot delete NS " + id + ", which is not empty. There exists at least one MCIS or one of resources."
                errString += " \n len(mcisList): " + strconv.Itoa(len(mcisList))
                errString += " \n len(imageList): " + strconv.Itoa(len(imageList))
                errString += " \n len(vNetList): " + strconv.Itoa(len(vNetList))
                //errString += " \n len(publicIpList): " + strconv.Itoa(len(publicIpList))
                errString += " \n len(securityGroupList): " + strconv.Itoa(len(securityGroupList))
                errString += " \n len(specList): " + strconv.Itoa(len(specList))
                errString += " \n len(sshKeyList): " + strconv.Itoa(len(sshKeyList))
                //errString += " \n len(subnetList): " + strconv.Itoa(len(subnetList))
                //errString += " \n len(vNicList): " + strconv.Itoa(len(vNicList))

                err := fmt.Errorf(errString)
                CBLog.Error(err)
                return err
        }</span>

        // delete ns info
        <span class="cov8" title="1">err = CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func DelAllNs() error <span class="cov8" title="1">{
        fmt.Printf("DelAllNs() called;")

        nsIdList, err := ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(nsIdList) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, v := range nsIdList </span><span class="cov0" title="0">{
                err := DelNs(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func CheckNs(id string) (bool, error) <span class="cov8" title="1">{

        if id == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckNs failed; nsId given is null.")
                return false, err
        }</span>

        <span class="cov8" title="1">err := CheckString(id)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return false, err
        }</span>

        //fmt.Println("[Check ns] " + lowerizedId)

        <span class="cov8" title="1">key := "/ns/" + id
        //fmt.Println(key)

        keyValue, _ := CBStore.Get(key)
        if keyValue != nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package common

import (
        "os"
        "regexp"
        "runtime"
        "strconv"
        "strings"

        //"encoding/json"

        "github.com/cloud-barista/cb-spider/interface/api"
        cbstore_utils "github.com/cloud-barista/cb-store/utils"
        uuid "github.com/google/uuid"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gopkg.in/yaml.v2"

        // CB-Store
        //"github.com/cloud-barista/cb-grpc-project/pkg/logging"

        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"

        "encoding/json"
        "fmt"

        //"net/http"
        //"io/ioutil"
        //"strconv"
        "github.com/go-resty/resty/v2"
)

// MCIS utilities

// JSON Simple message struct
type SimpleMsg struct {
        Message string `json:"message" example:"Any message"`
}

func GenUuid() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>

func CheckString(name string) error <span class="cov8" title="1">{

        if name == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("The provided name is empty.")
                return err
        }</span>

        <span class="cov8" title="1">r, _ := regexp.Compile("[a-z]([-a-z0-9]*[a-z0-9])?")
        filtered := r.FindString(name)

        if filtered != name </span><span class="cov0" title="0">{
                err := fmt.Errorf(name + ": The first character of name must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.")
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// To be deprecated
func ToLower(name string) string <span class="cov8" title="1">{
        out := strings.ReplaceAll(name, "_", "-")
        out = strings.ReplaceAll(out, " ", "-")
        out = strings.ToLower(out)
        return out
}</span>

func GenMcisKey(nsId string, mcisId string, vmId string) string <span class="cov8" title="1">{

        if vmId != "" </span><span class="cov8" title="1">{
                return "/ns/" + nsId + "/mcis/" + mcisId + "/vm/" + vmId
        }</span> else<span class="cov8" title="1"> if mcisId != "" </span><span class="cov8" title="1">{
                return "/ns/" + nsId + "/mcis/" + mcisId
        }</span> else<span class="cov8" title="1"> if nsId != "" </span><span class="cov8" title="1">{
                return "/ns/" + nsId
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>

}

func GenMcisVmGroupKey(nsId string, mcisId string, groupId string) string <span class="cov8" title="1">{

        return "/ns/" + nsId + "/mcis/" + mcisId + "/vmgroup/" + groupId

}</span>

// Generate Mcis policy key
func GenMcisPolicyKey(nsId string, mcisId string, vmId string) string <span class="cov8" title="1">{
        if vmId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId + "/policy/mcis/" + mcisId + "/vm/" + vmId
        }</span> else<span class="cov8" title="1"> if mcisId != "" </span><span class="cov8" title="1">{
                return "/ns/" + nsId + "/policy/mcis/" + mcisId
        }</span> else<span class="cov0" title="0"> if nsId != "" </span><span class="cov0" title="0">{
                return "/ns/" + nsId
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}

func LookupKeyValueList(kvl []KeyValue, key string) string <span class="cov8" title="1">{
        for _, v := range kvl </span><span class="cov0" title="0">{
                if v.Key == key </span><span class="cov0" title="0">{
                        return v.Value
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func PrintJsonPretty(v interface{}) <span class="cov8" title="1">{
        prettyJSON, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%+v\n", v)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("%s\n", string(prettyJSON))
        }</span>
}

func GenResourceKey(nsId string, resourceType string, resourceId string) string <span class="cov8" title="1">{

        if resourceType == StrImage ||
                resourceType == StrSSHKey ||
                resourceType == StrSpec ||
                resourceType == StrVNet ||
                resourceType == StrSecurityGroup </span><span class="cov8" title="1">{
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" {
                return "/ns/" + nsId + "/resources/" + resourceType + "/" + resourceId
        }</span> else<span class="cov0" title="0"> {
                return "/invalidKey"
        }</span>
}

type mcirIds struct { // Tumblebug
        CspImageId           string
        CspImageName         string
        CspSshKeyName        string
        CspSpecName          string
        CspVNetId            string
        CspVNetName          string
        CspSecurityGroupId   string
        CspSecurityGroupName string
        CspPublicIpId        string
        CspPublicIpName      string
        CspVNicId            string
        CspVNicName          string

        ConnectionName string
}

func GetCspResourceId(nsId string, resourceType string, resourceId string) (string, error) <span class="cov8" title="1">{
        key := GenResourceKey(nsId, resourceType, resourceId)
        if key == "/invalidKey" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid nsId or resourceType or resourceId")
        }</span>
        <span class="cov8" title="1">keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">if keyValue == nil </span><span class="cov0" title="0">{
                //CBLog.Error(err)
                // if there is no matched value for the key, return empty string. Error will be handled in a parent function
                return "", fmt.Errorf("cannot find the key " + key)
        }</span>

        <span class="cov8" title="1">switch resourceType </span>{
        case StrImage:<span class="cov8" title="1">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return content.CspImageId, nil</span>
        case StrSSHKey:<span class="cov8" title="1">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return resourceId, nil</span>
        case StrSpec:<span class="cov8" title="1">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return content.CspSpecName, nil</span>
        case StrVNet:<span class="cov8" title="1">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return resourceId, nil</span> // contains CspSubnetId
        // case "subnet":
        //         content := subnetInfo{}
        //         json.Unmarshal([]byte(keyValue.Value), &amp;content)
        //         return content.CspSubnetId
        case StrSecurityGroup:<span class="cov0" title="0">
                content := mcirIds{}
                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                return content.CspSecurityGroupName, nil</span>
        /*
                case "publicIp":
                        content := mcirIds{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        return content.CspPublicIpName
                case "vNic":
                        content := mcirIds{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        if err != nil {
                                CBLog.Error(err)
                                // if there is no matched value for the key, return empty string. Error will be handled in a parent function
                                return ""
                        }
                        return content.CspVNicName
        */
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid resourceType")</span>
        }
        //}
}

type ConnConfig struct { // Spider
        ConfigName     string
        ProviderName   string
        DriverName     string
        CredentialName string
        RegionName     string
}

func GetConnConfig(ConnConfigName string) (ConnConfig, error) <span class="cov8" title="1">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := SPIDER_REST_URL + "/connectionconfig/" + ConnConfigName

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;ConnConfig{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := ConnConfig{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := ConnConfig{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp, _ := resp.Result().(*ConnConfig)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CIM API 설정
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return ConnConfig{}, err
                }</span>
                <span class="cov8" title="1">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return ConnConfig{}, err
                }</span>
                <span class="cov8" title="1">defer cim.Close()

                result, err := cim.GetConnectionConfigByParam(ConnConfigName)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return ConnConfig{}, err
                }</span>

                <span class="cov8" title="1">temp := ConnConfig{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return ConnConfig{}, err
                }</span>
                <span class="cov8" title="1">return temp, nil</span>
        }
}

type ConnConfigList struct { // Spider
        Connectionconfig []ConnConfig `json:"connectionconfig"`
}

func GetConnConfigList() (ConnConfigList, error) <span class="cov8" title="1">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := SPIDER_REST_URL + "/connectionconfig"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;ConnConfigList{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := ConnConfigList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := ConnConfigList{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp, _ := resp.Result().(*ConnConfigList)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CIM API 설정
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return ConnConfigList{}, err
                }</span>
                <span class="cov8" title="1">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return ConnConfigList{}, err
                }</span>
                <span class="cov8" title="1">defer cim.Close()

                result, err := cim.ListConnectionConfig()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return ConnConfigList{}, err
                }</span>

                <span class="cov8" title="1">temp := ConnConfigList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api Unmarshal failed : ", err)
                        return ConnConfigList{}, err
                }</span>
                <span class="cov8" title="1">return temp, nil</span>

        }
}

type Region struct { // Spider
        RegionName       string     // ex) "region01"
        ProviderName     string     // ex) "GCP"
        KeyValueInfoList []KeyValue // ex) { {region, us-east1}, {zone, us-east1-c} }
}

func GetRegion(RegionName string) (Region, error) <span class="cov8" title="1">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := SPIDER_REST_URL + "/region/" + RegionName

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;Region{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := Region{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := Region{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp, _ := resp.Result().(*Region)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CIM API 설정
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return Region{}, err
                }</span>
                <span class="cov8" title="1">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return Region{}, err
                }</span>
                <span class="cov8" title="1">defer cim.Close()

                result, err := cim.GetRegionByParam(RegionName)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return Region{}, err
                }</span>

                <span class="cov8" title="1">temp := Region{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api Unmarshal failed : ", err)
                        return Region{}, err
                }</span>
                <span class="cov8" title="1">return temp, nil</span>

        }
}

// RegionList is array struct for Region
type RegionList struct {
        Region []Region `json:"region"`
}

// GetRegionList retrieves region list
func GetRegionList() (RegionList, error) <span class="cov8" title="1">{

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := SPIDER_REST_URL + "/region"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetResult(&amp;RegionList{}).
                        //SetError(&amp;SimpleMsg{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        content := RegionList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body())) // for debug

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        CBLog.Error(err)
                        content := RegionList{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp, _ := resp.Result().(*RegionList)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CIM API 설정
                cim := api.NewCloudInfoManager()
                err := cim.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim failed to set config : ", err)
                        return RegionList{}, err
                }</span>
                <span class="cov8" title="1">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api open failed : ", err)
                        return RegionList{}, err
                }</span>
                <span class="cov8" title="1">defer cim.Close()

                result, err := cim.ListRegion()
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api request failed : ", err)
                        return RegionList{}, err
                }</span>

                <span class="cov8" title="1">temp := RegionList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error("cim api Unmarshal failed : ", err)
                        return RegionList{}, err
                }</span>
                <span class="cov8" title="1">return temp, nil</span>

        }
}

// ConvertToMessage - 입력 데이터를 grpc 메시지로 변환
func ConvertToMessage(inType string, inData string, obj interface{}) error <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        if inType == "yaml" </span><span class="cov0" title="0">{
                err := yaml.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //logger.Debug("yaml Unmarshal: \n", obj)
        }

        <span class="cov0" title="0">if inType == "json" </span><span class="cov0" title="0">{
                err := json.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //logger.Debug("json Unmarshal: \n", obj)
        }

        <span class="cov0" title="0">return nil</span>
}

// ConvertToOutput - grpc 메시지를 출력포맷으로 변환
func ConvertToOutput(outType string, obj interface{}) (string, error) <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        if outType == "yaml" </span><span class="cov0" title="0">{
                // 메시지 포맷에서 불필요한 필드(XXX_로 시작하는 필드)를 제거하기 위해 json 태그를 이용하여 마샬링
                j, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // 필드를 소팅하지 않고 지정된 순서대로 출력하기 위해 MapSlice 이용
                <span class="cov0" title="0">jsonObj := yaml.MapSlice{}
                err2 := yaml.Unmarshal(j, &amp;jsonObj)
                if err2 != nil </span><span class="cov0" title="0">{
                        return "", err2
                }</span>

                // yaml 마샬링
                <span class="cov0" title="0">y, err3 := yaml.Marshal(jsonObj)
                if err3 != nil </span><span class="cov0" title="0">{
                        return "", err3
                }</span>
                //logger.Debug("yaml Marshal: \n", string(y))

                <span class="cov0" title="0">return string(y), nil</span>
        }

        <span class="cov0" title="0">if outType == "json" </span><span class="cov0" title="0">{
                j, err := json.MarshalIndent(obj, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                //logger.Debug("json Marshal: \n", string(j))

                <span class="cov0" title="0">return string(j), nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// CopySrcToDest - 소스에서 타켓으로 데이터 복사
func CopySrcToDest(src interface{}, dest interface{}) error <span class="cov8" title="1">{
        //logger := logging.NewLogger()

        j, err := json.MarshalIndent(src, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //logger.Debug("source value : \n", string(j))

        <span class="cov8" title="1">err = json.Unmarshal(j, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">j, err = json.MarshalIndent(dest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //logger.Debug("target value : \n", string(j))

        <span class="cov8" title="1">return nil</span>
}

// ConvGrpcStatusErr - GRPC 상태 코드 에러로 변환
func ConvGrpcStatusErr(err error, tag string, method string) error <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        //_, fn, line, _ := runtime.Caller(1)
        runtime.Caller(1)
        if err != nil </span><span class="cov0" title="0">{
                if errStatus, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        //logger.Error(tag, " error while calling ", method, " method: [", fn, ":", line, "] ", errStatus.Message())
                        return status.Errorf(errStatus.Code(), "%s error while calling %s method: %v ", tag, method, errStatus.Message())
                }</span>
                //logger.Error(tag, " error while calling ", method, " method: [", fn, ":", line, "] ", err)
                <span class="cov0" title="0">return status.Errorf(codes.Internal, "%s error while calling %s method: %v ", tag, method, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewGrpcStatusErr - GRPC 상태 코드 에러 생성
func NewGrpcStatusErr(msg string, tag string, method string) error <span class="cov0" title="0">{
        //logger := logging.NewLogger()

        //_, fn, line, _ := runtime.Caller(1)
        runtime.Caller(1)
        //logger.Error(tag, " error while calling ", method, " method: [", fn, ":", line, "] ", msg)
        return status.Errorf(codes.Internal, "%s error while calling %s method: %s ", tag, method, msg)
}</span>

// NVL is null value logic
func NVL(str string, def string) string <span class="cov8" title="1">{
        if len(str) == 0 </span><span class="cov0" title="0">{
                return def
        }</span>
        <span class="cov8" title="1">return str</span>
}

func GetChildIdList(key string) []string <span class="cov8" title="1">{

        keyValue, _ := CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        var childIdList []string
        for _, v := range keyValue </span><span class="cov0" title="0">{
                childIdList = append(childIdList, strings.TrimPrefix(v.Key, key+"/"))

        }</span>
        <span class="cov8" title="1">for _, v := range childIdList </span><span class="cov0" title="0">{
                fmt.Println("&lt;" + v + "&gt; \n")
        }</span>
        <span class="cov8" title="1">fmt.Println("===============================================")
        return childIdList</span>

}

// func GetObjectList returns IDs of each child objects that has the same key.
func GetObjectList(key string) []string <span class="cov8" title="1">{

        keyValue, _ := CBStore.GetList(key, true)

        var childIdList []string
        for _, v := range keyValue </span><span class="cov8" title="1">{
                childIdList = append(childIdList, v.Key)
        }</span>

        <span class="cov8" title="1">fmt.Println("===============================================")
        return childIdList</span>

}

// func GetObjectValue returns the object value.
func GetObjectValue(key string) (string, error) <span class="cov8" title="1">{

        keyValue, err := CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">if keyValue == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return keyValue.Value, nil</span>
}

// func DeleteObject delete the object.
func DeleteObject(key string) error <span class="cov8" title="1">{

        err := CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// func DeleteObjects delete objects.
func DeleteObjects(key string) error <span class="cov8" title="1">{
        keyValue, _ := CBStore.GetList(key, true)
        for _, v := range keyValue </span><span class="cov0" title="0">{
                err := CBStore.Delete(v.Key)
                if err != nil </span><span class="cov0" title="0">{
                        CBLog.Error(err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "strings"

        //uuid "github.com/google/uuid"
        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"

        // CB-Store
        cbstore_utils "github.com/cloud-barista/cb-store/utils"
        "github.com/tidwall/gjson"
        "github.com/tidwall/sjson"
)

// CB-Store
//var cblog *logrus.Logger
//var store icbs.Store

//var SPIDER_REST_URL string

func init() {<span class="cov8" title="1">
        //cblog = config.Cblogger
        //store = cbstore.GetStore()
        //SPIDER_REST_URL = os.Getenv("SPIDER_REST_URL")
}</span>

// DelAllResources deletes all TB MCIR object of given resourceType
func DelAllResources(nsId string, resourceType string, forceFlag string) error <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">resourceIdList, err := ListResourceId(nsId, resourceType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(resourceIdList) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, v := range resourceIdList </span><span class="cov8" title="1">{
                err := DelResource(nsId, resourceType, v, forceFlag)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// DelResource deletes the TB MCIR object
func DelResource(nsId string, resourceType string, resourceId string, forceFlag string) error <span class="cov8" title="1">{

        fmt.Printf("DelResource() called; %s %s %s \n", nsId, resourceType, resourceId) // for debug

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov8" title="1">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                //return http.StatusNotFound, mapB, err
                return err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">key := common.GenResourceKey(nsId, resourceType, resourceId)
        fmt.Println("key: " + key)

        keyValue, _ := common.CBStore.Get(key)
        /*
                if keyValue == nil {
                        mapA := map[string]string{"message": "Failed to find the resource with given ID."}
                        mapB, _ := json.Marshal(mapA)
                        err := fmt.Errorf("Failed to find the resource with given ID.")
                        return http.StatusNotFound, mapB, err
                }
        */
        //fmt.Println("keyValue: " + keyValue.Key + " / " + keyValue.Value)

        //cspType := common.GetResourcesCspType(nsId, resourceType, resourceId)

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                var url string

                // Create Req body
                type JsonTemplate struct {
                        ConnectionName string
                }
                tempReq := JsonTemplate{}

                switch resourceType </span>{
                case common.StrImage:<span class="cov8" title="1">
                        // delete image info
                        err := common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //return http.StatusInternalServerError, nil, err
                                return err
                        }</span>

                        // "DELETE FROM `image` WHERE `id` = '" + resourceId + "';"
                        <span class="cov8" title="1">_, err = common.ORM.Delete(&amp;TbImageInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        //return http.StatusOK, nil, nil
                        <span class="cov8" title="1">return nil</span>
                case common.StrSpec:<span class="cov8" title="1">
                        // delete spec info

                        //get related recommend spec
                        //keyValue, err := common.CBStore.Get(key)
                        content := TbSpecInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">err = common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        //delete related recommend spec
                        <span class="cov8" title="1">err = DelRecommendSpec(nsId, resourceId, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        // "DELETE FROM `spec` WHERE `id` = '" + resourceId + "';"
                        <span class="cov8" title="1">_, err = common.ORM.Delete(&amp;TbSpecInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        //return http.StatusOK, nil, nil
                        <span class="cov8" title="1">return nil</span>
                case common.StrSSHKey:<span class="cov8" title="1">
                        temp := TbSshKeyInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov8" title="1">tempReq.ConnectionName = temp.ConnectionName
                        url = common.SPIDER_REST_URL + "/keypair/" + temp.Name</span>
                case common.StrVNet:<span class="cov8" title="1">
                        temp := TbVNetInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov8" title="1">tempReq.ConnectionName = temp.ConnectionName
                        url = common.SPIDER_REST_URL + "/vpc/" + temp.Name</span>
                case common.StrSecurityGroup:<span class="cov8" title="1">
                        temp := TbSecurityGroupInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov8" title="1">tempReq.ConnectionName = temp.ConnectionName
                        url = common.SPIDER_REST_URL + "/securitygroup/" + temp.Name</span>
                /*
                        case "subnet":
                                temp := subnetInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;content)
                                return content.CspSubnetId
                        case "publicIp":
                                temp := publicIpInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                                tempReq.ConnectionName = temp.ConnectionName
                                url = common.SPIDER_REST_URL + "/publicip/" + temp.CspPublicIpName
                        case "vNic":
                                temp := vNicInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                                tempReq.ConnectionName = temp.ConnectionName
                                url = common.SPIDER_REST_URL + "/vnic/" + temp.CspVNicName
                */
                default:<span class="cov0" title="0">
                        err := fmt.Errorf("invalid resourceType")
                        //return http.StatusBadRequest, nil, err
                        return err</span>
                }

                <span class="cov8" title="1">fmt.Println("url: " + url)

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        //SetResult(&amp;SpiderSpecInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Delete(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return err
                }</span>

                <span class="cov8" title="1">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case forceFlag == "true":<span class="cov0" title="0">
                        url += "?force=true"
                        fmt.Println("forceFlag == true; url: " + url)

                        _, err := client.R().
                                SetHeader("Content-Type", "application/json").
                                SetBody(tempReq).
                                //SetResult(&amp;SpiderSpecInfo{}). // or SetResult(AuthSuccess{}).
                                //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                                Delete(url)

                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                                return err
                        }</span>

                        <span class="cov0" title="0">err = common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        return err</span>
                default:<span class="cov8" title="1">
                        err := common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                switch resourceType </span>{
                case common.StrImage:<span class="cov8" title="1">
                        // delete image info
                        err := common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //return http.StatusInternalServerError, nil, err
                                return err
                        }</span>

                        // "DELETE FROM `image` WHERE `id` = '" + resourceId + "';"
                        <span class="cov8" title="1">_, err = common.ORM.Delete(&amp;TbImageInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        //return http.StatusOK, nil, nil
                        <span class="cov8" title="1">return nil</span>
                case common.StrSpec:<span class="cov8" title="1">
                        // delete spec info

                        //get related recommend spec
                        content := TbSpecInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;content)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">err = common.CBStore.Delete(key)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        //delete related recommend spec
                        <span class="cov8" title="1">err = DelRecommendSpec(nsId, resourceId, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        // "DELETE FROM `spec` WHERE `id` = '" + resourceId + "';"
                        <span class="cov8" title="1">_, err = common.ORM.Delete(&amp;TbSpecInfo{Namespace: nsId, Id: resourceId})
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Println("Data deleted successfully..")
                        }</span>

                        <span class="cov8" title="1">return nil</span>

                case common.StrSSHKey:<span class="cov8" title="1">
                        temp := TbSshKeyInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">_, err = ccm.DeleteKeyByParam(temp.ConnectionName, temp.Name, forceFlag)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case common.StrVNet:<span class="cov8" title="1">
                        temp := TbVNetInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">_, err = ccm.DeleteVPCByParam(temp.ConnectionName, temp.Name, forceFlag)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case common.StrSecurityGroup:<span class="cov8" title="1">
                        temp := TbSecurityGroupInfo{}
                        err := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">_, err = ccm.DeleteSecurityByParam(temp.ConnectionName, temp.Name, forceFlag)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                default:<span class="cov0" title="0">
                        err := fmt.Errorf("invalid resourceType")
                        return err</span>
                }

                <span class="cov8" title="1">err = common.CBStore.Delete(key)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>

        }
}

type SpiderNameIdSystemId struct {
        NameId   string
        SystemId string
}

type SpiderAllListWrapper struct {
        AllList SpiderAllList
}

type SpiderAllList struct {
        MappedList     []SpiderNameIdSystemId
        OnlySpiderList []SpiderNameIdSystemId
        OnlyCSPList    []SpiderNameIdSystemId
}

// Response struct for InspectResources
type TbInspectResourcesResponse struct {
        // ResourcesOnCsp       interface{} `json:"resourcesOnCsp"`
        // ResourcesOnSpider    interface{} `json:"resourcesOnSpider"`
        // ResourcesOnTumblebug interface{} `json:"resourcesOnTumblebug"`
        ResourcesOnCsp       []resourceOnCspOrSpider `json:"resourcesOnCsp"`
        ResourcesOnSpider    []resourceOnCspOrSpider `json:"resourcesOnSpider"`
        ResourcesOnTumblebug []resourceOnTumblebug   `json:"resourcesOnTumblebug"`
}

type resourceOnCspOrSpider struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
}

type resourceOnTumblebug struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
        NsId        string `json:"nsId"`
        //McisId      string `json:"mcisId"`
        Type      string `json:"type"`
        ObjectKey string `json:"objectKey"`
}

// InspectResources returns the state list of TB MCIR objects of given connConfig and resourceType
func InspectResources(connConfig string, resourceType string) (interface{}, error) <span class="cov8" title="1">{

        nsList, err := common.ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err = fmt.Errorf("an error occurred while getting namespaces' list: " + err.Error())
                return nil, err
        }</span>
        // var TbResourceList []string
        <span class="cov8" title="1">var TbResourceList []resourceOnTumblebug
        for _, ns := range nsList </span><span class="cov8" title="1">{
                /*
                        resourceListInNs := ListResourceId(ns, resourceType)
                        for i, _ := range resourceListInNs {
                                resourceListInNs[i] = ns + "/" + resourceListInNs[i]
                        }
                        TbResourceList = append(TbResourceList, resourceListInNs...)
                */

                resourceListInNs, err := ListResource(ns, resourceType)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        err := fmt.Errorf("an error occurred while getting resource list")
                        return nil, err
                }</span>
                <span class="cov8" title="1">if resourceListInNs == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">switch resourceType </span>{
                case common.StrVNet:<span class="cov8" title="1">
                        resourcesInNs := resourceListInNs.([]TbVNetInfo) // type assertion
                        for _, resource := range resourcesInNs </span><span class="cov8" title="1">{
                                if resource.ConnectionName == connConfig </span><span class="cov8" title="1">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = resource.Id
                                        temp.CspNativeId = resource.CspVNetId
                                        temp.NsId = ns
                                        //temp.McisId = ""
                                        temp.Type = resourceType
                                        temp.ObjectKey = common.GenResourceKey(ns, resourceType, resource.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                case common.StrSecurityGroup:<span class="cov8" title="1">
                        resourcesInNs := resourceListInNs.([]TbSecurityGroupInfo) // type assertion
                        for _, resource := range resourcesInNs </span><span class="cov8" title="1">{
                                if resource.ConnectionName == connConfig </span><span class="cov8" title="1">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = resource.Id
                                        temp.CspNativeId = resource.CspSecurityGroupId
                                        temp.NsId = ns
                                        //temp.McisId = ""
                                        temp.Type = resourceType
                                        temp.ObjectKey = common.GenResourceKey(ns, resourceType, resource.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                case common.StrSSHKey:<span class="cov8" title="1">
                        resourcesInNs := resourceListInNs.([]TbSshKeyInfo) // type assertion
                        for _, resource := range resourcesInNs </span><span class="cov8" title="1">{
                                if resource.ConnectionName == connConfig </span><span class="cov8" title="1">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = resource.Id
                                        temp.CspNativeId = resource.CspSshKeyName
                                        temp.NsId = ns
                                        //temp.McisId = ""
                                        temp.Type = resourceType
                                        temp.ObjectKey = common.GenResourceKey(ns, resourceType, resource.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">client := resty.New().SetCloseConnection(true)
        client.SetAllowGetMethodPayload(true)

        // Create Req body
        type JsonTemplate struct {
                ConnectionName string
        }
        tempReq := JsonTemplate{}
        tempReq.ConnectionName = connConfig

        var spiderRequestURL string
        switch resourceType </span>{
        case common.StrVNet:<span class="cov8" title="1">
                spiderRequestURL = common.SPIDER_REST_URL + "/allvpc"</span>
        case common.StrSecurityGroup:<span class="cov8" title="1">
                spiderRequestURL = common.SPIDER_REST_URL + "/allsecuritygroup"</span>
        case common.StrSSHKey:<span class="cov8" title="1">
                spiderRequestURL = common.SPIDER_REST_URL + "/allkeypair"</span>
        }

        <span class="cov8" title="1">resp, err := client.R().
                SetHeader("Content-Type", "application/json").
                SetBody(tempReq).
                SetResult(&amp;SpiderAllListWrapper{}). // or SetResult(AuthSuccess{}).
                //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                Get(spiderRequestURL)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                return nil, err
        }</span>

        <span class="cov8" title="1">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
        switch </span>{
        case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                err := fmt.Errorf(string(resp.Body()))
                common.CBLog.Error(err)
                return nil, err</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">temp, _ := resp.Result().(*SpiderAllListWrapper) // type assertion

        result := TbInspectResourcesResponse{}

        /*
                // Implementation style 1
                if len(TbResourceList) &gt; 0 {
                        result.ResourcesOnTumblebug = TbResourceList
                } else {
                        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
                }
        */
        // Implementation style 2
        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
        result.ResourcesOnTumblebug = append(result.ResourcesOnTumblebug, TbResourceList...)

        // result.ResourcesOnCsp = append((*temp).AllList.MappedList, (*temp).AllList.OnlyCSPList...)
        // result.ResourcesOnSpider = append((*temp).AllList.MappedList, (*temp).AllList.OnlySpiderList...)
        result.ResourcesOnCsp = []resourceOnCspOrSpider{}
        result.ResourcesOnSpider = []resourceOnCspOrSpider{}

        for _, v := range (*temp).AllList.MappedList </span><span class="cov8" title="1">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov8" title="1">for _, v := range (*temp).AllList.OnlySpiderList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov8" title="1">for _, v := range (*temp).AllList.OnlyCSPList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// ListResourceId returns the list of TB MCIR object IDs of given resourceType
func ListResourceId(nsId string, resourceType string) ([]string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" ||
                resourceType == common.StrSecurityGroup </span>{<span class="cov8" title="1">
                // continue
        }</span> else<span class="cov0" title="0"> {
                err = fmt.Errorf("invalid resource type")
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[ListResourceId] ns: " + nsId + ", type: " + resourceType)
        key := "/ns/" + nsId + "/resources/"
        fmt.Println(key)

        keyValue, _ := common.CBStore.GetList(key, true)

        var resourceList []string
        for _, v := range keyValue </span><span class="cov8" title="1">{
                trimmedString := strings.TrimPrefix(v.Key, (key + resourceType + "/"))
                // prevent malformed key (if key for resource id includes '/', the key does not represent resource ID)
                if !strings.Contains(trimmedString, "/") </span><span class="cov8" title="1">{
                        resourceList = append(resourceList, trimmedString)
                }</span>
        }
        // for _, v := range resourceList {
        //         fmt.Println("&lt;" + v + "&gt; \n")
        // }
        // fmt.Println("===============================================")
        <span class="cov8" title="1">return resourceList, nil</span>

}

// ListResource returns the list of TB MCIR objects of given resourceType
func ListResource(nsId string, resourceType string) (interface{}, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" ||
                resourceType == common.StrSecurityGroup </span>{<span class="cov8" title="1">
                // continue
        }</span> else<span class="cov0" title="0"> {
                errString := "Cannot list " + resourceType + "s."
                err := fmt.Errorf(errString)
                return nil, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Get " + resourceType + " list")
        key := "/ns/" + nsId + "/resources/" + resourceType
        fmt.Println(key)

        keyValue, err := common.CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                /*
                        fmt.Println("func ListResource; common.CBStore.GetList gave error")
                        var resourceList []string
                        for _, v := range keyValue {
                                resourceList = append(resourceList, strings.TrimPrefix(v.Key, "/ns/"+nsId+"/resources/"+resourceType+"/"))
                        }
                        for _, v := range resourceList {
                                fmt.Println("&lt;" + v + "&gt; \n")
                        }
                        fmt.Println("===============================================")
                */
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                switch resourceType </span>{
                case common.StrImage:<span class="cov8" title="1">
                        res := []TbImageInfo{}
                        for _, v := range keyValue </span><span class="cov8" title="1">{
                                tempObj := TbImageInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">res = append(res, tempObj)</span>
                        }
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrSecurityGroup:<span class="cov8" title="1">
                        res := []TbSecurityGroupInfo{}
                        for _, v := range keyValue </span><span class="cov8" title="1">{
                                tempObj := TbSecurityGroupInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">res = append(res, tempObj)</span>
                        }
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrSpec:<span class="cov8" title="1">
                        res := []TbSpecInfo{}
                        for _, v := range keyValue </span><span class="cov8" title="1">{
                                tempObj := TbSpecInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">res = append(res, tempObj)</span>
                        }
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrSSHKey:<span class="cov8" title="1">
                        res := []TbSshKeyInfo{}
                        for _, v := range keyValue </span><span class="cov8" title="1">{
                                tempObj := TbSshKeyInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">res = append(res, tempObj)</span>
                        }
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrVNet:<span class="cov8" title="1">
                        res := []TbVNetInfo{}
                        for _, v := range keyValue </span><span class="cov8" title="1">{
                                tempObj := TbVNetInfo{}
                                err = json.Unmarshal([]byte(v.Value), &amp;tempObj)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">res = append(res, tempObj)</span>
                        }
                        <span class="cov8" title="1">return res, nil</span>
                }

                //return true, nil
        }

        <span class="cov8" title="1">return nil, nil</span> // When err == nil &amp;&amp; keyValue == nil
}

// GetAssociatedObjectCount returns the number of MCIR's associated Tumblebug objects
func GetAssociatedObjectCount(nsId string, resourceType string, resourceId string) (int, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov0" title="0">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return -1, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>
        <span class="cov8" title="1">fmt.Println("[Get count] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return -1, err
        }</span>
        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                inUseCount := int(gjson.Get(keyValue.Value, "associatedObjectList.#").Int())
                return inUseCount, nil
        }</span>
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return -1, err</span>
}

// GetAssociatedObjectList returns the list of MCIR's associated Tumblebug objects
func GetAssociatedObjectList(nsId string, resourceType string, resourceId string) ([]string, error) <span class="cov8" title="1">{

        var result []string

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov0" title="0">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return nil, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">fmt.Println("[Get count] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                /*
                        objList := gjson.Get(keyValue.Value, "associatedObjectList")
                        objList.ForEach(func(key, value gjson.Result) bool {
                                result = append(result, value.String())
                                return true
                        })
                */

                /*
                        switch resourceType {
                        case common.StrImage:
                                res := TbImageInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)
                                //result = res.
                        case common.StrSecurityGroup:
                                res := TbSecurityGroupInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)

                        case common.StrSpec:
                                res := TbSpecInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)

                        case common.StrSSHKey:
                                res := TbSshKeyInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)
                                result = res.AssociatedObjectList
                        case common.StrVNet:
                                res := TbVNetInfo{}
                                json.Unmarshal([]byte(keyValue.Value), &amp;res)

                        }
                */

                type stringList struct {
                        AssociatedObjectList []string `json:"associatedObjectList"`
                }
                res := stringList{}
                err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = res.AssociatedObjectList

                return result, nil</span>
        }
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return nil, err</span>
}

// UpdateAssociatedObjectList adds or deletes the objectKey (currently, vmKey) to/from TB object's associatedObjectList
func UpdateAssociatedObjectList(nsId string, resourceType string, resourceId string, cmd string, objectKey string) ([]string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        /*
                check, err := CheckResource(nsId, resourceType, resourceId)

                if !check {
                        errString := "The " + resourceType + " " + resourceId + " does not exist."
                        //mapA := map[string]string{"message": errString}
                        //mapB, _ := json.Marshal(mapA)
                        err := fmt.Errorf(errString)
                        return -1, err
                }

                if err != nil {
                        common.CBLog.Error(err)
                        return -1, err
                }
        */
        <span class="cov8" title="1">fmt.Println("[Set count] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                objList, _ := GetAssociatedObjectList(nsId, resourceType, resourceId)
                switch cmd </span>{
                case common.StrAdd:<span class="cov8" title="1">
                        for _, v := range objList </span><span class="cov8" title="1">{
                                if v == objectKey </span><span class="cov0" title="0">{
                                        errString := objectKey + " is already associated with " + resourceType + " " + resourceId + "."
                                        err = fmt.Errorf(errString)
                                        return nil, err
                                }</span>
                        }
                        // fmt.Println("len(objList): " + strconv.Itoa(len(objList))) // for debug
                        // fmt.Print("objList: ")                                     // for debug
                        // fmt.Println(objList)                                       // for debug

                        <span class="cov8" title="1">var anyJson map[string]interface{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;anyJson)
                        if anyJson["associatedObjectList"] == nil </span><span class="cov0" title="0">{
                                array_to_be := []string{objectKey}
                                // fmt.Println("array_to_be: ", array_to_be) // for debug

                                anyJson["associatedObjectList"] = array_to_be
                        }</span> else<span class="cov8" title="1"> { // anyJson["associatedObjectList"] != nil
                                array_as_is := anyJson["associatedObjectList"].([]interface{})
                                // fmt.Println("array_as_is: ", array_as_is) // for debug

                                array_to_be := append(array_as_is, objectKey)
                                // fmt.Println("array_to_be: ", array_to_be) // for debug

                                anyJson["associatedObjectList"] = array_to_be
                        }</span>
                        <span class="cov8" title="1">updatedJson, _ := json.Marshal(anyJson)
                        // fmt.Println(string(updatedJson)) // for debug

                        keyValue.Value = string(updatedJson)</span>
                case common.StrDelete:<span class="cov8" title="1">
                        var foundKey int
                        var foundVal string
                        for k, v := range objList </span><span class="cov8" title="1">{
                                if v == objectKey </span><span class="cov8" title="1">{
                                        foundKey = k
                                        foundVal = v
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if foundVal == "" </span><span class="cov8" title="1">{
                                errString := "Cannot find the associated object " + objectKey + "."
                                err = fmt.Errorf(errString)
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                keyValue.Value, err = sjson.Delete(keyValue.Value, "associatedObjectList."+strconv.Itoa(foundKey))
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return nil, err
                                }</span>
                        }
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = common.CBStore.Put(key, keyValue.Value)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>
                /*
                        keyValue, _ := common.CBStore.Get(key)
                        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                        fmt.Println("===========================")
                        to_be = int8(gjson.Get(keyValue.Value, "inUseCount").Uint())
                        return to_be, nil
                */

                <span class="cov8" title="1">result, _ := GetAssociatedObjectList(nsId, resourceType, resourceId)
                return result, nil</span>
        }
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return nil, err</span>
}

// GetResource returns the requested TB MCIR object
func GetResource(nsId string, resourceType string, resourceId string) (interface{}, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, resourceId)

        if !check </span><span class="cov8" title="1">{
                errString := "The " + resourceType + " " + resourceId + " does not exist."
                //mapA := map[string]string{"message": errString}
                //mapB, _ := json.Marshal(mapA)
                err := fmt.Errorf(errString)
                return nil, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">fmt.Println("[Get resource] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValue != nil </span><span class="cov8" title="1">{
                switch resourceType </span>{
                case common.StrImage:<span class="cov8" title="1">
                        res := TbImageInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrSecurityGroup:<span class="cov8" title="1">
                        res := TbSecurityGroupInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrSpec:<span class="cov8" title="1">
                        res := TbSpecInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrSSHKey:<span class="cov8" title="1">
                        res := TbSshKeyInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return res, nil</span>
                case common.StrVNet:<span class="cov8" title="1">
                        res := TbVNetInfo{}
                        err = json.Unmarshal([]byte(keyValue.Value), &amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return res, nil</span>
                }

                //return true, nil
        }
        <span class="cov0" title="0">errString := "Cannot get " + resourceType + " " + resourceId + "."
        err = fmt.Errorf(errString)
        return nil, err</span>
}

// CheckResource returns the existence of the TB MCIR resource in bool form.
func CheckResource(nsId string, resourceType string, resourceId string) (bool, error) <span class="cov8" title="1">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckResource failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov8" title="1"> if resourceType == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckResource failed; resourceType given is null.")
                return false, err
        }</span> else<span class="cov8" title="1"> if resourceId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckResource failed; resourceId given is null.")
                return false, err
        }</span>

        // Check resourceType's validity
        <span class="cov8" title="1">if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                resourceType == common.StrSecurityGroup </span>{<span class="cov8" title="1">
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" {
                // continue
        }</span> else<span class="cov0" title="0"> {
                err := fmt.Errorf("invalid resource type")
                return false, err
        }</span>

        <span class="cov8" title="1">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(resourceId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Check resource] " + resourceType + ", " + resourceId)

        key := common.GenResourceKey(nsId, resourceType, resourceId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        if keyValue != nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>

}

/*
func convertSpiderResourceToTumblebugResource(resourceType string, i interface{}) (interface{}, error) {
        if resourceType == "" {
                err := fmt.Errorf("CheckResource failed; resourceType given is null.")
                return nil, err
        }

        // Check resourceType's validity
        if resourceType == common.StrImage ||
                resourceType == common.StrSSHKey ||
                resourceType == common.StrSpec ||
                resourceType == common.StrVNet ||
                resourceType == common.StrSecurityGroup {
                //resourceType == "subnet" ||
                //resourceType == "publicIp" ||
                //resourceType == "vNic" {
                // continue
        } else {
                err := fmt.Errorf("invalid resource type")
                return nil, err
        }

}
*/

// https://stackoverflow.com/questions/45139954/dynamic-struct-as-parameter-golang

type ReturnValue struct {
        CustomStruct interface{}
}

type NameOnly struct {
        Name string
}

// GetNameFromStruct accepts any struct for argument, and returns
func GetNameFromStruct(u interface{}) string <span class="cov0" title="0">{
        var result = ReturnValue{CustomStruct: u}

        //fmt.Println(result)

        msg, ok := result.CustomStruct.(NameOnly)
        if ok </span><span class="cov0" title="0">{
                //fmt.Printf("Message1 is %s\n", msg.Name)
                return msg.Name
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}

//func createResource(nsId string, resourceType string, u interface{}) (interface{}, int, []byte, error) {
</pre>
		
		<pre class="file" id="file84" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "net/url"
        "os"
        "strconv"
        "strings"

        "github.com/go-resty/resty/v2"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// 2020-04-03 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/ImageHandler.go

type SpiderImageReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderImageInfo
}

/*
type SpiderImageReqInfo struct { // Spider
        //IId   IID         // {NameId, SystemId}
        Name string
        // @todo
}
*/

type SpiderImageInfo struct { // Spider
        // Fields for request
        Name string

        // Fields for response
        IId          common.IID // {NameId, SystemId}
        GuestOS      string     // Windows7, Ubuntu etc.
        Status       string     // available, unavailable
        KeyValueList []common.KeyValue
}

type TbImageReq struct {
        Name           string `json:"name"`
        ConnectionName string `json:"connectionName"`
        CspImageId     string `json:"cspImageId"`
        Description    string `json:"description"`
}

type TbImageInfo struct {
        Namespace            string            `json:"namespace"` // required to save in RDB
        Id                   string            `json:"id"`
        Name                 string            `json:"name"`
        ConnectionName       string            `json:"connectionName"`
        CspImageId           string            `json:"cspImageId"`
        CspImageName         string            `json:"cspImageName"`
        Description          string            `json:"description,omitempty"`
        CreationDate         string            `json:"creationDate,omitempty"`
        GuestOS              string            `json:"guestOS,omitempty"` // Windows7, Ubuntu etc.
        Status               string            `json:"status,omitempty"`  // available, unavailable
        KeyValueList         []common.KeyValue `json:"keyValueList,omitempty"`
        AssociatedObjectList []string          `json:"associatedObjectList"`
        IsAutoGenerated      bool              `json:"isAutoGenerated"`
}

// ConvertSpiderImageToTumblebugImage accepts an Spider image object, converts to and returns an TB image object
func ConvertSpiderImageToTumblebugImage(spiderImage SpiderImageInfo) (TbImageInfo, error) <span class="cov8" title="1">{
        if spiderImage.IId.NameId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("ConvertSpiderImageToTumblebugImage failed; spiderImage.IId.NameId == \"\" ")
                emptyTumblebugImage := TbImageInfo{}
                return emptyTumblebugImage, err
        }</span>

        <span class="cov8" title="1">tumblebugImage := TbImageInfo{}
        //tumblebugImage.Id = spiderImage.IId.NameId

        spiderKeyValueListName := common.LookupKeyValueList(spiderImage.KeyValueList, "Name")
        if len(spiderKeyValueListName) &gt; 0 </span><span class="cov0" title="0">{
                tumblebugImage.Name = spiderKeyValueListName
        }</span> else<span class="cov8" title="1"> {
                tumblebugImage.Name = spiderImage.IId.NameId
        }</span>

        <span class="cov8" title="1">tumblebugImage.CspImageId = spiderImage.IId.NameId
        tumblebugImage.CspImageName = common.LookupKeyValueList(spiderImage.KeyValueList, "Name")
        tumblebugImage.Description = common.LookupKeyValueList(spiderImage.KeyValueList, "Description")
        tumblebugImage.CreationDate = common.LookupKeyValueList(spiderImage.KeyValueList, "CreationDate")
        tumblebugImage.GuestOS = spiderImage.GuestOS
        tumblebugImage.Status = spiderImage.Status
        tumblebugImage.KeyValueList = spiderImage.KeyValueList

        return tumblebugImage, nil</span>
}

// RegisterImageWithId accepts image creation request, creates and returns an TB image object
func RegisterImageWithId(nsId string, u *TbImageReq) (TbImageInfo, error) <span class="cov8" title="1">{

        resourceType := common.StrImage

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov8" title="1">{
                temp := TbImageInfo{}
                err := fmt.Errorf("The image " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                err := fmt.Errorf("Failed to check the existence of the image " + u.Name + ".")
                return temp, err
        }</span>

        <span class="cov8" title="1">res, err := LookupImage(u.ConnectionName, u.CspImageId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //err := fmt.Errorf("an error occurred while lookup image via CB-Spider")
                emptyImageInfoObj := TbImageInfo{}
                return emptyImageInfoObj, err
        }</span>

        <span class="cov8" title="1">content, err := ConvertSpiderImageToTumblebugImage(res)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                //err := fmt.Errorf("an error occurred while converting Spider image info to Tumblebug image info.")
                emptyImageInfoObj := TbImageInfo{}
                return emptyImageInfoObj, err
        }</span>
        <span class="cov8" title="1">content.Namespace = nsId
        content.ConnectionName = u.ConnectionName
        content.Id = u.Name
        content.Name = u.Name
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT registerImage")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // "INSERT INTO `image`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        _, err = common.ORM.Insert(&amp;content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov8" title="1">return content, nil</span>
}

// RegisterImageWithInfo accepts image creation request, creates and returns an TB image object
func RegisterImageWithInfo(nsId string, content *TbImageInfo) (TbImageInfo, error) <span class="cov8" title="1">{

        resourceType := common.StrImage

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(content.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, content.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                err := fmt.Errorf("The image " + content.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := TbImageInfo{}
                err := fmt.Errorf("Failed to check the existence of the image " + content.Name + ".")
                return temp, err
        }</span>

        <span class="cov8" title="1">content.Namespace = nsId
        //content.Id = common.GenUuid()
        content.Id = content.Name
        content.AssociatedObjectList = []string{}

        fmt.Println("=========================== PUT registerImage")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return *content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // "INSERT INTO `image`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        _, err = common.ORM.Insert(content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov8" title="1">return *content, nil</span>
}

type SpiderImageList struct {
        Image []SpiderImageInfo `json:"image"`
}

// LookupImageList accepts Spider conn config,
// lookups and returns the list of all images in the region of conn config
// in the form of the list of Spider image objects
func LookupImageList(connConfig string) (SpiderImageList, error) <span class="cov8" title="1">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderImageList{}
                err := fmt.Errorf("LookupImage() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov8" title="1">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/vmimage"

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderImageList{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderImageList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderImageList{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp := resp.Result().(*SpiderImageList)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderImageList{}, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderImageList{}, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                result, err := ccm.ListImageByParam(connConfig)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderImageList{}, err
                }</span>

                <span class="cov8" title="1">temp := SpiderImageList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderImageList{}, err
                }</span>
                <span class="cov8" title="1">return temp, nil</span>

        }
}

// LookupImage accepts Spider conn config and CSP image ID, lookups and returns the Spider image object
func LookupImage(connConfig string, imageId string) (SpiderImageInfo, error) <span class="cov8" title="1">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderImageInfo{}
                err := fmt.Errorf("LookupImage() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span> else<span class="cov8" title="1"> if imageId == "" </span><span class="cov0" title="0">{
                content := SpiderImageInfo{}
                err := fmt.Errorf("LookupImage() called with empty imageId.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov8" title="1">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/vmimage/" + url.QueryEscape(imageId)

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderImageInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderImageInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderImageInfo{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp := resp.Result().(*SpiderImageInfo)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderImageInfo{}, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderImageInfo{}, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                result, err := ccm.GetImageByParam(connConfig, imageId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderImageInfo{}, err
                }</span>

                <span class="cov8" title="1">temp := SpiderImageInfo{}
                err2 := json.Unmarshal([]byte(result), &amp;temp)
                if err2 != nil </span><span class="cov0" title="0">{
                        //fmt.Errorf("an error occurred while unmarshaling: " + err2.Error())
                        common.CBLog.Error(err2)
                }</span>
                <span class="cov8" title="1">return temp, nil</span>

        }
}

func RefineImageName(imageName string) string <span class="cov8" title="1">{
        out := strings.ToLower(imageName)
        out = strings.ReplaceAll(out, ".", "-")
        out = strings.ReplaceAll(out, "_", "-")
        out = strings.ReplaceAll(out, ":", "-")
        out = strings.ReplaceAll(out, "/", "-")

        return out
}</span>

// FetchImagesForAllConnConfigs gets all conn configs from Spider, lookups all images for each region of conn config, and saves into TB image objects
func FetchImagesForConnConfig(connConfig string, nsId string) (imageCount uint, err error) <span class="cov8" title="1">{
        fmt.Println("FetchImagesForConnConfig(" + connConfig + ")")

        spiderImageList, err := LookupImageList(connConfig)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>

        <span class="cov8" title="1">for _, spiderImage := range spiderImageList.Image </span><span class="cov8" title="1">{
                tumblebugImage, err := ConvertSpiderImageToTumblebugImage(spiderImage)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return 0, err
                }</span>

                <span class="cov8" title="1">tumblebugImageId := connConfig + "-" + RefineImageName(tumblebugImage.Name)
                //fmt.Println("tumblebugImageId: " + tumblebugImageId) // for debug

                check, err := CheckResource(nsId, common.StrImage, tumblebugImageId)
                if check </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("The image " + tumblebugImageId + " already exists in TB; continue")
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("Cannot check the existence of " + tumblebugImageId + " in TB; continue")
                        continue</span>
                } else<span class="cov8" title="1"> {
                        tumblebugImage.Name = tumblebugImageId
                        tumblebugImage.ConnectionName = connConfig

                        _, err := RegisterImageWithInfo(nsId, &amp;tumblebugImage)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">imageCount++</span>
                }
        }
        <span class="cov8" title="1">return imageCount, nil</span>
}

// FetchImagesForAllConnConfigs gets all conn configs from Spider, lookups all images for each region of conn config, and saves into TB image objects
func FetchImagesForAllConnConfigs(nsId string) (connConfigCount uint, imageCount uint, err error) <span class="cov8" title="1">{

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov8" title="1">connConfigs, err := common.GetConnConfigList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov8" title="1">for _, connConfig := range connConfigs.Connectionconfig </span><span class="cov8" title="1">{
                temp, _ := FetchImagesForConnConfig(connConfig.ConfigName, nsId)
                imageCount += temp
                connConfigCount++
        }</span>
        <span class="cov8" title="1">return connConfigCount, imageCount, nil</span>
}

// SearchImage accepts arbitrary number of keywords, and returns the list of matched TB image objects
func SearchImage(nsId string, keywords ...string) ([]TbImageInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">tempList := []TbImageInfo{}

        //sqlQuery := "SELECT * FROM `image` WHERE `namespace`='" + nsId + "'"
        sqlQuery := common.ORM.Where("Namespace = ?", nsId)

        for _, keyword := range keywords </span><span class="cov8" title="1">{
                keyword = RefineImageName(keyword)
                //sqlQuery += " AND `name` LIKE '%" + keyword + "%'"
                sqlQuery = sqlQuery.And("Name LIKE ?", "%"+keyword+"%")
        }</span>

        <span class="cov8" title="1">err = sqlQuery.Find(&amp;tempList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempList, err
        }</span>
        <span class="cov8" title="1">return tempList, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"
)

// 2020-04-13 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/SecurityHandler.go

type SpiderSecurityReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderSecurityInfo
}

/*
type SpiderSecurityReqInfo struct { // Spider
        Name          string
        VPCName       string
        SecurityRules *[]SpiderSecurityRuleInfo
        //Direction     string // @todo used??
}
*/

type SpiderSecurityRuleInfo struct { // Spider
        FromPort   string //`json:"fromPort"`
        ToPort     string //`json:"toPort"`
        IPProtocol string //`json:"ipProtocol"`
        Direction  string //`json:"direction"`
        CIDR       string
}

type SpiderSecurityInfo struct { // Spider
        // Fields for request
        Name    string
        VPCName string

        // Fields for both request and response
        SecurityRules *[]SpiderSecurityRuleInfo

        // Fields for response
        IId          common.IID // {NameId, SystemId}
        VpcIID       common.IID // {NameId, SystemId}
        Direction    string     // @todo userd??
        KeyValueList []common.KeyValue
}

type TbSecurityGroupReq struct { // Tumblebug
        Name           string                    `json:"name"`
        ConnectionName string                    `json:"connectionName"`
        VNetId         string                    `json:"vNetId"`
        Description    string                    `json:"description"`
        FirewallRules  *[]SpiderSecurityRuleInfo `json:"firewallRules"`
}

type TbSecurityGroupInfo struct { // Tumblebug
        Id                   string                    `json:"id"`
        Name                 string                    `json:"name"`
        ConnectionName       string                    `json:"connectionName"`
        VNetId               string                    `json:"vNetId"`
        Description          string                    `json:"description"`
        FirewallRules        *[]SpiderSecurityRuleInfo `json:"firewallRules"`
        CspSecurityGroupId   string                    `json:"cspSecurityGroupId"`
        CspSecurityGroupName string                    `json:"cspSecurityGroupName"`
        KeyValueList         []common.KeyValue         `json:"keyValueList"`
        AssociatedObjectList []string                  `json:"associatedObjectList"`
        IsAutoGenerated      bool                      `json:"isAutoGenerated"`

        // Disabled for now
        //ResourceGroupName  string `json:"resourceGroupName"`
}

// CreateSecurityGroup accepts SG creation request, creates and returns an TB SG object
func CreateSecurityGroup(nsId string, u *TbSecurityGroupReq) (TbSecurityGroupInfo, error) <span class="cov8" title="1">{

        resourceType := common.StrSecurityGroup

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSecurityGroupInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSecurityGroupInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov8" title="1">{
                temp := TbSecurityGroupInfo{}
                err := fmt.Errorf("The securityGroup " + u.Name + " already exists.")
                //return temp, http.StatusConflict, nil, err
                return temp, err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                content := TbSecurityGroupInfo{}
                err := fmt.Errorf("Cannot create securityGroup")
                return content, err
        }</span>

        <span class="cov8" title="1">tempReq := SpiderSecurityReqInfoWrapper{}
        tempReq.ConnectionName = u.ConnectionName
        tempReq.ReqInfo.Name = u.Name
        tempReq.ReqInfo.VPCName = u.VNetId
        tempReq.ReqInfo.SecurityRules = u.FirewallRules

        var tempSpiderSecurityInfo *SpiderSecurityInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/securitygroup"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderSecurityInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Post(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := TbSecurityGroupInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := TbSecurityGroupInfo{}
                        return content, err</span>
                }

                <span class="cov8" title="1">tempSpiderSecurityInfo = resp.Result().(*SpiderSecurityInfo)</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return TbSecurityGroupInfo{}, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return TbSecurityGroupInfo{}, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                payload, _ := json.Marshal(tempReq)
                fmt.Println("payload: " + string(payload)) // for debug

                result, err := ccm.CreateSecurity(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSecurityGroupInfo{}, err
                }</span>

                <span class="cov8" title="1">tempSpiderSecurityInfo = &amp;SpiderSecurityInfo{}
                err = json.Unmarshal([]byte(result), &amp;tempSpiderSecurityInfo)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSecurityGroupInfo{}, err
                }</span>
        }

        <span class="cov8" title="1">content := TbSecurityGroupInfo{}
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.ConnectionName = u.ConnectionName
        content.VNetId = tempSpiderSecurityInfo.VpcIID.NameId
        content.CspSecurityGroupId = tempSpiderSecurityInfo.IId.SystemId
        content.CspSecurityGroupName = tempSpiderSecurityInfo.IId.NameId
        content.Description = u.Description
        content.FirewallRules = tempSpiderSecurityInfo.SecurityRules
        content.KeyValueList = tempSpiderSecurityInfo.KeyValueList
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT CreateSecurityGroup")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")
        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strconv"
        "strings"

        //"strings"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"

        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcis"

        _ "github.com/go-sql-driver/mysql"
)

type SpiderSpecInfo struct { // Spider
        // https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/VMSpecHandler.go

        Region string
        Name   string
        VCpu   SpiderVCpuInfo
        Mem    string
        Gpu    []SpiderGpuInfo

        KeyValueList []common.KeyValue
}

type SpiderVCpuInfo struct { // Spider
        Count string
        Clock string // GHz
}

type SpiderGpuInfo struct { // Spider
        Count string
        Mfr   string
        Model string
        Mem   string
}

type TbSpecReq struct { // Tumblebug
        Name           string `json:"name"`
        ConnectionName string `json:"connectionName"`
        CspSpecName    string `json:"cspSpecName"`
        Description    string `json:"description"`
}

type TbSpecInfo struct { // Tumblebug
        Namespace             string   `json:"namespace"` // required to save in RDB
        Id                    string   `json:"id"`
        Name                  string   `json:"name"`
        ConnectionName        string   `json:"connectionName"`
        CspSpecName           string   `json:"cspSpecName"`
        Os_type               string   `json:"os_type"`
        Num_vCPU              uint16   `json:"num_vCPU"`
        Num_core              uint16   `json:"num_core"`
        Mem_GiB               uint16   `json:"mem_GiB"`
        Storage_GiB           uint32   `json:"storage_GiB"`
        Description           string   `json:"description"`
        Cost_per_hour         float32  `json:"cost_per_hour"`
        Num_storage           uint8    `json:"num_storage"`
        Max_num_storage       uint8    `json:"max_num_storage"`
        Max_total_storage_TiB uint16   `json:"max_total_storage_TiB"`
        Net_bw_Gbps           uint16   `json:"net_bw_Gbps"`
        Ebs_bw_Mbps           uint32   `json:"ebs_bw_Mbps"`
        Gpu_model             string   `json:"gpu_model"`
        Num_gpu               uint8    `json:"num_gpu"`
        Gpumem_GiB            uint16   `json:"gpumem_GiB"`
        Gpu_p2p               string   `json:"gpu_p2p"`
        OrderInFilteredResult uint16   `json:"orderInFilteredResult"`
        EvaluationStatus      string   `json:"evaluationStatus"`
        EvaluationScore_01    float32  `json:"evaluationScore_01"`
        EvaluationScore_02    float32  `json:"evaluationScore_02"`
        EvaluationScore_03    float32  `json:"evaluationScore_03"`
        EvaluationScore_04    float32  `json:"evaluationScore_04"`
        EvaluationScore_05    float32  `json:"evaluationScore_05"`
        EvaluationScore_06    float32  `json:"evaluationScore_06"`
        EvaluationScore_07    float32  `json:"evaluationScore_07"`
        EvaluationScore_08    float32  `json:"evaluationScore_08"`
        EvaluationScore_09    float32  `json:"evaluationScore_09"`
        EvaluationScore_10    float32  `json:"evaluationScore_10"`
        AssociatedObjectList  []string `json:"associatedObjectList"`
        IsAutoGenerated       bool     `json:"isAutoGenerated"`
}

// ConvertSpiderSpecToTumblebugSpec accepts an Spider spec object, converts to and returns an TB spec object
func ConvertSpiderSpecToTumblebugSpec(spiderSpec SpiderSpecInfo) (TbSpecInfo, error) <span class="cov8" title="1">{
        if spiderSpec.Name == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("ConvertSpiderSpecToTumblebugSpec failed; spiderSpec.Name == \"\" ")
                emptyTumblebugSpec := TbSpecInfo{}
                return emptyTumblebugSpec, err
        }</span>

        <span class="cov8" title="1">tumblebugSpec := TbSpecInfo{}

        tumblebugSpec.Name = spiderSpec.Name
        tumblebugSpec.CspSpecName = spiderSpec.Name
        tempUint64, _ := strconv.ParseUint(spiderSpec.VCpu.Count, 10, 16)
        tumblebugSpec.Num_vCPU = uint16(tempUint64)
        tempFloat64, _ := strconv.ParseFloat(spiderSpec.Mem, 32)
        tumblebugSpec.Mem_GiB = uint16(tempFloat64 / 1024) //fmt.Sprintf("%.0f", tempFloat64/1024)

        return tumblebugSpec, nil</span>
}

type SpiderSpecList struct {
        Vmspec []SpiderSpecInfo `json:"vmspec"`
}

// LookupSpecList accepts Spider conn config,
// lookups and returns the list of all specs in the region of conn config
// in the form of the list of Spider spec objects
func LookupSpecList(connConfig string) (SpiderSpecList, error) <span class="cov8" title="1">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderSpecList{}
                err := fmt.Errorf("LookupSpec() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov8" title="1">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/vmspec"

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderSpecList{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderSpecList{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderSpecList{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp := resp.Result().(*SpiderSpecList)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderSpecList{}, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderSpecList{}, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                result, err := ccm.ListVMSpecByParam(connConfig)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderSpecList{}, err
                }</span>

                <span class="cov8" title="1">temp := SpiderSpecList{}
                err = json.Unmarshal([]byte(result), &amp;temp)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderSpecList{}, err
                }</span>
                <span class="cov8" title="1">return temp, nil</span>

        }
}

// LookupSpec accepts Spider conn config and CSP spec name, lookups and returns the Spider spec object
func LookupSpec(connConfig string, specName string) (SpiderSpecInfo, error) <span class="cov8" title="1">{

        if connConfig == "" </span><span class="cov0" title="0">{
                content := SpiderSpecInfo{}
                err := fmt.Errorf("LookupSpec() called with empty connConfig.")
                common.CBLog.Error(err)
                return content, err
        }</span> else<span class="cov8" title="1"> if specName == "" </span><span class="cov0" title="0">{
                content := SpiderSpecInfo{}
                err := fmt.Errorf("LookupSpec() called with empty specName.")
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov8" title="1">if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                //url := common.SPIDER_REST_URL + "/vmspec/" + u.CspSpecName
                url := common.SPIDER_REST_URL + "/vmspec/" + specName

                // Create Req body
                tempReq := common.SpiderConnectionName{}
                tempReq.ConnectionName = connConfig

                client := resty.New().SetCloseConnection(true)
                client.SetAllowGetMethodPayload(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderSpecInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Get(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := SpiderSpecInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println(string(resp.Body()))

                fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := SpiderSpecInfo{}
                        return content, err</span>
                }

                <span class="cov8" title="1">temp := resp.Result().(*SpiderSpecInfo)
                return *temp, nil</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return SpiderSpecInfo{}, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return SpiderSpecInfo{}, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                result, err := ccm.GetVMSpecByParam(connConfig, specName)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return SpiderSpecInfo{}, err
                }</span>

                <span class="cov8" title="1">temp := SpiderSpecInfo{}
                err2 := json.Unmarshal([]byte(result), &amp;temp)
                if err2 != nil </span><span class="cov0" title="0">{
                        fmt.Errorf("an error occurred while unmarshaling: " + err2.Error())
                }</span>
                <span class="cov8" title="1">return temp, nil</span>

        }
}

func RefineSpecName(specName string) string <span class="cov8" title="1">{
        out := strings.ToLower(specName)
        out = strings.ReplaceAll(out, ".", "-")
        out = strings.ReplaceAll(out, "_", "-")

        return out
}</span>

// FetchSpecsForConnConfig lookups all specs for region of conn config, and saves into TB spec objects
func FetchSpecsForConnConfig(connConfig string, nsId string) (specCount uint, err error) <span class="cov8" title="1">{
        fmt.Println("FetchSpecsForConnConfig(" + connConfig + ")")

        spiderSpecList, err := LookupSpecList(connConfig)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>

        <span class="cov8" title="1">for _, spiderSpec := range spiderSpecList.Vmspec </span><span class="cov8" title="1">{
                tumblebugSpec, err := ConvertSpiderSpecToTumblebugSpec(spiderSpec)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return 0, err
                }</span>

                <span class="cov8" title="1">tumblebugSpecId := connConfig + "-" + RefineSpecName(tumblebugSpec.Name)
                //fmt.Println("tumblebugSpecId: " + tumblebugSpecId) // for debug

                check, err := CheckResource(nsId, common.StrSpec, tumblebugSpecId)
                if check </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("The spec " + tumblebugSpecId + " already exists in TB; continue")
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Infoln("Cannot check the existence of " + tumblebugSpecId + " in TB; continue")
                        continue</span>
                } else<span class="cov8" title="1"> {
                        tumblebugSpec.Name = tumblebugSpecId
                        tumblebugSpec.ConnectionName = connConfig

                        _, err := RegisterSpecWithInfo(nsId, &amp;tumblebugSpec)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">specCount++</span>
                }
        }
        <span class="cov8" title="1">return specCount, nil</span>
}

// FetchSpecsForAllConnConfigs gets all conn configs from Spider, lookups all specs for each region of conn config, and saves into TB spec objects
func FetchSpecsForAllConnConfigs(nsId string) (connConfigCount uint, specCount uint, err error) <span class="cov8" title="1">{

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov8" title="1">connConfigs, err := common.GetConnConfigList()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, 0, err
        }</span>

        <span class="cov8" title="1">for _, connConfig := range connConfigs.Connectionconfig </span><span class="cov8" title="1">{
                temp, _ := FetchSpecsForConnConfig(connConfig.ConfigName, nsId)
                specCount += temp
                connConfigCount++
        }</span>
        <span class="cov8" title="1">return connConfigCount, specCount, nil</span>
}

// RegisterSpecWithCspSpecName accepts spec creation request, creates and returns an TB spec object
func RegisterSpecWithCspSpecName(nsId string, u *TbSpecReq) (TbSpecInfo, error) <span class="cov8" title="1">{

        resourceType := common.StrSpec

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov8" title="1">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("The spec " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">res, err := LookupSpec(u.ConnectionName, u.CspSpecName)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err := fmt.Errorf("an error occurred while lookup spec via CB-Spider")
                emptySpecInfoObj := TbSpecInfo{}
                return emptySpecInfoObj, err
        }</span>

        <span class="cov8" title="1">content := TbSpecInfo{}
        content.Namespace = nsId
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.CspSpecName = res.Name
        content.ConnectionName = u.ConnectionName
        content.AssociatedObjectList = []string{}

        tempUint64, _ := strconv.ParseUint(res.VCpu.Count, 10, 16)
        content.Num_vCPU = uint16(tempUint64)

        //content.Num_core = res.Num_core

        tempFloat64, _ := strconv.ParseFloat(res.Mem, 32)
        content.Mem_GiB = uint16(tempFloat64 / 1024)

        //content.Storage_GiB = res.Storage_GiB
        //content.Description = res.Description

        // cb-store
        fmt.Println("=========================== PUT registerSpec")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // register information related with MCIS recommendation
        err = RegisterRecommendList(nsId, content.ConnectionName, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB, content.Id, content.Cost_per_hour)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>

        // "INSERT INTO `spec`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        <span class="cov8" title="1">_, err = common.ORM.Insert(&amp;content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov8" title="1">return content, nil</span>
}

// RegisterSpecWithInfo accepts spec creation request, creates and returns an TB spec object
func RegisterSpecWithInfo(nsId string, content *TbSpecInfo) (TbSpecInfo, error) <span class="cov8" title="1">{

        resourceType := common.StrSpec

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(content.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckResource(nsId, resourceType, content.Name)

        if check </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("The spec " + content.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">content.Namespace = nsId
        content.Id = content.Name
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT registerSpec")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return *content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // register information related with MCIS recommendation
        err = RegisterRecommendList(nsId, content.ConnectionName, content.Num_vCPU, content.Mem_GiB, content.Storage_GiB, content.Id, content.Cost_per_hour)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return *content, err
        }</span>

        // "INSERT INTO `spec`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
        <span class="cov8" title="1">_, err = common.ORM.Insert(content)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov8" title="1">return *content, nil</span>
}

// RegisterRecommendList creates the spec recommendation info
func RegisterRecommendList(nsId string, connectionName string, cpuSize uint16, memSize uint16, diskSize uint32, specId string, price float32) error <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        //fmt.Println("[Get MCISs")
        <span class="cov8" title="1">key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + strconv.Itoa(int(cpuSize)) + "/memSize/" + strconv.Itoa(int(memSize)) + "/diskSize/" + strconv.Itoa(int(diskSize)) + "/specId/" + specId
        fmt.Println(key)

        mapA := map[string]string{"id": specId, "price": fmt.Sprintf("%.6f", price), "connectionName": connectionName}
        Val, _ := json.Marshal(mapA)

        err = common.CBStore.Put(string(key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("===============================================")
        return nil</span>

}

// DelRecommendSpec deletes the spec recommendation info
func DelRecommendSpec(nsId string, specId string, cpuSize uint16, memSize uint16, diskSize uint32) error <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("DelRecommendSpec()")

        key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + strconv.Itoa(int(cpuSize)) + "/memSize/" + strconv.Itoa(int(memSize)) + "/diskSize/" + strconv.Itoa(int(diskSize)) + "/specId/" + specId

        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

// FilterSpecs accepts criteria for filtering, and returns the list of filtered TB spec objects
func FilterSpecs(nsId string, filter TbSpecInfo) ([]TbSpecInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">tempList := []TbSpecInfo{}

        //sqlQuery := "SELECT * FROM `spec` WHERE `namespace`='" + nsId + "'"
        sqlQuery := common.ORM.Where("Namespace = ?", nsId)

        if filter.Id != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `id` LIKE '%" + filter.Id + "%'"
                filter.Id = RefineSpecName(filter.Id)
                sqlQuery = sqlQuery.And("Id LIKE ?", "%"+filter.Id+"%")
        }</span>
        <span class="cov8" title="1">if filter.Name != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `name` LIKE '%" + filter.Name + "%'"
                filter.Name = RefineSpecName(filter.Name)
                sqlQuery = sqlQuery.And("Name LIKE ?", "%"+filter.Name+"%")
        }</span>
        <span class="cov8" title="1">if filter.ConnectionName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `connectionName` LIKE '%" + filter.ConnectionName + "%'"
                filter.ConnectionName = RefineSpecName(filter.ConnectionName)
                sqlQuery = sqlQuery.And("ConnectionName LIKE ?", "%"+filter.ConnectionName+"%")
        }</span>
        <span class="cov8" title="1">if filter.CspSpecName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cspSpecName` LIKE '%" + filter.CspSpecName + "%'"
                filter.CspSpecName = RefineSpecName(filter.CspSpecName)
                sqlQuery = sqlQuery.And("CspSpecName LIKE ?", "%"+filter.CspSpecName+"%")
        }</span>
        <span class="cov8" title="1">if filter.Os_type != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `os_type` LIKE '%" + filter.Os_type + "%'"
                filter.Os_type = RefineSpecName(filter.Os_type)
                sqlQuery = sqlQuery.And("Os_type LIKE ?", "%"+filter.Os_type+"%")
        }</span>

        <span class="cov8" title="1">if filter.Num_vCPU &gt; 0 </span><span class="cov8" title="1">{
                //sqlQuery += " AND `num_vCPU`=" + strconv.Itoa(int(filter.Num_vCPU))
                sqlQuery = sqlQuery.And("Num_vCPU = ?", filter.Num_vCPU)
        }</span>
        <span class="cov8" title="1">if filter.Num_core &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_core`=" + strconv.Itoa(int(filter.Num_core))
                sqlQuery = sqlQuery.And("Num_core = ?", filter.Num_core)
        }</span>
        <span class="cov8" title="1">if filter.Mem_GiB &gt; 0 </span><span class="cov8" title="1">{
                //sqlQuery += " AND `mem_GiB`=" + strconv.Itoa(int(filter.Mem_GiB))
                sqlQuery = sqlQuery.And("Mem_GiB = ?", filter.Mem_GiB)
        }</span>
        <span class="cov8" title="1">if filter.Storage_GiB &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `storage_GiB`=" + strconv.Itoa(int(filter.Storage_GiB))
                sqlQuery = sqlQuery.And("Storage_GiB = ?", filter.Storage_GiB)
        }</span>
        <span class="cov8" title="1">if filter.Description != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `description` LIKE '%" + filter.Description + "%'"
                filter.Description = RefineSpecName(filter.Description)
                sqlQuery = sqlQuery.And("Description LIKE ?", "%"+filter.Description+"%")
        }</span>
        <span class="cov8" title="1">if filter.Cost_per_hour &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cost_per_hour`=" + fmt.Sprintf("%.6f", filter.Cost_per_hour)
                sqlQuery = sqlQuery.And("Cost_per_hour = ?", filter.Cost_per_hour)
        }</span>
        <span class="cov8" title="1">if filter.Num_storage &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_storage`=" + strconv.Itoa(int(filter.Num_storage))
                sqlQuery = sqlQuery.And("Num_storage = ?", filter.Num_storage)
        }</span>
        <span class="cov8" title="1">if filter.Max_num_storage &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_num_storage`=" + strconv.Itoa(int(filter.Max_num_storage))
                sqlQuery = sqlQuery.And("Max_num_storage = ?", filter.Max_num_storage)
        }</span>
        <span class="cov8" title="1">if filter.Max_total_storage_TiB &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_total_storage_TiB`=" + strconv.Itoa(int(filter.Max_total_storage_TiB))
                sqlQuery = sqlQuery.And("Max_total_storage_TiB = ?", filter.Max_total_storage_TiB)
        }</span>
        <span class="cov8" title="1">if filter.Net_bw_Gbps &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `net_bw_Gbps`=" + strconv.Itoa(int(filter.Net_bw_Gbps))
                sqlQuery = sqlQuery.And("Net_bw_Gbps = ?", filter.Net_bw_Gbps)
        }</span>
        <span class="cov8" title="1">if filter.Ebs_bw_Mbps &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `ebs_bw_Mbps`=" + strconv.Itoa(int(filter.Ebs_bw_Mbps))
                sqlQuery = sqlQuery.And("Ebs_bw_Mbps = ?", filter.Ebs_bw_Mbps)
        }</span>
        <span class="cov8" title="1">if filter.Gpu_model != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_model` LIKE '%" + filter.Gpu_model + "%'"
                filter.Gpu_model = RefineSpecName(filter.Gpu_model)
                sqlQuery = sqlQuery.And("Gpu_model LIKE ?", "%"+filter.Gpu_model+"%")
        }</span>
        <span class="cov8" title="1">if filter.Num_gpu &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_gpu`=" + strconv.Itoa(int(filter.Num_gpu))
                sqlQuery = sqlQuery.And("Num_gpu = ?", filter.Num_gpu)
        }</span>
        <span class="cov8" title="1">if filter.Gpumem_GiB &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpumem_GiB`=" + strconv.Itoa(int(filter.Gpumem_GiB))
                sqlQuery = sqlQuery.And("Gpumem_GiB = ?", filter.Gpumem_GiB)
        }</span>
        <span class="cov8" title="1">if filter.Gpu_p2p != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_p2p` LIKE '%" + filter.Gpu_p2p + "%'"
                filter.Gpu_p2p = RefineSpecName(filter.Gpu_p2p)
                sqlQuery = sqlQuery.And("Gpu_p2p LIKE ?", "%"+filter.Gpu_p2p+"%")
        }</span>
        <span class="cov8" title="1">if filter.EvaluationStatus != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationStatus` LIKE '%" + filter.EvaluationStatus + "%'"
                filter.EvaluationStatus = RefineSpecName(filter.EvaluationStatus)
                sqlQuery = sqlQuery.And("EvaluationStatus LIKE ?", "%"+filter.EvaluationStatus+"%")
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_01 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_01`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_01)
                sqlQuery = sqlQuery.And("EvaluationScore_01 = ?", filter.EvaluationScore_01)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_02 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_02`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_02)
                sqlQuery = sqlQuery.And("EvaluationScore_02 = ?", filter.EvaluationScore_02)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_03 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_03`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_03)
                sqlQuery = sqlQuery.And("EvaluationScore_03 = ?", filter.EvaluationScore_03)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_04 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_04`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_04)
                sqlQuery = sqlQuery.And("EvaluationScore_04 = ?", filter.EvaluationScore_04)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_05 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_05`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_05)
                sqlQuery = sqlQuery.And("EvaluationScore_05 = ?", filter.EvaluationScore_05)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_06 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_06`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_06)
                sqlQuery = sqlQuery.And("EvaluationScore_06 = ?", filter.EvaluationScore_06)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_07 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_07`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_07)
                sqlQuery = sqlQuery.And("EvaluationScore_07 = ?", filter.EvaluationScore_07)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_08 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_08`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_08)
                sqlQuery = sqlQuery.And("EvaluationScore_08 = ?", filter.EvaluationScore_08)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_09 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_09`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_09)
                sqlQuery = sqlQuery.And("EvaluationScore_09 = ?", filter.EvaluationScore_09)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_10 &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_10`=" + fmt.Sprintf("%.6f", filter.EvaluationScore_10)
                sqlQuery = sqlQuery.And("EvaluationScore_10 = ?", filter.EvaluationScore_10)
        }</span>

        <span class="cov8" title="1">err = sqlQuery.Find(&amp;tempList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempList, err
        }</span>
        <span class="cov8" title="1">return tempList, nil</span>
}

type Range struct {
        Min float32 `json:"min"`
        Max float32 `json:"max"`
}

type FilterSpecsByRangeRequest struct {
        Id                    string `json:"id"`
        Name                  string `json:"name"`
        ConnectionName        string `json:"connectionName"`
        CspSpecName           string `json:"cspSpecName"`
        Os_type               string `json:"os_type"`
        Num_vCPU              Range  `json:"num_vCPU"`
        Num_core              Range  `json:"num_core"`
        Mem_GiB               Range  `json:"mem_GiB"`
        Storage_GiB           Range  `json:"storage_GiB"`
        Description           string `json:"description"`
        Cost_per_hour         Range  `json:"cost_per_hour"`
        Num_storage           Range  `json:"num_storage"`
        Max_num_storage       Range  `json:"max_num_storage"`
        Max_total_storage_TiB Range  `json:"max_total_storage_TiB"`
        Net_bw_Gbps           Range  `json:"net_bw_Gbps"`
        Ebs_bw_Mbps           Range  `json:"ebs_bw_Mbps"`
        Gpu_model             string `json:"gpu_model"`
        Num_gpu               Range  `json:"num_gpu"`
        Gpumem_GiB            Range  `json:"gpumem_GiB"`
        Gpu_p2p               string `json:"gpu_p2p"`
        EvaluationStatus      string `json:"evaluationStatus"`
        EvaluationScore_01    Range  `json:"evaluationScore_01"`
        EvaluationScore_02    Range  `json:"evaluationScore_02"`
        EvaluationScore_03    Range  `json:"evaluationScore_03"`
        EvaluationScore_04    Range  `json:"evaluationScore_04"`
        EvaluationScore_05    Range  `json:"evaluationScore_05"`
        EvaluationScore_06    Range  `json:"evaluationScore_06"`
        EvaluationScore_07    Range  `json:"evaluationScore_07"`
        EvaluationScore_08    Range  `json:"evaluationScore_08"`
        EvaluationScore_09    Range  `json:"evaluationScore_09"`
        EvaluationScore_10    Range  `json:"evaluationScore_10"`
}

// FilterSpecsByRange accepts criteria ranges for filtering, and returns the list of filtered TB spec objects
func FilterSpecsByRange(nsId string, filter FilterSpecsByRangeRequest) ([]TbSpecInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">tempList := []TbSpecInfo{}

        //sqlQuery := "SELECT * FROM `spec` WHERE `namespace`='" + nsId + "'"
        sqlQuery := common.ORM.Where("Namespace = ?", nsId)

        if filter.Id != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `id` LIKE '%" + filter.Id + "%'"
                filter.Id = RefineSpecName(filter.Id)
                sqlQuery = sqlQuery.And("Id LIKE ?", "%"+filter.Id+"%")
        }</span>
        <span class="cov8" title="1">if filter.Name != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `name` LIKE '%" + filter.Name + "%'"
                filter.Name = RefineSpecName(filter.Name)
                sqlQuery = sqlQuery.And("Name LIKE ?", "%"+filter.Name+"%")
        }</span>
        <span class="cov8" title="1">if filter.ConnectionName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `connectionName` LIKE '%" + filter.ConnectionName + "%'"
                filter.ConnectionName = RefineSpecName(filter.ConnectionName)
                sqlQuery = sqlQuery.And("ConnectionName LIKE ?", "%"+filter.ConnectionName+"%")
        }</span>
        <span class="cov8" title="1">if filter.CspSpecName != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cspSpecName` LIKE '%" + filter.CspSpecName + "%'"
                filter.CspSpecName = RefineSpecName(filter.CspSpecName)
                sqlQuery = sqlQuery.And("CspSpecName LIKE ?", "%"+filter.CspSpecName+"%")
        }</span>
        <span class="cov8" title="1">if filter.Os_type != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `os_type` LIKE '%" + filter.Os_type + "%'"
                filter.Os_type = RefineSpecName(filter.Os_type)
                sqlQuery = sqlQuery.And("Os_type LIKE ?", "%"+filter.Os_type+"%")
        }</span>

        <span class="cov8" title="1">if filter.Num_vCPU.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_vCPU`&gt;=" + fmt.Sprintf("%.6f", filter.Num_vCPU.Min)
                sqlQuery = sqlQuery.And("Num_vCPU &gt;= ?", filter.Num_vCPU.Min)
        }</span>
        <span class="cov8" title="1">if filter.Num_vCPU.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_vCPU`&lt;=" + fmt.Sprintf("%.6f", filter.Num_vCPU.Max)
                sqlQuery = sqlQuery.And("Num_vCPU &lt;= ?", filter.Num_vCPU.Max)
        }</span>

        <span class="cov8" title="1">if filter.Num_core.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_core`&gt;=" + fmt.Sprintf("%.6f", filter.Num_core.Min)
                sqlQuery = sqlQuery.And("Num_core &gt;= ?", filter.Num_core.Min)
        }</span>
        <span class="cov8" title="1">if filter.Num_core.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_core`&lt;=" + fmt.Sprintf("%.6f", filter.Num_core.Max)
                sqlQuery = sqlQuery.And("Num_core &lt;= ?", filter.Num_core.Max)
        }</span>

        <span class="cov8" title="1">if filter.Mem_GiB.Min &gt; 0 </span><span class="cov8" title="1">{
                //sqlQuery += " AND `mem_GiB`&gt;=" + fmt.Sprintf("%.6f", filter.Mem_GiB.Min)
                sqlQuery = sqlQuery.And("Mem_GiB &gt;= ?", filter.Mem_GiB.Min)
        }</span>
        <span class="cov8" title="1">if filter.Mem_GiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `mem_GiB`&lt;=" + fmt.Sprintf("%.6f", filter.Mem_GiB.Max)
                sqlQuery = sqlQuery.And("Mem_GiB &lt;= ?", filter.Mem_GiB.Max)
        }</span>

        <span class="cov8" title="1">if filter.Storage_GiB.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `storage_GiB`&gt;=" + fmt.Sprintf("%.6f", filter.Storage_GiB.Min)
                sqlQuery = sqlQuery.And("Storage_GiB &gt;= ?", filter.Storage_GiB.Min)
        }</span>
        <span class="cov8" title="1">if filter.Storage_GiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `storage_GiB`&lt;=" + fmt.Sprintf("%.6f", filter.Storage_GiB.Max)
                sqlQuery = sqlQuery.And("Storage_GiB &lt;= ?", filter.Storage_GiB.Max)
        }</span>

        <span class="cov8" title="1">if filter.Description != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `description` LIKE '%" + filter.Description + "%'"
                filter.Description = RefineSpecName(filter.Description)
                sqlQuery = sqlQuery.And("Description LIKE ?", "%"+filter.Description+"%")
        }</span>

        <span class="cov8" title="1">if filter.Cost_per_hour.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cost_per_hour`&gt;=" + fmt.Sprintf("%.6f", filter.Cost_per_hour.Min)
                sqlQuery = sqlQuery.And("Cost_per_hour &gt;= ?", filter.Cost_per_hour.Min)
        }</span>
        <span class="cov8" title="1">if filter.Cost_per_hour.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `cost_per_hour`&lt;=" + fmt.Sprintf("%.6f", filter.Cost_per_hour.Max)
                sqlQuery = sqlQuery.And("Cost_per_hour &lt;= ?", filter.Cost_per_hour.Max)
        }</span>

        <span class="cov8" title="1">if filter.Num_storage.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_storage`&gt;=" + fmt.Sprintf("%.6f", filter.Num_storage.Min)
                sqlQuery = sqlQuery.And("Num_storage &gt;= ?", filter.Num_storage.Min)
        }</span>
        <span class="cov8" title="1">if filter.Num_storage.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_storage`&lt;=" + fmt.Sprintf("%.6f", filter.Num_storage.Max)
                sqlQuery = sqlQuery.And("Num_storage &lt;= ?", filter.Num_storage.Max)
        }</span>

        <span class="cov8" title="1">if filter.Max_num_storage.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_num_storage`&gt;=" + fmt.Sprintf("%.6f", filter.Max_num_storage.Min)
                sqlQuery = sqlQuery.And("Max_num_storage &gt;= ?", filter.Max_num_storage.Min)
        }</span>
        <span class="cov8" title="1">if filter.Max_num_storage.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_num_storage`&lt;=" + fmt.Sprintf("%.6f", filter.Max_num_storage.Max)
                sqlQuery = sqlQuery.And("Max_num_storage &lt;= ?", filter.Max_num_storage.Max)
        }</span>

        <span class="cov8" title="1">if filter.Max_total_storage_TiB.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_total_storage_TiB`&gt;=" + fmt.Sprintf("%.6f", filter.Max_total_storage_TiB.Min)
                sqlQuery = sqlQuery.And("Max_total_storage_TiB &gt;= ?", filter.Max_total_storage_TiB.Min)
        }</span>
        <span class="cov8" title="1">if filter.Max_total_storage_TiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `max_total_storage_TiB`&lt;=" + fmt.Sprintf("%.6f", filter.Max_total_storage_TiB.Max)
                sqlQuery = sqlQuery.And("Max_total_storage_TiB &lt;= ?", filter.Max_total_storage_TiB.Max)
        }</span>

        <span class="cov8" title="1">if filter.Net_bw_Gbps.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `net_bw_Gbps`&gt;=" + fmt.Sprintf("%.6f", filter.Net_bw_Gbps.Min)
                sqlQuery = sqlQuery.And("Net_bw_Gbps &gt;= ?", filter.Net_bw_Gbps.Min)
        }</span>
        <span class="cov8" title="1">if filter.Net_bw_Gbps.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `net_bw_Gbps`&lt;=" + fmt.Sprintf("%.6f", filter.Net_bw_Gbps.Max)
                sqlQuery = sqlQuery.And("Net_bw_Gbps &lt;= ?", filter.Net_bw_Gbps.Max)
        }</span>

        <span class="cov8" title="1">if filter.Ebs_bw_Mbps.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `ebs_bw_Mbps`&gt;=" + fmt.Sprintf("%.6f", filter.Ebs_bw_Mbps.Min)
                sqlQuery = sqlQuery.And("Ebs_bw_Mbps &gt;= ?", filter.Ebs_bw_Mbps.Min)
        }</span>
        <span class="cov8" title="1">if filter.Ebs_bw_Mbps.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `ebs_bw_Mbps`&lt;=" + fmt.Sprintf("%.6f", filter.Ebs_bw_Mbps.Max)
                sqlQuery = sqlQuery.And("Ebs_bw_Mbps &lt;= ?", filter.Ebs_bw_Mbps.Max)
        }</span>

        <span class="cov8" title="1">if filter.Gpu_model != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_model` LIKE '%" + filter.Gpu_model + "%'"
                filter.Gpu_model = RefineSpecName(filter.Gpu_model)
                sqlQuery = sqlQuery.And("Gpu_model LIKE ?", "%"+filter.Gpu_model+"%")
        }</span>

        <span class="cov8" title="1">if filter.Num_gpu.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_gpu`&gt;=" + fmt.Sprintf("%.6f", filter.Num_gpu.Min)
                sqlQuery = sqlQuery.And("Num_gpu &gt;= ?", filter.Num_gpu.Min)
        }</span>
        <span class="cov8" title="1">if filter.Num_gpu.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `num_gpu`&lt;=" + fmt.Sprintf("%.6f", filter.Num_gpu.Max)
                sqlQuery = sqlQuery.And("Num_gpu &lt;= ?", filter.Num_gpu.Max)
        }</span>

        <span class="cov8" title="1">if filter.Gpumem_GiB.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpumem_GiB`&gt;=" + fmt.Sprintf("%.6f", filter.Gpumem_GiB.Min)
                sqlQuery = sqlQuery.And("Gpumem_GiB &gt;= ?", filter.Gpumem_GiB.Min)
        }</span>
        <span class="cov8" title="1">if filter.Gpumem_GiB.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpumem_GiB`&lt;=" + fmt.Sprintf("%.6f", filter.Gpumem_GiB.Max)
                sqlQuery = sqlQuery.And("Gpumem_GiB &lt;= ?", filter.Gpumem_GiB.Max)
        }</span>

        <span class="cov8" title="1">if filter.Gpu_p2p != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `gpu_p2p` LIKE '%" + filter.Gpu_p2p + "%'"
                filter.Gpu_p2p = RefineSpecName(filter.Gpu_p2p)
                sqlQuery = sqlQuery.And("Gpu_p2p LIKE ?", "%"+filter.Gpu_p2p+"%")
        }</span>
        <span class="cov8" title="1">if filter.EvaluationStatus != "" </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationStatus` LIKE '%" + filter.EvaluationStatus + "%'"
                filter.EvaluationStatus = RefineSpecName(filter.EvaluationStatus)
                sqlQuery = sqlQuery.And("EvaluationStatus LIKE ?", "%"+filter.EvaluationStatus+"%")
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_01.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_01`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_01.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_01 &gt;= ?", filter.EvaluationScore_01.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_01.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_01`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_01.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_01 &lt;= ?", filter.EvaluationScore_01.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_02.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_02`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_02.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_02 &gt;= ?", filter.EvaluationScore_02.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_02.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_02`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_02.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_02 &lt;= ?", filter.EvaluationScore_02.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_03.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_03`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_03.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_03 &gt;= ?", filter.EvaluationScore_03.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_03.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_03`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_03.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_03 &lt;= ?", filter.EvaluationScore_03.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_04.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_04`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_04.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_04 &gt;= ?", filter.EvaluationScore_04.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_04.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_04`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_04.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_04 &lt;= ?", filter.EvaluationScore_04.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_05.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_05`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_05.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_05 &gt;= ?", filter.EvaluationScore_05.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_05.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_05`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_05.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_05 &lt;= ?", filter.EvaluationScore_05.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_06.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_06`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_06.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_06 &gt;= ?", filter.EvaluationScore_06.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_06.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_06`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_06.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_06 &lt;= ?", filter.EvaluationScore_06.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_07.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_07`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_07.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_07 &gt;= ?", filter.EvaluationScore_07.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_07.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_07`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_07.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_07 &lt;= ?", filter.EvaluationScore_07.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_08.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_08`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_08.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_08 &gt;= ?", filter.EvaluationScore_08.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_08.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_08`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_08.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_08 &lt;= ?", filter.EvaluationScore_08.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_09.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_09`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_09.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_09 &gt;= ?", filter.EvaluationScore_09.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_09.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_09`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_09.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_09 &lt;= ?", filter.EvaluationScore_09.Max)
        }</span>

        <span class="cov8" title="1">if filter.EvaluationScore_10.Min &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_10`&gt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_10.Min)
                sqlQuery = sqlQuery.And("EvaluationScore_10 &gt;= ?", filter.EvaluationScore_10.Min)
        }</span>
        <span class="cov8" title="1">if filter.EvaluationScore_10.Max &gt; 0 </span><span class="cov0" title="0">{
                //sqlQuery += " AND `evaluationScore_10`&lt;=" + fmt.Sprintf("%.6f", filter.EvaluationScore_10.Max)
                sqlQuery = sqlQuery.And("EvaluationScore_10 &lt;= ?", filter.EvaluationScore_10.Max)
        }</span>

        <span class="cov8" title="1">err = sqlQuery.Find(&amp;tempList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempList, err
        }</span>

        <span class="cov8" title="1">return tempList, nil</span>
}

// SortSpecs accepts the list of TB spec objects, criteria and sorting direction,
// sorts and returns the sorted list of TB spec objects
func SortSpecs(specList []TbSpecInfo, orderBy string, direction string) ([]TbSpecInfo, error) <span class="cov0" title="0">{
        var err error = nil

        sort.Slice(specList, func(i, j int) bool </span><span class="cov0" title="0">{
                if orderBy == "num_vCPU" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].Num_vCPU &gt; specList[j].Num_vCPU
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].Num_vCPU &lt; specList[j].Num_vCPU
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "mem_GiB" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].Mem_GiB &gt; specList[j].Mem_GiB
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].Mem_GiB &lt; specList[j].Mem_GiB
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "storage_GiB" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].Storage_GiB &gt; specList[j].Storage_GiB
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].Storage_GiB &lt; specList[j].Storage_GiB
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_01" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_01 &gt; specList[j].EvaluationScore_01
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_01 &lt; specList[j].EvaluationScore_01
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_02" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_02 &gt; specList[j].EvaluationScore_02
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_02 &lt; specList[j].EvaluationScore_02
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_03" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_03 &gt; specList[j].EvaluationScore_03
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_03 &lt; specList[j].EvaluationScore_03
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_04" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_04 &gt; specList[j].EvaluationScore_04
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_04 &lt; specList[j].EvaluationScore_04
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_05" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_05 &gt; specList[j].EvaluationScore_05
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_05 &lt; specList[j].EvaluationScore_05
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_06" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_06 &gt; specList[j].EvaluationScore_06
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_06 &lt; specList[j].EvaluationScore_06
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_07" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_07 &gt; specList[j].EvaluationScore_07
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_07 &lt; specList[j].EvaluationScore_07
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_08" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_08 &gt; specList[j].EvaluationScore_08
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_08 &lt; specList[j].EvaluationScore_08
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_09" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_09 &gt; specList[j].EvaluationScore_09
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_09 &lt; specList[j].EvaluationScore_09
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> if orderBy == "evaluationScore_10" </span><span class="cov0" title="0">{
                        if direction == "descending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_10 &gt; specList[j].EvaluationScore_10
                        }</span> else<span class="cov0" title="0"> if direction == "ascending" </span><span class="cov0" title="0">{
                                return specList[i].EvaluationScore_10 &lt; specList[j].EvaluationScore_10
                        }</span> else<span class="cov0" title="0"> {
                                err = fmt.Errorf("'direction' should one of these: ascending, descending")
                                return true
                        }</span>
                } else<span class="cov0" title="0"> {
                        err = fmt.Errorf("'orderBy' should one of these: num_vCPU, mem_GiB, storage_GiB")
                        return true
                }</span>
        })

        <span class="cov0" title="0">for i := range specList </span><span class="cov0" title="0">{
                specList[i].OrderInFilteredResult = uint16(i + 1)
        }</span>

        <span class="cov0" title="0">return specList, err</span>
}

// UpdateSpec accepts to-be TB spec objects,
// updates and returns the updated TB spec objects
func UpdateSpec(nsId string, newSpec TbSpecInfo) (TbSpecInfo, error) <span class="cov8" title="1">{
        resourceType := common.StrSpec

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(newSpec.Id)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckResource(nsId, resourceType, newSpec.Id)

        if !check </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("The spec " + newSpec.Id + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">tempInterface, err := GetResource(nsId, resourceType, newSpec.Id)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("Failed to get the spec " + newSpec.Id + ".")
                return temp, err
        }</span>
        <span class="cov8" title="1">tempSpec := TbSpecInfo{}
        err = common.CopySrcToDest(&amp;tempInterface, &amp;tempSpec)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                err := fmt.Errorf("Failed to CopySrcToDest() " + newSpec.Id + ".")
                return temp, err
        }</span>

        // cb-store
        <span class="cov8" title="1">fmt.Println("=========================== PUT registerSpec")
        Key := common.GenResourceKey(nsId, resourceType, tempSpec.Id)
        Val, _ := json.Marshal(tempSpec)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSpecInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // register information related with MCIS recommendation
        err = RegisterRecommendList(nsId, tempSpec.ConnectionName, tempSpec.Num_vCPU, tempSpec.Mem_GiB, tempSpec.Storage_GiB, tempSpec.Id, tempSpec.Cost_per_hour)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return tempSpec, err
        }</span>

        // "UPDATE `spec` SET `id`='" + newSpec.Id + "', ... WHERE `namespace`='" + nsId + "' AND `id`='" + newSpec.Id + "';"
        <span class="cov8" title="1">_, err = common.ORM.Update(&amp;newSpec, &amp;TbSpecInfo{Namespace: nsId, Id: newSpec.Id})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Data inserted successfully..")
        }</span>

        <span class="cov8" title="1">return tempSpec, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"
)

// 2020-04-03 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/KeyPairHandler.go

type SpiderKeyPairReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderKeyPairInfo
}

/*
type SpiderKeyPairReqInfo struct { // Spider
        Name string
}
*/

type SpiderKeyPairInfo struct { // Spider
        // Fields for request
        Name string

        // Fields for response
        IId          common.IID // {NameId, SystemId}
        Fingerprint  string
        PublicKey    string
        PrivateKey   string
        VMUserID     string
        KeyValueList []common.KeyValue
}

type TbSshKeyReq struct {
        Name           string `json:"name"`
        ConnectionName string `json:"connectionName"`
        Description    string `json:"description"`
}

type TbSshKeyInfo struct {
        Id                   string            `json:"id"`
        Name                 string            `json:"name"`
        ConnectionName       string            `json:"connectionName"`
        Description          string            `json:"description"`
        CspSshKeyName        string            `json:"cspSshKeyName"`
        Fingerprint          string            `json:"fingerprint"`
        Username             string            `json:"username"`
        VerifiedUsername     string            `json:"verifiedUsername"`
        PublicKey            string            `json:"publicKey"`
        PrivateKey           string            `json:"privateKey"`
        KeyValueList         []common.KeyValue `json:"keyValueList"`
        AssociatedObjectList []string          `json:"associatedObjectList"`
        IsAutoGenerated      bool              `json:"isAutoGenerated"`
}

// CreateSshKey accepts SSH key creation request, creates and returns an TB sshKey object
func CreateSshKey(nsId string, u *TbSshKeyReq) (TbSshKeyInfo, error) <span class="cov8" title="1">{

        resourceType := common.StrSSHKey

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSshKeyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbSshKeyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov8" title="1">{
                temp := TbSshKeyInfo{}
                err := fmt.Errorf("The sshKey " + u.Name + " already exists.")
                //return temp, http.StatusConflict, nil, err
                return temp, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := TbSshKeyInfo{}
                err := fmt.Errorf("Failed to check the existence of the sshKey " + u.Name + ".")
                return temp, err
        }</span>

        <span class="cov8" title="1">tempReq := SpiderKeyPairReqInfoWrapper{}
        tempReq.ConnectionName = u.ConnectionName
        tempReq.ReqInfo.Name = u.Name

        var tempSpiderKeyPairInfo *SpiderKeyPairInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/keypair"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderKeyPairInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Post(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := TbSshKeyInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        fmt.Println("body: ", string(resp.Body()))
                        common.CBLog.Error(err)
                        content := TbSshKeyInfo{}
                        return content, err</span>
                }

                <span class="cov8" title="1">tempSpiderKeyPairInfo = resp.Result().(*SpiderKeyPairInfo)</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return TbSshKeyInfo{}, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return TbSshKeyInfo{}, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                //fmt.Println("payload: " + string(payload)) // for debug

                result, err := ccm.CreateKey(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSshKeyInfo{}, err
                }</span>

                <span class="cov8" title="1">tempSpiderKeyPairInfo = &amp;SpiderKeyPairInfo{}
                err = json.Unmarshal([]byte(result), &amp;tempSpiderKeyPairInfo)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbSshKeyInfo{}, err
                }</span>

        }

        <span class="cov8" title="1">content := TbSshKeyInfo{}
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.ConnectionName = u.ConnectionName
        content.CspSshKeyName = tempSpiderKeyPairInfo.IId.NameId
        content.Fingerprint = tempSpiderKeyPairInfo.Fingerprint
        content.Username = tempSpiderKeyPairInfo.VMUserID
        content.PublicKey = tempSpiderKeyPairInfo.PublicKey
        content.PrivateKey = tempSpiderKeyPairInfo.PrivateKey
        content.Description = u.Description
        content.KeyValueList = tempSpiderKeyPairInfo.KeyValueList
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT CreateSshKey")
        Key := common.GenResourceKey(nsId, resourceType, content.Id)
        Val, _ := json.Marshal(content)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        //keyValue, _ := common.CBStore.Get(string(Key))
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        <span class="cov8" title="1">fmt.Println("===========================")
        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package mcir

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/go-resty/resty/v2"
)

// 2020-04-09 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/VPCHandler.go

type SpiderVPCReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderVPCReqInfo
}

type SpiderVPCReqInfo struct { // Spider
        Name           string
        IPv4_CIDR      string
        SubnetInfoList []SpiderSubnetReqInfo
        //SubnetInfoList []SpiderSubnetInfo
}

type SpiderSubnetReqInfo struct { // Spider
        Name         string
        IPv4_CIDR    string
        KeyValueList []common.KeyValue
}

type SpiderVPCInfo struct { // Spider
        IId            common.IID // {NameId, SystemId}
        IPv4_CIDR      string
        SubnetInfoList []SpiderSubnetInfo
        KeyValueList   []common.KeyValue
}

type SpiderSubnetInfo struct { // Spider
        IId          common.IID // {NameId, SystemId}
        IPv4_CIDR    string
        KeyValueList []common.KeyValue
}

type TbVNetReq struct { // Tumblebug
        Name           string                `json:"name"`
        ConnectionName string                `json:"connectionName"`
        CidrBlock      string                `json:"cidrBlock"`
        SubnetInfoList []SpiderSubnetReqInfo `json:"subnetInfoList"`
        Description    string                `json:"description"`
}

type TbVNetInfo struct { // Tumblebug
        Id                   string             `json:"id"`
        Name                 string             `json:"name"`
        ConnectionName       string             `json:"connectionName"`
        CidrBlock            string             `json:"cidrBlock"`
        SubnetInfoList       []SpiderSubnetInfo `json:"subnetInfoList"`
        Description          string             `json:"description"`
        CspVNetId            string             `json:"cspVNetId"`
        CspVNetName          string             `json:"cspVNetName"`
        Status               string             `json:"status"`
        KeyValueList         []common.KeyValue  `json:"keyValueList"`
        AssociatedObjectList []string           `json:"associatedObjectList"`
        IsAutoGenerated      bool               `json:"isAutoGenerated"`

        // Disabled for now
        //Region         string `json:"region"`
        //ResourceGroupName string `json:"resourceGroupName"`
}

// CreateVNet accepts vNet creation request, creates and returns an TB vNet object
func CreateVNet(nsId string, u *TbVNetReq) (TbVNetInfo, error) <span class="cov8" title="1">{

        resourceType := common.StrVNet

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbVNetInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(u.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := TbVNetInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, err := CheckResource(nsId, resourceType, u.Name)

        if check </span><span class="cov8" title="1">{
                temp := TbVNetInfo{}
                err := fmt.Errorf("The vNet " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                temp := TbVNetInfo{}
                err := fmt.Errorf("Failed to check the existence of the vNet " + u.Name + ".")
                return temp, err
        }</span>

        <span class="cov8" title="1">tempReq := SpiderVPCReqInfoWrapper{}
        tempReq.ConnectionName = u.ConnectionName
        tempReq.ReqInfo.Name = u.Name
        tempReq.ReqInfo.IPv4_CIDR = u.CidrBlock
        tempReq.ReqInfo.SubnetInfoList = u.SubnetInfoList

        var tempSpiderVPCInfo *SpiderVPCInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/vpc"

                client := resty.New().SetCloseConnection(true)

                resp, err := client.R().
                        SetHeader("Content-Type", "application/json").
                        SetBody(tempReq).
                        SetResult(&amp;SpiderVPCInfo{}). // or SetResult(AuthSuccess{}).
                        //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                        Post(url)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        content := TbVNetInfo{}
                        err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                        return content, err
                }</span>

                <span class="cov8" title="1">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
                switch </span>{
                case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                        err := fmt.Errorf(string(resp.Body()))
                        common.CBLog.Error(err)
                        content := TbVNetInfo{}
                        return content, err</span>
                }

                <span class="cov8" title="1">tempSpiderVPCInfo = resp.Result().(*SpiderVPCInfo)</span>

        } else<span class="cov8" title="1"> {

                // Set CCM API
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return TbVNetInfo{}, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return TbVNetInfo{}, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                fmt.Println("payload: " + string(payload)) // for debug

                result, err := ccm.CreateVPC(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbVNetInfo{}, err
                }</span>

                <span class="cov8" title="1">tempSpiderVPCInfo = &amp;SpiderVPCInfo{} // Spider
                err = json.Unmarshal([]byte(result), &amp;tempSpiderVPCInfo)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbVNetInfo{}, err
                }</span>

        }

        <span class="cov8" title="1">content := TbVNetInfo{}
        //content.Id = common.GenUuid()
        content.Id = u.Name
        content.Name = u.Name
        content.ConnectionName = u.ConnectionName
        content.CspVNetId = tempSpiderVPCInfo.IId.SystemId
        content.CspVNetName = tempSpiderVPCInfo.IId.NameId
        content.CidrBlock = tempSpiderVPCInfo.IPv4_CIDR
        content.SubnetInfoList = tempSpiderVPCInfo.SubnetInfoList
        content.Description = u.Description
        content.KeyValueList = tempSpiderVPCInfo.KeyValueList
        content.AssociatedObjectList = []string{}

        // cb-store
        fmt.Println("=========================== PUT CreateVNet")
        Key := common.GenResourceKey(nsId, common.StrVNet, content.Id)
        Val, _ := json.Marshal(content)

        //fmt.Println("Key: ", Key)
        //fmt.Println("Val: ", Val)
        err3 := common.CBStore.Put(string(Key), string(Val))
        if err3 != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err3)
                return content, err3
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")
        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package mcis

import (
        "errors"

        "encoding/json"
        "fmt"
        "io/ioutil"

        //"log"
        "strconv"
        "strings"
        "time"

        //csv file handling
        "bufio"
        "encoding/csv"
        "os"

        "math/rand"
        "reflect"

        // REST API (echo)
        "net/http"

        "sync"

        "github.com/cloud-barista/cb-spider/interface/api"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"

        cbstore_utils "github.com/cloud-barista/cb-store/utils"
)

// const ActionCreate
const ActionCreate string = "Create"

// const ActionTerminate
const ActionTerminate string = "Terminate"

// const ActionSuspend
const ActionSuspend string = "Suspend"

// const ActionResume
const ActionResume string = "Resume"

// const ActionReboot
const ActionReboot string = "Reboot"

// const ActionComplete
const ActionComplete string = "None"

// const StatusRunning
const StatusRunning string = "Running"

// const StatusSuspended
const StatusSuspended string = "Suspended"

// const StatusFailed
const StatusFailed string = "Failed"

// const StatusTerminated
const StatusTerminated string = "Terminated"

// const StatusCreating
const StatusCreating string = "Creating"

// const StatusSuspending
const StatusSuspending string = "Suspending"

// const StatusResuming
const StatusResuming string = "Resuming"

// const StatusRebooting
const StatusRebooting string = "Rebooting"

// const StatusTerminating
const StatusTerminating string = "Terminating"

// const StatusUndefined
const StatusUndefined string = "Undefined"

// const StatusComplete
const StatusComplete string = "None"

const milkywayPort string = ":1324/milkyway/"

const sshDefaultUserName01 string = "cb-user"
const sshDefaultUserName02 string = "ubuntu"
const sshDefaultUserName03 string = "root"
const sshDefaultUserName04 string = "ec2-user"

const labelAutoGen string = "AutoGen"

// Structs for REST API

// 2020-04-13 https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/VMHandler.go
type SpiderVMReqInfoWrapper struct { // Spider
        ConnectionName string
        ReqInfo        SpiderVMInfo
}

type SpiderVMInfo struct { // Spider
        // Fields for request
        Name               string
        ImageName          string
        VPCName            string
        SubnetName         string
        SecurityGroupNames []string
        KeyPairName        string

        // Fields for both request and response
        VMSpecName   string //  instance type or flavour, etc... ex) t2.micro or f1.micro
        VMUserId     string // ex) user1
        VMUserPasswd string

        // Fields for response
        IId               common.IID // {NameId, SystemId}
        ImageIId          common.IID
        VpcIID            common.IID
        SubnetIID         common.IID   // AWS, ex) subnet-8c4a53e4
        SecurityGroupIIds []common.IID // AWS, ex) sg-0b7452563e1121bb6
        KeyPairIId        common.IID
        StartTime         time.Time  // Timezone: based on cloud-barista server location.
        Region            RegionInfo //  ex) {us-east1, us-east1-c} or {ap-northeast-2}
        NetworkInterface  string     // ex) eth0
        PublicIP          string
        PublicDNS         string
        PrivateIP         string
        PrivateDNS        string
        VMBootDisk        string // ex) /dev/sda1
        VMBlockDisk       string // ex)
        SSHAccessPoint    string
        KeyValueList      []common.KeyValue
}

type RegionInfo struct { // Spider
        Region string
        Zone   string
}

type TbMcisReq struct {
        Name string `json:"name"`

        // InstallMonAgent Option for CB-Dragonfly agent installation ([yes/no] default:yes)
        InstallMonAgent string `json:"installMonAgent" example:"yes" default:"yes" enums:"yes,no"` // yes or no

        Label string `json:"label"`

        PlacementAlgo string `json:"placementAlgo"`
        Description   string `json:"description"`

        Vm []TbVmReq `json:"vm"`
}

type TbMcisInfo struct {
        Id           string `json:"id"`
        Name         string `json:"name"`
        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`

        // InstallMonAgent Option for CB-Dragonfly agent installation ([yes/no] default:yes)
        InstallMonAgent string `json:"installMonAgent" example:"yes" default:"yes" enums:"yes,no"` // yes or no

        Label string `json:"label"`

        PlacementAlgo string     `json:"placementAlgo"`
        Description   string     `json:"description"`
        Vm            []TbVmInfo `json:"vm"`
}

// struct TbVmReq is to get requirements to create a new server instance.
type TbVmReq struct {
        // VM name or VM group name if is (not empty) &amp;&amp; (&gt; 0). If it is a group, actual VM name will be generated with -N postfix.
        Name string `json:"name"`

        // if vmGroupSize is (not empty) &amp;&amp; (&gt; 0), VM group will be gernetad. VMs will be created accordingly.
        VmGroupSize string `json:"vmGroupSize" example:"3" default:""`

        Label string `json:"label"`

        Description string `json:"description"`

        ConnectionName   string   `json:"connectionName"`
        SpecId           string   `json:"specId"`
        ImageId          string   `json:"imageId"`
        VNetId           string   `json:"vNetId"`
        SubnetId         string   `json:"subnetId"`
        SecurityGroupIds []string `json:"securityGroupIds"`
        SshKeyId         string   `json:"sshKeyId"`
        VmUserAccount    string   `json:"vmUserAccount"`
        VmUserPassword   string   `json:"vmUserPassword"`
}

// struct TbVmGroupInfo is to define an object that includes homogeneous VMs.
type TbVmGroupInfo struct {
        Id          string   `json:"id"`
        Name        string   `json:"name"`
        VmId        []string `json:"vmId"`
        VmGroupSize string   `json:"vmGroupSize"`
}

// struct TbVmGroupInfo is to define a server instance object
type TbVmInfo struct {
        Id   string `json:"id"`
        Name string `json:"name"`

        // defined if the VM is in a group
        VmGroupId string `json:"vmGroupId"`

        Location GeoLocation `json:"location"`

        // Required by CB-Tumblebug
        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`

        // Montoring agent status
        MonAgentStatus string `json:"monAgentStatus" example:"[installed, notInstalled, failed]"` // yes or no// installed, notInstalled, failed

        // Latest system message such as error message
        SystemMessage string `json:"systemMessage" example:"Failed because ..." default:""` // systeam-given string message

        // Created time
        CreatedTime string `json:"createdTime" example:"2022-11-10 23:00:00" default:""`

        Label       string `json:"label"`
        Description string `json:"description"`

        Region      RegionInfo `json:"region"` // AWS, ex) {us-east1, us-east1-c} or {ap-northeast-2}
        PublicIP    string     `json:"publicIP"`
        SSHPort     string     `json:"sshPort"`
        PublicDNS   string     `json:"publicDNS"`
        PrivateIP   string     `json:"privateIP"`
        PrivateDNS  string     `json:"privateDNS"`
        VMBootDisk  string     `json:"vmBootDisk"` // ex) /dev/sda1
        VMBlockDisk string     `json:"vmBlockDisk"`

        ConnectionName   string   `json:"connectionName"`
        SpecId           string   `json:"specId"`
        ImageId          string   `json:"imageId"`
        VNetId           string   `json:"vNetId"`
        SubnetId         string   `json:"subnetId"`
        SecurityGroupIds []string `json:"securityGroupIds"`
        SshKeyId         string   `json:"sshKeyId"`
        VmUserAccount    string   `json:"vmUserAccount"`
        VmUserPassword   string   `json:"vmUserPassword"`

        CspViewVmDetail SpiderVMInfo `json:"cspViewVmDetail"`
}

type GeoLocation struct {
        Latitude     string `json:"latitude"`
        Longitude    string `json:"longitude"`
        BriefAddr    string `json:"briefAddr"`
        CloudType    string `json:"cloudType"`
        NativeRegion string `json:"nativeRegion"`
}

// struct McisStatusInfo is to define simple information of MCIS with updated status of all VMs
type McisStatusInfo struct {
        Id   string `json:"id"`
        Name string `json:"name"`

        //Vm_num string         `json:"vm_num"`
        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`

        // InstallMonAgent Option for CB-Dragonfly agent installation ([yes/no] default:yes)
        InstallMonAgent string `json:"installMonAgent" example:"[yes, no]"` // yes or no

        MasterVmId    string `json:"masterVmId" example:"vm-asiaeast1-cb-01"`
        MasterIp      string `json:"masterIp" example:"32.201.134.113"`
        MasterSSHPort string `json:"masterSSHPort"`

        Vm []TbVmStatusInfo `json:"vm"`
}

// TbVmStatusInfo is to define simple information of VM with updated status
type TbVmStatusInfo struct {
        Id      string `json:"id"`
        Name    string `json:"name"`
        CspVmId string `json:"cspVmId"`

        Status       string `json:"status"`
        TargetStatus string `json:"targetStatus"`
        TargetAction string `json:"targetAction"`
        NativeStatus string `json:"nativeStatus"`

        // Montoring agent status
        MonAgentStatus string `json:"monAgentStatus" example:"[installed, notInstalled, failed]"` // yes or no// installed, notInstalled, failed

        // Latest system message such as error message
        SystemMessage string `json:"systemMessage" example:"Failed because ..." default:""` // systeam-given string message

        // Created time
        CreatedTime string `json:"createdTime" example:"2022-11-10 23:00:00" default:""`

        PublicIp  string `json:"publicIp"`
        PrivateIp string `json:"privateIp"`
        SSHPort   string `json:"sshPort"`

        Location GeoLocation `json:"location"`
}

// McisCmdReq is remote command struct
type McisCmdReq struct {
        UserName string `json:"userName" example:"cb-user" default:""`
        Command  string `json:"command" example:"sudo apt-get install ..." default:""`
}

type McisRecommendReq struct {
        VmReq          []TbVmRecommendReq `json:"vmReq"`
        PlacementAlgo  string             `json:"placementAlgo"`
        PlacementParam []common.KeyValue  `json:"placementParam"`
        MaxResultNum   string             `json:"maxResultNum"`
}

type TbVmRecommendReq struct {
        RequestName  string `json:"requestName"`
        MaxResultNum string `json:"maxResultNum"`

        VcpuSize   string `json:"vcpuSize"`
        MemorySize string `json:"memorySize"`
        DiskSize   string `json:"diskSize"`
        //Disk_type   string `json:"disk_type"`

        PlacementAlgo  string            `json:"placementAlgo"`
        PlacementParam []common.KeyValue `json:"placementParam"`
}

type TbVmPriority struct {
        Priority string          `json:"priority"`
        VmSpec   mcir.TbSpecInfo `json:"vmSpec"`
}

type TbVmRecommendInfo struct {
        VmReq          TbVmRecommendReq  `json:"vmReq"`
        VmPriority     []TbVmPriority    `json:"vmPriority"`
        PlacementAlgo  string            `json:"placementAlgo"`
        PlacementParam []common.KeyValue `json:"placementParam"`
}

func VerifySshUserName(nsId string, mcisId string, vmId string, vmIp string, sshPort string, givenUserName string) (string, string, error) <span class="cov8" title="1">{

        // verify if vm is running with a public ip.
        if vmIp == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("Cannot do ssh, VM IP is null")
        }</span>
        <span class="cov8" title="1">vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", "", err
        }</span>
        <span class="cov8" title="1">if vmStatusInfoTmp.Status != StatusRunning || vmIp == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("Cannot do ssh, VM IP is not Running")
        }</span>

        // find vaild username
        <span class="cov8" title="1">userName, _, privateKey := GetVmSshKey(nsId, mcisId, vmId)
        userNames := []string{
                userName,
                givenUserName,
                sshDefaultUserName01,
                sshDefaultUserName02,
                sshDefaultUserName03,
                sshDefaultUserName04,
        }

        theUserName := ""
        cmd := "ls"

        _, verifiedUserName, _ := GetVmSshKey(nsId, mcisId, vmId)

        if verifiedUserName != "" </span><span class="cov8" title="1">{
                fmt.Println("[SSH] " + "(" + vmIp + ")" + "with userName:" + verifiedUserName)
                fmt.Println("[CMD] " + cmd)

                retrycheck := 10
                for i := 0; i &lt; retrycheck; i++ </span><span class="cov8" title="1">{
                        conerr := CheckConnectivity(vmIp, sshPort)
                        if conerr == nil </span><span class="cov8" title="1">{
                                fmt.Println("[ERR: CheckConnectivity] nil. break")
                                break</span>
                        }
                        <span class="cov0" title="0">if i == retrycheck-1 </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("Cannot do ssh, the port is not opened (10 trials)")
                        }</span>
                        <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
                }

                <span class="cov8" title="1">result, err := RunSSH(vmIp, sshPort, verifiedUserName, privateKey, cmd)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("[ERR: result] " + "[ERR: err] " + err.Error())
                        return "", "", fmt.Errorf("Cannot do ssh, with" + verifiedUserName + ", " + err.Error())
                }</span>
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        theUserName = verifiedUserName
                        fmt.Println("[RST] " + *result + "[Username] " + verifiedUserName)
                        return theUserName, privateKey, nil
                }</span>
        }

        <span class="cov8" title="1">retrycheck := 10
        for i := 0; i &lt; retrycheck; i++ </span><span class="cov8" title="1">{
                conerr := CheckConnectivity(vmIp, sshPort)
                if conerr == nil </span><span class="cov8" title="1">{
                        //fmt.Println("[ERR: conerr] nil. break")
                        break</span>
                }
                <span class="cov0" title="0">if i == retrycheck-1 </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("Cannot do ssh, the port is not opened (10 trials)")
                }</span>
                <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
        }
        <span class="cov8" title="1">fmt.Println("[Retrieve ssh username from the given list]")
        for _, v := range userNames </span><span class="cov8" title="1">{
                if v != "" </span><span class="cov8" title="1">{
                        fmt.Println("[SSH] " + "(" + vmIp + ")" + "with userName:" + v)
                        result, err := RunSSH(vmIp, sshPort, v, privateKey, cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("[ERR: result] " + "[ERR: err] " + err.Error())
                        }</span>
                        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                theUserName = v
                                fmt.Println("[RST] " + *result + "[Username] " + v)
                                break</span>
                        }
                        <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
                }
        }
        <span class="cov8" title="1">if theUserName != "" </span><span class="cov8" title="1">{
                err := UpdateVmSshKey(nsId, mcisId, vmId, theUserName)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("[ERR: result] " + "[ERR: err] " + err.Error())
                        return "", "", err
                }</span>
        } else<span class="cov0" title="0"> {
                return "", "", fmt.Errorf("Could not find username")
        }</span>

        <span class="cov8" title="1">return theUserName, privateKey, nil</span>
}

type SshCmdResult struct { // Tumblebug
        McisId string `json:"mcisId"`
        VmId   string `json:"vmId"`
        VmIp   string `json:"vmIp"`
        Result string `json:"result"`
        Err    error  `json:"err"`
}

// AgentInstallContentWrapper ...
type AgentInstallContentWrapper struct {
        Result_array []AgentInstallContent `json:"result_array"`
}

// AgentInstallContent ...
type AgentInstallContent struct {
        McisId string `json:"mcisId"`
        VmId   string `json:"vmId"`
        VmIp   string `json:"vmIp"`
        Result string `json:"result"`
}

func InstallAgentToMcis(nsId string, mcisId string, req *McisCmdReq) (AgentInstallContentWrapper, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov0" title="0">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov0" title="0">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov0" title="0">content := AgentInstallContentWrapper{}

        //install script
        cmd := "wget https://github.com/cloud-barista/cb-milkyway/raw/master/src/milkyway -O ~/milkyway; chmod +x ~/milkyway; ~/milkyway &gt; /dev/null 2&gt;&amp;1 &amp; netstat -tulpn | grep milkyway"

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>

        //goroutin sync wg
        <span class="cov0" title="0">var wg sync.WaitGroup

        var resultArray []SshCmdResult

        for _, v := range vmList </span><span class="cov0" title="0">{

                vmId := v
                vmIp, sshPort := GetVmIp(nsId, mcisId, vmId)

                //cmd := req.Command

                // userName, sshKey := GetVmSshKey(nsId, mcisId, vmId)
                // if (userName == "") {
                //         userName = req.UserName
                // }
                // if (userName == "") {
                //         userName = sshDefaultUserName
                // }

                // find vaild username
                userName, sshKey, err := VerifySshUserName(nsId, mcisId, vmId, vmIp, sshPort, req.UserName)

                fmt.Println("[SSH] " + mcisId + "/" + vmId + "(" + vmIp + ")" + "with userName:" + userName)
                fmt.Println("[CMD] " + cmd)

                // Avoid RunSSH to not ready VM
                if err != nil </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go RunSSHAsync(&amp;wg, vmId, vmIp, sshPort, userName, sshKey, cmd, &amp;resultArray)
                }</span> else<span class="cov0" title="0"> {
                        common.CBLog.Error(err)
                        sshResultTmp := SshCmdResult{}
                        sshResultTmp.McisId = mcisId
                        sshResultTmp.VmId = vmId
                        sshResultTmp.VmIp = vmIp
                        sshResultTmp.Result = err.Error()
                        sshResultTmp.Err = err
                }</span>

        }
        <span class="cov0" title="0">wg.Wait() //goroutin sync wg

        for _, v := range resultArray </span><span class="cov0" title="0">{

                resultTmp := AgentInstallContent{}
                resultTmp.McisId = mcisId
                resultTmp.VmId = v.VmId
                resultTmp.VmIp = v.VmIp
                resultTmp.Result = v.Result
                content.Result_array = append(content.Result_array, resultTmp)
                //fmt.Println("result from goroutin " + v)
        }</span>

        //fmt.Printf("%+v\n", content)
        <span class="cov0" title="0">common.PrintJsonPretty(content)

        return content, nil</span>

}

type SpecBenchmarkInfo struct {
        SpecId     string `json:"specid"`
        Cpus       string `json:"cpus"`
        Cpum       string `json:"cpum"`
        MemR       string `json:"memR"`
        MemW       string `json:"memW"`
        FioR       string `json:"fioR"`
        FioW       string `json:"fioW"`
        DbR        string `json:"dbR"`
        DbW        string `json:"dbW"`
        Rtt        string `json:"rtt"`
        EvaledTime string `json:"evaledTime"`
}

type BenchmarkInfo struct {
        Result      string          `json:"result"`
        Unit        string          `json:"unit"`
        Desc        string          `json:"desc"`
        Elapsed     string          `json:"elapsed"`
        SpecId      string          `json:"specid"`
        ResultArray []BenchmarkInfo `json:"resultarray"` // struct-element cycle ?
}

type BenchmarkInfoArray struct {
        ResultArray []BenchmarkInfo `json:"resultarray"`
}

type BenchmarkReq struct {
        Host string `json:"host"`
        Spec string `json:"spec"`
}

type MultihostBenchmarkReq struct {
        Multihost []BenchmarkReq `json:"multihost"`
}

func CallMilkyway(wg *sync.WaitGroup, vmList []string, nsId string, mcisId string, vmId string, vmIp string, action string, option string, results *BenchmarkInfoArray) <span class="cov0" title="0">{
        defer wg.Done() //goroutine sync done

        url := "http://" + vmIp + milkywayPort + action
        method := "GET"

        client := &amp;http.Client{
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse
                }</span>,
        }

        // Create Req body
        <span class="cov0" title="0">type JsonTemplate struct {
                Host string `json:"host"`
        }
        tempReq := JsonTemplate{}
        tempReq.Host = option
        payload, _ := json.MarshalIndent(tempReq, "", "  ")

        if action == "mrtt" </span><span class="cov0" title="0">{
                reqTmp := MultihostBenchmarkReq{}
                for _, vm := range vmList </span><span class="cov0" title="0">{
                        vmIdTmp := vm
                        vmIpTmp, _ := GetVmIp(nsId, mcisId, vmIdTmp)
                        fmt.Println("[Test for vmList " + vmIdTmp + ", " + vmIpTmp + "]")

                        hostTmp := BenchmarkReq{}
                        hostTmp.Host = vmIpTmp
                        hostTmp.Spec = GetVmSpecId(nsId, mcisId, vmIdTmp)
                        reqTmp.Multihost = append(reqTmp.Multihost, hostTmp)
                }</span>
                <span class="cov0" title="0">common.PrintJsonPretty(reqTmp)
                payload, _ = json.MarshalIndent(reqTmp, "", "  ")</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))
        req.Header.Add("Content-Type", "application/json")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
        <span class="cov0" title="0">errStr := ""
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        body, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>
        <span class="cov0" title="0">fmt.Println(string(body))

        fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
        switch </span>{
        case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                err := fmt.Errorf(string(body))
                common.CBLog.Error(err)
                errStr = err.Error()</span>
        }

        //benchInfoTmp := BenchmarkInfo{}
        <span class="cov0" title="0">resultTmp := BenchmarkInfo{}
        err2 := json.Unmarshal(body, &amp;resultTmp)
        if err2 != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err2)
                errStr = err2.Error()
        }</span>
        //benchInfoTmp.ResultArray =  resultTmp.ResultArray
        <span class="cov0" title="0">if errStr != "" </span><span class="cov0" title="0">{
                resultTmp.Result = errStr
        }</span>
        <span class="cov0" title="0">resultTmp.SpecId = GetVmSpecId(nsId, mcisId, vmId)
        results.ResultArray = append(results.ResultArray, resultTmp)</span>
}

func CoreGetAllBenchmark(nsId string, mcisId string, host string) (*BenchmarkInfoArray, error) <span class="cov8" title="1">{

        var err error

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;BenchmarkInfoArray{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">target := host

        action := "all"
        fmt.Println("[Get MCIS benchmark action: " + action + target)

        option := "localhost"
        option = target

        content := BenchmarkInfoArray{}

        allBenchCmd := []string{"cpus", "cpum", "memR", "memW", "fioR", "fioW", "dbR", "dbW", "rtt"}

        resultMap := make(map[string]SpecBenchmarkInfo)

        for i, v := range allBenchCmd </span><span class="cov8" title="1">{
                fmt.Println("[Benchmark] " + v)
                content, err = BenchmarkAction(nsId, mcisId, v, option)
                for _, k := range content.ResultArray </span><span class="cov8" title="1">{
                        SpecId := k.SpecId
                        Result := k.Result
                        specBenchInfoTmp := SpecBenchmarkInfo{}

                        val, exist := resultMap[SpecId]
                        if exist </span><span class="cov8" title="1">{
                                specBenchInfoTmp = val
                        }</span> else<span class="cov8" title="1"> {
                                specBenchInfoTmp.SpecId = SpecId
                        }</span>

                        <span class="cov8" title="1">switch i </span>{
                        case 0:<span class="cov8" title="1">
                                specBenchInfoTmp.Cpus = Result</span>
                        case 1:<span class="cov8" title="1">
                                specBenchInfoTmp.Cpum = Result</span>
                        case 2:<span class="cov8" title="1">
                                specBenchInfoTmp.MemR = Result</span>
                        case 3:<span class="cov8" title="1">
                                specBenchInfoTmp.MemW = Result</span>
                        case 4:<span class="cov8" title="1">
                                specBenchInfoTmp.FioR = Result</span>
                        case 5:<span class="cov8" title="1">
                                specBenchInfoTmp.FioW = Result</span>
                        case 6:<span class="cov8" title="1">
                                specBenchInfoTmp.DbR = Result</span>
                        case 7:<span class="cov8" title="1">
                                specBenchInfoTmp.DbW = Result</span>
                        case 8:<span class="cov8" title="1">
                                specBenchInfoTmp.Rtt = Result</span>
                        }

                        <span class="cov8" title="1">resultMap[SpecId] = specBenchInfoTmp</span>

                }
        }

        <span class="cov8" title="1">file, err := os.OpenFile("benchmarking.csv", os.O_CREATE|os.O_WRONLY, 0777)
        defer file.Close()
        csvWriter := csv.NewWriter(file)
        strsTmp := []string{}
        for key, val := range resultMap </span><span class="cov8" title="1">{
                strsTmp = nil
                fmt.Println(key, val)
                strsTmp = append(strsTmp, val.SpecId)
                strsTmp = append(strsTmp, val.Cpus)
                strsTmp = append(strsTmp, val.Cpum)
                strsTmp = append(strsTmp, val.MemR)
                strsTmp = append(strsTmp, val.MemW)
                strsTmp = append(strsTmp, val.FioR)
                strsTmp = append(strsTmp, val.FioW)
                strsTmp = append(strsTmp, val.DbR)
                strsTmp = append(strsTmp, val.DbW)
                strsTmp = append(strsTmp, val.Rtt)
                csvWriter.Write(strsTmp)
                csvWriter.Flush()
        }</span>

        <span class="cov8" title="1">file2, err := os.OpenFile("rttmap.csv", os.O_CREATE|os.O_WRONLY, 0777)
        defer file2.Close()
        csvWriter2 := csv.NewWriter(file2)

        const mrttArrayXMax = 50
        const mrttArrayYMax = 50
        mrttArray := make([][]string, mrttArrayXMax)
        for i := 0; i &lt; mrttArrayXMax; i++ </span><span class="cov8" title="1">{
                mrttArray[i] = make([]string, mrttArrayYMax)
                for j := 0; j &lt; mrttArrayYMax; j++ </span><span class="cov8" title="1">{
                        mrttArray[i][j] = "0"
                }</span>
        }

        <span class="cov8" title="1">rttIndexMapX := make(map[string]int)
        cntTargetX := 1
        rttIndexMapY := make(map[string]int)
        cntTargetY := 1

        action = "mrtt"
        fmt.Println("[Benchmark] " + action)
        content, err = BenchmarkAction(nsId, mcisId, action, option)
        for _, k := range content.ResultArray </span><span class="cov8" title="1">{
                SpecId := k.SpecId
                iX, exist := rttIndexMapX[SpecId]
                if !exist </span><span class="cov8" title="1">{
                        rttIndexMapX[SpecId] = cntTargetX
                        iX = cntTargetX
                        mrttArray[iX][0] = SpecId
                        cntTargetX++
                }</span>
                <span class="cov8" title="1">for _, m := range k.ResultArray </span><span class="cov0" title="0">{
                        tagetSpecId := m.SpecId
                        tagetRtt := m.Result
                        iY, exist2 := rttIndexMapY[tagetSpecId]
                        if !exist2 </span><span class="cov0" title="0">{
                                rttIndexMapY[tagetSpecId] = cntTargetY
                                iY = cntTargetY
                                mrttArray[0][iY] = tagetSpecId
                                cntTargetY++
                        }</span>
                        <span class="cov0" title="0">mrttArray[iX][iY] = tagetRtt</span>
                }
        }

        <span class="cov8" title="1">csvWriter2.WriteAll(mrttArray)
        csvWriter2.Flush()

        if err != nil </span><span class="cov0" title="0">{
                //mapError := map[string]string{"message": "Benchmark Error"}
                //return c.JSON(http.StatusFailedDependency, &amp;mapError)
                return nil, fmt.Errorf("Benchmark Error")
        }</span>

        <span class="cov8" title="1">return &amp;content, nil</span>
}

func CoreGetBenchmark(nsId string, mcisId string, action string, host string) (*BenchmarkInfoArray, error) <span class="cov8" title="1">{

        var err error

        err = common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := BenchmarkInfoArray{}
                common.CBLog.Error(err)
                return &amp;temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;BenchmarkInfoArray{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">target := host

        fmt.Println("[Get MCIS benchmark action: " + action + target)

        option := "localhost"
        option = target

        content := BenchmarkInfoArray{}

        vaildActions := "install init cpus cpum memR memW fioR fioW dbR dbW rtt mrtt clean"

        fmt.Println("[Benchmark] " + action)
        if strings.Contains(vaildActions, action) </span><span class="cov8" title="1">{
                content, err = BenchmarkAction(nsId, mcisId, action, option)
        }</span> else<span class="cov0" title="0"> {
                //mapA := map[string]string{"message": "Not available action"}
                //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                return nil, fmt.Errorf("Not available action")
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                //mapError := map[string]string{"message": "Benchmark Error"}
                //return c.JSON(http.StatusFailedDependency, &amp;mapError)
                return nil, fmt.Errorf("Benchmark Error")
        }</span>

        <span class="cov8" title="1">return &amp;content, nil</span>
}

func BenchmarkAction(nsId string, mcisId string, action string, option string) (BenchmarkInfoArray, error) <span class="cov8" title="1">{

        var results BenchmarkInfoArray

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return BenchmarkInfoArray{}, err
        }</span>

        //goroutin sync wg
        <span class="cov8" title="1">var wg sync.WaitGroup

        for _, v := range vmList </span><span class="cov8" title="1">{
                wg.Add(1)

                vmId := v
                vmIp, _ := GetVmIp(nsId, mcisId, vmId)

                go CallMilkyway(&amp;wg, vmList, nsId, mcisId, vmId, vmIp, action, option, &amp;results)
        }</span>
        <span class="cov8" title="1">wg.Wait() //goroutine sync wg

        return results, nil</span>

}

/*
func BenchmarkAction(nsId string, mcisId string, action string, option string) (BenchmarkInfoArray, error) {


        var results BenchmarkInfoArray

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil {
                common.CBLog.Error(err)
                return BenchmarkInfoArray{}, err
        }

        for _, v := range vmList {

                vmId := v
                vmIp := GetVmIp(nsId, mcisId, vmId)

                url := "http://"+ vmIp + milkywayPort + action
                method := "GET"

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error {
                                return http.ErrUseLastResponse
                        },
                }



                // Create Req body
                type JsonTemplate struct {
                        Host string `json:"host"`
                }
                tempReq := JsonTemplate{}
                tempReq.Host = option
                payload, _ := json.MarshalIndent(tempReq, "", "  ")

                if action == "mrtt" {
                        reqTmp := MultihostBenchmarkReq{}
                        for _, vm := range vmList {
                                vmIdTmp := vm
                                vmIpTmp := GetVmIp(nsId, mcisId, vmIdTmp)
                                fmt.Println("[Test for vmList " + vmIdTmp + ", " +vmIpTmp + "]")

                                hostTmp := BenchmarkReq{}
                                hostTmp.Host = vmIpTmp
                                reqTmp.Multihost = append(reqTmp.Multihost, hostTmp)
                        }
                        common.PrintJsonPretty(reqTmp)
                        payload, _ = json.MarshalIndent(reqTmp, "", "  ")
                }

                req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))
                req.Header.Add("Content-Type", "application/json")
                if err != nil {
                        fmt.Println(err)
                }

                res, err := client.Do(req)
                if err != nil {
                        common.CBLog.Error(err)
                        return BenchmarkInfoArray{}, err
                }
                defer res.Body.Close()

                body, err := ioutil.ReadAll(res.Body)
                if err != nil {
                        common.CBLog.Error(err)
                        return BenchmarkInfoArray{}, err
                }
                fmt.Println(string(body))

                fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch {
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:
                        err := fmt.Errorf(string(body))
                        common.CBLog.Error(err)
                        return BenchmarkInfoArray{}, err
                }

                if action == "mrtt" {
                        //benchInfoTmp := BenchmarkInfo{}
                        resultTmp := BenchmarkInfo{}
                        err2 := json.Unmarshal(body, &amp;resultTmp)
                        if err2 != nil {
                                common.CBLog.Error(err2)
                                return BenchmarkInfoArray{}, err2
                        }
                        //benchInfoTmp.ResultArray =  resultTmp.ResultArray
                        results.ResultArray = append(results.ResultArray, resultTmp)

                } else{
                        resultTmp := BenchmarkInfo{}
                        err2 := json.Unmarshal(body, &amp;resultTmp)
                        if err2 != nil {
                                common.CBLog.Error(err2)
                                return BenchmarkInfoArray{}, err2
                        }
                        results.ResultArray = append(results.ResultArray, resultTmp)
                }

        }

        return results, nil

}
*/

// MCIS Information Managemenet

/*
func AddVmInfoToMcis(nsId string, mcisId string, vmInfoData TbVmInfo) {

        key := common.GenMcisKey(nsId, mcisId, vmInfoData.Id)
        val, _ := json.Marshal(vmInfoData)
        err := common.CBStore.Put(string(key), string(val))
        if err != nil {
                common.CBLog.Error(err)
        }
        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")

}
*/

// UpdateMcisInfo func Update MCIS Info (without VM info in MCIS)
func UpdateMcisInfo(nsId string, mcisInfoData TbMcisInfo) <span class="cov8" title="1">{

        mcisInfoData.Vm = nil

        key := common.GenMcisKey(nsId, mcisInfoData.Id, "")

        // Check existence of the key. If no key, no update.
        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">mcisTmp := TbMcisInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)

        if !reflect.DeepEqual(mcisTmp, mcisInfoData) </span><span class="cov8" title="1">{
                val, _ := json.Marshal(mcisInfoData)
                err = common.CBStore.Put(string(key), string(val))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                }</span>
        }
        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")
}

func UpdateVmInfo(nsId string, mcisId string, vmInfoData TbVmInfo) <span class="cov8" title="1">{
        key := common.GenMcisKey(nsId, mcisId, vmInfoData.Id)

        // Check existence of the key. If no key, no update.
        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">vmTmp := TbVmInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;vmTmp)

        if !reflect.DeepEqual(vmTmp, vmInfoData) </span><span class="cov8" title="1">{
                val, _ := json.Marshal(vmInfoData)
                err = common.CBStore.Put(string(key), string(val))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                }</span>
        }

        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")
}

func ListMcisId(nsId string) ([]string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        // fmt.Println("[ListMcisId]")
        <span class="cov8" title="1">var mcisList []string

        // Check MCIS exists
        key := common.GenMcisKey(nsId, "", "")
        key += "/"

        keyValue, err := common.CBStore.GetList(key, true)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, v := range keyValue </span><span class="cov8" title="1">{
                if strings.Contains(v.Key, "/mcis/") </span><span class="cov8" title="1">{
                        trimmedString := strings.TrimPrefix(v.Key, (key + "mcis/"))
                        // prevent malformed key (if key for mcis id includes '/', the key does not represent MCIS ID)
                        if !strings.Contains(trimmedString, "/") </span><span class="cov8" title="1">{
                                mcisList = append(mcisList, trimmedString)
                        }</span>
                }
        }

        <span class="cov8" title="1">return mcisList, nil</span>
}

func ListVmId(nsId string, mcisId string) ([]string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        // fmt.Println("[ListVmId]")
        <span class="cov8" title="1">var vmList []string

        // Check MCIS exists
        key := common.GenMcisKey(nsId, mcisId, "")
        key += "/"

        _, err = common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("[Not found] " + mcisId)
                common.CBLog.Error(err)
                return vmList, err
        }</span>

        <span class="cov8" title="1">keyValue, err := common.CBStore.GetList(key, true)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, v := range keyValue </span><span class="cov8" title="1">{
                if strings.Contains(v.Key, "/vm/") </span><span class="cov8" title="1">{
                        trimmedString := strings.TrimPrefix(v.Key, (key + "vm/"))
                        // prevent malformed key (if key for vm id includes '/', the key does not represent VM ID)
                        if !strings.Contains(trimmedString, "/") </span><span class="cov8" title="1">{
                                vmList = append(vmList, trimmedString)
                        }</span>
                }
        }
        /*
                for _, v := range vmList {
                        fmt.Println("&lt;" + v + "&gt;")
                }
                fmt.Println("===============================================")
        */
        <span class="cov8" title="1">return vmList, nil</span>

}

// func ListVmGroupId returns list of VmGroups in a given MCIS.
func ListVmGroupId(nsId string, mcisId string) ([]string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[ListVmGroupId]")
        key := common.GenMcisKey(nsId, mcisId, "")
        key += "/"

        keyValue, err := common.CBStore.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">var vmGroupList []string
        for _, v := range keyValue </span><span class="cov8" title="1">{
                if strings.Contains(v.Key, "/vmgroup/") </span><span class="cov8" title="1">{
                        trimmedString := strings.TrimPrefix(v.Key, (key + "vmgroup/"))
                        // prevent malformed key (if key for vm id includes '/', the key does not represent VM ID)
                        if !strings.Contains(trimmedString, "/") </span><span class="cov8" title="1">{
                                vmGroupList = append(vmGroupList, trimmedString)
                        }</span>
                }
        }
        <span class="cov8" title="1">return vmGroupList, nil</span>
}

func DelMcis(nsId string, mcisId string, option string) error <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov8" title="1">{
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Delete MCIS] " + mcisId)

        // // ControlMcis first
        // err = ControlMcisAsync(nsId, mcisId, ActionTerminate)
        // if err != nil {
        //         common.CBLog.Error(err)
        //         if option != "force" {
        //                 return err
        //         }
        // }
        // // for deletion, need to wait until termination is finished
        // // Sleep for 5 seconds
        // fmt.Printf("\n\n[Info] Sleep for 5 seconds for safe MCIS-VMs termination.\n\n")
        // time.Sleep(5 * time.Second)

        // Check MCIS status is Terminated so that approve deletion
        mcisStatus, _ := GetMcisStatus(nsId, mcisId)
        if mcisStatus == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("MCIS " + mcisId + " status nil, Deletion is not allowed (use option=force for force deletion)")
                common.CBLog.Error(err)
                if option != "force" </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // Check MCIS status is Terminated (not Partial)
        <span class="cov8" title="1">if !(!strings.Contains(mcisStatus.Status, "Partial-") &amp;&amp; (strings.Contains(mcisStatus.Status, StatusTerminated) || strings.Contains(mcisStatus.Status, StatusUndefined) || strings.Contains(mcisStatus.Status, StatusFailed))) </span><span class="cov0" title="0">{
                err := fmt.Errorf("MCIS " + mcisId + " is " + mcisStatus.Status + " and not " + StatusTerminated + "/" + StatusUndefined + "/" + StatusFailed + ", Deletion is not allowed (use option=force for force deletion)")
                common.CBLog.Error(err)
                if option != "force" </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">key := common.GenMcisKey(nsId, mcisId, "")
        fmt.Println(key)

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        // delete vms info
        <span class="cov8" title="1">for _, v := range vmList </span><span class="cov8" title="1">{
                vmKey := common.GenMcisKey(nsId, mcisId, v)
                fmt.Println(vmKey)

                // get vm info
                vmInfo, err := GetVmObject(nsId, mcisId, v)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">err = common.CBStore.Delete(vmKey)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">mcir.UpdateAssociatedObjectList(nsId, common.StrImage, vmInfo.ImageId, common.StrDelete, vmKey)
                mcir.UpdateAssociatedObjectList(nsId, common.StrSpec, vmInfo.SpecId, common.StrDelete, vmKey)
                mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfo.SshKeyId, common.StrDelete, vmKey)
                mcir.UpdateAssociatedObjectList(nsId, common.StrVNet, vmInfo.VNetId, common.StrDelete, vmKey)

                for _, v2 := range vmInfo.SecurityGroupIds </span><span class="cov8" title="1">{
                        mcir.UpdateAssociatedObjectList(nsId, common.StrSecurityGroup, v2, common.StrDelete, vmKey)
                }</span>
        }

        // delete vm group info
        <span class="cov8" title="1">vmGroupList, err := ListVmGroupId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">for _, v := range vmGroupList </span><span class="cov8" title="1">{
                vmGroupKey := common.GenMcisVmGroupKey(nsId, mcisId, v)
                fmt.Println(vmGroupKey)
                err := common.CBStore.Delete(vmGroupKey)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>
        }

        // delete mcis info
        <span class="cov8" title="1">err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func DelMcisVm(nsId string, mcisId string, vmId string, option string) error <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Delete VM] " + vmId)

        // ControlVm first
        err = ControlVm(nsId, mcisId, vmId, ActionTerminate)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                if option != "force" </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // for deletion, need to wait until termination is finished
        // Sleep for 5 seconds
        <span class="cov8" title="1">fmt.Printf("\n\n[Info] Sleep for 20 seconds for safe VM termination.\n\n")
        time.Sleep(5 * time.Second)

        // get vm info
        vmInfo, _ := GetVmObject(nsId, mcisId, vmId)

        // delete vms info
        key := common.GenMcisKey(nsId, mcisId, vmId)
        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">mcir.UpdateAssociatedObjectList(nsId, common.StrImage, vmInfo.ImageId, common.StrDelete, key)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSpec, vmInfo.SpecId, common.StrDelete, key)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfo.SshKeyId, common.StrDelete, key)
        mcir.UpdateAssociatedObjectList(nsId, common.StrVNet, vmInfo.VNetId, common.StrDelete, key)

        for _, v2 := range vmInfo.SecurityGroupIds </span><span class="cov8" title="1">{
                mcir.UpdateAssociatedObjectList(nsId, common.StrSecurityGroup, v2, common.StrDelete, key)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

//// Info manage for MCIS recommendation
func GetRecommendList(nsId string, cpuSize string, memSize string, diskSize string) ([]TbVmPriority, error) <span class="cov0" title="0">{

        fmt.Println("GetRecommendList")

        var content struct {
                Id             string
                Price          string
                ConnectionName string
        }
        //fmt.Println("[Get MCISs")
        key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + cpuSize + "/memSize/" + memSize + "/diskSize/" + diskSize
        fmt.Println(key)
        keyValue, err := common.CBStore.GetList(key, true)
        keyValue = cbstore_utils.GetChildList(keyValue, key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return []TbVmPriority{}, err
        }</span>

        <span class="cov0" title="0">var vmPriorityList []TbVmPriority

        for cnt, v := range keyValue </span><span class="cov0" title="0">{
                fmt.Println("getRecommendList1: " + v.Key)
                err = json.Unmarshal([]byte(v.Value), &amp;content)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return []TbVmPriority{}, err
                }</span>

                <span class="cov0" title="0">content2 := mcir.TbSpecInfo{}
                key2 := common.GenResourceKey(nsId, common.StrSpec, content.Id)

                keyValue2, err := common.CBStore.Get(key2)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return []TbVmPriority{}, err
                }</span>
                <span class="cov0" title="0">json.Unmarshal([]byte(keyValue2.Value), &amp;content2)
                content2.Id = content.Id

                vmPriorityTmp := TbVmPriority{}
                vmPriorityTmp.Priority = strconv.Itoa(cnt)
                vmPriorityTmp.VmSpec = content2
                vmPriorityList = append(vmPriorityList, vmPriorityTmp)</span>
        }

        <span class="cov0" title="0">fmt.Println("===============================================")
        return vmPriorityList, err</span>

        //requires error handling

}

// MCIS Control

func HandleMcisAction(nsId string, mcisId string, action string) (string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov8" title="1">{
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return err.Error(), err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Get MCIS requested action: " + action)
        if action == "suspend" </span><span class="cov8" title="1">{
                fmt.Println("[suspend MCIS]")

                err := ControlMcisAsync(nsId, mcisId, ActionSuspend)
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", err
                }</span>

                //mapA := map[string]string{"message": "Suspending the MCIS"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                <span class="cov8" title="1">return "Suspending the MCIS", nil</span>

        } else<span class="cov8" title="1"> if action == "resume" </span><span class="cov8" title="1">{
                fmt.Println("[resume MCIS]")

                err := ControlMcisAsync(nsId, mcisId, ActionResume)
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", err
                }</span>

                //mapA := map[string]string{"message": "Resuming the MCIS"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                <span class="cov8" title="1">return "Resuming the MCIS", nil</span>

        } else<span class="cov8" title="1"> if action == "reboot" </span><span class="cov8" title="1">{
                fmt.Println("[reboot MCIS]")

                err := ControlMcisAsync(nsId, mcisId, ActionReboot)
                if err != nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": err.Error()}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", err
                }</span>

                //mapA := map[string]string{"message": "Rebooting the MCIS"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                <span class="cov8" title="1">return "Rebooting the MCIS", nil</span>

        } else<span class="cov8" title="1"> if action == "terminate" </span><span class="cov8" title="1">{
                fmt.Println("[terminate MCIS]")

                vmList, err := ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return "", err
                }</span>

                //fmt.Println("len(vmList) %d ", len(vmList))
                <span class="cov8" title="1">if len(vmList) == 0 </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": "No VM to terminate in the MCIS"}
                        //return c.JSON(http.StatusOK, &amp;mapA)
                        return "No VM to terminate in the MCIS", nil
                }</span>

                /*
                        for _, v := range vmList {
                                ControlVm(nsId, mcisId, v, ActionTerminate)
                        }
                */
                <span class="cov8" title="1">err = ControlMcisAsync(nsId, mcisId, ActionTerminate)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">return "Terminating the MCIS", nil</span>

        } else<span class="cov8" title="1"> if action == "refine" </span><span class="cov8" title="1">{ //refine delete VMs in StatusFailed or StatusUndefined
                fmt.Println("[terminate MCIS]")

                vmList, err := ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return "", err
                }</span>

                <span class="cov8" title="1">if len(vmList) == 0 </span><span class="cov0" title="0">{
                        return "No VM in the MCIS", nil
                }</span>

                <span class="cov8" title="1">mcisStatus, err := GetMcisStatus(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return "", err
                }</span>

                <span class="cov8" title="1">for _, v := range mcisStatus.Vm </span><span class="cov8" title="1">{

                        // Remove VMs in StatusFailed or StatusUndefined
                        fmt.Println("[vmInfo.Status]", v.Status)
                        if v.Status == StatusFailed || v.Status == StatusUndefined </span><span class="cov0" title="0">{
                                // Delete VM sequentially for safety (for performance, need to use goroutine)
                                err := DelMcisVm(nsId, mcisId, v.Id, "force")
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return "", err
                                }</span>
                        }
                }

                <span class="cov8" title="1">return "Refined the MCIS", nil</span>

        } else<span class="cov0" title="0"> {
                return "", fmt.Errorf(action + " not supported")
        }</span>
}

// GetMcisInfo func returns MCIS information with the current status update
func GetMcisInfo(nsId string, mcisId string) (*TbMcisInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov8" title="1">{
                temp := &amp;TbMcisInfo{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">mcisObj, err := GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        // common.PrintJsonPretty(mcisObj)

        <span class="cov8" title="1">mcisStatus, err := GetMcisStatus(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        // common.PrintJsonPretty(mcisStatus)

        <span class="cov8" title="1">mcisObj.Status = mcisStatus.Status

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">for num := range vmList </span><span class="cov8" title="1">{
                //fmt.Println("[GetMcisInfo compare two VMs]")
                //common.PrintJsonPretty(mcisObj.Vm[num])
                //common.PrintJsonPretty(mcisStatus.Vm[num])

                mcisObj.Vm[num].Status = mcisStatus.Vm[num].Status
                mcisObj.Vm[num].TargetStatus = mcisStatus.Vm[num].TargetStatus
                mcisObj.Vm[num].TargetAction = mcisStatus.Vm[num].TargetAction
        }</span>

        <span class="cov8" title="1">return &amp;mcisObj, nil</span>
}

func CoreGetAllMcis(nsId string, option string) ([]TbMcisInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        /*
                var content struct {
                        //Name string     `json:"name"`
                        Mcis []mcis.TbMcisInfo `json:"mcis"`
                }
        */
        // content := RestGetAllMcisResponse{}

        <span class="cov8" title="1">Mcis := []TbMcisInfo{}

        mcisList, err := ListMcisId(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, v := range mcisList </span><span class="cov8" title="1">{

                key := common.GenMcisKey(nsId, v, "")
                //fmt.Println(key)
                keyValue, _ := common.CBStore.Get(key)
                if keyValue == nil </span><span class="cov0" title="0">{
                        //mapA := map[string]string{"message": "Cannot find " + key}
                        //return c.JSON(http.StatusOK, &amp;mapA)
                        return nil, fmt.Errorf("in CoreGetAllMcis() mcis loop; Cannot find " + key)
                }</span>
                //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                <span class="cov8" title="1">mcisTmp := TbMcisInfo{}
                json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
                mcisId := v
                mcisTmp.Id = mcisId

                if option == "status" </span><span class="cov8" title="1">{
                        //get current mcis status
                        mcisStatus, err := GetMcisStatus(nsId, mcisId)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">mcisTmp.Status = mcisStatus.Status</span>
                } else<span class="cov0" title="0"> {
                        //Set current mcis status with NullStr
                        mcisTmp.Status = ""
                }</span>

                <span class="cov8" title="1">vmList, err := ListVmId(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, err
                }</span>

                <span class="cov8" title="1">for _, v1 := range vmList </span><span class="cov8" title="1">{
                        vmKey := common.GenMcisKey(nsId, mcisId, v1)
                        //fmt.Println(vmKey)
                        vmKeyValue, _ := common.CBStore.Get(vmKey)
                        if vmKeyValue == nil </span><span class="cov0" title="0">{
                                //mapA := map[string]string{"message": "Cannot find " + key}
                                //return c.JSON(http.StatusOK, &amp;mapA)
                                return nil, fmt.Errorf("in CoreGetAllMcis() vm loop; Cannot find " + vmKey)
                        }</span>
                        //fmt.Println("&lt;" + vmKeyValue.Key + "&gt; \n" + vmKeyValue.Value)
                        //vmTmp := vmOverview{}
                        <span class="cov8" title="1">vmTmp := TbVmInfo{}
                        json.Unmarshal([]byte(vmKeyValue.Value), &amp;vmTmp)
                        vmTmp.Id = v1

                        if option == "status" </span><span class="cov8" title="1">{
                                //get current vm status
                                vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, v1)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                }</span>
                                <span class="cov8" title="1">vmTmp.Status = vmStatusInfoTmp.Status</span>
                        } else<span class="cov0" title="0"> {
                                //Set current vm status with NullStr
                                vmTmp.Status = ""
                        }</span>

                        <span class="cov8" title="1">mcisTmp.Vm = append(mcisTmp.Vm, vmTmp)</span>
                }

                <span class="cov8" title="1">Mcis = append(Mcis, mcisTmp)</span>

        }

        <span class="cov8" title="1">return Mcis, nil</span>
}

func CoreDelAllMcis(nsId string, option string) (string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">mcisList, err := ListMcisId(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">if len(mcisList) == 0 </span><span class="cov8" title="1">{
                //mapA := map[string]string{"message": "No MCIS to delete"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "No MCIS to delete", nil
        }</span>

        <span class="cov0" title="0">for _, v := range mcisList </span><span class="cov0" title="0">{
                err := DelMcis(nsId, v, option)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        //mapA := map[string]string{"message": "Failed to delete All MCISs"}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return "", fmt.Errorf("Failed to delete All MCISs")
                }</span>
        }

        <span class="cov0" title="0">return "All MCISs has been deleted", nil</span>
}

func CorePostMcisRecommend(nsId string, req *McisRecommendReq) ([]TbVmRecommendInfo, error) <span class="cov0" title="0">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        /*
                var content struct {
                        //VmReq          []TbVmRecommendReq    `json:"vmReq"`
                        Vm_recommend    []mcis.TbVmRecommendInfo `json:"vm_recommend"`
                        PlacementAlgo  string                   `json:"placementAlgo"`
                        PlacementParam []common.KeyValue        `json:"placementParam"`
                }
        */
        //content := RestPostMcisRecommendResponse{}
        //content.VmReq = req.VmReq
        //content.PlacementAlgo = req.PlacementAlgo
        //content.PlacementParam = req.PlacementParam

        <span class="cov0" title="0">Vm_recommend := []TbVmRecommendInfo{}

        vmList := req.VmReq

        for i, v := range vmList </span><span class="cov0" title="0">{
                vmTmp := TbVmRecommendInfo{}
                //vmTmp.RequestName = v.RequestName
                vmTmp.VmReq = req.VmReq[i]
                vmTmp.PlacementAlgo = v.PlacementAlgo
                vmTmp.PlacementParam = v.PlacementParam

                var err error
                vmTmp.VmPriority, err = GetRecommendList(nsId, v.VcpuSize, v.MemorySize, v.DiskSize)

                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        //mapA := map[string]string{"message": "Failed to recommend MCIS"}
                        //return c.JSON(http.StatusFailedDependency, &amp;mapA)
                        return nil, fmt.Errorf("Failed to recommend MCIS")
                }</span>

                <span class="cov0" title="0">Vm_recommend = append(Vm_recommend, vmTmp)</span>
        }

        <span class="cov0" title="0">return Vm_recommend, nil</span>
}

func CorePostCmdMcisVm(nsId string, mcisId string, vmId string, req *McisCmdReq) (string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov8" title="1">{
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return err.Error(), err
        }</span>

        <span class="cov8" title="1">vmIp, sshPort := GetVmIp(nsId, mcisId, vmId)

        //fmt.Printf("[vmIp] " +vmIp)

        //sshKey := req.SshKey
        cmd := req.Command

        // find vaild username
        userName, sshKey, err := VerifySshUserName(nsId, mcisId, vmId, vmIp, sshPort, req.UserName)

        if err != nil || userName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Not found: valid ssh username, " + err.Error())
        }</span>

        <span class="cov8" title="1">fmt.Println("[SSH] " + mcisId + "/" + vmId + "(" + vmIp + ")" + "with userName:" + userName)
        fmt.Println("[CMD] " + cmd)

        if result, err := RunSSH(vmIp, sshPort, userName, sshKey, cmd); err != nil </span><span class="cov0" title="0">{
                //return c.JSON(http.StatusInternalServerError, err)
                return "", err
        }</span> else<span class="cov8" title="1"> {
                //response := echo.Map{}
                //response["result"] = *result
                //response := RestPostCmdMcisVmResponse{Result: *result}
                //return c.JSON(http.StatusOK, response)
                return *result, nil
        }</span>
}

func CorePostCmdMcis(nsId string, mcisId string, req *McisCmdReq) ([]SshCmdResult, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov8" title="1">{
                temp := []SshCmdResult{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        /*
                type contentSub struct {
                        McisId string `json:"mcisId"`
                        VmId   string `json:"vmId"`
                        VmIp   string `json:"vmIp"`
                        Result  string `json:"result"`
                }
                var content struct {
                        Result_array []contentSub `json:"result_array"`
                }
        */
        //content := RestPostCmdMcisResponseWrapper{}

        <span class="cov8" title="1">vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        //goroutine sync wg
        <span class="cov8" title="1">var wg sync.WaitGroup

        var resultArray []SshCmdResult

        for _, v := range vmList </span><span class="cov8" title="1">{

                vmId := v
                vmIp, sshPort := GetVmIp(nsId, mcisId, vmId)

                cmd := req.Command

                // userName, sshKey := GetVmSshKey(nsId, mcisId, vmId)
                // if (userName == "") {
                //         userName = req.UserName
                // }
                // if (userName == "") {
                //         userName = sshDefaultUserName
                // }
                // find vaild username
                userName, sshKey, err := VerifySshUserName(nsId, mcisId, vmId, vmIp, sshPort, req.UserName)

                fmt.Println("[SSH] " + mcisId + "/" + vmId + "(" + vmIp + ")" + "with userName:" + userName)
                fmt.Println("[CMD] " + cmd)

                // Avoid RunSSH to not ready VM
                if err == nil </span><span class="cov8" title="1">{
                        wg.Add(1)
                        go RunSSHAsync(&amp;wg, vmId, vmIp, sshPort, userName, sshKey, cmd, &amp;resultArray)
                }</span> else<span class="cov0" title="0"> {
                        common.CBLog.Error(err)
                        sshResultTmp := SshCmdResult{}
                        sshResultTmp.McisId = mcisId
                        sshResultTmp.VmId = vmId
                        sshResultTmp.VmIp = vmIp
                        sshResultTmp.Result = err.Error()
                        sshResultTmp.Err = err
                }</span>

        }
        <span class="cov8" title="1">wg.Wait() //goroutine sync wg

        return resultArray, nil</span>
}

func CorePostMcisVm(nsId string, mcisId string, vmInfoData *TbVmInfo) (*TbVmInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(vmInfoData.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckVm(nsId, mcisId, vmInfoData.Name)

        if check </span><span class="cov8" title="1">{
                temp := &amp;TbVmInfo{}
                err := fmt.Errorf("The vm " + vmInfoData.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">targetAction := ActionCreate
        targetStatus := StatusRunning

        vmInfoData.Id = vmInfoData.Name
        vmInfoData.PublicIP = "Not assigned yet"
        vmInfoData.PublicDNS = "Not assigned yet"
        vmInfoData.TargetAction = targetAction
        vmInfoData.TargetStatus = targetStatus
        vmInfoData.Status = StatusCreating

        //goroutin
        var wg sync.WaitGroup
        wg.Add(1)

        go AddVmToMcis(&amp;wg, nsId, mcisId, vmInfoData)

        wg.Wait()

        vmStatus, err := GetVmStatus(nsId, mcisId, vmInfoData.Id)
        if err != nil </span><span class="cov0" title="0">{
                //mapA := map[string]string{"message": "Cannot find " + common.GenMcisKey(nsId, mcisId, "")}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return nil, fmt.Errorf("Cannot find " + common.GenMcisKey(nsId, mcisId, vmInfoData.Id))
        }</span>

        <span class="cov8" title="1">vmInfoData.Status = vmStatus.Status
        vmInfoData.TargetStatus = vmStatus.TargetStatus
        vmInfoData.TargetAction = vmStatus.TargetAction

        // Install CB-Dragonfly monitoring agent

        mcisTmp, _ := GetMcisObject(nsId, mcisId)

        fmt.Printf("\n[Init monitoring agent] for %+v\n - req.InstallMonAgent: %+v\n\n", mcisId, mcisTmp.InstallMonAgent)

        if mcisTmp.InstallMonAgent != "no" </span><span class="cov0" title="0">{

                // Sleep for 20 seconds for a safe DF agent installation.
                fmt.Printf("\n\n[Info] Sleep for 20 seconds for safe CB-Dragonfly Agent installation.\n\n")
                time.Sleep(20 * time.Second)

                check := CheckDragonflyEndpoint()
                if check != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\n\n[Warring] CB-Dragonfly is not available\n\n")
                }</span> else<span class="cov0" title="0"> {
                        reqToMon := &amp;McisCmdReq{}
                        reqToMon.UserName = "ubuntu" // this MCIS user name is temporal code. Need to improve.

                        fmt.Printf("\n[InstallMonitorAgentToMcis]\n\n")
                        content, err := InstallMonitorAgentToMcis(nsId, mcisId, reqToMon)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //mcisTmp.InstallMonAgent = "no"
                        }</span>
                        <span class="cov0" title="0">common.PrintJsonPretty(content)</span>
                        //mcisTmp.InstallMonAgent = "yes"
                }
        }

        <span class="cov8" title="1">return vmInfoData, nil</span>
}

// CorePostMcisGroupVm function is a wrapper for CreateMcisGroupVm
func CorePostMcisGroupVm(nsId string, mcisId string, vmReq *TbVmReq) (*TbMcisInfo, error) <span class="cov8" title="1">{

        content, err := CreateMcisGroupVm(nsId, mcisId, vmReq)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">return content, nil</span>
}

func CreateMcisGroupVm(nsId string, mcisId string, vmRequest *TbVmReq) (*TbMcisInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(vmRequest.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">mcisTmp, err := GetMcisObject(nsId, mcisId)

        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                return temp, err
        }</span>

        //vmRequest := req

        <span class="cov8" title="1">targetAction := ActionCreate
        targetStatus := StatusRunning

        //goroutin
        var wg sync.WaitGroup

        // VM Group handling
        vmGroupSize, _ := strconv.Atoi(vmRequest.VmGroupSize)
        fmt.Printf("vmGroupSize: %v\n", vmGroupSize)

        if vmGroupSize &gt; 0 </span><span class="cov8" title="1">{

                fmt.Println("=========================== Create MCIS VM Group object")
                key := common.GenMcisVmGroupKey(nsId, mcisId, vmRequest.Name)

                // TODO: Enhancement Required. Need to check existing VM Group. Need to update it if exist.
                vmGroupInfoData := TbVmGroupInfo{}
                vmGroupInfoData.Id = vmRequest.Name
                vmGroupInfoData.Name = vmRequest.Name
                vmGroupInfoData.VmGroupSize = vmRequest.VmGroupSize

                for i := 0; i &lt; vmGroupSize; i++ </span><span class="cov8" title="1">{
                        vmGroupInfoData.VmId = append(vmGroupInfoData.VmId, vmGroupInfoData.Id+"-"+strconv.Itoa(i))
                }</span>

                <span class="cov8" title="1">val, _ := json.Marshal(vmGroupInfoData)
                err := common.CBStore.Put(string(key), string(val))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                }</span>
                <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(key))
                fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                fmt.Println("===========================")</span>

        }

        <span class="cov8" title="1">for i := 0; i &lt;= vmGroupSize; i++ </span><span class="cov8" title="1">{
                vmInfoData := TbVmInfo{}

                if vmGroupSize == 0 </span><span class="cov0" title="0">{ // for VM (not in a group)
                        vmInfoData.Name = vmRequest.Name
                }</span> else<span class="cov8" title="1"> { // for VM (in a group)
                        if i == vmGroupSize </span><span class="cov8" title="1">{
                                break</span> // if vmGroupSize != 0 &amp;&amp; vmGroupSize == i, skip the final loop
                        }
                        <span class="cov8" title="1">vmInfoData.VmGroupId = vmRequest.Name
                        // TODO: Enhancement Required. Need to check existing VM Group. Need to update it if exist.
                        vmInfoData.Name = vmRequest.Name + "-" + strconv.Itoa(i)
                        fmt.Println("===========================")
                        fmt.Println("vmInfoData.Name: " + vmInfoData.Name)
                        fmt.Println("===========================")</span>

                }
                <span class="cov8" title="1">vmInfoData.Id = vmInfoData.Name

                vmInfoData.Description = vmRequest.Description
                vmInfoData.PublicIP = "Not assigned yet"
                vmInfoData.PublicDNS = "Not assigned yet"

                vmInfoData.Status = StatusCreating
                vmInfoData.TargetAction = targetAction
                vmInfoData.TargetStatus = targetStatus

                vmInfoData.ConnectionName = vmRequest.ConnectionName
                vmInfoData.SpecId = vmRequest.SpecId
                vmInfoData.ImageId = vmRequest.ImageId
                vmInfoData.VNetId = vmRequest.VNetId
                vmInfoData.SubnetId = vmRequest.SubnetId
                //vmInfoData.VnicId = vmRequest.VnicId
                //vmInfoData.PublicIpId = vmRequest.PublicIpId
                vmInfoData.SecurityGroupIds = vmRequest.SecurityGroupIds
                vmInfoData.SshKeyId = vmRequest.SshKeyId
                vmInfoData.Description = vmRequest.Description

                vmInfoData.VmUserAccount = vmRequest.VmUserAccount
                vmInfoData.VmUserPassword = vmRequest.VmUserPassword

                wg.Add(1)
                go AddVmToMcis(&amp;wg, nsId, mcisId, &amp;vmInfoData)</span>

        }

        <span class="cov8" title="1">wg.Wait()

        //Update MCIS status

        mcisTmp, err = GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                return temp, err
        }</span>

        <span class="cov8" title="1">mcisStatusTmp, _ := GetMcisStatus(nsId, mcisId)

        mcisTmp.Status = mcisStatusTmp.Status

        if mcisTmp.TargetStatus == mcisTmp.Status </span><span class="cov0" title="0">{
                mcisTmp.TargetStatus = StatusComplete
                mcisTmp.TargetAction = ActionComplete
        }</span>
        <span class="cov8" title="1">UpdateMcisInfo(nsId, mcisTmp)

        // Install CB-Dragonfly monitoring agent

        fmt.Printf("\n[Init monitoring agent] for %+v\n - req.InstallMonAgent: %+v\n\n", mcisId, mcisTmp.InstallMonAgent)
        if mcisTmp.InstallMonAgent != "no" </span><span class="cov0" title="0">{

                // Sleep for 60 seconds for a safe DF agent installation.
                fmt.Printf("\n\n[Info] Sleep for 60 seconds for safe CB-Dragonfly Agent installation.\n\n")
                time.Sleep(60 * time.Second)

                check := CheckDragonflyEndpoint()
                if check != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\n\n[Warring] CB-Dragonfly is not available\n\n")
                }</span> else<span class="cov0" title="0"> {
                        reqToMon := &amp;McisCmdReq{}
                        reqToMon.UserName = "ubuntu" // this MCIS user name is temporal code. Need to improve.

                        fmt.Printf("\n[InstallMonitorAgentToMcis]\n\n")
                        content, err := InstallMonitorAgentToMcis(nsId, mcisId, reqToMon)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //mcisTmp.InstallMonAgent = "no"
                        }</span>
                        <span class="cov0" title="0">common.PrintJsonPretty(content)</span>
                        //mcisTmp.InstallMonAgent = "yes"
                }
        }
        <span class="cov8" title="1">return &amp;mcisTmp, nil</span>

}

func CoreGetMcisVmAction(nsId string, mcisId string, vmId string, action string) (string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return err.Error(), err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Get VM requested action: " + action)
        if action == "suspend" </span><span class="cov8" title="1">{
                fmt.Println("[suspend VM]")

                ControlVm(nsId, mcisId, vmId, ActionSuspend)
                //mapA := map[string]string{"message": "Suspending the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Suspending the VM", nil

        }</span> else<span class="cov8" title="1"> if action == "resume" </span><span class="cov8" title="1">{
                fmt.Println("[resume VM]")

                ControlVm(nsId, mcisId, vmId, ActionResume)
                //mapA := map[string]string{"message": "Resuming the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Resuming the VM", nil

        }</span> else<span class="cov8" title="1"> if action == "reboot" </span><span class="cov8" title="1">{
                fmt.Println("[reboot VM]")

                ControlVm(nsId, mcisId, vmId, ActionReboot)
                //mapA := map[string]string{"message": "Rebooting the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Rebooting the VM", nil

        }</span> else<span class="cov8" title="1"> if action == "terminate" </span><span class="cov8" title="1">{
                fmt.Println("[terminate VM]")

                ControlVm(nsId, mcisId, vmId, ActionTerminate)

                //mapA := map[string]string{"message": "Terminating the VM"}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return "Terminating the VM", nil
        }</span> else<span class="cov0" title="0"> {
                return "", fmt.Errorf(action + " not supported")
        }</span>
}

func CoreGetMcisVmStatus(nsId string, mcisId string, vmId string) (*TbVmStatusInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;TbVmStatusInfo{}
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[status VM]")

        vmKey := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(vmKey)
        vmKeyValue, _ := common.CBStore.Get(vmKey)
        if vmKeyValue == nil </span><span class="cov0" title="0">{
                //mapA := map[string]string{"message": "Cannot find " + vmKey}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return nil, fmt.Errorf("Cannot find " + vmKey)
        }</span>

        <span class="cov8" title="1">vmStatusResponse, err := GetVmStatus(nsId, mcisId, vmId)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;vmStatusResponse, nil</span>
}

func CoreGetMcisVmInfo(nsId string, mcisId string, vmId string) (*TbVmInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckVm(nsId, mcisId, vmId)

        if !check </span><span class="cov0" title="0">{
                temp := &amp;TbVmInfo{}
                err := fmt.Errorf("The vm " + vmId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Get MCIS-VM info for id]" + vmId)

        key := common.GenMcisKey(nsId, mcisId, "")
        //fmt.Println(key)

        vmKey := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(vmKey)
        vmKeyValue, _ := common.CBStore.Get(vmKey)
        if vmKeyValue == nil </span><span class="cov0" title="0">{
                //mapA := map[string]string{"message": "Cannot find " + key}
                //return c.JSON(http.StatusOK, &amp;mapA)
                return nil, fmt.Errorf("Cannot find " + key)
        }</span>
        //fmt.Println("&lt;" + vmKeyValue.Key + "&gt; \n" + vmKeyValue.Value)
        <span class="cov8" title="1">vmTmp := TbVmInfo{}
        json.Unmarshal([]byte(vmKeyValue.Value), &amp;vmTmp)
        vmTmp.Id = vmId

        //get current vm status
        vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
        }</span>

        <span class="cov8" title="1">vmTmp.Status = vmStatusInfoTmp.Status
        vmTmp.TargetStatus = vmStatusInfoTmp.TargetStatus
        vmTmp.TargetAction = vmStatusInfoTmp.TargetAction

        return &amp;vmTmp, nil</span>
}

// CreateMcis function create MCIS obeject and deploy requested VMs.
func CreateMcis(nsId string, req *TbMcisReq) (*TbMcisInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(req.Name)
        if err != nil </span><span class="cov0" title="0">{
                temp := &amp;TbMcisInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, req.Name)
        if check </span><span class="cov8" title="1">{
                err := fmt.Errorf("The mcis " + req.Name + " already exists.")
                return nil, err
        }</span>

        <span class="cov8" title="1">targetAction := ActionCreate
        targetStatus := StatusRunning

        mcisId := req.Name
        vmRequest := req.Vm

        fmt.Println("=========================== Create MCIS object")
        key := common.GenMcisKey(nsId, mcisId, "")
        mapA := map[string]string{
                "id":              mcisId,
                "name":            mcisId,
                "description":     req.Description,
                "status":          StatusCreating,
                "targetAction":    targetAction,
                "targetStatus":    targetStatus,
                "InstallMonAgent": req.InstallMonAgent,
        }
        val, err := json.Marshal(mapA)
        if err != nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("System Error: CreateMcis json.Marshal(mapA) Error")
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = common.CBStore.Put(string(key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("System Error: CreateMcis CBStore.Put Error")
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(key))
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===========================")

        // Check whether VM names meet requirement.
        for _, k := range vmRequest </span><span class="cov8" title="1">{
                err = common.CheckString(k.Name)
                if err != nil </span><span class="cov0" title="0">{
                        temp := &amp;TbMcisInfo{}
                        common.CBLog.Error(err)
                        return temp, err
                }</span>
        }

        //goroutin
        <span class="cov8" title="1">var wg sync.WaitGroup

        for _, k := range vmRequest </span><span class="cov8" title="1">{

                // VM Group handling
                vmGroupSize, _ := strconv.Atoi(k.VmGroupSize)
                fmt.Printf("vmGroupSize: %v\n", vmGroupSize)

                if vmGroupSize &gt; 0 </span><span class="cov8" title="1">{

                        fmt.Println("=========================== Create MCIS VM Group object")
                        key := common.GenMcisVmGroupKey(nsId, mcisId, k.Name)

                        vmGroupInfoData := TbVmGroupInfo{}
                        vmGroupInfoData.Id = common.ToLower(k.Name)
                        vmGroupInfoData.Name = common.ToLower(k.Name)
                        vmGroupInfoData.VmGroupSize = k.VmGroupSize

                        for i := 0; i &lt; vmGroupSize; i++ </span><span class="cov8" title="1">{
                                vmGroupInfoData.VmId = append(vmGroupInfoData.VmId, vmGroupInfoData.Id+"-"+strconv.Itoa(i))
                        }</span>

                        <span class="cov8" title="1">val, _ := json.Marshal(vmGroupInfoData)
                        err := common.CBStore.Put(string(key), string(val))
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                        }</span>
                        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(key))
                        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                        fmt.Println("===========================")</span>

                }

                <span class="cov8" title="1">for i := 0; i &lt;= vmGroupSize; i++ </span><span class="cov8" title="1">{
                        vmInfoData := TbVmInfo{}

                        if vmGroupSize == 0 </span><span class="cov8" title="1">{ // for VM (not in a group)
                                vmInfoData.Name = common.ToLower(k.Name)
                        }</span> else<span class="cov8" title="1"> { // for VM (in a group)
                                if i == vmGroupSize </span><span class="cov8" title="1">{
                                        break</span> // if vmGroupSize != 0 &amp;&amp; vmGroupSize == i, skip the final loop
                                }
                                <span class="cov8" title="1">vmInfoData.VmGroupId = common.ToLower(k.Name)
                                vmInfoData.Name = common.ToLower(k.Name) + "-" + strconv.Itoa(i)
                                fmt.Println("===========================")
                                fmt.Println("vmInfoData.Name: " + vmInfoData.Name)
                                fmt.Println("===========================")</span>

                        }
                        <span class="cov8" title="1">vmInfoData.Id = vmInfoData.Name

                        vmInfoData.PublicIP = "Not assigned yet"
                        vmInfoData.PublicDNS = "Not assigned yet"

                        vmInfoData.Status = StatusCreating
                        vmInfoData.TargetAction = targetAction
                        vmInfoData.TargetStatus = targetStatus

                        vmInfoData.ConnectionName = k.ConnectionName
                        vmInfoData.SpecId = k.SpecId
                        vmInfoData.ImageId = k.ImageId
                        vmInfoData.VNetId = k.VNetId
                        vmInfoData.SubnetId = k.SubnetId
                        vmInfoData.SecurityGroupIds = k.SecurityGroupIds
                        vmInfoData.SshKeyId = k.SshKeyId
                        vmInfoData.Description = k.Description
                        vmInfoData.VmUserAccount = k.VmUserAccount
                        vmInfoData.VmUserPassword = k.VmUserPassword

                        // Avoid concurrent requests to CSP.
                        time.Sleep(time.Duration(i) * time.Second)

                        wg.Add(1)
                        go AddVmToMcis(&amp;wg, nsId, mcisId, &amp;vmInfoData)</span>
                        //AddVmToMcis(nsId, req.Id, vmInfoData)

                }
        }
        <span class="cov8" title="1">wg.Wait()

        mcisTmp, err := GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">mcisStatusTmp, err := GetMcisStatus(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">mcisTmp.Status = mcisStatusTmp.Status

        if mcisTmp.TargetStatus == mcisTmp.Status </span><span class="cov0" title="0">{
                mcisTmp.TargetStatus = StatusComplete
                mcisTmp.TargetAction = ActionComplete
        }</span>
        <span class="cov8" title="1">UpdateMcisInfo(nsId, mcisTmp)

        fmt.Println("[MCIS has been created]" + mcisId)
        //common.PrintJsonPretty(mcisTmp)

        // Install CB-Dragonfly monitoring agent

        fmt.Printf("[Init monitoring agent] for %+v\n - req.InstallMonAgent: %+v\n\n", mcisTmp.Id, req.InstallMonAgent)

        mcisTmp.InstallMonAgent = req.InstallMonAgent
        UpdateMcisInfo(nsId, mcisTmp)

        if req.InstallMonAgent != "no" </span><span class="cov8" title="1">{

                check := CheckDragonflyEndpoint()
                if check != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\n\n[Warring] CB-Dragonfly is not available\n\n")
                }</span> else<span class="cov8" title="1"> {
                        reqToMon := &amp;McisCmdReq{}
                        reqToMon.UserName = "ubuntu" // this MCIS user name is temporal code. Need to improve.

                        fmt.Printf("\n===========================\n")
                        // Sleep for 60 seconds for a safe DF agent installation.
                        fmt.Printf("\n\n[Info] Sleep for 60 seconds for safe CB-Dragonfly Agent installation.\n")
                        time.Sleep(60 * time.Second)

                        fmt.Printf("\n[InstallMonitorAgentToMcis]\n\n")
                        content, err := InstallMonitorAgentToMcis(nsId, mcisId, reqToMon)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                //mcisTmp.InstallMonAgent = "no"
                        }</span>
                        <span class="cov8" title="1">common.PrintJsonPretty(content)</span>
                        //mcisTmp.InstallMonAgent = "yes"
                }
        }

        <span class="cov8" title="1">mcisTmp, err = GetMcisObject(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;mcisTmp, nil</span>
}

func AddVmToMcis(wg *sync.WaitGroup, nsId string, mcisId string, vmInfoData *TbVmInfo) error <span class="cov8" title="1">{
        fmt.Printf("\n[AddVmToMcis]\n")
        //goroutin
        defer wg.Done()

        key := common.GenMcisKey(nsId, mcisId, "")
        keyValue, _ := common.CBStore.Get(key)
        if keyValue == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("AddVmToMcis: Cannot find mcisId. Key: %s", key)
        }</span>

        <span class="cov8" title="1">configTmp, _ := common.GetConnConfig(vmInfoData.ConnectionName)
        regionTmp, _ := common.GetRegion(configTmp.RegionName)

        nativeRegion := ""
        for _, v := range regionTmp.KeyValueInfoList </span><span class="cov8" title="1">{
                if strings.ToLower(v.Key) == "region" || strings.ToLower(v.Key) == "location" </span><span class="cov8" title="1">{
                        nativeRegion = v.Value
                        break</span>
                }
        }

        <span class="cov8" title="1">vmInfoData.Location = GetCloudLocation(strings.ToLower(configTmp.ProviderName), strings.ToLower(nativeRegion))

        //fmt.Printf("\n[configTmp]\n %+v regionTmp %+v \n", configTmp, regionTmp)
        //fmt.Printf("\n[vmInfoData.Location]\n %+v\n", vmInfoData.Location)

        //AddVmInfoToMcis(nsId, mcisId, *vmInfoData)
        // Make VM object
        key = common.GenMcisKey(nsId, mcisId, vmInfoData.Id)
        val, _ := json.Marshal(vmInfoData)
        err := common.CBStore.Put(string(key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">fmt.Printf("\n[AddVmToMcis Befor request vmInfoData]\n")
        //common.PrintJsonPretty(vmInfoData)

        //instanceIds, publicIPs := CreateVm(&amp;vmInfoData)
        err = CreateVm(nsId, mcisId, vmInfoData)

        fmt.Printf("\n[AddVmToMcis After request vmInfoData]\n")
        //common.PrintJsonPretty(vmInfoData)

        if err != nil </span><span class="cov8" title="1">{
                vmInfoData.Status = StatusFailed
                vmInfoData.SystemMessage = err.Error()
                UpdateVmInfo(nsId, mcisId, *vmInfoData)
                common.CBLog.Error(err)
                return err
        }</span>

        // set initial TargetAction, TargetStatus
        <span class="cov8" title="1">vmInfoData.TargetAction = ActionComplete
        vmInfoData.TargetStatus = StatusComplete

        // get and set current vm status
        vmStatusInfoTmp, err := GetVmStatus(nsId, mcisId, vmInfoData.Id)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">fmt.Printf("\n[AddVmToMcis vmStatusInfoTmp]\n")
        common.PrintJsonPretty(vmStatusInfoTmp)

        vmInfoData.Status = vmStatusInfoTmp.Status

        // Monitoring Agent Installation Status (init: notInstalled)
        vmInfoData.MonAgentStatus = "notInstalled"

        // set CreatedTime
        t := time.Now()
        vmInfoData.CreatedTime = t.Format("2006-01-02 15:04:05")
        fmt.Println(vmInfoData.CreatedTime)

        UpdateVmInfo(nsId, mcisId, *vmInfoData)

        return nil</span>

}

func CreateVm(nsId string, mcisId string, vmInfoData *TbVmInfo) error <span class="cov8" title="1">{

        fmt.Printf("\n\n[CreateVm(vmInfoData *TbVmInfo)]\n\n")

        switch </span>{
        case vmInfoData.Name == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.Name is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.ImageId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.ImageId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.ConnectionName == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.ConnectionName is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SshKeyId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SshKeyId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SpecId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SpecId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SecurityGroupIds == nil:<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SecurityGroupIds is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.VNetId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.VNetId is empty")
                common.CBLog.Error(err)
                return err</span>
        case vmInfoData.SubnetId == "":<span class="cov0" title="0">
                err := fmt.Errorf("vmInfoData.SubnetId is empty")
                common.CBLog.Error(err)
                return err</span>
        default:<span class="cov8" title="1"></span>

        }

        //prettyJSON, err := json.MarshalIndent(vmInfoData, "", "    ")
        //if err != nil {
        //log.Fatal("Failed to generate json")
        //}
        //fmt.Printf("%s\n", string(prettyJSON))

        //common.PrintJsonPretty(vmInfoData)

        //fmt.Printf("%+v\n", vmInfoData.CspVmId)

        <span class="cov8" title="1">var tempSpiderVMInfo SpiderVMInfo

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/vm"

                method := "POST"

                fmt.Println("\n[Calling SPIDER]START")
                fmt.Println("url: " + url + " method: " + method)

                tempReq := SpiderVMReqInfoWrapper{}
                tempReq.ConnectionName = vmInfoData.ConnectionName

                //generate VM ID(Name) to request to CSP(Spider)
                //combination of nsId, mcidId, and vmName reqested from user
                cspVmIdToRequest := nsId + "-" + mcisId + "-" + vmInfoData.Name
                tempReq.ReqInfo.Name = cspVmIdToRequest

                err := fmt.Errorf("")

                tempReq.ReqInfo.ImageName, err = common.GetCspResourceId(nsId, common.StrImage, vmInfoData.ImageId)
                if tempReq.ReqInfo.ImageName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempReq.ReqInfo.VMSpecName, err = common.GetCspResourceId(nsId, common.StrSpec, vmInfoData.SpecId)
                if tempReq.ReqInfo.VMSpecName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempReq.ReqInfo.VPCName, err = common.GetCspResourceId(nsId, common.StrVNet, vmInfoData.VNetId)
                if tempReq.ReqInfo.VPCName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                // TODO: needs to be enhnaced to use GetCspResourceId (GetCspResourceId needs to be updated as well)
                <span class="cov8" title="1">tempReq.ReqInfo.SubnetName = vmInfoData.SubnetId //common.GetCspResourceId(nsId, common.StrVNet, vmInfoData.SubnetId)
                if tempReq.ReqInfo.SubnetName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">var SecurityGroupIdsTmp []string
                for _, v := range vmInfoData.SecurityGroupIds </span><span class="cov8" title="1">{
                        CspSgId := v //common.GetCspResourceId(nsId, common.StrSecurityGroup, v)
                        if CspSgId == "" </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">SecurityGroupIdsTmp = append(SecurityGroupIdsTmp, CspSgId)</span>
                }
                <span class="cov8" title="1">tempReq.ReqInfo.SecurityGroupNames = SecurityGroupIdsTmp

                tempReq.ReqInfo.KeyPairName, err = common.GetCspResourceId(nsId, common.StrSSHKey, vmInfoData.SshKeyId)
                if tempReq.ReqInfo.KeyPairName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempReq.ReqInfo.VMUserId = vmInfoData.VmUserAccount
                tempReq.ReqInfo.VMUserPasswd = vmInfoData.VmUserPassword

                fmt.Printf("\n[Request body to CB-SPIDER for Creating VM]\n")
                common.PrintJsonPretty(tempReq)

                payload, _ := json.Marshal(tempReq)
                // fmt.Println("payload: " + string(payload))

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>,
                }
                <span class="cov8" title="1">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">req.Header.Add("Content-Type", "application/json")

                //reqBody, _ := ioutil.ReadAll(req.Body)
                //fmt.Println(string(reqBody))

                res, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        common.PrintJsonPretty(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">fmt.Println("Called CB-Spider API.")
                defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)

                if err != nil </span><span class="cov0" title="0">{
                        common.PrintJsonPretty(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempSpiderVMInfo = SpiderVMInfo{} // FYI; SpiderVMInfo: the struct in CB-Spider
                err = json.Unmarshal(body, &amp;tempSpiderVMInfo)

                if err != nil </span><span class="cov0" title="0">{
                        common.PrintJsonPretty(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">fmt.Println("[Response from SPIDER]")
                common.PrintJsonPretty(tempSpiderVMInfo)
                fmt.Println("[Calling SPIDER]END")

                fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch </span>{
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov8" title="1">
                        err := fmt.Errorf(string(body))
                        fmt.Println("body: ", string(body))
                        common.CBLog.Error(err)
                        return err</span>
                }

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                fmt.Println("\n[Calling SPIDER]START")

                tempReq := SpiderVMReqInfoWrapper{}
                tempReq.ConnectionName = vmInfoData.ConnectionName

                //generate VM ID(Name) to request to CSP(Spider)
                //combination of nsId, mcidId, and vmName reqested from user
                cspVmIdToRequest := nsId + "-" + mcisId + "-" + vmInfoData.Name
                tempReq.ReqInfo.Name = cspVmIdToRequest

                err = fmt.Errorf("")

                tempReq.ReqInfo.ImageName, err = common.GetCspResourceId(nsId, common.StrImage, vmInfoData.ImageId)
                if tempReq.ReqInfo.ImageName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempReq.ReqInfo.VMSpecName, err = common.GetCspResourceId(nsId, common.StrSpec, vmInfoData.SpecId)
                if tempReq.ReqInfo.VMSpecName == "" || err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempReq.ReqInfo.VPCName = vmInfoData.VNetId //common.GetCspResourceId(nsId, common.StrVNet, vmInfoData.VNetId)
                if tempReq.ReqInfo.VPCName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempReq.ReqInfo.SubnetName = vmInfoData.SubnetId //common.GetCspResourceId(nsId, "subnet", vmInfoData.SubnetId)
                if tempReq.ReqInfo.SubnetName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">var SecurityGroupIdsTmp []string
                for _, v := range vmInfoData.SecurityGroupIds </span><span class="cov8" title="1">{
                        CspSgId := v //common.GetCspResourceId(nsId, common.StrSecurityGroup, v)
                        if CspSgId == "" </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">SecurityGroupIdsTmp = append(SecurityGroupIdsTmp, CspSgId)</span>
                }
                <span class="cov8" title="1">tempReq.ReqInfo.SecurityGroupNames = SecurityGroupIdsTmp

                tempReq.ReqInfo.KeyPairName = vmInfoData.SshKeyId //common.GetCspResourceId(nsId, common.StrSSHKey, vmInfoData.SshKeyId)
                if tempReq.ReqInfo.KeyPairName == "" </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempReq.ReqInfo.VMUserId = vmInfoData.VmUserAccount
                tempReq.ReqInfo.VMUserPasswd = vmInfoData.VmUserPassword

                fmt.Printf("\n[Request body to CB-SPIDER for Creating VM]\n")
                common.PrintJsonPretty(tempReq)

                payload, _ := json.Marshal(tempReq)
                fmt.Println("payload: " + string(payload))

                result, err := ccm.StartVM(string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">tempSpiderVMInfo = SpiderVMInfo{} // FYI; SpiderVMInfo: the struct in CB-Spider
                err2 := json.Unmarshal([]byte(result), &amp;tempSpiderVMInfo)

                if err2 != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        common.CBLog.Error(err)
                        return err
                }</span>

        }

        <span class="cov8" title="1">vmInfoData.CspViewVmDetail = tempSpiderVMInfo

        vmInfoData.VmUserAccount = tempSpiderVMInfo.VMUserId
        vmInfoData.VmUserPassword = tempSpiderVMInfo.VMUserPasswd

        //vmInfoData.Location = vmInfoData.Location

        //vmInfoData.VcpuSize = vmInfoData.VcpuSize
        //vmInfoData.MemorySize = vmInfoData.MemorySize
        //vmInfoData.DiskSize = vmInfoData.DiskSize
        //vmInfoData.Disk_type = vmInfoData.Disk_type

        //vmInfoData.PlacementAlgo = vmInfoData.PlacementAlgo

        // 2. Provided by CB-Spider
        //vmInfoData.CspVmId = temp.Id
        //vmInfoData.StartTime = temp.StartTime
        vmInfoData.Region = tempSpiderVMInfo.Region
        vmInfoData.PublicIP = tempSpiderVMInfo.PublicIP
        vmInfoData.SSHPort, _ = TrimIP(tempSpiderVMInfo.SSHAccessPoint)
        vmInfoData.PublicDNS = tempSpiderVMInfo.PublicDNS
        vmInfoData.PrivateIP = tempSpiderVMInfo.PrivateIP
        vmInfoData.PrivateDNS = tempSpiderVMInfo.PrivateDNS
        vmInfoData.VMBootDisk = tempSpiderVMInfo.VMBootDisk
        vmInfoData.VMBlockDisk = tempSpiderVMInfo.VMBlockDisk
        //vmInfoData.KeyValueList = temp.KeyValueList

        //configTmp, _ := common.GetConnConfig(vmInfoData.ConnectionName)
        //vmInfoData.Location = GetCloudLocation(strings.ToLower(configTmp.ProviderName), strings.ToLower(tempSpiderVMInfo.Region.Region))

        vmKey := common.GenMcisKey(nsId, mcisId, vmInfoData.Id)
        //mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfoData.SshKeyId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrImage, vmInfoData.ImageId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSpec, vmInfoData.SpecId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrSSHKey, vmInfoData.SshKeyId, common.StrAdd, vmKey)
        mcir.UpdateAssociatedObjectList(nsId, common.StrVNet, vmInfoData.VNetId, common.StrAdd, vmKey)

        for _, v2 := range vmInfoData.SecurityGroupIds </span><span class="cov8" title="1">{
                mcir.UpdateAssociatedObjectList(nsId, common.StrSecurityGroup, v2, common.StrAdd, vmKey)
        }</span>

        //content.Status = temp.
        //content.CloudId = temp.

        // cb-store
        //fmt.Println("=========================== PUT createVM")
        /*
                Key := genResourceKey(nsId, "vm", content.Id)

                Val, _ := json.Marshal(content)
                fmt.Println("Key: ", Key)
                fmt.Println("Val: ", Val)
                err := common.CBStore.Put(string(Key), string(Val))
                if err != nil {
                        common.CBLog.Error(err)
                        return nil, nil
                }
                keyValue, _ := common.CBStore.Get(string(Key))
                fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                fmt.Println("===========================")
                return content, nil
        */

        //instanceIds := make([]*string, 1)
        //publicIPs := make([]*string, 1)
        //instanceIds[0] = &amp;content.CspVmId
        //publicIPs[0] = &amp;content.PublicIP

        <span class="cov8" title="1">UpdateVmInfo(nsId, mcisId, *vmInfoData)

        return nil</span>
}

func ControlMcis(nsId string, mcisId string, action string) error <span class="cov0" title="0">{

        key := common.GenMcisKey(nsId, mcisId, "")
        fmt.Println("[ControlMcis] " + key + " to " + action)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)

        vmList, err := ListVmId(nsId, mcisId)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Println("vmList ", vmList)

        for _, v := range vmList </span><span class="cov0" title="0">{
                ControlVm(nsId, mcisId, v, action)
        }</span>
        <span class="cov0" title="0">return nil</span>

        //need to change status

}

func CheckAllowedTransition(nsId string, mcisId string, action string) error <span class="cov8" title="1">{

        fmt.Println("[CheckAllowedTransition]" + mcisId + " to " + action)
        key := common.GenMcisKey(nsId, mcisId, "")
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">mcisTmp := TbMcisInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("Unmarshal Error:", unmarshalErr)
        }</span>

        <span class="cov8" title="1">mcisStatusTmp, _ := GetMcisStatus(nsId, mcisId)

        UpdateMcisInfo(nsId, mcisTmp)

        if strings.Contains(mcisStatusTmp.Status, StatusTerminating) || strings.Contains(mcisStatusTmp.Status, StatusResuming) || strings.Contains(mcisStatusTmp.Status, StatusSuspending) || strings.Contains(mcisStatusTmp.Status, StatusCreating) || strings.Contains(mcisStatusTmp.Status, StatusRebooting) </span><span class="cov0" title="0">{
                return errors.New(action + " is not allowed for MCIS under " + mcisStatusTmp.Status)
        }</span>
        <span class="cov8" title="1">if !strings.Contains(mcisStatusTmp.Status, "Partial-") &amp;&amp; strings.Contains(mcisStatusTmp.Status, StatusTerminated) </span><span class="cov0" title="0">{
                return errors.New(action + " is not allowed for " + mcisStatusTmp.Status + " MCIS")
        }</span>
        <span class="cov8" title="1">if strings.Contains(mcisStatusTmp.Status, StatusSuspended) </span><span class="cov8" title="1">{
                if strings.EqualFold(action, ActionResume) || strings.EqualFold(action, ActionSuspend) </span><span class="cov8" title="1">{
                        return nil
                }</span> else<span class="cov0" title="0"> {
                        return errors.New(action + " is not allowed for " + mcisStatusTmp.Status + " MCIS")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func ControlMcisAsync(nsId string, mcisId string, action string) error <span class="cov8" title="1">{

        checkError := CheckAllowedTransition(nsId, mcisId, action)
        if checkError != nil </span><span class="cov0" title="0">{
                return checkError
        }</span>

        <span class="cov8" title="1">key := common.GenMcisKey(nsId, mcisId, "")
        fmt.Println("[ControlMcisAsync] " + key + " to " + action)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===============================================")

        mcisTmp := TbMcisInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
        }</span>

        <span class="cov8" title="1">vmList, err := ListVmId(nsId, mcisId)
        fmt.Println("=============================================== ", vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch action </span>{
        case ActionTerminate:<span class="cov8" title="1">

                mcisTmp.TargetAction = ActionTerminate
                mcisTmp.TargetStatus = StatusTerminated
                mcisTmp.Status = StatusTerminating</span>

        case ActionReboot:<span class="cov8" title="1">

                mcisTmp.TargetAction = ActionReboot
                mcisTmp.TargetStatus = StatusRunning
                mcisTmp.Status = StatusRebooting</span>

        case ActionSuspend:<span class="cov8" title="1">

                mcisTmp.TargetAction = ActionSuspend
                mcisTmp.TargetStatus = StatusSuspended
                mcisTmp.Status = StatusSuspending</span>

        case ActionResume:<span class="cov8" title="1">

                mcisTmp.TargetAction = ActionResume
                mcisTmp.TargetStatus = StatusRunning
                mcisTmp.Status = StatusResuming</span>

        default:<span class="cov0" title="0">
                return errors.New(action + "is invalid actionType")</span>
        }
        <span class="cov8" title="1">UpdateMcisInfo(nsId, mcisTmp)

        //goroutin sync wg
        var wg sync.WaitGroup
        var results ControlVmResultWrapper

        for _, v := range vmList </span><span class="cov8" title="1">{
                wg.Add(1)

                // Avoid concurrent requests to CSP.
                time.Sleep(time.Duration(3) * time.Second)

                go ControlVmAsync(&amp;wg, nsId, mcisId, v, action, &amp;results)
        }</span>
        <span class="cov8" title="1">wg.Wait() //goroutine sync wg

        checkErrFlag := ""
        for _, v := range results.ResultArray </span><span class="cov8" title="1">{
                if v.Error != nil </span><span class="cov0" title="0">{
                        checkErrFlag += "["
                        checkErrFlag += v.Error.Error()
                        checkErrFlag += "]"
                }</span>
        }
        <span class="cov8" title="1">if checkErrFlag != "" </span><span class="cov0" title="0">{
                return fmt.Errorf(checkErrFlag)
        }</span>

        <span class="cov8" title="1">return nil</span>

        //need to change status

}

type ControlVmResult struct {
        VmId   string `json:"vmId"`
        Status string `json:"Status"`
        Error  error  `json:"Error"`
}
type ControlVmResultWrapper struct {
        ResultArray []ControlVmResult `json:"resultarray"`
}

func ControlVmAsync(wg *sync.WaitGroup, nsId string, mcisId string, vmId string, action string, results *ControlVmResultWrapper) error <span class="cov8" title="1">{
        defer wg.Done() //goroutine sync done

        var errTmp error
        var err error
        var err2 error
        resultTmp := ControlVmResult{}
        resultTmp.VmId = vmId
        resultTmp.Status = ""
        temp := TbVmInfo{}

        key := common.GenMcisKey(nsId, mcisId, vmId)
        fmt.Println("[ControlVmAsync] " + key)

        keyValue, err := common.CBStore.Get(key)

        if keyValue == nil || err != nil </span><span class="cov0" title="0">{

                resultTmp.Error = fmt.Errorf("CBStoreGetErr. keyValue == nil || err != nil. key[" + key + "]")
                results.ResultArray = append(results.ResultArray, resultTmp)
                common.PrintJsonPretty(resultTmp)
                return resultTmp.Error

        }</span> else<span class="cov8" title="1"> {
                fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                fmt.Println("===============================================")

                unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
                if unmarshalErr != nil </span><span class="cov0" title="0">{
                        fmt.Println("Unmarshal error:", unmarshalErr)
                }</span>

                <span class="cov8" title="1">fmt.Println("\n[Calling SPIDER]START vmControl")

                cspVmId := temp.CspViewVmDetail.IId.NameId
                common.PrintJsonPretty(temp.CspViewVmDetail)

                // Prevent malformed cspVmId
                if cspVmId == "" || common.CheckString(cspVmId) != nil </span><span class="cov0" title="0">{
                        resultTmp.Error = fmt.Errorf("Not valid requested CSPNativeVmId: [" + cspVmId + "]")
                        temp.Status = StatusFailed
                        temp.SystemMessage = resultTmp.Error.Error()
                        UpdateVmInfo(nsId, mcisId, temp)
                        //return err
                }</span> else<span class="cov8" title="1"> {
                        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                                url := ""
                                method := ""
                                switch action </span>{
                                case ActionTerminate:<span class="cov8" title="1">

                                        temp.TargetAction = ActionTerminate
                                        temp.TargetStatus = StatusTerminated
                                        temp.Status = StatusTerminating

                                        url = common.SPIDER_REST_URL + "/vm/" + cspVmId
                                        method = "DELETE"</span>
                                case ActionReboot:<span class="cov8" title="1">

                                        temp.TargetAction = ActionReboot
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusRebooting

                                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=reboot"
                                        method = "GET"</span>
                                case ActionSuspend:<span class="cov8" title="1">

                                        temp.TargetAction = ActionSuspend
                                        temp.TargetStatus = StatusSuspended
                                        temp.Status = StatusSuspending

                                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=suspend"
                                        method = "GET"</span>
                                case ActionResume:<span class="cov8" title="1">

                                        temp.TargetAction = ActionResume
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusResuming

                                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=resume"
                                        method = "GET"</span>
                                default:<span class="cov0" title="0">
                                        return errors.New(action + "is invalid actionType")</span>
                                }

                                <span class="cov8" title="1">UpdateVmInfo(nsId, mcisId, temp)
                                //fmt.Println("url: " + url + " method: " + method)

                                type ControlVMReqInfo struct {
                                        ConnectionName string
                                }
                                tempReq := ControlVMReqInfo{}
                                tempReq.ConnectionName = temp.ConnectionName
                                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                                //fmt.Println("payload: " + string(payload)) // for debug

                                client := &amp;http.Client{
                                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                                return http.ErrUseLastResponse
                                        }</span>,
                                }
                                <span class="cov8" title="1">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">req.Header.Add("Content-Type", "application/json")

                                res, err := client.Do(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">defer res.Body.Close()
                                body, err := ioutil.ReadAll(res.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return err
                                }</span>

                                <span class="cov8" title="1">fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                                switch </span>{
                                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                                        err := fmt.Errorf(string(body))
                                        common.CBLog.Error(err)
                                        errTmp = err</span>
                                }

                                <span class="cov8" title="1">err2 = json.Unmarshal(body, &amp;resultTmp)</span>

                        } else<span class="cov8" title="1"> {

                                // CCM API 설정
                                ccm := api.NewCloudResourceHandler()
                                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error("ccm failed to set config : ", err)
                                        temp.Status = StatusFailed
                                        UpdateVmInfo(nsId, mcisId, temp)
                                        return err
                                }</span>
                                <span class="cov8" title="1">err = ccm.Open()
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error("ccm api open failed : ", err)
                                        temp.Status = StatusFailed
                                        UpdateVmInfo(nsId, mcisId, temp)
                                        return err
                                }</span>
                                <span class="cov8" title="1">defer ccm.Close()

                                var result string

                                switch action </span>{
                                case ActionTerminate:<span class="cov8" title="1">

                                        temp.TargetAction = ActionTerminate
                                        temp.TargetStatus = StatusTerminated
                                        temp.Status = StatusTerminating

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.TerminateVMByParam(temp.ConnectionName, cspVmId, "false")</span>

                                case ActionReboot:<span class="cov8" title="1">

                                        temp.TargetAction = ActionReboot
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusRebooting

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "reboot")</span>

                                case ActionSuspend:<span class="cov8" title="1">

                                        temp.TargetAction = ActionSuspend
                                        temp.TargetStatus = StatusSuspended
                                        temp.Status = StatusSuspending

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "suspend")</span>

                                case ActionResume:<span class="cov8" title="1">

                                        temp.TargetAction = ActionResume
                                        temp.TargetStatus = StatusRunning
                                        temp.Status = StatusResuming

                                        UpdateVmInfo(nsId, mcisId, temp)

                                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "resume")</span>

                                default:<span class="cov0" title="0">
                                        return errors.New(action + "is invalid actionType")</span>
                                }

                                <span class="cov8" title="1">err2 = json.Unmarshal([]byte(result), &amp;resultTmp)</span>

                        }

                        <span class="cov8" title="1">if err2 != nil </span><span class="cov0" title="0">{
                                fmt.Println(err2)
                                common.CBLog.Error(err)
                                errTmp = err
                        }</span>
                        <span class="cov8" title="1">if errTmp != nil </span><span class="cov0" title="0">{
                                resultTmp.Error = errTmp

                                temp.Status = StatusFailed
                                temp.SystemMessage = errTmp.Error()
                                UpdateVmInfo(nsId, mcisId, temp)
                        }</span>
                        <span class="cov8" title="1">results.ResultArray = append(results.ResultArray, resultTmp)

                        common.PrintJsonPretty(resultTmp)

                        fmt.Println("[Calling SPIDER]END vmControl")

                        if action != ActionTerminate </span><span class="cov8" title="1">{
                                //When VM is restared, temporal PublicIP will be chanaged. Need update.
                                UpdateVmPublicIp(nsId, mcisId, temp)
                        }</span>
                }

        }

        <span class="cov8" title="1">return nil</span>

}

func ControlVm(nsId string, mcisId string, vmId string, action string) error <span class="cov8" title="1">{

        var content struct {
                CloudId string `json:"cloudId"`
                CspVmId string `json:"cspVmId"`
        }

        key := common.GenMcisKey(nsId, mcisId, vmId)
        fmt.Println("[ControlVm] " + key)

        keyValue, _ := common.CBStore.Get(key)
        fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        fmt.Println("===============================================")

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        //fmt.Printf("%+v\n", content.CloudId)
        //fmt.Printf("%+v\n", content.CspVmId)

        temp := TbVmInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
        }</span>

        <span class="cov8" title="1">fmt.Println("\n[Calling SPIDER]START vmControl")

        //fmt.Println("temp.CspVmId: " + temp.CspViewVmDetail.IId.NameId)

        /*
                cspType := getVMsCspType(nsId, mcisId, vmId)
                var cspVmId string
                if cspType == "AWS" {
                        cspVmId = temp.CspViewVmDetail.Id
                } else {
        */
        cspVmId := temp.CspViewVmDetail.IId.NameId
        common.PrintJsonPretty(temp.CspViewVmDetail)

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := ""
                method := ""
                switch action </span>{
                case ActionTerminate:<span class="cov8" title="1">

                        temp.TargetAction = ActionTerminate
                        temp.TargetStatus = StatusTerminated
                        temp.Status = StatusTerminating

                        url = common.SPIDER_REST_URL + "/vm/" + cspVmId
                        method = "DELETE"</span>
                case ActionReboot:<span class="cov8" title="1">

                        temp.TargetAction = ActionReboot
                        temp.TargetStatus = StatusRunning
                        temp.Status = StatusRebooting

                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=reboot"
                        method = "GET"</span>
                case ActionSuspend:<span class="cov8" title="1">

                        temp.TargetAction = ActionSuspend
                        temp.TargetStatus = StatusSuspended
                        temp.Status = StatusSuspending

                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=suspend"
                        method = "GET"</span>
                case ActionResume:<span class="cov8" title="1">

                        temp.TargetAction = ActionResume
                        temp.TargetStatus = StatusRunning
                        temp.Status = StatusResuming

                        url = common.SPIDER_REST_URL + "/controlvm/" + cspVmId + "?action=resume"
                        method = "GET"</span>
                default:<span class="cov0" title="0">
                        return errors.New(action + "is invalid actionType")</span>
                }

                <span class="cov8" title="1">UpdateVmInfo(nsId, mcisId, temp)
                //fmt.Println("url: " + url + " method: " + method)

                type ControlVMReqInfo struct {
                        ConnectionName string
                }
                tempReq := ControlVMReqInfo{}
                tempReq.ConnectionName = temp.ConnectionName
                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                //fmt.Println("payload: " + string(payload)) // for debug

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>,
                }
                <span class="cov8" title="1">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return err
                }</span>
                <span class="cov8" title="1">req.Header.Add("Content-Type", "application/json")

                res, err := client.Do(req)
                //fmt.Println("Called mockAPI.")
                defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)

                fmt.Println(string(body))

                fmt.Println("[Calling SPIDER]END vmControl\n")
                /*
                        if strings.Compare(content.CspVmId, "Not assigned yet") == 0 {
                                return nil
                        }
                        if strings.Compare(content.CloudId, "aws") == 0 {
                                controlVmAws(content.CspVmId)
                        } else if strings.Compare(content.CloudId, "gcp") == 0 {
                                controlVmGcp(content.CspVmId)
                        } else if strings.Compare(content.CloudId, "azure") == 0 {
                                controlVmAzure(content.CspVmId)
                        } else {
                                fmt.Println("==============ERROR=no matched providerId=================")
                        }
                */

                return nil</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                var result string

                switch action </span>{
                case ActionTerminate:<span class="cov8" title="1">

                        result, err = ccm.TerminateVMByParam(temp.ConnectionName, cspVmId, "false")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case ActionReboot:<span class="cov8" title="1">

                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "reboot")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case ActionSuspend:<span class="cov8" title="1">

                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "suspend")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                case ActionResume:<span class="cov8" title="1">

                        result, err = ccm.ControlVMByParam(temp.ConnectionName, cspVmId, "resume")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return err
                        }</span>

                default:<span class="cov0" title="0">
                        return errors.New(action + "is invalid actionType")</span>
                }

                <span class="cov8" title="1">fmt.Println(result)
                fmt.Println("[Calling SPIDER]END vmControl\n")

                return nil</span>
        }
}

// GetMcisObject func retrieve MCIS object from database (no current status update)
func GetMcisObject(nsId string, mcisId string) (TbMcisInfo, error) <span class="cov8" title="1">{
        fmt.Println("[GetMcisObject]" + mcisId)
        key := common.GenMcisKey(nsId, mcisId, "")
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbMcisInfo{}, err
        }</span>
        <span class="cov8" title="1">mcisTmp := TbMcisInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbMcisInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, vmID := range vmList </span><span class="cov8" title="1">{
                vmtmp, err := GetVmObject(nsId, mcisId, vmID)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return TbMcisInfo{}, err
                }</span>
                <span class="cov8" title="1">mcisTmp.Vm = append(mcisTmp.Vm, vmtmp)</span>
        }

        <span class="cov8" title="1">return mcisTmp, nil</span>
}

func GetMcisStatus(nsId string, mcisId string) (*McisStatusInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[GetMcisStatus]" + mcisId)

        key := common.GenMcisKey(nsId, mcisId, "")
        //fmt.Println(key)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>
        <span class="cov8" title="1">if keyValue == nil </span><span class="cov8" title="1">{
                err := fmt.Errorf("Not found [" + key + "]")
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        //fmt.Println("===============================================")

        <span class="cov8" title="1">mcisStatus := McisStatusInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisStatus)

        mcisTmp := TbMcisInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)

        vmList, err := ListVmId(nsId, mcisId)
        //fmt.Println("=============================================== %#v", vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return &amp;McisStatusInfo{}, err
        }</span>
        <span class="cov8" title="1">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return &amp;McisStatusInfo{}, nil
        }</span>

        //goroutin sync wg
        <span class="cov8" title="1">var wg sync.WaitGroup
        for _, v := range vmList </span><span class="cov8" title="1">{
                wg.Add(1)
                go GetVmStatusAsync(&amp;wg, nsId, mcisId, v, &amp;mcisStatus)
        }</span>
        <span class="cov8" title="1">wg.Wait() //goroutine sync wg

        for _, v := range vmList </span><span class="cov8" title="1">{
                // set master IP of MCIS (Default rule: select 1st Running VM as master)
                vmtmp, _ := GetVmObject(nsId, mcisId, v)
                if vmtmp.Status == StatusRunning </span><span class="cov8" title="1">{
                        mcisStatus.MasterVmId = vmtmp.Id
                        mcisStatus.MasterIp = vmtmp.PublicIP
                        mcisStatus.MasterSSHPort = vmtmp.SSHPort
                        break</span>
                }
        }

        <span class="cov8" title="1">statusFlag := []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        statusFlagStr := []string{StatusFailed, StatusSuspended, StatusRunning, StatusTerminated, StatusCreating, StatusSuspending, StatusResuming, StatusRebooting, StatusTerminating, StatusUndefined}
        for _, v := range mcisStatus.Vm </span><span class="cov8" title="1">{

                switch v.Status </span>{
                case StatusFailed:<span class="cov8" title="1">
                        statusFlag[0]++</span>
                case StatusSuspended:<span class="cov8" title="1">
                        statusFlag[1]++</span>
                case StatusRunning:<span class="cov8" title="1">
                        statusFlag[2]++</span>
                case StatusTerminated:<span class="cov8" title="1">
                        statusFlag[3]++</span>
                case StatusCreating:<span class="cov0" title="0">
                        statusFlag[4]++</span>
                case StatusSuspending:<span class="cov0" title="0">
                        statusFlag[5]++</span>
                case StatusResuming:<span class="cov0" title="0">
                        statusFlag[6]++</span>
                case StatusRebooting:<span class="cov0" title="0">
                        statusFlag[7]++</span>
                case StatusTerminating:<span class="cov0" title="0">
                        statusFlag[8]++</span>
                default:<span class="cov0" title="0">
                        statusFlag[9]++</span>
                }
        }

        <span class="cov8" title="1">tmpMax := 0
        tmpMaxIndex := 0
        for i, v := range statusFlag </span><span class="cov8" title="1">{
                if v &gt; tmpMax </span><span class="cov8" title="1">{
                        tmpMax = v
                        tmpMaxIndex = i
                }</span>
        }

        <span class="cov8" title="1">numVm := len(mcisStatus.Vm)
        numUnNormalStatus := statusFlag[0] + statusFlag[9]
        numNormalStatus := numVm - numUnNormalStatus

        proportionStr := "-" + strconv.Itoa(tmpMax) + "(" + strconv.Itoa(numNormalStatus) + "/" + strconv.Itoa(numVm) + ")"
        if tmpMax == numVm </span><span class="cov8" title="1">{
                mcisStatus.Status = statusFlagStr[tmpMaxIndex] + proportionStr
        }</span> else<span class="cov8" title="1"> if tmpMax &lt; numVm </span><span class="cov8" title="1">{
                mcisStatus.Status = "Partial-" + statusFlagStr[tmpMaxIndex] + proportionStr
        }</span> else<span class="cov0" title="0"> {
                mcisStatus.Status = statusFlagStr[9] + proportionStr
        }</span>
        // for representing Failed status in front.

        <span class="cov8" title="1">proportionStr = "-" + strconv.Itoa(statusFlag[0]) + "(" + strconv.Itoa(numNormalStatus) + "/" + strconv.Itoa(numVm) + ")"
        if statusFlag[0] &gt; 0 </span><span class="cov8" title="1">{
                mcisStatus.Status = "Partial-" + statusFlagStr[0] + proportionStr
                if statusFlag[0] == numVm </span><span class="cov0" title="0">{
                        mcisStatus.Status = statusFlagStr[0] + proportionStr
                }</span>
        }

        // proportionStr = "-(" + strconv.Itoa(statusFlag[9]) + "/" + strconv.Itoa(numVm) + ")"
        // if statusFlag[9] &gt; 0 {
        //         mcisStatus.Status = statusFlagStr[9] + proportionStr
        // }

        <span class="cov8" title="1">var isDone bool
        isDone = true
        for _, v := range mcisStatus.Vm </span><span class="cov8" title="1">{
                if v.TargetStatus != StatusComplete </span><span class="cov8" title="1">{
                        isDone = false
                }</span>
        }
        <span class="cov8" title="1">if isDone </span><span class="cov8" title="1">{
                mcisStatus.TargetAction = ActionComplete
                mcisStatus.TargetStatus = StatusComplete
                mcisTmp.TargetAction = ActionComplete
                mcisTmp.TargetStatus = StatusComplete
                UpdateMcisInfo(nsId, mcisTmp)
        }</span>

        <span class="cov8" title="1">return &amp;mcisStatus, nil</span>

        //need to change status

}

func GetMcisStatusAll(nsId string) ([]McisStatusInfo, error) <span class="cov8" title="1">{

        mcisStatuslist := []McisStatusInfo{}
        mcisList, err := ListMcisId(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return mcisStatuslist, err
        }</span>

        <span class="cov8" title="1">for _, mcisId := range mcisList </span><span class="cov8" title="1">{
                mcisStatus, err := GetMcisStatus(nsId, mcisId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return mcisStatuslist, err
                }</span>
                <span class="cov8" title="1">mcisStatuslist = append(mcisStatuslist, *mcisStatus)</span>
        }
        <span class="cov8" title="1">return mcisStatuslist, nil</span>

        //need to change status

}

func GetVmObject(nsId string, mcisId string, vmId string) (TbVmInfo, error) <span class="cov8" title="1">{
        //fmt.Println("[GetVmObject] mcisId: " + mcisId + ", vmId: " + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbVmInfo{}, err
        }</span>
        <span class="cov8" title="1">vmTmp := TbVmInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;vmTmp)
        return vmTmp, nil</span>
}

func GetVmStatusAsync(wg *sync.WaitGroup, nsId string, mcisId string, vmId string, results *McisStatusInfo) error <span class="cov8" title="1">{
        defer wg.Done() //goroutine sync done

        vmStatusTmp, err := GetVmStatus(nsId, mcisId, vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                vmStatusTmp.Status = StatusFailed
                vmStatusTmp.SystemMessage = err.Error()
        }</span>

        <span class="cov8" title="1">results.Vm = append(results.Vm, vmStatusTmp)
        return nil</span>
}

func GetVmStatus(nsId string, mcisId string, vmId string) (TbVmStatusInfo, error) <span class="cov8" title="1">{

        // defer func() {
        //         if runtimeErr := recover(); runtimeErr != nil {
        //                 myErr := fmt.Errorf("in GetVmStatus; mcisId: " + mcisId + ", vmId: " + vmId)
        //                 common.CBLog.Error(myErr)
        //                 common.CBLog.Error(runtimeErr)
        //         }
        // }()

        //fmt.Println("[GetVmStatus]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)
        errorInfo := TbVmStatusInfo{}

        keyValue, err := common.CBStore.Get(key)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                fmt.Println("CBStoreGetErr. keyValue == nil || err != nil", err)
                fmt.Println(err)
                return errorInfo, err
        }</span>

        // fmt.Println(keyValue.Value)
        // fmt.Println("&lt;" + keyValue.Key + "&gt; \n")
        // fmt.Println("===============================================")

        <span class="cov8" title="1">temp := TbVmInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
                fmt.Println(err)
                return errorInfo, err
        }</span>

        <span class="cov8" title="1">errorInfo.Id = temp.Id
        errorInfo.Name = temp.Name
        errorInfo.CspVmId = temp.CspViewVmDetail.IId.NameId
        errorInfo.PublicIp = temp.PublicIP
        errorInfo.SSHPort = temp.SSHPort
        errorInfo.PrivateIp = temp.PrivateIP
        errorInfo.NativeStatus = StatusUndefined
        errorInfo.TargetAction = temp.TargetAction
        errorInfo.TargetStatus = temp.TargetStatus
        errorInfo.Location = temp.Location
        errorInfo.MonAgentStatus = temp.MonAgentStatus
        errorInfo.CreatedTime = temp.CreatedTime
        errorInfo.SystemMessage = "Error in GetVmStatus"

        cspVmId := temp.CspViewVmDetail.IId.NameId

        type statusResponse struct {
                Status string
        }
        statusResponseTmp := statusResponse{}
        statusResponseTmp.Status = ""

        if cspVmId != "" &amp;&amp; temp.Status != StatusTerminated </span><span class="cov8" title="1">{
                fmt.Print("[Calling SPIDER] vmstatus, ")
                fmt.Println("CspVmId: " + cspVmId)
                if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                        url := common.SPIDER_REST_URL + "/vmstatus/" + cspVmId
                        method := "GET"

                        type VMStatusReqInfo struct {
                                ConnectionName string
                        }
                        tempReq := VMStatusReqInfo{}
                        tempReq.ConnectionName = temp.ConnectionName
                        payload, _ := json.MarshalIndent(tempReq, "", "  ")
                        //fmt.Println("payload: " + string(payload)) // for debug

                        client := &amp;http.Client{
                                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                        return http.ErrUseLastResponse
                                }</span>,
                        }

                        // Retry to get right VM status from cb-spider. Sometimes cb-spider returns not approriate status.
                        <span class="cov8" title="1">retrycheck := 2
                        for i := 0; i &lt; retrycheck; i++ </span><span class="cov8" title="1">{

                                req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))
                                errorInfo.Status = StatusFailed
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err)
                                        return errorInfo, err
                                }</span>
                                <span class="cov8" title="1">req.Header.Add("Content-Type", "application/json")

                                res, err := client.Do(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err)
                                        errorInfo.SystemMessage = err.Error()
                                        //return errorInfo, err
                                }</span> else<span class="cov8" title="1"> {
                                        body, err := ioutil.ReadAll(res.Body)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Println(err)
                                                errorInfo.SystemMessage = err.Error()
                                                return errorInfo, err
                                        }</span>
                                        <span class="cov8" title="1">err = json.Unmarshal(body, &amp;statusResponseTmp)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Println(err)
                                                errorInfo.SystemMessage = err.Error()
                                                return errorInfo, err
                                        }</span>
                                        <span class="cov8" title="1">defer res.Body.Close()</span>
                                }

                                <span class="cov8" title="1">if statusResponseTmp.Status != "" </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">time.Sleep(1 * time.Second)</span>
                        }

                } else<span class="cov8" title="1"> {

                        // CCM API 설정
                        ccm := api.NewCloudResourceHandler()
                        err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error("ccm failed to set config : ", err)
                                return errorInfo, err
                        }</span>
                        <span class="cov8" title="1">err = ccm.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error("ccm api open failed : ", err)
                                return errorInfo, err
                        }</span>
                        <span class="cov8" title="1">defer ccm.Close()

                        // Retry to get right VM status from cb-spider. Sometimes cb-spider returns not approriate status.
                        retrycheck := 2
                        for i := 0; i &lt; retrycheck; i++ </span><span class="cov8" title="1">{
                                result, err := ccm.GetVMStatusByParam(temp.ConnectionName, cspVmId)
                                if err != nil </span><span class="cov8" title="1">{
                                        common.CBLog.Error(err)
                                        errorInfo.SystemMessage = err.Error()
                                        //return errorInfo, err
                                }</span> else<span class="cov8" title="1"> {
                                        err = json.Unmarshal([]byte(result), &amp;statusResponseTmp)
                                        if err != nil </span><span class="cov0" title="0">{
                                                common.CBLog.Error(err)
                                                errorInfo.SystemMessage = err.Error()
                                                return errorInfo, err
                                        }</span>
                                }

                                <span class="cov8" title="1">if statusResponseTmp.Status != "" </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">time.Sleep(1 * time.Second)</span>
                        }
                }

        } else<span class="cov8" title="1"> {
                statusResponseTmp.Status = ""
        }</span>

        <span class="cov8" title="1">nativeStatus := statusResponseTmp.Status
        // Temporal CODE. This should be changed after CB-Spider fixes status types and strings/
        if nativeStatus == "Creating" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusCreating
        }</span> else<span class="cov8" title="1"> if nativeStatus == "Running" </span><span class="cov8" title="1">{
                statusResponseTmp.Status = StatusRunning
        }</span> else<span class="cov8" title="1"> if nativeStatus == "Suspending" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusSuspending
        }</span> else<span class="cov8" title="1"> if nativeStatus == "Suspended" </span><span class="cov8" title="1">{
                statusResponseTmp.Status = StatusSuspended
        }</span> else<span class="cov8" title="1"> if nativeStatus == "Resuming" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusResuming
        }</span> else<span class="cov8" title="1"> if nativeStatus == "Rebooting" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusRebooting
        }</span> else<span class="cov8" title="1"> if nativeStatus == "Terminating" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusTerminating
        }</span> else<span class="cov8" title="1"> if nativeStatus == "Terminated" </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusTerminated
        }</span> else<span class="cov8" title="1"> {
                statusResponseTmp.Status = StatusUndefined
        }</span>
        // End of Temporal CODE.
        <span class="cov8" title="1">temp, err = GetVmObject(nsId, mcisId, vmId)
        if keyValue == nil || err != nil </span><span class="cov0" title="0">{
                fmt.Println("CBStoreGetErr. keyValue == nil || err != nil", err)
                fmt.Println(err)
                return errorInfo, err
        }</span>
        <span class="cov8" title="1">vmStatusTmp := TbVmStatusInfo{}
        vmStatusTmp.Id = temp.Id
        vmStatusTmp.Name = temp.Name
        vmStatusTmp.CspVmId = temp.CspViewVmDetail.IId.NameId

        vmStatusTmp.PrivateIp = temp.PrivateIP
        vmStatusTmp.NativeStatus = nativeStatus
        vmStatusTmp.TargetAction = temp.TargetAction
        vmStatusTmp.TargetStatus = temp.TargetStatus
        vmStatusTmp.Location = temp.Location
        vmStatusTmp.MonAgentStatus = temp.MonAgentStatus
        vmStatusTmp.CreatedTime = temp.CreatedTime
        vmStatusTmp.SystemMessage = temp.SystemMessage

        // fmt.Println("[VM Native Status]" + temp.Id + ":" + nativeStatus)

        //Correct undefined status using TargetAction
        if vmStatusTmp.TargetAction == ActionCreate </span><span class="cov8" title="1">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov8" title="1">{
                        statusResponseTmp.Status = StatusCreating
                }</span>
                <span class="cov8" title="1">if temp.Status == StatusFailed </span><span class="cov8" title="1">{
                        statusResponseTmp.Status = StatusFailed
                }</span>
        }
        <span class="cov8" title="1">if vmStatusTmp.TargetAction == ActionTerminate </span><span class="cov8" title="1">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov8" title="1">{
                        statusResponseTmp.Status = StatusTerminated
                }</span>
                <span class="cov8" title="1">if statusResponseTmp.Status == StatusSuspending </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusTerminated
                }</span>
        }
        <span class="cov8" title="1">if vmStatusTmp.TargetAction == ActionResume </span><span class="cov8" title="1">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusResuming
                }</span>
                <span class="cov8" title="1">if statusResponseTmp.Status == StatusCreating </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusResuming
                }</span>
        }
        // for action reboot, some csp's native status are suspending, suspended, creating, resuming
        <span class="cov8" title="1">if vmStatusTmp.TargetAction == ActionReboot </span><span class="cov8" title="1">{
                if statusResponseTmp.Status == StatusUndefined </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusRebooting
                }</span>
                <span class="cov8" title="1">if statusResponseTmp.Status == StatusSuspending || statusResponseTmp.Status == StatusSuspended || statusResponseTmp.Status == StatusCreating || statusResponseTmp.Status == StatusResuming </span><span class="cov0" title="0">{
                        statusResponseTmp.Status = StatusRebooting
                }</span>
        }

        <span class="cov8" title="1">if vmStatusTmp.Status == StatusTerminated </span><span class="cov0" title="0">{
                statusResponseTmp.Status = StatusTerminated
        }</span>

        <span class="cov8" title="1">vmStatusTmp.Status = statusResponseTmp.Status

        // TODO: Alibaba Undefined status error is not resolved yet.
        // (After Terminate action. "status": "Undefined", "targetStatus": "None", "targetAction": "None")

        //if TargetStatus == CurrentStatus, record to finialize the control operation
        if vmStatusTmp.TargetStatus == vmStatusTmp.Status </span><span class="cov8" title="1">{
                if vmStatusTmp.TargetStatus != StatusTerminated </span><span class="cov8" title="1">{
                        vmStatusTmp.SystemMessage = vmStatusTmp.TargetStatus + "==" + vmStatusTmp.Status
                        vmStatusTmp.TargetStatus = StatusComplete
                        vmStatusTmp.TargetAction = ActionComplete

                        //Get current public IP when status has been changed.
                        //UpdateVmPublicIp(nsId, mcisId, temp)
                        vmInfoTmp, err := GetVmCurrentPublicIp(nsId, mcisId, temp.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                errorInfo.SystemMessage = err.Error()
                                return errorInfo, err
                        }</span>
                        <span class="cov8" title="1">temp.PublicIP = vmInfoTmp.PublicIp
                        temp.SSHPort = vmInfoTmp.SSHPort</span>

                } else<span class="cov8" title="1"> {
                        // Don't init TargetStatus if the TargetStatus is StatusTerminated. It is to finalize VM lifecycle if StatusTerminated.
                        vmStatusTmp.TargetStatus = StatusTerminated
                        vmStatusTmp.TargetAction = ActionTerminate
                        vmStatusTmp.Status = StatusTerminated
                        vmStatusTmp.SystemMessage = "This VM has been terminated. No action is acceptable except deletion"
                }</span>
        }

        <span class="cov8" title="1">vmStatusTmp.PublicIp = temp.PublicIP
        vmStatusTmp.SSHPort = temp.SSHPort

        // Apply current status to vmInfo
        temp.Status = vmStatusTmp.Status
        temp.SystemMessage = vmStatusTmp.SystemMessage
        temp.TargetAction = vmStatusTmp.TargetAction
        temp.TargetStatus = vmStatusTmp.TargetStatus

        if cspVmId != "" </span><span class="cov8" title="1">{
                // don't update VM info, if cspVmId is empty
                UpdateVmInfo(nsId, mcisId, temp)
        }</span>

        <span class="cov8" title="1">return vmStatusTmp, nil</span>
}

func UpdateVmPublicIp(nsId string, mcisId string, vmInfoData TbVmInfo) error <span class="cov8" title="1">{

        vmInfoTmp, err := GetVmCurrentPublicIp(nsId, mcisId, vmInfoData.Id)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">if vmInfoData.PublicIP != vmInfoTmp.PublicIp || vmInfoData.SSHPort != vmInfoTmp.SSHPort </span><span class="cov0" title="0">{
                vmInfoData.PublicIP = vmInfoTmp.PublicIp
                vmInfoData.SSHPort = vmInfoTmp.SSHPort
                UpdateVmInfo(nsId, mcisId, vmInfoData)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func GetVmCurrentPublicIp(nsId string, mcisId string, vmId string) (TbVmStatusInfo, error) <span class="cov8" title="1">{

        fmt.Println("[GetVmStatus]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        errorInfo := TbVmStatusInfo{}
        //fmt.Println(key)

        keyValue, err := common.CBStore.Get(key)
        if err != nil || keyValue == nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return errorInfo, err
        }</span>

        <span class="cov8" title="1">temp := TbVmInfo{}
        unmarshalErr := json.Unmarshal([]byte(keyValue.Value), &amp;temp)
        if unmarshalErr != nil </span><span class="cov0" title="0">{
                fmt.Println("unmarshalErr:", unmarshalErr)
        }</span>
        <span class="cov8" title="1">fmt.Println("\n[Calling SPIDER]START")
        fmt.Println("CspVmId: " + temp.CspViewVmDetail.IId.NameId)

        cspVmId := temp.CspViewVmDetail.IId.NameId

        type statusResponse struct {
                Status         string
                PublicIP       string
                SSHAccessPoint string
        }
        var statusResponseTmp statusResponse

        if os.Getenv("SPIDER_CALL_METHOD") == "REST" </span><span class="cov8" title="1">{

                url := common.SPIDER_REST_URL + "/vm/" + cspVmId
                method := "GET"

                type VMStatusReqInfo struct {
                        ConnectionName string
                }
                tempReq := VMStatusReqInfo{}
                tempReq.ConnectionName = temp.ConnectionName
                payload, _ := json.MarshalIndent(tempReq, "", "  ")
                //fmt.Println("payload: " + string(payload)) // for debug

                client := &amp;http.Client{
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>,
                }
                <span class="cov8" title="1">req, err := http.NewRequest(method, url, strings.NewReader(string(payload)))

                errorInfo.Status = StatusFailed

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return errorInfo, err
                }</span>
                <span class="cov8" title="1">req.Header.Add("Content-Type", "application/json")

                res, err := client.Do(req)
                //fmt.Println("Called CB-Spider API.")

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return errorInfo, err
                }</span>

                <span class="cov8" title="1">defer res.Body.Close()
                body, err := ioutil.ReadAll(res.Body)

                statusResponseTmp = statusResponse{}

                err2 := json.Unmarshal(body, &amp;statusResponseTmp)
                if err2 != nil </span><span class="cov0" title="0">{
                        fmt.Println(err2)
                        return errorInfo, err2
                }</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm := api.NewCloudResourceHandler()
                err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm failed to set config : ", err)
                        return errorInfo, err
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error("ccm api open failed : ", err)
                        return errorInfo, err
                }</span>
                <span class="cov8" title="1">defer ccm.Close()

                result, err := ccm.GetVMByParam(temp.ConnectionName, cspVmId)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return errorInfo, err
                }</span>

                <span class="cov8" title="1">statusResponseTmp = statusResponse{}
                err2 := json.Unmarshal([]byte(result), &amp;statusResponseTmp)
                if err2 != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err2)
                        return errorInfo, err2
                }</span>

        }

        //common.PrintJsonPretty(statusResponseTmp)
        <span class="cov8" title="1">fmt.Println(statusResponseTmp)
        //fmt.Println("[Calling SPIDER]END\n")

        vmStatusTmp := TbVmStatusInfo{}
        vmStatusTmp.PublicIp = statusResponseTmp.PublicIP
        vmStatusTmp.SSHPort, _ = TrimIP(statusResponseTmp.SSHAccessPoint)

        return vmStatusTmp, nil</span>

}

func GetVmSshKey(nsId string, mcisId string, vmId string) (string, string, string) <span class="cov8" title="1">{

        var content struct {
                SshKeyId string `json:"sshKeyId"`
        }

        fmt.Println("[GetVmSshKey]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        //fmt.Println("===============================================")

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        fmt.Printf("%+v\n", content.SshKeyId)

        sshKey := common.GenResourceKey(nsId, common.StrSSHKey, content.SshKeyId)
        keyValue, _ = common.CBStore.Get(sshKey)
        var keyContent struct {
                Username         string `json:"username"`
                VerifiedUsername string `json:"verifiedUsername"`
                PrivateKey       string `json:"privateKey"`
        }
        json.Unmarshal([]byte(keyValue.Value), &amp;keyContent)

        return keyContent.Username, keyContent.VerifiedUsername, keyContent.PrivateKey
}</span>

// func UpdateVmInfo(nsId string, mcisId string, vmInfoData TbVmInfo)
func UpdateVmSshKey(nsId string, mcisId string, vmId string, verifiedUserName string) error <span class="cov8" title="1">{

        var content struct {
                SshKeyId string `json:"sshKeyId"`
        }
        fmt.Println("[GetVmSshKey]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        keyValue, _ := common.CBStore.Get(key)
        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        sshKey := common.GenResourceKey(nsId, common.StrSSHKey, content.SshKeyId)
        keyValue, _ = common.CBStore.Get(sshKey)

        tmpSshKeyInfo := mcir.TbSshKeyInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;tmpSshKeyInfo)

        tmpSshKeyInfo.VerifiedUsername = verifiedUserName

        val, _ := json.Marshal(tmpSshKeyInfo)
        err := common.CBStore.Put(string(keyValue.Key), string(val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func GetVmIp(nsId string, mcisId string, vmId string) (string, string) <span class="cov8" title="1">{

        var content struct {
                PublicIP string `json:"publicIP"`
                SSHPort  string `json:"sshPort"`
        }

        fmt.Printf("[GetVmIp] " + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
        //fmt.Println("===============================================")

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        fmt.Printf(" %+v\n", content.PublicIP)

        return content.PublicIP, content.SSHPort
}</span>

func GetVmSpecId(nsId string, mcisId string, vmId string) string <span class="cov8" title="1">{

        var content struct {
                SpecId string `json:"specId"`
        }

        fmt.Println("[getVmSpecID]" + vmId)
        key := common.GenMcisKey(nsId, mcisId, vmId)

        keyValue, _ := common.CBStore.Get(key)

        json.Unmarshal([]byte(keyValue.Value), &amp;content)

        fmt.Printf("%+v\n", content.SpecId)

        return content.SpecId
}</span>

func GetVmListByLabel(nsId string, mcisId string, label string) ([]string, error) <span class="cov0" title="0">{

        fmt.Println("[GetVmListByLabel]" + mcisId + " by " + label)

        var vmListByLabel []string

        vmList, err := ListVmId(nsId, mcisId)
        fmt.Println(vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // delete vms info
        <span class="cov0" title="0">for _, v := range vmList </span><span class="cov0" title="0">{
                vmObj, vmErr := GetVmObject(nsId, mcisId, v)
                if vmErr != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return nil, vmErr
                }</span>
                //fmt.Println("vmObj.Label: "+ vmObj.Label)
                <span class="cov0" title="0">if vmObj.Label == label </span><span class="cov0" title="0">{
                        fmt.Println("Found VM with " + vmObj.Label + ", VM ID: " + vmObj.Id)
                        vmListByLabel = append(vmListByLabel, vmObj.Id)
                }</span>
        }
        <span class="cov0" title="0">return vmListByLabel, nil</span>

}

func GetVmTemplate(nsId string, mcisId string, algo string) (TbVmInfo, error) <span class="cov0" title="0">{

        fmt.Println("[GetVmTemplate]" + mcisId + " by algo: " + algo)

        vmList, err := ListVmId(nsId, mcisId)
        //fmt.Println(vmList)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbVmInfo{}, err
        }</span>
        <span class="cov0" title="0">if len(vmList) == 0 </span><span class="cov0" title="0">{
                return TbVmInfo{}, nil
        }</span>

        <span class="cov0" title="0">rand.Seed(time.Now().UnixNano())
        index := rand.Intn(len(vmList))
        vmObj, vmErr := GetVmObject(nsId, mcisId, vmList[index])
        var vmTemplate TbVmInfo

        // only take template required to create VM
        vmTemplate.Name = vmObj.Name
        vmTemplate.ConnectionName = vmObj.ConnectionName
        vmTemplate.ImageId = vmObj.ImageId
        vmTemplate.SpecId = vmObj.SpecId
        vmTemplate.VNetId = vmObj.VNetId
        vmTemplate.SubnetId = vmObj.SubnetId
        vmTemplate.SecurityGroupIds = vmObj.SecurityGroupIds
        vmTemplate.SshKeyId = vmObj.SshKeyId
        vmTemplate.VmUserAccount = vmObj.VmUserAccount
        vmTemplate.VmUserPassword = vmObj.VmUserPassword

        if vmErr != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return TbVmInfo{}, vmErr
        }</span>

        <span class="cov0" title="0">return vmTemplate, nil</span>

}

// GetCloudLocation. (need error handling)
func GetCloudLocation(cloudType string, nativeRegion string) GeoLocation <span class="cov0" title="0">{

        location := GeoLocation{}

        if cloudType == "" || nativeRegion == "" </span><span class="cov0" title="0">{

                // need error handling instead of assigning default value
                location.CloudType = "ufc"
                location.NativeRegion = "ufc"
                location.BriefAddr = "South Korea (Seoul)"
                location.Latitude = "37.4767"
                location.Longitude = "126.8841"

                return location
        }</span>

        <span class="cov0" title="0">key := "/cloudtype/" + cloudType + "/region/" + nativeRegion

        fmt.Printf("[GetCloudLocation] KEY: %+v\n", key)

        keyValue, err := common.CBStore.Get(key)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return location
        }</span>

        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                file, fileErr := os.Open("../assets/cloudlocation.csv")
                defer file.Close()
                if fileErr != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(fileErr)
                        return location
                }</span>

                <span class="cov0" title="0">rdr := csv.NewReader(bufio.NewReader(file))
                rows, _ := rdr.ReadAll()
                for i, row := range rows </span><span class="cov0" title="0">{
                        keyLoc := "/cloudtype/" + rows[i][0] + "/region/" + rows[i][1]
                        location.CloudType = rows[i][0]
                        location.NativeRegion = rows[i][1]
                        location.BriefAddr = rows[i][2]
                        location.Latitude = rows[i][3]
                        location.Longitude = rows[i][4]
                        valLoc, _ := json.Marshal(location)
                        dbErr := common.CBStore.Put(string(keyLoc), string(valLoc))
                        if dbErr != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(dbErr)
                                return location
                        }</span>
                        <span class="cov0" title="0">for j := range row </span><span class="cov0" title="0">{
                                fmt.Printf("%s ", rows[i][j])
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                <span class="cov0" title="0">keyValue, err = common.CBStore.Get(key)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return location
                }</span>
        }

        <span class="cov0" title="0">if keyValue != nil </span><span class="cov0" title="0">{
                fmt.Printf("[GetCloudLocation] %+v %+v\n", keyValue.Key, keyValue.Value)
                err = json.Unmarshal([]byte(keyValue.Value), &amp;location)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)
                        return location
                }</span>
        }

        <span class="cov0" title="0">return location</span>
}

/*
type vmOverview struct {
        Id          string      `json:"id"`
        Name        string      `json:"name"`
        ConnectionName string      `json:"connectionName"`
        Region      RegionInfo  `json:"region"` // AWS, ex) {us-east1, us-east1-c} or {ap-northeast-2}
        Location    GeoLocation `json:"location"`
        PublicIP    string      `json:"publicIP"`
        PublicDNS   string      `json:"publicDNS"`
        Status      string      `json:"status"`
}
*/

/* Use "SpiderVMInfo" (from Spider), instead of this.
type vmCspViewInfo struct {
        Name      string    // AWS,
        Id        string    // AWS,
        StartTime time.Time // Timezone: based on cloud-barista server location.

        Region           RegionInfo // AWS, ex) {us-east1, us-east1-c} or {ap-northeast-2}
        ImageId          string
        VMSpecId         string   // AWS, instance type or flavour, etc... ex) t2.micro or f1.micro
        VirtualNetworkId string   // AWS, ex) subnet-8c4a53e4
        SecurityGroupIds []string // AWS, ex) sg-0b7452563e1121bb6

        NetworkInterfaceId string // ex) eth0
        PublicIP           string // ex) AWS, 13.125.43.21
        PublicDNS          string // ex) AWS, ec2-13-125-43-0.ap-northeast-2.compute.amazonaws.com
        PrivateIP          string // ex) AWS, ip-172-31-4-60.ap-northeast-2.compute.internal
        PrivateDNS         string // ex) AWS, 172.31.4.60

        KeyPairName  string // ex) AWS, powerkimKeyPair
        VMUserId     string // ex) user1
        VMUserPasswd string

        VMBootDisk  string // ex) /dev/sda1
        VMBlockDisk string // ex)

        KeyValueList []common.KeyValue
}
*/
</pre>
		
		<pre class="file" id="file90" style="display: none">package mcis

import (

        //"encoding/json"

        "time"

        "github.com/tidwall/gjson"

        "fmt"
        "io/ioutil"

        //"log"

        //"strings"
        "strconv"

        "bytes"
        "mime/multipart"

        // REST API (echo)
        "net/http"

        "sync"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

const monMetricAll string = "all"
const monMetricCpu string = "cpu"
const monMetricCpufreq string = "cpufreq"
const monMetricMem string = "mem"
const monMetricNet string = "net"
const monMetricSwap string = "swap"
const monMetricDisk string = "disk"
const monMetricDiskio string = "diskio"

// MonAgentInstallReq struct
type MonAgentInstallReq struct {
        NsId     string `json:"nsId,omitempty"`
        McisId   string `json:"mcisId,omitempty"`
        VmId     string `json:"vmId,omitempty"`
        PublicIp string `json:"publicIp,omitempty"`
        Port     string `json:"port,omitempty"`
        UserName string `json:"userName,omitempty"`
        SshKey   string `json:"sshKey,omitempty"`
        Csp_type string `json:"cspType,omitempty"`
}

/*
type DfTelegrafMetric struct {
        Name      string                 `json:"name"`
        Tags      map[string]interface{} `json:"tags"`
        Fields    map[string]interface{} `json:"fields"`
        Timestamp int64                  `json:"timestamp"`
        TagInfo   map[string]interface{} `json:"tagInfo"`
}
*/

// MonResultSimple struct is for containing vm monitoring results
type MonResultSimple struct {
        Metric string `json:"metric"`
        VmId   string `json:"vmId"`
        Value  string `json:"value"`
        Err    string `json:"err"`
}

// MonResultSimpleResponse struct is for containing Mcis monitoring results
type MonResultSimpleResponse struct {
        NsId           string            `json:"nsId"`
        McisId         string            `json:"mcisId"`
        McisMonitoring []MonResultSimple `json:"mcisMonitoring"`
}

// Module for checking CB-Dragonfly endpoint (call get config)
func CheckDragonflyEndpoint() error <span class="cov0" title="0">{
        cmd := "/config"

        url := common.DRAGONFLY_REST_URL + cmd
        method := "GET"

        client := &amp;http.Client{}
        req, err := http.NewRequest(method, url, nil)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov0" title="0">res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        body, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println(string(body))
        return nil</span>
}

func CallMonitoringAsync(wg *sync.WaitGroup, nsID string, mcisID string, vmID string, givenUserName string, method string, cmd string, returnResult *[]SshCmdResult) <span class="cov0" title="0">{

        defer wg.Done() //goroutin sync done

        vmIP, sshPort := GetVmIp(nsID, mcisID, vmID)
        userName, privateKey, err := VerifySshUserName(nsID, mcisID, vmID, vmIP, sshPort, givenUserName)
        errStr := ""
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>
        <span class="cov0" title="0">fmt.Println("[CallMonitoringAsync] " + mcisID + "/" + vmID + "(" + vmIP + ")" + "with userName:" + userName)

        // set vm MonAgentStatus = "installing" (to avoid duplicated requests)
        vmInfoTmp, _ := GetVmObject(nsID, mcisID, vmID)
        vmInfoTmp.MonAgentStatus = "installing"
        UpdateVmInfo(nsID, mcisID, vmInfoTmp)

        url := common.DRAGONFLY_REST_URL + cmd
        fmt.Println("\n[Calling DRAGONFLY] START")
        fmt.Println("VM:" + nsID + "_" + mcisID + "_" + vmID + ", URL:" + url + ", userName:" + userName + ", cspType:" + vmInfoTmp.Location.CloudType)

        tempReq := MonAgentInstallReq{
                NsId:     nsID,
                McisId:   mcisID,
                VmId:     vmID,
                PublicIp: vmIP,
                Port:     sshPort,
                UserName: userName,
                SshKey:   privateKey,
        }
        if tempReq.SshKey == "" </span><span class="cov0" title="0">{
                fmt.Printf("\n[Request body to CB-DRAGONFLY]A problem detected.SshKey is empty.\n")
                common.PrintJsonPretty(tempReq)
        }</span>

        <span class="cov0" title="0">payload := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(payload)
        _ = writer.WriteField("ns_id", nsID)
        _ = writer.WriteField("mcis_id", mcisID)
        _ = writer.WriteField("vm_id", vmID)
        _ = writer.WriteField("public_ip", vmIP)
        _ = writer.WriteField("port", sshPort)
        _ = writer.WriteField("user_name", userName)
        _ = writer.WriteField("ssh_key", privateKey)
        _ = writer.WriteField("cspType", vmInfoTmp.Location.CloudType)
        err = writer.Close()

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>

        <span class="cov0" title="0">responseLimit := 8
        client := &amp;http.Client{
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse
                }</span>,
                Timeout: time.Duration(responseLimit) * time.Minute,
        }
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, payload)
        req.Header.Set("Content-Type", writer.FormDataContentType())

        res, err := client.Do(req)

        result := ""

        fmt.Println("Called CB-DRAGONFLY API")
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch </span>{
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                        err1 := fmt.Errorf("HTTP Status: not in 200-399")
                        common.CBLog.Error(err1)
                        errStr = err1.Error()</span>
                }

                <span class="cov0" title="0">defer res.Body.Close()
                body, err2 := ioutil.ReadAll(res.Body)
                if err2 != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err2)
                        errStr = err2.Error()
                }</span>

                <span class="cov0" title="0">result = string(body)</span>
        }

        //wg.Done() //goroutin sync done

        //vmInfoTmp, _ := GetVmObject(nsID, mcisID, vmID)

        <span class="cov0" title="0">sshResultTmp := SshCmdResult{}
        sshResultTmp.McisId = mcisID
        sshResultTmp.VmId = vmID
        sshResultTmp.VmIp = vmIP

        if err != nil </span><span class="cov0" title="0">{
                sshResultTmp.Result = errStr
                sshResultTmp.Err = err
                *returnResult = append(*returnResult, sshResultTmp)
                vmInfoTmp.MonAgentStatus = "failed"
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("result " + result)
                sshResultTmp.Result = result
                sshResultTmp.Err = nil
                *returnResult = append(*returnResult, sshResultTmp)
                vmInfoTmp.MonAgentStatus = "installed"
        }</span>

        <span class="cov0" title="0">UpdateVmInfo(nsID, mcisID, vmInfoTmp)</span>

}

func InstallMonitorAgentToMcis(nsId string, mcisId string, req *McisCmdReq) (AgentInstallContentWrapper, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := AgentInstallContentWrapper{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov8" title="1">{
                temp := AgentInstallContentWrapper{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">content := AgentInstallContentWrapper{}

        //install script
        cmd := "/agent"

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Install agent for each VM]")

        //goroutin sync wg
        var wg sync.WaitGroup

        var resultArray []SshCmdResult

        method := "POST"

        for _, v := range vmList </span><span class="cov8" title="1">{
                vmObjTmp, _ := GetVmObject(nsId, mcisId, v)
                fmt.Println("MonAgentStatus : " + vmObjTmp.MonAgentStatus)

                // Request agent installation (skip if in installing or installed status)
                if vmObjTmp.MonAgentStatus != "installed" &amp;&amp; vmObjTmp.MonAgentStatus != "installing" </span><span class="cov8" title="1">{

                        // Avoid RunSSH to not ready VM
                        if err == nil </span><span class="cov8" title="1">{
                                wg.Add(1)
                                go CallMonitoringAsync(&amp;wg, nsId, mcisId, v, req.UserName, method, cmd, &amp;resultArray)
                        }</span> else<span class="cov0" title="0"> {
                                common.CBLog.Error(err)
                        }</span>

                }
        }
        <span class="cov8" title="1">wg.Wait() //goroutin sync wg

        for _, v := range resultArray </span><span class="cov8" title="1">{

                resultTmp := AgentInstallContent{}
                resultTmp.McisId = mcisId
                resultTmp.VmId = v.VmId
                resultTmp.VmIp = v.VmIp
                resultTmp.Result = v.Result
                content.Result_array = append(content.Result_array, resultTmp)
                //fmt.Println("result from goroutin " + v)
        }</span>

        //fmt.Printf("%+v\n", content)
        <span class="cov8" title="1">common.PrintJsonPretty(content)

        return content, nil</span>

}

// GetMonitoringData func retrieves monitoring data from cb-dragonfly
func GetMonitoringData(nsId string, mcisId string, metric string) (MonResultSimpleResponse, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := MonResultSimpleResponse{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := MonResultSimpleResponse{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcis(nsId, mcisId)

        if !check </span><span class="cov8" title="1">{
                temp := MonResultSimpleResponse{}
                err := fmt.Errorf("The mcis " + mcisId + " does not exist.")
                return temp, err
        }</span>

        <span class="cov8" title="1">content := MonResultSimpleResponse{}

        vmList, err := ListVmId(nsId, mcisId)
        if err != nil </span><span class="cov0" title="0">{
                //common.CBLog.Error(err)
                return content, err
        }</span>

        //goroutin sync wg
        <span class="cov8" title="1">var wg sync.WaitGroup

        var resultArray []MonResultSimple

        method := "GET"

        for _, v := range vmList </span><span class="cov8" title="1">{
                wg.Add(1)

                vmId := v
                vmIp, _ := GetVmIp(nsId, mcisId, vmId)

                // DF: Get vm on-demand monitoring metric info
                // Path Para: /ns/:nsId/mcis/:mcisId/vm/:vmId/agent_ip/:agent_ip/metric/:metric_name/ondemand-monitoring-info
                cmd := "/ns/" + nsId + "/mcis/" + mcisId + "/vm/" + vmId + "/agent_ip/" + vmIp + "/metric/" + metric + "/ondemand-monitoring-info"
                //fmt.Println("[CMD] " + cmd)

                go CallGetMonitoringAsync(&amp;wg, nsId, mcisId, vmId, vmIp, method, metric, cmd, &amp;resultArray)

        }</span>
        <span class="cov8" title="1">wg.Wait() //goroutin sync wg

        content.NsId = nsId
        content.McisId = mcisId
        for _, v := range resultArray </span><span class="cov8" title="1">{
                content.McisMonitoring = append(content.McisMonitoring, v)
                //fmt.Println("result from goroutin " + v)
        }</span>

        <span class="cov8" title="1">fmt.Printf("%+v\n", content)
        //common.PrintJsonPretty(content)

        return content, nil</span>

}

func CallGetMonitoringAsync(wg *sync.WaitGroup, nsID string, mcisID string, vmID string, vmIP string, method string, metric string, cmd string, returnResult *[]MonResultSimple) <span class="cov0" title="0">{

        defer wg.Done() //goroutin sync done

        url := common.DRAGONFLY_REST_URL + cmd
        fmt.Print("[Call CB-DF] ")
        fmt.Println("URL: " + url)

        responseLimit := 8
        client := &amp;http.Client{
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse
                }</span>,
                Timeout: time.Duration(responseLimit) * time.Minute,
        }
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, nil)
        errStr := ""
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span>

        <span class="cov0" title="0">res, err := client.Do(req)

        result := ""

        fmt.Print("[Call CB-DF Result (" + mcisID + "," + vmID + ")] ")
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                errStr = err.Error()
        }</span> else<span class="cov0" title="0"> {
                //fmt.Println("HTTP Status code: " + strconv.Itoa(res.StatusCode))
                switch </span>{
                case res.StatusCode &gt;= 400 || res.StatusCode &lt; 200:<span class="cov0" title="0">
                        err1 := fmt.Errorf("HTTP Status: not in 200-399")
                        common.CBLog.Error(err1)
                        errStr = err1.Error()</span>
                }

                <span class="cov0" title="0">defer res.Body.Close()
                body, err2 := ioutil.ReadAll(res.Body)
                if err2 != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err2)
                        errStr = err2.Error()
                }</span>

                <span class="cov0" title="0">switch </span>{
                case metric == monMetricCpu:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.cpu_utilization")
                        result = value.String()</span>
                case metric == monMetricMem:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.mem_utilization")
                        result = value.String()</span>
                case metric == monMetricDisk:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.disk_utilization")
                        result = value.String()</span>
                case metric == monMetricNet:<span class="cov0" title="0">
                        value := gjson.Get(string(body), "values.bytes_out")
                        result = value.String()</span>
                default:<span class="cov0" title="0">
                        result = string(body)</span>
                }

        }

        //wg.Done() //goroutin sync done

        <span class="cov0" title="0">ResultTmp := MonResultSimple{}
        ResultTmp.VmId = vmID
        ResultTmp.Metric = metric

        if err != nil </span><span class="cov0" title="0">{
                ResultTmp.Value = errStr
                ResultTmp.Err = err.Error()
                *returnResult = append(*returnResult, ResultTmp)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("result " + result)
                ResultTmp.Value = result
                *returnResult = append(*returnResult, ResultTmp)
        }</span>

}
</pre>
		
		<pre class="file" id="file91" style="display: none">package mcis

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
)

// Status for mcis automation
const (
        // AutoStatusReady is const for "Ready" status.
        AutoStatusReady string = "Ready"
        // AutoStatusChecking is const for "Checking" status.
        AutoStatusChecking string = "Checking"
        // AutoStatusDetected is const for "Detected" status.
        AutoStatusDetected string = "Detected"
        // AutoStatusOperating is const for "Operating" status.
        AutoStatusOperating string = "Operating"
        // AutoStatusStabilizing is const for "Stabilizing" status.
        AutoStatusStabilizing string = "Stabilizing"
        // AutoStatusTimeout is const for "Timeout" status.
        AutoStatusTimeout string = "Timeout"
        // AutoStatusError is const for "Failed" status.
        AutoStatusError string = "Failed"
        // AutoStatusSuspended is const for "Suspended" status.
        AutoStatusSuspended string = "Suspended"
)

// Action for mcis automation
const (
        // AutoActionScaleOut is const for "ScaleOut" action.
        AutoActionScaleOut string = "ScaleOut"
        // AutoActionScaleIn is const for "ScaleIn" action.
        AutoActionScaleIn string = "ScaleIn"
)

// AutoCondition is struct for MCIS auto-control condition.
type AutoCondition struct {
        Metric           string   `json:"metric"`
        Operator         string   `json:"operator"`         // &lt;, &lt;=, &gt;, &gt;=, ...
        Operand          string   `json:"operand"`          // 10, 70, 80, 98, ...
        EvaluationPeriod string   `json:"evaluationPeriod"` // evaluationPeriod
        EvaluationValue  []string `json:"evaluationValue"`
        //InitTime           string           `json:"initTime"`  // to check start of duration
        //Duration           string           `json:"duration"`  // duration for checking
}

// AutoAction is struct for MCIS auto-control action.
type AutoAction struct {
        ActionType    string     `json:"actionType"`
        Vm            TbVmInfo   `json:"vm"`
        PostCommand   McisCmdReq `json:"postCommand"`
        PlacementAlgo string     `json:"placementAlgo"`
}

// Policy is struct for MCIS auto-control Policy request that includes AutoCondition, AutoAction, Status.
type Policy struct {
        AutoCondition AutoCondition `json:"autoCondition"`
        AutoAction    AutoAction    `json:"autoAction"`
        Status        string        `json:"status"`
}

// McisPolicyInfo is struct for MCIS auto-control Policy object.
type McisPolicyInfo struct {
        Name   string   `json:"Name"` //MCIS Name (for request)
        Id     string   `json:"Id"`   //MCIS Id (generated ID by the Name)
        Policy []Policy `json:"policy"`

        ActionLog   string `json:"actionLog"`
        Description string `json:"description"`
}

// OrchestrationController is responsible for executing MCIS automation policy.
// OrchestrationController will be periodically involked by a time.NewTicker in main.go.
func OrchestrationController() <span class="cov0" title="0">{

        nsList, err := common.ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err = fmt.Errorf("an error occurred while getting namespaces' list: " + err.Error())
                return
        }</span>

        //fmt.Println("")
        <span class="cov0" title="0">for _, nsId := range nsList </span><span class="cov0" title="0">{

                mcisPolicyList := ListMcisPolicyId(nsId)

                for _, m := range mcisPolicyList </span><span class="cov0" title="0">{
                        fmt.Println("NS[" + nsId + "]" + "McisPolicy[" + m + "]")
                }</span>

                <span class="cov0" title="0">for _, v := range mcisPolicyList </span><span class="cov0" title="0">{

                        key := common.GenMcisPolicyKey(nsId, v, "")
                        //fmt.Println(key)
                        keyValue, _ := common.CBStore.Get(key)
                        if keyValue == nil </span><span class="cov0" title="0">{
                                //mapA := map[string]string{"message": "Cannot find " + key}
                                //return c.JSON(http.StatusOK, &amp;mapA)
                                fmt.Println("keyValue is nil")
                        }</span>
                        //fmt.Println("&lt;" + keyValue.Key + "&gt; \n" + keyValue.Value)
                        <span class="cov0" title="0">mcisPolicyTmp := McisPolicyInfo{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;mcisPolicyTmp)

                        /* FYI
                        const AutoStatusReady string = "Ready"
                        const AutoStatusChecking string = "Checking"
                        const AutoStatusHappened string = "Happened"
                        const AutoStatusOperating string = "Operating"
                        const AutoStatusTimeout string = "Timeout"
                        const AutoStatusError string = "Error"
                        const AutoStatusSuspend string = "Suspend"
                        */

                        for policyIndex := range mcisPolicyTmp.Policy </span><span class="cov0" title="0">{
                                fmt.Println("\n[MCIS-Policy-StateMachine]")
                                common.PrintJsonPretty(mcisPolicyTmp.Policy[policyIndex])

                                switch </span>{
                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusReady:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + AutoStatusReady + "],[" + v + "]")
                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusChecking
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)

                                        fmt.Println("[Check MCIS Policy] " + mcisPolicyTmp.Id)
                                        check, _ := CheckMcis(nsId, mcisPolicyTmp.Id)
                                        fmt.Println("[Check existence of MCIS] " + mcisPolicyTmp.Id)
                                        //keyValueMcis, _ := common.CBStore.Get(common.GenMcisKey(nsId, mcisPolicyTmp.Id, ""))

                                        if !check </span><span class="cov0" title="0">{
                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                fmt.Println("[MCIS is not exist] " + mcisPolicyTmp.Id)
                                                break</span>
                                        } else<span class="cov0" title="0"> { // need to enhance : loop for each policies and realize metric

                                                //Checking (measuring)
                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusChecking
                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")

                                                fmt.Println("[MCIS is exist] " + mcisPolicyTmp.Id)
                                                content, err := GetMonitoringData(nsId, mcisPolicyTmp.Id, mcisPolicyTmp.Policy[policyIndex].AutoCondition.Metric)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        common.CBLog.Error(err)
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        break</span>
                                                }
                                                //common.PrintJsonPretty(content)

                                                //Statistic
                                                <span class="cov0" title="0">sumMcis := 0.0
                                                for _, monData := range content.McisMonitoring </span><span class="cov0" title="0">{
                                                        //fmt.Println("[monData.Value: ] " + monData.Value)
                                                        monDataValue, _ := strconv.ParseFloat(monData.Value, 64)
                                                        sumMcis += monDataValue
                                                }</span>
                                                <span class="cov0" title="0">averMcis := (sumMcis / float64(len(content.McisMonitoring)))
                                                fmt.Printf("[monData.Value] AverMcis: %f,  SumMcis: %f \n", averMcis, sumMcis)

                                                evaluationPeriod, _ := strconv.Atoi(mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationPeriod)
                                                evaluationValue := mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationValue
                                                evaluationValue = append([]string{fmt.Sprintf("%f", averMcis)}, evaluationValue...) // prepend current aver date
                                                mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationValue = evaluationValue

                                                sum := 0.0
                                                aver := -0.1
                                                // accumerate previous evaluation value
                                                fmt.Printf("[Evaluation History]\n")
                                                for evi, evv := range evaluationValue </span><span class="cov0" title="0">{
                                                        evvFloat, _ := strconv.ParseFloat(evv, 64)
                                                        sum += evvFloat
                                                        fmt.Printf("[%v] %f ", evi, evvFloat)
                                                        // break with outside evaluationValue
                                                        if evi &gt;= evaluationPeriod-1 </span><span class="cov0" title="0">{
                                                                break</span>
                                                        }
                                                }
                                                // average for evaluationPeriod (if data for the period is not enough, skip)
                                                <span class="cov0" title="0">if evaluationPeriod != 0 &amp;&amp; len(evaluationValue) &gt;= evaluationPeriod </span><span class="cov0" title="0">{
                                                        aver = sum / float64(evaluationPeriod)
                                                }</span>
                                                <span class="cov0" title="0">fmt.Printf("\n[Evaluation] Aver: %f,  Period: %v \n", aver, evaluationPeriod)

                                                //Detecting
                                                operator := mcisPolicyTmp.Policy[policyIndex].AutoCondition.Operator
                                                operand, _ := strconv.ParseFloat(mcisPolicyTmp.Policy[policyIndex].AutoCondition.Operand, 64)

                                                if evaluationPeriod == 0 </span><span class="cov0" title="0">{
                                                        fmt.Println("[Checking] Not available evaluationPeriod ")
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        break</span>
                                                }
                                                // not enough evaluationPeriod
                                                <span class="cov0" title="0">if aver == -0.1 </span><span class="cov0" title="0">{
                                                        fmt.Println("[Checking] Not enough evaluationPeriod ")
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">switch </span>{
                                                case operator == "&gt;=":<span class="cov0" title="0">
                                                        if aver &gt;= operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &gt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected
                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &gt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                case operator == "&gt;":<span class="cov0" title="0">
                                                        if aver &gt; operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &gt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &gt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                case operator == "&lt;=":<span class="cov0" title="0">
                                                        if aver &lt;= operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &lt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &lt;=  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                case operator == "&lt;":<span class="cov0" title="0">
                                                        if aver &lt; operand </span><span class="cov0" title="0">{
                                                                fmt.Printf("[Detected] Aver: %f &lt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[Not Detected] Aver: %f &lt;  Operand: %f \n", aver, operand)
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                                        }</span>
                                                default:<span class="cov0" title="0">
                                                        fmt.Println("[Checking] Not available operator " + operator)
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError</span>
                                                }
                                        }
                                        <span class="cov0" title="0">UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusChecking:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>
                                        //mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusDetected

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusDetected:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")
                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusOperating
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")

                                        //Action
                                        /*
                                                // Actions for mcis automation
                                                const AutoActionScaleOut string = "ScaleOut"
                                                const AutoActionScaleIn string = "ScaleIn"
                                        */

                                        autoAction := mcisPolicyTmp.Policy[policyIndex].AutoAction
                                        fmt.Println("[autoAction] " + autoAction.ActionType)

                                        switch </span>{
                                        case autoAction.ActionType == AutoActionScaleOut:<span class="cov0" title="0">

                                                autoAction.Vm.Label = labelAutoGen
                                                // append UUID to given vm name to avoid duplicated vm ID.
                                                autoAction.Vm.Name = autoAction.Vm.Name + "-" + common.GenUuid()
                                                //vmReqTmp := autoAction.Vm

                                                if autoAction.PlacementAlgo == "random" </span><span class="cov0" title="0">{
                                                        fmt.Println("[autoAction.PlacementAlgo] " + autoAction.PlacementAlgo)
                                                        var vmTmpErr error
                                                        autoAction.Vm, vmTmpErr = GetVmTemplate(nsId, mcisPolicyTmp.Id, autoAction.PlacementAlgo)
                                                        if vmTmpErr != nil </span><span class="cov0" title="0">{
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        }</span>
                                                        <span class="cov0" title="0">autoAction.Vm.Name = autoAction.Vm.Name + "-Random"
                                                        autoAction.Vm.Label = labelAutoGen</span>
                                                }

                                                <span class="cov0" title="0">common.PrintJsonPretty(autoAction.Vm)
                                                fmt.Println("[Action] " + autoAction.ActionType)

                                                // ScaleOut MCIS according to the VM requirement.
                                                fmt.Println("[Generating VM]")
                                                result, vmCreateErr := CorePostMcisVm(nsId, mcisPolicyTmp.Id, &amp;autoAction.Vm)
                                                if vmCreateErr != nil </span><span class="cov0" title="0">{
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                }</span>
                                                <span class="cov0" title="0">common.PrintJsonPretty(*result)

                                                nullMcisCmdReq := McisCmdReq{}
                                                if autoAction.PostCommand != nullMcisCmdReq </span><span class="cov0" title="0">{
                                                        fmt.Println("[Post Command to VM] " + autoAction.PostCommand.Command)
                                                        _, cmdErr := CorePostCmdMcisVm(nsId, mcisPolicyTmp.Id, autoAction.Vm.Name, &amp;autoAction.PostCommand)
                                                        if cmdErr != nil </span><span class="cov0" title="0">{
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        }</span>
                                                }

                                        case autoAction.ActionType == AutoActionScaleIn:<span class="cov0" title="0">
                                                fmt.Println("[Action] " + autoAction.ActionType)

                                                // ScaleIn MCIS.
                                                fmt.Println("[Removing VM]")
                                                vmList, vmListErr := GetVmListByLabel(nsId, mcisPolicyTmp.Id, labelAutoGen)
                                                if vmListErr != nil </span><span class="cov0" title="0">{
                                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                }</span>
                                                <span class="cov0" title="0">if len(vmList) != 0 </span><span class="cov0" title="0">{
                                                        removeTargetVm := vmList[len(vmList)-1]
                                                        fmt.Println("[Removing VM ID] " + removeTargetVm)
                                                        delVmErr := DelMcisVm(nsId, mcisPolicyTmp.Id, removeTargetVm, "")
                                                        if delVmErr != nil </span><span class="cov0" title="0">{
                                                                mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusError
                                                                UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                                        }</span>
                                                }

                                        default:<span class="cov0" title="0"></span>
                                        }

                                        <span class="cov0" title="0">mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusStabilizing
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusStabilizing:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")

                                        //initialize Evaluation history so that controller does not act too early.
                                        //with this we can stablize MCIS by init previously measures.
                                        //Will invoke [Checking] Not enough evaluationPeriod
                                        mcisPolicyTmp.Policy[policyIndex].AutoCondition.EvaluationValue = nil

                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusOperating:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>
                                        //mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                        //UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusTimeout:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusError:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")
                                        mcisPolicyTmp.Policy[policyIndex].Status = AutoStatusReady
                                        UpdateMcisPolicyInfo(nsId, mcisPolicyTmp)</span>

                                case mcisPolicyTmp.Policy[policyIndex].Status == AutoStatusSuspended:<span class="cov0" title="0">
                                        fmt.Println("- PolicyStatus[" + mcisPolicyTmp.Policy[policyIndex].Status + "],[" + v + "]")</span>

                                default:<span class="cov0" title="0"></span>
                                }
                        }

                }

        }

}

// UpdateMcisPolicyInfo updates McisPolicyInfo object in DB.
func UpdateMcisPolicyInfo(nsId string, mcisPolicyInfoData McisPolicyInfo) <span class="cov0" title="0">{
        key := common.GenMcisPolicyKey(nsId, mcisPolicyInfoData.Id, "")
        val, _ := json.Marshal(mcisPolicyInfoData)
        err := common.CBStore.Put(string(key), string(val))
        if err != nil &amp;&amp; !strings.Contains(err.Error(), common.CbStoreKeyNotFoundErrorString) </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
        }</span>
        //fmt.Println("===========================")
        //vmkeyValue, _ := common.CBStore.Get(string(key))
        //fmt.Println("&lt;" + vmkeyValue.Key + "&gt; \n" + vmkeyValue.Value)
        //fmt.Println("===========================")
}

// CreateMcisPolicy create McisPolicyInfo object in DB according to user's requirements.
func CreateMcisPolicy(nsId string, mcisId string, u *McisPolicyInfo) (McisPolicyInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcisPolicy(nsId, mcisId)

        u.Name = mcisId
        u.Id = mcisId
        //u.Status = AutoStatusReady

        if check </span><span class="cov8" title="1">{
                temp := McisPolicyInfo{}
                err := fmt.Errorf("The MCIS Policy Obj " + u.Name + " already exists.")
                return temp, err
        }</span>

        <span class="cov8" title="1">for policyIndex := range u.Policy </span><span class="cov8" title="1">{
                u.Policy[policyIndex].Status = AutoStatusReady
        }</span>

        <span class="cov8" title="1">content := *u

        // cb-store
        fmt.Println("=========================== PUT CreateMcisPolicy")
        Key := common.GenMcisPolicyKey(nsId, content.Id, "")
        Val, _ := json.Marshal(content)

        //fmt.Println("Key: ", Key)
        //fmt.Println("Val: ", Val)
        err = common.CBStore.Put(string(Key), string(Val))
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return content, err
        }</span>
        <span class="cov8" title="1">keyValue, _ := common.CBStore.Get(string(Key))
        fmt.Println("&lt;KEY&gt;\n" + keyValue.Key + "\n&lt;VAL&gt;\n" + keyValue.Value)
        fmt.Println("===========================")

        return content, nil</span>
}

// GetMcisPolicyObject returns McisPolicyInfo object.
func GetMcisPolicyObject(nsId string, mcisId string) (McisPolicyInfo, error) <span class="cov8" title="1">{
        fmt.Println("[GetMcisPolicyObject]" + mcisId)

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                temp := McisPolicyInfo{}
                common.CBLog.Error(err)
                return temp, err
        }</span>
        <span class="cov8" title="1">key := common.GenMcisPolicyKey(nsId, mcisId, "")
        fmt.Println("Key: ", key)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return McisPolicyInfo{}, err
        }</span>
        <span class="cov8" title="1">if keyValue == nil </span><span class="cov8" title="1">{
                return McisPolicyInfo{}, err
        }</span>

        <span class="cov8" title="1">fmt.Println("&lt;KEY&gt;\n" + keyValue.Key + "\n&lt;VAL&gt;\n" + keyValue.Value)

        mcisPolicyTmp := McisPolicyInfo{}
        json.Unmarshal([]byte(keyValue.Value), &amp;mcisPolicyTmp)
        return mcisPolicyTmp, nil</span>
}

// GetAllMcisPolicyObject returns all McisPolicyInfo objects.
func GetAllMcisPolicyObject(nsId string) ([]McisPolicyInfo, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">Mcis := []McisPolicyInfo{}
        mcisList := ListMcisPolicyId(nsId)

        for _, v := range mcisList </span><span class="cov8" title="1">{

                key := common.GenMcisPolicyKey(nsId, v, "")
                keyValue, _ := common.CBStore.Get(key)
                if keyValue == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Cannot find " + key)
                }</span>
                <span class="cov8" title="1">mcisTmp := McisPolicyInfo{}
                json.Unmarshal([]byte(keyValue.Value), &amp;mcisTmp)
                Mcis = append(Mcis, mcisTmp)</span>
        }

        <span class="cov8" title="1">return Mcis, nil</span>
}

// ListMcisPolicyId returns a list of Ids for all McisPolicyInfo objects .
func ListMcisPolicyId(nsId string) []string <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return nil
        }</span>
        //fmt.Println("[Get MCIS Policy ID list]")
        <span class="cov8" title="1">key := "/ns/" + nsId + "/policy/mcis"
        keyValue, _ := common.CBStore.GetList(key, true)

        var mcisList []string
        for _, v := range keyValue </span><span class="cov8" title="1">{
                if !strings.Contains(v.Key, "vm") </span><span class="cov8" title="1">{
                        mcisList = append(mcisList, strings.TrimPrefix(v.Key, "/ns/"+nsId+"/policy/mcis/"))
                }</span>
        }
        <span class="cov8" title="1">return mcisList</span>
}

// DelMcisPolicy deletes McisPolicyInfo object by mcisId.
func DelMcisPolicy(nsId string, mcisId string) error <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">check, _ := CheckMcisPolicy(nsId, mcisId)

        if !check </span><span class="cov8" title="1">{
                err := fmt.Errorf("The mcis Policy" + mcisId + " does not exist.")
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("[Delete MCIS Policy] " + mcisId)

        key := common.GenMcisPolicyKey(nsId, mcisId, "")
        fmt.Println(key)

        // delete mcis Policy info
        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DelAllMcisPolicy deletes all McisPolicyInfo objects.
func DelAllMcisPolicy(nsId string) (string, error) <span class="cov8" title="1">{

        err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">mcisList := ListMcisPolicyId(nsId)
        if len(mcisList) == 0 </span><span class="cov8" title="1">{
                return "No MCIS Policy to delete", nil
        }</span>
        <span class="cov0" title="0">for _, v := range mcisList </span><span class="cov0" title="0">{
                err := DelMcisPolicy(nsId, v)
                if err != nil </span><span class="cov0" title="0">{
                        common.CBLog.Error(err)

                        return "", fmt.Errorf("Failed to delete All MCIS Policies")
                }</span>
        }
        <span class="cov0" title="0">return "All MCIS Policies has been deleted", nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package mcis

import (
        "fmt"
        "math"
        "sort"
        "strconv"
        "strings"

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcir"
)

// DeploymentPlan is struct for .
type DeploymentPlan struct {
        Filter   FilterInfo   `json:"filter"`
        Priority PriorityInfo `json:"priority"`
        Limit    string       `json:"limit" example:"5" enums:"1,2,...,30,..."`
}

// FilterInfo is struct for .
type FilterInfo struct {
        Policy []FilterCondition `json:"policy"`
}

// FilterCondition is struct for .
type FilterCondition struct {
        Metric    string      `json:"metric" example:"num_vCPU" enums:"num_vCPU,mem_GiB,Cost_per_hour"`
        Condition []Operation `json:"condition"`
}

// Operation is struct for .
type Operation struct {
        Operator string `json:"operator" example:"&gt;=" enums:"&gt;=,&lt;=,=="` // &gt;=, &lt;=, ==
        Operand  string `json:"operand" example:"4" enums:"4,8,.."`     // 10, 70, 80, 98, ...
}

// PriorityInfo is struct for .
type PriorityInfo struct {
        Policy []PriorityCondition `json:"policy"`
}

// FilterCondition is struct for .
type PriorityCondition struct {
        Metric    string            `json:"metric" example:"location" enums:"location,latency,cost"` // location,latency,cost
        Weight    string            `json:"weight" example:"0.3" enums:"0.1,0.2,..."`                // 0.3
        Parameter []ParameterKeyVal `json:"parameter"`
}

// Operation is struct for .
type ParameterKeyVal struct {
        Key string   `json:"key" example:"coordinateClose" enums:"coordinateClose,coordinateWithin,coordinateFair"` // coordinate
        Val []string `json:"val" example:"46.3772/2.3730"`                                                          // ["Latitude,Longitude","12,543",..,"31,433"]
}

///

//// Info manage for MCIS recommendation
func RecommendVm(nsId string, plan DeploymentPlan) ([]mcir.TbSpecInfo, error) <span class="cov0" title="0">{

        fmt.Println("RecommendVm")

        // Filtering first

        u := &amp;mcir.FilterSpecsByRangeRequest{}

        // veryLargeValue := float32(math.MaxFloat32)
        // verySmallValue := float32(0)

        // Filtering
        fmt.Println("[Filtering specs]")

        for _, v := range plan.Filter.Policy </span><span class="cov0" title="0">{
                metric := v.Metric
                conditions := v.Condition
                for _, condition := range conditions </span><span class="cov0" title="0">{

                        operand64, err := strconv.ParseFloat(condition.Operand, 32)
                        operand := float32(operand64)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return []mcir.TbSpecInfo{}, err
                        }</span>

                        <span class="cov0" title="0">switch condition.Operator </span>{
                        case "&lt;=":<span class="cov0" title="0">

                                switch metric </span>{
                                case "num_vCPU":<span class="cov0" title="0">
                                        u.Num_vCPU.Max = operand</span>
                                case "mem_GiB":<span class="cov0" title="0">
                                        u.Mem_GiB.Max = operand</span>
                                case "Cost_per_hour":<span class="cov0" title="0">
                                        u.Cost_per_hour.Max = operand</span>
                                default:<span class="cov0" title="0">
                                        fmt.Println("[Checking] Not available metric " + metric)</span>
                                }

                        case "&gt;=":<span class="cov0" title="0">

                                switch metric </span>{
                                case "num_vCPU":<span class="cov0" title="0">
                                        u.Num_vCPU.Min = operand</span>
                                case "mem_GiB":<span class="cov0" title="0">
                                        u.Mem_GiB.Min = operand</span>
                                case "Cost_per_hour":<span class="cov0" title="0">
                                        u.Cost_per_hour.Min = operand</span>
                                default:<span class="cov0" title="0">
                                        fmt.Println("[Checking] Not available metric " + metric)</span>
                                }

                        case "==":<span class="cov0" title="0">

                                switch metric </span>{
                                case "num_vCPU":<span class="cov0" title="0">
                                        u.Num_vCPU.Max = operand
                                        u.Num_vCPU.Min = operand</span>
                                case "mem_GiB":<span class="cov0" title="0">
                                        u.Mem_GiB.Max = operand
                                        u.Mem_GiB.Min = operand</span>
                                case "Cost_per_hour":<span class="cov0" title="0">
                                        u.Cost_per_hour.Max = operand
                                        u.Cost_per_hour.Min = operand</span>
                                default:<span class="cov0" title="0">
                                        fmt.Println("[Checking] Not available metric " + metric)</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">filteredSpecs, err := mcir.FilterSpecsByRange(nsId, *u)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return []mcir.TbSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">if len(filteredSpecs) == 0 </span><span class="cov0" title="0">{
                return []mcir.TbSpecInfo{}, nil
        }</span>

        // Prioritizing
        <span class="cov0" title="0">fmt.Println("[Prioritizing specs]")
        prioritySpecs := []mcir.TbSpecInfo{}

        for _, v := range plan.Priority.Policy </span><span class="cov0" title="0">{
                metric := v.Metric

                switch metric </span>{
                case "location":<span class="cov0" title="0">
                        prioritySpecs, err = RecommendVmLocation(nsId, &amp;filteredSpecs, &amp;v.Parameter)</span>
                case "latency":<span class="cov0" title="0"></span>
                        //
                case "cost":<span class="cov0" title="0"></span>
                        //
                default:<span class="cov0" title="0"></span>
                        // fmt.Println("[Checking] Not available metric " + metric)
                }

        }

        // limit the number of items in result list
        <span class="cov0" title="0">result := []mcir.TbSpecInfo{}
        limitNum, err := strconv.Atoi(plan.Limit)
        if err != nil </span><span class="cov0" title="0">{
                limitNum = 65535
        }</span>
        <span class="cov0" title="0">for i, v := range prioritySpecs </span><span class="cov0" title="0">{
                result = append(result, v)
                if i == (limitNum - 1) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>

}

// RecommendVmLocation func prioritize specs based on given location
func RecommendVmLocation(nsId string, specList *[]mcir.TbSpecInfo, param *[]ParameterKeyVal) ([]mcir.TbSpecInfo, error) <span class="cov0" title="0">{

        result := []mcir.TbSpecInfo{}

        for _, v := range *param </span><span class="cov0" title="0">{

                switch v.Key </span>{
                case "coordinateClose":<span class="cov0" title="0">
                        //
                        coordinateStr := v.Val[0]

                        slice := strings.Split(coordinateStr, "/")
                        latitude, err := strconv.ParseFloat(slice[0], 32)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return []mcir.TbSpecInfo{}, err
                        }</span>
                        <span class="cov0" title="0">longitude, err := strconv.ParseFloat(slice[1], 32)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                return []mcir.TbSpecInfo{}, err
                        }</span>

                        <span class="cov0" title="0">type distanceType struct {
                                distance      float64
                                index         int
                                priorityIndex int
                        }
                        distances := []distanceType{}

                        for i := range *specList </span><span class="cov0" title="0">{
                                distances = append(distances, distanceType{})
                                distances[i].distance, err = getDistance(latitude, longitude, (*specList)[i].ConnectionName)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        return []mcir.TbSpecInfo{}, err
                                }</span>
                                <span class="cov0" title="0">distances[i].index = i</span>
                        }

                        <span class="cov0" title="0">sort.Slice(distances, func(i, j int) bool </span><span class="cov0" title="0">{
                                return distances[i].distance &lt; distances[j].distance
                        }</span>)
                        <span class="cov0" title="0">fmt.Printf("\n distances : %v \n", distances)

                        priorityCnt := 1
                        for i := range distances </span><span class="cov0" title="0">{

                                // priorityIndex++ if two distances are not equal (give the same priorityIndex if two variables are same)
                                if i != 0 </span><span class="cov0" title="0">{
                                        if distances[i].distance &gt; distances[i-1].distance </span><span class="cov0" title="0">{
                                                priorityCnt++
                                        }</span>
                                }
                                <span class="cov0" title="0">distances[i].priorityIndex = priorityCnt</span>

                        }

                        <span class="cov0" title="0">for i := range *specList </span><span class="cov0" title="0">{
                                // update OrderInFilteredResult based on calculated priorityIndex
                                (*specList)[distances[i].index].OrderInFilteredResult = uint16(distances[i].priorityIndex)
                                // assign nomalized priorityIdex value to EvaluationScore_01
                                (*specList)[distances[i].index].EvaluationScore_01 = float32(1 - (float32(distances[i].priorityIndex) / float32(len(*specList))))
                                (*specList)[distances[i].index].EvaluationScore_02 = float32(distances[i].distance)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("\n distances : %v \n", distances)</span>

                        //fmt.Printf("\n distances : %v \n", *specList)

                case "coordinateWithin":<span class="cov0" title="0"></span>
                        //
                case "coordinateFair":<span class="cov0" title="0"></span>
                        //
                default:<span class="cov0" title="0"></span>
                        // fmt.Println("[Checking] Not available metric " + metric)
                }

        }

        <span class="cov0" title="0">for i := range *specList </span><span class="cov0" title="0">{
                result = append(result, (*specList)[i])
                //result[i].OrderInFilteredResult = uint16(i + 1)
        }</span>

        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].OrderInFilteredResult &lt; result[j].OrderInFilteredResult
        }</span>)
        <span class="cov0" title="0">fmt.Printf("\n result : %v \n", result)

        // updatedSpec, err := mcir.UpdateSpec(nsId, *result)
        // content, err = mcir.SortSpecs(*specList, "mem_GiB", "descending")
        return result, nil</span>
}

// getDistance func get geographical distance between given coordinate and connectionConfig
func getDistance(latitude float64, longitude float64, ConnectionName string) (float64, error) <span class="cov0" title="0">{
        configTmp, _ := common.GetConnConfig(ConnectionName)
        regionTmp, _ := common.GetRegion(configTmp.RegionName)

        nativeRegion := ""
        for _, v := range regionTmp.KeyValueInfoList </span><span class="cov0" title="0">{
                if strings.ToLower(v.Key) == "region" || strings.ToLower(v.Key) == "location" </span><span class="cov0" title="0">{
                        nativeRegion = v.Value
                        break</span>
                }
        }
        <span class="cov0" title="0">Location := GetCloudLocation(strings.ToLower(configTmp.ProviderName), strings.ToLower(nativeRegion))

        cloudLatitude, err := strconv.ParseFloat(Location.Latitude, 32)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>
        <span class="cov0" title="0">cloudLongitude, err := strconv.ParseFloat(Location.Longitude, 32)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return 0, err
        }</span>

        // first := math.Pow(float64(cloudLatitude-latitude), 2)
        // second := math.Pow(float64(cloudLongitude-longitude), 2)
        // return math.Sqrt(first + second), nil
        <span class="cov0" title="0">return getHaversineDistance(cloudLatitude, cloudLongitude, latitude, longitude), nil</span>

}

// getHaversineDistance func return HaversineDistance
func getHaversineDistance(a1 float64, b1 float64, a2 float64, b2 float64) (distance float64) <span class="cov0" title="0">{
        deltaA := (a2 - a1) * (math.Pi / 180)
        deltaB := (b2 - b1) * (math.Pi / 180)

        a := math.Sin(deltaA/2)*math.Sin(deltaA/2) +
                math.Cos(a1*(math.Pi/180))*math.Cos(a2*(math.Pi/180))*math.Sin(deltaB/2)*math.Sin(deltaB/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        earthRadius := float64(6371)
        return (earthRadius * c)
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">// Package for VM's SSH and SCP of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.
// Imported from CB-Spider

package mcis

import (

        //"github.com/sirupsen/logrus"

        "fmt"
        "io"
        "net"
        "os"
        "strings"
        "time"

        "github.com/bramvdbogaerde/go-scp"
        "github.com/bramvdbogaerde/go-scp/auth"
        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        "golang.org/x/crypto/ssh"
)

//var cblog *logrus.Logger

func init() {<span class="cov8" title="1">
        //cblog = config.Cblogger
}</span>

//====================================================================
type SSHInfo struct {
        UserName   string // ex) "root"
        PrivateKey []byte // ex)   []byte(`-----BEGIN RSA PRIVATE KEY-----
        //              MIIEoQIBAAKCAQEArVNOLwMIp5VmZ4VPZotcoCHdEzimKalAsz+ccLfvAA1Y2ELH
        //              ...`)
        ServerPort string // ex) "node12:22"
}

//====================================================================

func Connect(sshInfo SSHInfo) (scp.Client, error) <span class="cov0" title="0">{
        common.CBLog.Info("call Connect()")

        clientConfig, _ := getClientConfig(sshInfo.UserName, sshInfo.PrivateKey, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

//====================================================================
type SSHKeyPathInfo struct {
        UserName   string // ex) "root"
        KeyPath    string // ex) "/root/.ssh/id_rsa // You should use the full path.
        ServerPort string // ex) "node12:22"
}

//====================================================================

func ConnectKeyPath(sshKeyPathInfo SSHKeyPathInfo) (scp.Client, error) <span class="cov0" title="0">{
        common.CBLog.Info("call ConnectKeyPath()")

        clientConfig, _ := auth.PrivateKey(sshKeyPathInfo.UserName, sshKeyPathInfo.KeyPath, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshKeyPathInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

func getClientConfig(username string, privateKey []byte, keyCallBack ssh.HostKeyCallback) (ssh.ClientConfig, error) <span class="cov0" title="0">{

        signer, err := ssh.ParsePrivateKey(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return ssh.ClientConfig{}, err
        }</span>

        <span class="cov0" title="0">clientConfig := ssh.ClientConfig{
                User: username,
                Auth: []ssh.AuthMethod{
                        ssh.PublicKeys(signer),
                },
                HostKeyCallback: keyCallBack,
        }
        return clientConfig, nil</span>
}

func Close(client scp.Client) <span class="cov0" title="0">{
        common.CBLog.Info("call Close()")

        client.Close()
}</span>

func RunCommand(client scp.Client, cmd string) (string, error) <span class="cov0" title="0">{
        common.CBLog.Info("call RunCommand()")

        session := client.Session
        sshOut, err := session.StdoutPipe()
        session.Stderr = os.Stderr

        err = session.Run(cmd)
        //err = session.Start(cmd)

        return stdoutToString(sshOut), err
}</span>

func stdoutToString(sshOut io.Reader) string <span class="cov0" title="0">{
        buf := make([]byte, 1000)
        num, err := sshOut.Read(buf)
        outStr := ""
        if err == nil </span><span class="cov0" title="0">{
                outStr = string(buf[:num])
        }</span>
        <span class="cov0" title="0">for err == nil </span><span class="cov0" title="0">{
                num, err = sshOut.Read(buf)
                outStr += string(buf[:num])
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                        }</span>
                }

        }
        <span class="cov0" title="0">return strings.Trim(outStr, "\n")</span>
}

func Copy(client scp.Client, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        common.CBLog.Info("call Copy()")

        // Open a file
        file, _ := os.Open(sourcePath)
        defer file.Close()
        return client.CopyFile(file, remotePath, "0755")
}</span>

//=============== for One Call Service
func SSHRun(sshInfo SSHInfo, cmd string) (string, error) <span class="cov0" title="0">{
        common.CBLog.Info("call SSHRun()")

        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHRunByKeyPath(sshInfo SSHKeyPathInfo, cmd string) (string, error) <span class="cov0" title="0">{
        common.CBLog.Info("call SSHRunKeyPath()")

        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHCopy(sshInfo SSHInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        common.CBLog.Info("call SSHCopy()")

        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

func SSHCopyByKeyPath(sshInfo SSHKeyPathInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        common.CBLog.Info("call SSHCopyByKeyPath()")

        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

// CheckConnectivity func checks if given port is open and ready.
// For instance, ready for ssh port can be checkek.
func CheckConnectivity(host string, port string) error <span class="cov0" title="0">{

        deadline := 10
        timeout := time.Second * time.Duration(deadline)
        conn, err := net.DialTimeout("tcp", net.JoinHostPort(host, port), timeout)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("[CheckConnectivity]", host, ":", port, ". ERR:", err)
                return err
        }</span>
        <span class="cov0" title="0">if conn != nil </span><span class="cov0" title="0">{
                defer conn.Close()
                fmt.Println("[CheckConnectivity]", host, ":", port, ". Opened")
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package mcis

import (
        //"encoding/json"
        //uuid "github.com/google/uuid"
        "fmt"
        "strconv"
        "strings"
        "sync"

        //"fmt"
        //"net/http"
        //"io/ioutil"
        //"strconv"

        // CB-Store

        "github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"
        //"github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"
        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/mcism"
        //"github.com/cloud-barista/poc-cicd-tumblebug/src/core/common"

        "github.com/go-resty/resty/v2"
)

// CB-Store
//var cblog *logrus.Logger
//var store icbs.Store

//var SPIDER_REST_URL string

func init() {<span class="cov8" title="1">
        //cblog = config.Cblogger
        //store = cbstore.GetStore()
        //SPIDER_REST_URL = os.Getenv("SPIDER_REST_URL")
}</span>

/*
func genUuid() string {
        return uuid.New().String()
}
*/

/*
type mcirIds struct {
        CspImageId           string
        CspImageName         string
        CspSshKeyName        string
        Name                 string // Spec
        CspVNetId            string
        CspVNetName          string
        CspSecurityGroupId   string
        CspSecurityGroupName string
        CspPublicIpId        string
        CspPublicIpName      string
        CspVNicId            string
        CspVNicName          string

        ConnectionName string
}
*/

func CheckMcis(nsId string, mcisId string) (bool, error) <span class="cov8" title="1">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov8" title="1"> if mcisId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; mcisId given is null.")
                return false, err
        }</span>

        <span class="cov8" title="1">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov8" title="1">fmt.Println("[Check mcis] " + mcisId)

        //key := "/ns/" + nsId + "/mcis/" + mcisId
        key := common.GenMcisKey(nsId, mcisId, "")
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        if keyValue != nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>

}

func CheckVm(nsId string, mcisId string, vmId string) (bool, error) <span class="cov8" title="1">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckVm failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov8" title="1"> if mcisId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckVm failed; mcisId given is null.")
                return false, err
        }</span> else<span class="cov8" title="1"> if vmId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckVm failed; vmId given is null.")
                return false, err
        }</span>

        <span class="cov8" title="1">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov8" title="1">err = common.CheckString(vmId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov8" title="1">fmt.Println("[Check vm] " + mcisId + ", " + vmId)

        key := common.GenMcisKey(nsId, mcisId, vmId)
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)
        if keyValue != nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>

}

func CheckMcisPolicy(nsId string, mcisId string) (bool, error) <span class="cov8" title="1">{

        // Check parameters' emptiness
        if nsId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; nsId given is null.")
                return false, err
        }</span> else<span class="cov8" title="1"> if mcisId == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("CheckMcis failed; mcisId given is null.")
                return false, err
        }</span>

        <span class="cov8" title="1">err := common.CheckString(nsId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">err = common.CheckString(mcisId)
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                return false, err
        }</span>
        <span class="cov8" title="1">fmt.Println("[Check McisPolicy] " + mcisId)

        //key := "/ns/" + nsId + "/mcis/" + mcisId
        key := common.GenMcisPolicyKey(nsId, mcisId, "")
        //fmt.Println(key)

        keyValue, _ := common.CBStore.Get(key)

        if keyValue != nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, nil</span>

}

func RunSSH(vmIP string, sshPort string, userName string, privateKey string, cmd string) (*string, error) <span class="cov8" title="1">{

        // VM SSH 접속정보 설정 (외부 연결 정보, 사용자 아이디, Private Key)
        serverEndpoint := fmt.Sprintf("%s:%s", vmIP, sshPort)
        sshInfo := SSHInfo{
                ServerPort: serverEndpoint,
                UserName:   userName,
                PrivateKey: []byte(privateKey),
        }

        // VM SSH 명령어 실행
        if result, err := SSHRun(sshInfo, cmd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                return &amp;result, nil
        }</span>
}

func RunSSHAsync(wg *sync.WaitGroup, vmID string, vmIP string, sshPort string, userName string, privateKey string, cmd string, returnResult *[]SshCmdResult) <span class="cov8" title="1">{

        defer wg.Done() //goroutin sync done

        // VM SSH 접속정보 설정 (외부 연결 정보, 사용자 아이디, Private Key)
        serverEndpoint := fmt.Sprintf("%s:%s", vmIP, sshPort)
        sshInfo := SSHInfo{
                ServerPort: serverEndpoint,
                UserName:   userName,
                PrivateKey: []byte(privateKey),
        }

        // VM SSH 명령어 실행
        result, err := SSHRun(sshInfo, cmd)

        //wg.Done() //goroutin sync done

        sshResultTmp := SshCmdResult{}
        sshResultTmp.McisId = ""
        sshResultTmp.VmId = vmID
        sshResultTmp.VmIp = vmIP

        if err != nil </span><span class="cov0" title="0">{
                sshResultTmp.Result = err.Error()
                sshResultTmp.Err = err
                *returnResult = append(*returnResult, sshResultTmp)
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("cmd result " + result)
                sshResultTmp.Result = result
                sshResultTmp.Err = nil
                *returnResult = append(*returnResult, sshResultTmp)
        }</span>

}

func TrimIP(sshAccessPoint string) (string, error) <span class="cov8" title="1">{
        splitted := strings.Split(sshAccessPoint, ":")
        if len(splitted) != 2 </span><span class="cov0" title="0">{
                err := fmt.Errorf("In TrimIP(), sshAccessPoint does not seem 8.8.8.8:22 form.")
                return strconv.Itoa(0), err
        }</span>
        <span class="cov8" title="1">port_string := splitted[1]
        port, err := strconv.Atoi(port_string)
        if err != nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("In TrimIP(), strconv.Atoi returned an error.")
                return strconv.Itoa(0), err
        }</span>
        <span class="cov8" title="1">if port &gt;= 1 &amp;&amp; port &lt;= 65535 </span><span class="cov8" title="1">{ // valid port number
                return port_string, nil
        }</span> else<span class="cov0" title="0"> {
                err := fmt.Errorf("In TrimIP(), detected port number seems wrong: " + port_string)
                return strconv.Itoa(0), err
        }</span>
}

type SpiderNameIdSystemId struct {
        NameId   string
        SystemId string
}

type SpiderAllListWrapper struct {
        AllList SpiderAllList
}

type SpiderAllList struct {
        MappedList     []SpiderNameIdSystemId
        OnlySpiderList []SpiderNameIdSystemId
        OnlyCSPList    []SpiderNameIdSystemId
}

// Response struct for InspectResources
type TbInspectResourcesResponse struct {
        // ResourcesOnCsp       interface{} `json:"resourcesOnCsp"`
        // ResourcesOnSpider    interface{} `json:"resourcesOnSpider"`
        // ResourcesOnTumblebug interface{} `json:"resourcesOnTumblebug"`
        ResourcesOnCsp       []resourceOnCspOrSpider `json:"resourcesOnCsp"`
        ResourcesOnSpider    []resourceOnCspOrSpider `json:"resourcesOnSpider"`
        ResourcesOnTumblebug []resourceOnTumblebug   `json:"resourcesOnTumblebug"`
}

type resourceOnCspOrSpider struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
}

type resourceOnTumblebug struct {
        Id          string `json:"id"`
        CspNativeId string `json:"cspNativeId"`
        NsId        string `json:"nsId"`
        McisId      string `json:"mcisId"`
        Type        string `json:"type"`
        ObjectKey   string `json:"objectKey"`
}

// InspectVMs returns the state list of TB VM objects of given connConfig
func InspectVMs(connConfig string) (interface{}, error) <span class="cov8" title="1">{

        nsList, err := common.ListNsId()
        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err = fmt.Errorf("an error occurred while getting namespaces' list: " + err.Error())
                return nil, err
        }</span>
        // var TbResourceList []string
        <span class="cov8" title="1">var TbResourceList []resourceOnTumblebug
        for _, ns := range nsList </span><span class="cov8" title="1">{

                mcisListinNs, _ := ListMcisId(ns)
                if mcisListinNs == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, mcis := range mcisListinNs </span><span class="cov8" title="1">{
                        vmListInMcis, err := ListVmId(ns, mcis)
                        if err != nil </span><span class="cov0" title="0">{
                                common.CBLog.Error(err)
                                err := fmt.Errorf("an error occurred while getting resource list")
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if vmListInMcis == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, vmId := range vmListInMcis </span><span class="cov8" title="1">{
                                vm, err := GetVmObject(ns, mcis, vmId)
                                if err != nil </span><span class="cov0" title="0">{
                                        common.CBLog.Error(err)
                                        err := fmt.Errorf("an error occurred while getting resource list")
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">if vm.ConnectionName == connConfig </span><span class="cov8" title="1">{ // filtering
                                        temp := resourceOnTumblebug{}
                                        temp.Id = vm.Id
                                        temp.CspNativeId = vm.CspViewVmDetail.IId.SystemId
                                        temp.NsId = ns
                                        temp.McisId = mcis
                                        temp.Type = "vm"
                                        temp.ObjectKey = common.GenMcisKey(ns, mcis, vm.Id)

                                        TbResourceList = append(TbResourceList, temp)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">client := resty.New().SetCloseConnection(true)
        client.SetAllowGetMethodPayload(true)

        // Create Req body
        type JsonTemplate struct {
                ConnectionName string
        }
        tempReq := JsonTemplate{}
        tempReq.ConnectionName = connConfig

        spiderRequestURL := common.SPIDER_REST_URL + "/allvm"

        resp, err := client.R().
                SetHeader("Content-Type", "application/json").
                SetBody(tempReq).
                SetResult(&amp;SpiderAllListWrapper{}). // or SetResult(AuthSuccess{}).
                //SetError(&amp;AuthError{}).       // or SetError(AuthError{}).
                Get(spiderRequestURL)

        if err != nil </span><span class="cov0" title="0">{
                common.CBLog.Error(err)
                err := fmt.Errorf("an error occurred while requesting to CB-Spider")
                return nil, err
        }</span>

        <span class="cov8" title="1">fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
        switch </span>{
        case resp.StatusCode() &gt;= 400 || resp.StatusCode() &lt; 200:<span class="cov0" title="0">
                err := fmt.Errorf(string(resp.Body()))
                common.CBLog.Error(err)
                return nil, err</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">temp, _ := resp.Result().(*SpiderAllListWrapper) // type assertion

        result := TbInspectResourcesResponse{}

        /*
                // Implementation style 1
                if len(TbResourceList) &gt; 0 {
                        result.ResourcesOnTumblebug = TbResourceList
                } else {
                        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
                }
        */
        // Implementation style 2
        result.ResourcesOnTumblebug = []resourceOnTumblebug{}
        result.ResourcesOnTumblebug = append(result.ResourcesOnTumblebug, TbResourceList...)

        // result.ResourcesOnCsp = append((*temp).AllList.MappedList, (*temp).AllList.OnlyCSPList...)
        // result.ResourcesOnSpider = append((*temp).AllList.MappedList, (*temp).AllList.OnlySpiderList...)
        result.ResourcesOnCsp = []resourceOnCspOrSpider{}
        result.ResourcesOnSpider = []resourceOnCspOrSpider{}

        for _, v := range (*temp).AllList.MappedList </span><span class="cov8" title="1">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov8" title="1">for _, v := range (*temp).AllList.OnlySpiderList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnSpider = append(result.ResourcesOnSpider, tmpObj)
        }</span>

        <span class="cov8" title="1">for _, v := range (*temp).AllList.OnlyCSPList </span><span class="cov0" title="0">{
                tmpObj := resourceOnCspOrSpider{}
                tmpObj.Id = v.NameId
                tmpObj.CspNativeId = v.SystemId

                result.ResourcesOnCsp = append(result.ResourcesOnCsp, tmpObj)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
