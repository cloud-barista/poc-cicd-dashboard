
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common-runtime: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime/CCMCommon.go (59.9%)</option>
				
				<option value="file1">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/cbconnection.go (0.0%)</option>
				
				<option value="file2">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/cbmessage.go (73.8%)</option>
				
				<option value="file3">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/cbserver.go (34.8%)</option>
				
				<option value="file4">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/grpcstatuserr.go (0.0%)</option>
				
				<option value="file5">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config/config.go (21.7%)</option>
				
				<option value="file6">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config/parser.go (37.5%)</option>
				
				<option value="file7">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog/client_interceptors.go (0.0%)</option>
				
				<option value="file8">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog/server_interceptors.go (55.0%)</option>
				
				<option value="file9">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt/auth.go (0.0%)</option>
				
				<option value="file10">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt/client_interceptors.go (0.0%)</option>
				
				<option value="file11">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt/server_interceptors.go (0.0%)</option>
				
				<option value="file12">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/jaegertracer/jaegertracer.go (0.0%)</option>
				
				<option value="file13">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger/logger.go (33.3%)</option>
				
				<option value="file14">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/connection.go (81.8%)</option>
				
				<option value="file15">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/credential.go (81.8%)</option>
				
				<option value="file16">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/driver.go (81.8%)</option>
				
				<option value="file17">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/image.go (82.9%)</option>
				
				<option value="file18">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/keypair.go (82.8%)</option>
				
				<option value="file19">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/os.go (100.0%)</option>
				
				<option value="file20">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/region.go (81.8%)</option>
				
				<option value="file21">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/security.go (81.5%)</option>
				
				<option value="file22">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/ssh.go (90.0%)</option>
				
				<option value="file23">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/vm.go (83.9%)</option>
				
				<option value="file24">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/vmspec.go (83.3%)</option>
				
				<option value="file25">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/vpc.go (82.6%)</option>
				
				<option value="file26">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider/cbspider.pb.go (59.3%)</option>
				
				<option value="file27">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/gogoproto/gogo.pb.go (100.0%)</option>
				
				<option value="file28">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/CBSpiderRuntime.go (38.2%)</option>
				
				<option value="file29">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/CCMRest.go (83.1%)</option>
				
				<option value="file30">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/CIMRest.go (86.6%)</option>
				
				<option value="file31">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/SSHRUNRest.go (81.8%)</option>
				
				<option value="file32">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb-CCM-MGMT.go (0.0%)</option>
				
				<option value="file33">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb-CCM.go (0.0%)</option>
				
				<option value="file34">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb-CIM.go (0.0%)</option>
				
				<option value="file35">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb.go (0.7%)</option>
				
				<option value="file36">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/docs/docs.go (8.3%)</option>
				
				<option value="file37">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/CloudDriverHandler_static.go (38.1%)</option>
				
				<option value="file38">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/calllogger.go (61.0%)</option>
				
				<option value="file39">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/config.go (70.6%)</option>
				
				<option value="file40">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/formatter/formatter.go (0.0%)</option>
				
				<option value="file41">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/AlibabaDriver.go (0.0%)</option>
				
				<option value="file42">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go (4.8%)</option>
				
				<option value="file43">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/CommonAlibabaFunc.go (0.0%)</option>
				
				<option value="file44">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file45">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file46">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file47">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/VMHandler.go (0.3%)</option>
				
				<option value="file48">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file49">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file50">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/AwsDriver.go (0.0%)</option>
				
				<option value="file51">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go (4.8%)</option>
				
				<option value="file52">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/CommonAwsFunc.go (0.0%)</option>
				
				<option value="file53">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file54">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file55">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file56">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/VMHandler.go (0.3%)</option>
				
				<option value="file57">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file58">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file59">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/AzureDriver.go (0.0%)</option>
				
				<option value="file60">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/connect/Azure_CloudConnection.go (4.8%)</option>
				
				<option value="file61">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/CommonAzureFunc.go (0.0%)</option>
				
				<option value="file62">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file63">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file64">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file65">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/VMHandler.go (0.0%)</option>
				
				<option value="file66">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file67">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file68">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/ClouditDriver.go (0.0%)</option>
				
				<option value="file69">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/RestClient.go (0.8%)</option>
				
				<option value="file70">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/image/Request.go (2.9%)</option>
				
				<option value="file71">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/nic/Request.go (2.8%)</option>
				
				<option value="file72">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/server/Request.go (2.0%)</option>
				
				<option value="file73">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/specs/Request.go (10.0%)</option>
				
				<option value="file74">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/adaptiveip/Request.go (2.3%)</option>
				
				<option value="file75">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/subnet/Request.go (2.3%)</option>
				
				<option value="file76">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup/Request.go (1.5%)</option>
				
				<option value="file77">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/connect/Cloudit_CloudConnection.go (4.8%)</option>
				
				<option value="file78">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/CommonClouditFunc.go (0.0%)</option>
				
				<option value="file79">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file80">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file81">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file82">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/VMHandler.go (0.0%)</option>
				
				<option value="file83">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file84">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file85">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/DockerDriver.go (4.8%)</option>
				
				<option value="file86">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/connect/DockerCloudConnection.go (4.3%)</option>
				
				<option value="file87">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/resources/ImageHandler.go (1.5%)</option>
				
				<option value="file88">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/resources/VMHandler.go (0.0%)</option>
				
				<option value="file89">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/GCPDriver.go (0.0%)</option>
				
				<option value="file90">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go (4.8%)</option>
				
				<option value="file91">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/CommonHandler.go (0.0%)</option>
				
				<option value="file92">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/ImageHandler.go (0.5%)</option>
				
				<option value="file93">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file94">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file95">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/VMHandler.go (0.0%)</option>
				
				<option value="file96">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file97">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file98">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/MockDriver.go (31.2%)</option>
				
				<option value="file99">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/connect/MockCloudConnection.go (76.0%)</option>
				
				<option value="file100">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/ImageHandler.go (85.4%)</option>
				
				<option value="file101">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/KeyPairHandler.go (83.3%)</option>
				
				<option value="file102">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/SecurityHandler.go (85.4%)</option>
				
				<option value="file103">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/VMHandler.go (70.6%)</option>
				
				<option value="file104">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/VMSpecHandler.go (88.9%)</option>
				
				<option value="file105">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/VPCHandler.go (81.4%)</option>
				
				<option value="file106">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/OpenStackDriver.go (0.0%)</option>
				
				<option value="file107">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go (4.8%)</option>
				
				<option value="file108">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/CommonOpenStackFunc.go (0.0%)</option>
				
				<option value="file109">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file110">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file111">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file112">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/VMHandler.go (0.0%)</option>
				
				<option value="file113">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file114">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file115">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/TencentDriver.go (1.8%)</option>
				
				<option value="file116">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go (4.8%)</option>
				
				<option value="file117">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/CommonTencentFunc.go (0.0%)</option>
				
				<option value="file118">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file119">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file120">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file121">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/VMHandler.go (0.3%)</option>
				
				<option value="file122">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file123">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file124">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/iid-manager/IIDManager.go (68.1%)</option>
				
				<option value="file125">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/iid-manager/InfoStore.go (81.1%)</option>
				
				<option value="file126">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/vm-ssh/sshrun.go (1.6%)</option>
				
				<option value="file127">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/CloudOSList.go (71.4%)</option>
				
				<option value="file128">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager/ConnectionConfigInfoManager.go (75.9%)</option>
				
				<option value="file129">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager/InfoStore.go (84.2%)</option>
				
				<option value="file130">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager/CredentialInfoManager.go (76.3%)</option>
				
				<option value="file131">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager/InfoStore.go (80.9%)</option>
				
				<option value="file132">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager/DriverInfoManager.go (78.7%)</option>
				
				<option value="file133">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager/InfoStore.go (85.0%)</option>
				
				<option value="file134">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager/InfoStore.go (80.9%)</option>
				
				<option value="file135">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager/RegionInfoManager.go (79.1%)</option>
				
				<option value="file136">github.com/cloud-barista/poc-cicd-spider/interface/api/ccm.go (81.6%)</option>
				
				<option value="file137">github.com/cloud-barista/poc-cicd-spider/interface/api/cim.go (78.8%)</option>
				
				<option value="file138">github.com/cloud-barista/poc-cicd-spider/interface/api/request/connection.go (76.2%)</option>
				
				<option value="file139">github.com/cloud-barista/poc-cicd-spider/interface/api/request/credential.go (76.2%)</option>
				
				<option value="file140">github.com/cloud-barista/poc-cicd-spider/interface/api/request/driver.go (76.2%)</option>
				
				<option value="file141">github.com/cloud-barista/poc-cicd-spider/interface/api/request/image.go (75.0%)</option>
				
				<option value="file142">github.com/cloud-barista/poc-cicd-spider/interface/api/request/keypair.go (75.0%)</option>
				
				<option value="file143">github.com/cloud-barista/poc-cicd-spider/interface/api/request/os.go (83.3%)</option>
				
				<option value="file144">github.com/cloud-barista/poc-cicd-spider/interface/api/request/region.go (76.2%)</option>
				
				<option value="file145">github.com/cloud-barista/poc-cicd-spider/interface/api/request/security.go (75.0%)</option>
				
				<option value="file146">github.com/cloud-barista/poc-cicd-spider/interface/api/request/ssh.go (75.0%)</option>
				
				<option value="file147">github.com/cloud-barista/poc-cicd-spider/interface/api/request/vm.go (75.0%)</option>
				
				<option value="file148">github.com/cloud-barista/poc-cicd-spider/interface/api/request/vmspec.go (76.0%)</option>
				
				<option value="file149">github.com/cloud-barista/poc-cicd-spider/interface/api/request/vpc.go (75.0%)</option>
				
				<option value="file150">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/connection.go (84.6%)</option>
				
				<option value="file151">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/credential.go (84.6%)</option>
				
				<option value="file152">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/driver.go (84.6%)</option>
				
				<option value="file153">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/gclient.go (79.7%)</option>
				
				<option value="file154">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/image.go (78.2%)</option>
				
				<option value="file155">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/keypair.go (78.0%)</option>
				
				<option value="file156">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/os.go (100.0%)</option>
				
				<option value="file157">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/region.go (84.6%)</option>
				
				<option value="file158">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/root.go (100.0%)</option>
				
				<option value="file159">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/security.go (78.0%)</option>
				
				<option value="file160">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/ssh.go (46.7%)</option>
				
				<option value="file161">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/version.go (66.7%)</option>
				
				<option value="file162">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/vm.go (65.9%)</option>
				
				<option value="file163">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/vmspec.go (76.9%)</option>
				
				<option value="file164">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/vpc.go (76.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Cloud Control Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package commonruntime

import (
        "fmt"
        "strconv"
        "strings"
        "sync"
        "time"

        ccm "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        iidm "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/iid-manager"
        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
)

// define string of resource types
const (
        rsImage string = "image"
        rsVPC   string = "vpc"
        // rsSubnet = SUBNET:{VPC NameID} =&gt; cook in code
        rsSG  string = "sg"
        rsKey string = "keypair"
        rsVM  string = "vm"
)

// definition of RWLock for each Resource Ops
var imgRWLock = new(sync.RWMutex)
var vpcRWLock = new(sync.RWMutex)
var sgRWLock = new(sync.RWMutex)
var keyRWLock = new(sync.RWMutex)
var vmRWLock = new(sync.RWMutex)

// definition of IIDManager RWLock
var iidRWLock = new(iidm.IIDRWLOCK)

var cblog *logrus.Logger
var callogger *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
        // logger for HisCall
        callogger = call.GetLogger("HISCALL")
}</span>

type AllResourceList struct {
        AllList struct {
                MappedList     []*cres.IID `json:"MappedList"`
                OnlySpiderList []*cres.IID `json:"OnlySpiderList"`
                OnlyCSPList    []*cres.IID `json:"OnlyCSPList"`
        }
}

//================ Image Handler
// @todo
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateImage(connectionName string, rsType string, reqInfo cres.ImageReqInfo) (*cres.ImageInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">imgRWLock.Lock()
        defer imgRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(reqInfo.IId.NameId + " already exists!")
        }</span>

        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateImage(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) insert IID
        <span class="cov8" title="1">iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteImage(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, err2
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListImage(connectionName string, rsType string) ([]*cres.ImageInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">infoList, err := handler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if infoList == nil || len(infoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.ImageInfo{}
        }</span>

        <span class="cov8" title="1">return infoList, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListRegisterImage(connectionName string, rsType string) ([]*cres.ImageInfo, error) <span class="cov0" title="0">{
        cblog.Info("call ListImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">imgRWLock.RLock()
        defer imgRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var infoList []*cres.ImageInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.ImageInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov0" title="0">infoList, err = handler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov0" title="0">infoList2 := []*cres.ImageInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov0" title="0">{
                exist := false
                for _, info := range infoList </span><span class="cov0" title="0">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov0" title="0">{
                                info.IId.NameId = iidInfo.IId.NameId
                                infoList2 = append(infoList2, info)
                                exist = true
                        }</span>
                }
                <span class="cov0" title="0">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov0" title="0">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetImage(connectionName string, rsType string, nameID string) (*cres.ImageInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // now, NameID = SystemID
        <span class="cov8" title="1">info, err := handler.GetImage(cres.IID{nameID, nameID})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetRegisterImage(connectionName string, rsType string, nameID string) (*cres.ImageInfo, error) <span class="cov0" title="0">{
        cblog.Info("call GetImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">imgRWLock.RLock()
        defer imgRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov0" title="0">start := time.Now()
        info, err := handler.GetImage(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">elapsed := time.Since(start)
        cblog.Infof(connectionName+" : elapsed %d", elapsed.Nanoseconds()/1000000) // msec

        // (3) set ResourceInfo(IID.NameId)
        info.IId.NameId = iidInfo.IId.NameId

        return &amp;info, nil</span>
}

// (1) get IID(NameId)
// (2) delete Resource(SystemId)
// (3) delete IID
func DeleteImage(connectionName string, rsType string, nameID string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">imgRWLock.Lock()
        defer imgRWLock.Unlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        // keeping for rollback
        <span class="cov8" title="1">info, err := handler.GetImage(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        // (2) delete Resource(SystemId)
        <span class="cov8" title="1">result, err := handler.DeleteImage(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>
        <span class="cov8" title="1">if result == false </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // (3) delete IID
        <span class="cov8" title="1">_, err = iidRWLock.DeleteIID(connectionName, rsType, iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                reqInfo := cres.ImageReqInfo{info.IId} // @todo
                _, err2 := handler.CreateImage(reqInfo)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return false, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

//================ VMSpec Handler
func ListVMSpec(connectionName string) ([]*cres.VMSpecInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">infoList, err := handler.ListVMSpec(regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if infoList == nil || len(infoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VMSpecInfo{}
        }</span>

        <span class="cov8" title="1">return infoList, nil</span>
}

func GetVMSpec(connectionName string, nameID string) (*cres.VMSpecInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">info, err := handler.GetVMSpec(regionName, nameID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

func ListOrgVMSpec(connectionName string) (string, error) <span class="cov8" title="1">{
        cblog.Info("call ListOrgVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">infoList, err := handler.ListOrgVMSpec(regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return infoList, nil</span>
}

func GetOrgVMSpec(connectionName string, nameID string) (string, error) <span class="cov8" title="1">{
        cblog.Info("call GetOrgVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">info, err := handler.GetOrgVMSpec(regionName, nameID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

//================ VPC Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateVPC(connectionName string, rsType string, reqInfo cres.VPCReqInfo) (*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateVPC()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.Lock()
        defer vpcRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>
        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateVPC(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">info.IId.NameId = reqInfo.IId.NameId

        // (3) insert IID
        // for VPC
        iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteVPC(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        // for Subnet list
        <span class="cov8" title="1">for _, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                // key-value structure: /{ConnectionName}/{VPC-NameId}/{Subnet-IId}
                _, err := iidRWLock.CreateIID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        // rollback
                        // (1) for resource
                        cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-CSP&gt;&gt; " + info.IId.SystemId)
                        _, err2 := handler.DeleteVPC(iidInfo.IId)
                        if err2 != nil </span><span class="cov0" title="0">{
                                cblog.Error(err2)
                                return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                        }</span>
                        // (2) for VPC IID
                        <span class="cov0" title="0">cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-IID&gt;&gt; " + info.IId.NameId)
                        _, err3 := iidRWLock.DeleteIID(connectionName, rsType, info.IId)
                        if err3 != nil </span><span class="cov0" title="0">{
                                cblog.Error(err3)
                                return nil, fmt.Errorf(err.Error() + ", " + err3.Error())
                        }</span>
                        // (3) for Subnet IID
                        <span class="cov0" title="0">tmpIIdInfoList, err := iidRWLock.ListIID(connectionName, SUBNET_PREFIX+info.IId.NameId)
                        for _, subnetInfo := range tmpIIdInfoList </span><span class="cov0" title="0">{
                                _, err := iidRWLock.DeleteIID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListVPC(connectionName string, rsType string) ([]*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVPC()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.RLock()
        defer vpcRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.VPCInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VPCInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.VPCInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{

                                //+++++++++++++++++++++++++++++++++++++++++++
                                // set ResourceInfo(IID.NameId)
                                // set VPC NameId
                                IIdInfo, err := iidRWLock.GetIIDbySystemID(connectionName, rsType, info.IId)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">info.IId.NameId = IIdInfo.IId.NameId
                                //+++++++++++++++++++++++++++++++++++++++++++
                                // set NameId for SubnetInfo List
                                // create new SubnetInfo List
                                subnetInfoList := []cres.SubnetInfo{}
                                for _, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                                        subnetIIDInfo, err := iidRWLock.GetIIDbySystemID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                                        if err != nil </span><span class="cov0" title="0">{
                                                cblog.Error(err)
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">if subnetIIDInfo.IId.NameId != "" </span><span class="cov8" title="1">{ // insert only this user created.
                                                subnetInfo.IId.NameId = subnetIIDInfo.IId.NameId
                                                subnetInfoList = append(subnetInfoList, subnetInfo)
                                        }</span>

                                }
                                <span class="cov8" title="1">info.SubnetInfoList = subnetInfoList

                                infoList2 = append(infoList2, info)
                                exist = true</span>
                        }
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetVPC(connectionName string, rsType string, nameID string) (*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetVPC()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.RLock()
        defer vpcRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetVPC(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        // (3) set ResourceInfo(IID.NameId)
        <span class="cov8" title="1">info.IId.NameId = iidInfo.IId.NameId

        // set NameId for SubnetInfo List
        // create new SubnetInfo List
        subnetInfoList := []cres.SubnetInfo{}
        for i, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                subnetIIDInfo, err := iidRWLock.GetIIDbySystemID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">if subnetIIDInfo.IId.NameId != "" </span><span class="cov8" title="1">{ // insert only this user created.
                        info.SubnetInfoList[i].IId.NameId = subnetIIDInfo.IId.NameId
                        subnetInfoList = append(subnetInfoList, info.SubnetInfoList[i])
                }</span>
        }
        <span class="cov8" title="1">info.SubnetInfoList = subnetInfoList

        return &amp;info, nil</span>
}

// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func AddSubnet(connectionName string, rsType string, vpcName string, reqInfo cres.SubnetInfo) (*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call AddSubnet()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.Lock()
        defer vpcRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>
        // (2) create Resource
        <span class="cov8" title="1">iidVPCInfo, err := iidRWLock.GetIID(connectionName, rsVPC, cres.IID{vpcName, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">info, err := handler.AddSubnet(iidVPCInfo.IId, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) insert IID
        // for Subnet list
        <span class="cov8" title="1">for _, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                if subnetInfo.IId.NameId == reqInfo.IId.NameId </span><span class="cov8" title="1">{
                        // key-value structure: /{ConnectionName}/{VPC-NameId}/{Subnet-IId}
                        _, err := iidRWLock.CreateIID(connectionName, SUBNET_PREFIX+iidVPCInfo.IId.NameId, subnetInfo.IId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                // rollback
                                // (1) for resource
                                cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-SUBNET-CSP&gt;&gt; " + subnetInfo.IId.SystemId)
                                _, err2 := handler.RemoveSubnet(iidVPCInfo.IId, subnetInfo.IId)
                                if err2 != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err2)
                                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                                }</span>
                                // (2) for Subnet IID
                                <span class="cov0" title="0">cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-SUBNET-IID&gt;&gt; " + subnetInfo.IId.NameId)
                                _, err3 := iidRWLock.DeleteIID(connectionName, SUBNET_PREFIX+iidVPCInfo.IId.NameId, subnetInfo.IId)
                                if err3 != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err3)
                                        return nil, fmt.Errorf(err.Error() + ", " + err3.Error())
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                }
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

//================ SecurityGroup Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateSecurity(connectionName string, rsType string, reqInfo cres.SecurityReqInfo) (*cres.SecurityInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateSecurity()")

        //+++++++++++++++++++++++++++++++++++++++++++
        // set VPC SystemId
        vpcIIDInfo, err := iidRWLock.GetIID(connectionName, rsVPC, reqInfo.VpcIID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">reqInfo.VpcIID.SystemId = vpcIIDInfo.IId.SystemId
        //+++++++++++++++++++++++++++++++++++++++++++

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateSecurityHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">sgRWLock.Lock()
        defer sgRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>

        // if no CIDR in input rules, set default ("0.0.0.0/0")
        <span class="cov8" title="1">for n, _ := range *reqInfo.SecurityRules </span><span class="cov8" title="1">{
                if (*reqInfo.SecurityRules)[n].CIDR == "" </span><span class="cov0" title="0">{
                        (*reqInfo.SecurityRules)[n].CIDR = "0.0.0.0/0"
                }</span>
        }

        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateSecurity(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // set VPC NameId
        <span class="cov8" title="1">info.VpcIID.NameId = reqInfo.VpcIID.NameId
        info.VpcIID.SystemId = reqInfo.VpcIID.SystemId

        // (3) insert IID
        iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteSecurity(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // set ResourceInfo(IID.NameId)
        // iidInfo.IId.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">vpc_sg_nameid := strings.Split(info.IId.NameId, SG_DELIMITER)
        info.IId.NameId = vpc_sg_nameid[1]

        return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListSecurity(connectionName string, rsType string) ([]*cres.SecurityInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListSecurity()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateSecurityHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">sgRWLock.RLock()
        defer sgRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.SecurityInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.SecurityInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.SecurityInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{

                                // set ResourceInfo(IID.NameId)
                                // iidInfo.IId.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
                                vpc_sg_nameid := strings.Split(iidInfo.IId.NameId, SG_DELIMITER)
                                info.VpcIID.NameId = vpc_sg_nameid[0]
                                info.IId.NameId = vpc_sg_nameid[1]

                                // set VPC SystemId
                                vpcIIDInfo, err := iidRWLock.GetIID(connectionName, rsVPC, info.VpcIID)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">info.VpcIID.SystemId = vpcIIDInfo.IId.SystemId

                                infoList2 = append(infoList2, info)
                                exist = true</span>
                        }
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetSecurity(connectionName string, rsType string, nameID string) (*cres.SecurityInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetSecurity()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateSecurityHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">sgRWLock.RLock()
        defer sgRWLock.RUnlock()
        // (1) get IID(NameId)
        // SG NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        iidInfo, err := iidRWLock.FindIID(connectionName, rsType, nameID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetSecurity(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) set ResourceInfo(IID.NameId)
        // set ResourceInfo(IID.NameId)
        // iidInfo.IId.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">vpc_sg_nameid := strings.Split(iidInfo.IId.NameId, SG_DELIMITER)
        info.VpcIID.NameId = vpc_sg_nameid[0]
        info.IId.NameId = vpc_sg_nameid[1]

        // set VPC SystemId
        vpcIIDInfo, err := iidRWLock.GetIID(connectionName, rsVPC, info.VpcIID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">info.VpcIID.SystemId = vpcIIDInfo.IId.SystemId

        return &amp;info, nil</span>
}

//================ KeyPair Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateKey(connectionName string, rsType string, reqInfo cres.KeyPairReqInfo) (*cres.KeyPairInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateKey()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateKeyPairHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">keyRWLock.Lock()
        defer keyRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(reqInfo.IId.NameId + " already exists!")
        }</span>

        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateKey(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) insert IID
        <span class="cov8" title="1">iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteKey(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListKey(connectionName string, rsType string) ([]*cres.KeyPairInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListKey()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateKeyPairHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">keyRWLock.RLock()
        defer keyRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.KeyPairInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.KeyPairInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListKey()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.KeyPairInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{
                                infoList2 = append(infoList2, info)
                                exist = true
                        }</span>
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetKey(connectionName string, rsType string, nameID string) (*cres.KeyPairInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetKey()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateKeyPairHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">keyRWLock.RLock()
        defer keyRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetKey(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) set ResourceInfo(IID.NameId)
        <span class="cov8" title="1">info.IId.NameId = iidInfo.IId.NameId

        return &amp;info, nil</span>
}

func getSetSystemId(ConnectionName string, reqInfo *cres.VMReqInfo) error <span class="cov8" title="1">{

        // set Image SystemId
        // @todo before Image Handling by powerkim
        reqInfo.ImageIID.SystemId = reqInfo.ImageIID.NameId

        // set VPC SystemId
        if reqInfo.VpcIID.NameId != "" </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, rsVPC, reqInfo.VpcIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.VpcIID.SystemId = IIdInfo.IId.SystemId</span>
        }

        // set Subnet SystemId
        <span class="cov8" title="1">if reqInfo.SubnetIID.NameId != "" </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, SUBNET_PREFIX+reqInfo.VpcIID.NameId, reqInfo.SubnetIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.SubnetIID.SystemId = IIdInfo.IId.SystemId</span>
        }

        // set SecurityGroups SystemId
        <span class="cov8" title="1">for i, sgIID := range reqInfo.SecurityGroupIIDs </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, rsSG, sgIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.SecurityGroupIIDs[i].SystemId = IIdInfo.IId.SystemId</span>
        }

        // set KeyPair SystemId
        <span class="cov8" title="1">if reqInfo.KeyPairIID.NameId != "" </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, rsKey, reqInfo.KeyPairIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.KeyPairIID.SystemId = IIdInfo.IId.SystemId</span>
        }

        <span class="cov8" title="1">return nil</span>
}

//================ VM Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func StartVM(connectionName string, rsType string, reqInfo cres.VMReqInfo) (*cres.VMInfo, error) <span class="cov8" title="1">{
        cblog.Info("call StartVM()")

        // get &amp; set SystemId
        err := getSetSystemId(connectionName, &amp;reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // vmRWLock.Lock() @todo undo this until supporting async call. by powerkim, 2020.05.10
        // defer vmRWLock.Unlock() @todo undo this until supporting async call. by powerkim, 2020.05.10
        // (1) check exist(NameID)
        <span class="cov8" title="1">bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>

        <span class="cov8" title="1">providerName, err := ccm.GetProviderNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">regionName, zoneName, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">callInfo := call.CLOUDLOGSCHEMA {
                CloudOS: call.CLOUD_OS(providerName),
                RegionZone: regionName + "/" + zoneName,
                ResourceType: call.VM,
                ResourceName: reqInfo.IId.NameId,
                CloudOSAPI: "CB-Spider:StartVM()",
                ElapsedTime: "",
                ErrorMSG: "",
        }
        start := call.Start()
        // (2) create Resource
        info, err := handler.StartVM(reqInfo)
        callInfo.ElapsedTime = call.Elapsed(start)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                callInfo.ErrorMSG = err.Error()
                return nil, err
        }</span>
        <span class="cov8" title="1">callogger.Info(call.String(callInfo))

        // set NameId for info by reqInfo
        setNameId(connectionName, &amp;info, &amp;reqInfo)

        // (3) insert IID
        iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.TerminateVM(iidInfo.IId) // @todo check validation
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // set sg NameId from VPCNameId-SecurityGroupNameId
        // IID.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">for i, sgIID := range info.SecurityGroupIIds </span><span class="cov8" title="1">{
                vpc_sg_nameid := strings.Split(sgIID.NameId, SG_DELIMITER)
                info.SecurityGroupIIds[i].NameId = vpc_sg_nameid[1]
        }</span>

        // current: Assume 22 port, except Cloud-Twin, by powerkim, 2021.03.24.
        <span class="cov8" title="1">if info.SSHAccessPoint == "" </span><span class="cov8" title="1">{
                info.SSHAccessPoint = info.PublicIP + ":22"
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

func setNameId(ConnectionName string, vmInfo *cres.VMInfo, reqInfo *cres.VMReqInfo) error <span class="cov8" title="1">{

        // set Image SystemId
        // @todo before Image Handling by powerkim
        if reqInfo.ImageIID.NameId != "" </span><span class="cov8" title="1">{
                vmInfo.ImageIId.NameId = reqInfo.ImageIID.NameId
        }</span>

        // set VPC SystemId
        <span class="cov8" title="1">if reqInfo.VpcIID.NameId != "" </span><span class="cov8" title="1">{
                vmInfo.VpcIID.NameId = reqInfo.VpcIID.NameId
        }</span>

        <span class="cov8" title="1">if reqInfo.SubnetIID.NameId != "" </span><span class="cov8" title="1">{
                // set Subnet SystemId
                vmInfo.SubnetIID.NameId = reqInfo.SubnetIID.NameId
        }</span>

        <span class="cov8" title="1">vmInfo.SecurityGroupIIds = reqInfo.SecurityGroupIIDs

        // set SecurityGroups SystemId
        for i, sgIID := range reqInfo.SecurityGroupIIDs </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsSG, sgIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.SecurityGroupIIDs[i].NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">if reqInfo.KeyPairIID.NameId != "" </span><span class="cov8" title="1">{
                // set KeyPair SystemId
                vmInfo.KeyPairIId.NameId = reqInfo.KeyPairIID.NameId
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListVM(connectionName string, rsType string) ([]*cres.VMInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVM()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.VMInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VMInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.VMInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{

                                //+++++++++++++++++++++++++++++++++++++++++++
                                // set ResourceInfo(IID.NameId)
                                // set VPC NameId
                                IIdInfo, err := iidRWLock.GetIIDbySystemID(connectionName, rsType, info.IId)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">info.IId.NameId = IIdInfo.IId.NameId
                                //+++++++++++++++++++++++++++++++++++++++++++
                                err = getSetNameId(connectionName, info)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>

                                // set sg NameId from VPCNameId-SecurityGroupNameId
                                // IID.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
                                <span class="cov8" title="1">for i, sgIID := range info.SecurityGroupIIds </span><span class="cov8" title="1">{
                                        vpc_sg_nameid := strings.Split(sgIID.NameId, SG_DELIMITER)
                                        info.SecurityGroupIIds[i].NameId = vpc_sg_nameid[1]
                                }</span>

                                // current: Assume 22 port, except Cloud-Twin, by powerkim, 2021.03.24.
                                <span class="cov8" title="1">if info.SSHAccessPoint == "" </span><span class="cov8" title="1">{
                                        info.SSHAccessPoint = info.PublicIP + ":22"
                                }</span>

                                <span class="cov8" title="1">infoList2 = append(infoList2, info)
                                exist = true</span>
                        }
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

func getSetNameId(ConnectionName string, vmInfo *cres.VMInfo) error <span class="cov8" title="1">{

        // set Image NameId
        // @todo before Image Handling by powerkim
        //vmInfo.ImageIId.NameId = vmInfo.ImageIId.SystemId

        if vmInfo.VpcIID.SystemId != "" </span><span class="cov8" title="1">{
                // set VPC NameId
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsVPC, vmInfo.VpcIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.VpcIID.NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">if vmInfo.SubnetIID.SystemId != "" </span><span class="cov8" title="1">{
                // set Subnet NameId
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, SUBNET_PREFIX+vmInfo.VpcIID.NameId, vmInfo.SubnetIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.SubnetIID.NameId = IIdInfo.IId.NameId</span>
        }

        // set SecurityGroups NameId
        <span class="cov8" title="1">for i, sgIID := range vmInfo.SecurityGroupIIds </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsSG, sgIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.SecurityGroupIIds[i].NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">if vmInfo.KeyPairIId.SystemId != "" </span><span class="cov8" title="1">{
                // set KeyPair NameId
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsKey, vmInfo.KeyPairIId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.KeyPairIId.NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetVM(connectionName string, rsType string, nameID string) (*cres.VMInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetVM()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetVM(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) set ResourceInfo(IID.NameId)
        <span class="cov8" title="1">info.IId.NameId = iidInfo.IId.NameId

        err = getSetNameId(connectionName, &amp;info)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // set sg NameId from VPCNameId-SecurityGroupNameId
        // IID.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">for i, sgIID := range info.SecurityGroupIIds </span><span class="cov8" title="1">{
                vpc_sg_nameid := strings.Split(sgIID.NameId, SG_DELIMITER)
                info.SecurityGroupIIds[i].NameId = vpc_sg_nameid[1]
        }</span>

        // current: Assume 22 port, except Cloud-Twin, by powerkim, 2021.03.24.
        <span class="cov8" title="1">if info.SSHAccessPoint == "" </span><span class="cov0" title="0">{
                info.SSHAccessPoint = info.PublicIP + ":22"
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:VMStatuslist
// (3) filtering CSP-VMStatuslist by IID-list
func ListVMStatus(connectionName string, rsType string) ([]*cres.VMStatusInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVMStatus()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.VMStatusInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VMStatusInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:VMStatuslist
        <span class="cov8" title="1">infoList, err = handler.ListVMStatus()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-VMStatuslist by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.VMStatusInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{
                                info.IId.NameId = iidInfo.IId.NameId
                                infoList2 = append(infoList2, info)
                                exist = true
                        }</span>
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get CSP:VMStatus(SystemId)
func GetVMStatus(connectionName string, rsType string, nameID string) (cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call GetVMStatus()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        // (2) get CSP:VMStatus(SystemId)
        <span class="cov8" title="1">info, err := handler.GetVMStatus(iidInfo.IId) // type of info =&gt; string
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

// (1) get IID(NameId)
// (2) control CSP:VM(SystemId)
func ControlVM(connectionName string, rsType string, nameID string, action string) (cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call ControlVM()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        // (2) control CSP:VM(SystemId)
        <span class="cov8" title="1">vmIID := iidInfo.IId

        var info cres.VMStatus

        switch strings.ToLower(action) </span>{
        case "suspend":<span class="cov8" title="1">
                info, err = handler.SuspendVM(vmIID)</span>
        case "resume":<span class="cov8" title="1">
                info, err = handler.ResumeVM(vmIID)</span>
        case "reboot":<span class="cov8" title="1">
                info, err = handler.RebootVM(vmIID)</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf(action + " is not a valid action!!")</span>

        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

// list all Resources for management
// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
// (4) make MappedList, OnlySpiderList, OnlyCSPList
func ListAllResource(connectionName string, rsType string) (AllResourceList, error) <span class="cov8" title="1">{
        cblog.Info("call ListAllResource()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                return AllResourceList{}, err
        }</span>

        <span class="cov8" title="1">var handler interface{}

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                handler, err = cldConn.CreateVPCHandler()</span>
        case rsSG:<span class="cov8" title="1">
                handler, err = cldConn.CreateSecurityHandler()</span>
        case rsKey:<span class="cov8" title="1">
                handler, err = cldConn.CreateKeyPairHandler()</span>
        case rsVM:<span class="cov8" title="1">
                handler, err = cldConn.CreateVMHandler()</span>
        default:<span class="cov0" title="0">
                return AllResourceList{}, fmt.Errorf(rsType + " is not supported Resource!!")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return AllResourceList{}, err
        }</span>

        <span class="cov8" title="1">var allResList AllResourceList

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                vpcRWLock.RLock()
                defer vpcRWLock.RUnlock()</span>
        case rsSG:<span class="cov8" title="1">
                sgRWLock.RLock()
                defer sgRWLock.RUnlock()</span>
        case rsKey:<span class="cov8" title="1">
                keyRWLock.RLock()
                defer keyRWLock.RUnlock()</span>
        case rsVM:<span class="cov8" title="1">
                vmRWLock.RLock()
                defer vmRWLock.RUnlock()</span>
        default:<span class="cov0" title="0">
                return AllResourceList{}, fmt.Errorf(rsType + " is not supported Resource!!")</span>
        }

        // (1) get IID:list
        <span class="cov8" title="1">iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return AllResourceList{}, err
        }</span>

        // if iidInfoList is empty, OnlySpiderList is empty.
        <span class="cov8" title="1">if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                emptyIIDInfoList := []*cres.IID{}
                allResList.AllList.MappedList = emptyIIDInfoList
                allResList.AllList.OnlySpiderList = emptyIIDInfoList
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">iidCSPList := []*cres.IID{}
        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                infoList, err := handler.(cres.VPCHandler).ListVPC()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        case rsSG:<span class="cov8" title="1">
                infoList, err := handler.(cres.SecurityHandler).ListSecurity()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        case rsKey:<span class="cov8" title="1">
                infoList, err := handler.(cres.KeyPairHandler).ListKey()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        case rsVM:<span class="cov8" title="1">
                infoList, err := handler.(cres.VMHandler).ListVM()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        default:<span class="cov0" title="0">
                return AllResourceList{}, fmt.Errorf(rsType + " is not supported Resource!!")</span>
        }

        <span class="cov8" title="1">if iidCSPList == nil || len(iidCSPList) &lt;= 0 </span><span class="cov0" title="0">{
                // if iidCSPList is empty, iidInfoList is empty =&gt; all list is empty &lt;-------------- (1)
                if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                        emptyIIDInfoList := []*cres.IID{}
                        allResList.AllList.OnlyCSPList = emptyIIDInfoList

                        return allResList, nil
                }</span> else<span class="cov0" title="0"> { // iidCSPList is empty and iidInfoList has value =&gt; only OnlySpiderList &lt;--(2)
                        emptyIIDInfoList := []*cres.IID{}
                        allResList.AllList.MappedList = emptyIIDInfoList
                        allResList.AllList.OnlyCSPList = emptyIIDInfoList
                        allResList.AllList.OnlySpiderList = getIIDList(iidInfoList)

                        return allResList, nil
                }</span>
        }

        // iidInfoList is empty, iidCSPList has values =&gt; only OnlyCSPList &lt;--------------------------(3)
        <span class="cov8" title="1">if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                OnlyCSPList := []*cres.IID{}
                for _, iid := range iidCSPList </span><span class="cov0" title="0">{
                        OnlyCSPList = append(OnlyCSPList, iid)
                }</span>
                <span class="cov0" title="0">allResList.AllList.OnlyCSPList = OnlyCSPList

                return allResList, nil</span>
        }

        ////// iidInfoList has values, iidCSPList has values  &lt;----------------------------------(4)
        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">MappedList := []*cres.IID{}
        OnlySpiderList := []*cres.IID{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, iid := range iidCSPList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                                MappedList = append(MappedList, &amp;iidInfo.IId)
                                exist = true
                        }</span>
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        OnlySpiderList = append(OnlySpiderList, &amp;iidInfo.IId)
                }</span>
        }

        // if SG then MappedList, OnlySpiderList : remove delimeter and set SG name
        <span class="cov8" title="1">if rsType == rsSG </span><span class="cov8" title="1">{ // vpc-01-delimiter-sg-01 ==&gt; sg-01
                for i, iid := range MappedList </span><span class="cov8" title="1">{
                        vpc_sg_nameid := strings.Split(iid.NameId, SG_DELIMITER)
                        MappedList[i].NameId = vpc_sg_nameid[1]
                }</span>
                <span class="cov8" title="1">for i, iid := range OnlySpiderList </span><span class="cov0" title="0">{
                        vpc_sg_nameid := strings.Split(iid.NameId, SG_DELIMITER)
                        OnlySpiderList[i].NameId = vpc_sg_nameid[1]
                }</span>
        }

        <span class="cov8" title="1">allResList.AllList.MappedList = MappedList
        allResList.AllList.OnlySpiderList = OnlySpiderList

        OnlyCSPList := []*cres.IID{}
        for _, iid := range iidCSPList </span><span class="cov8" title="1">{
                if MappedList == nil || len(MappedList) &lt;= 0 </span><span class="cov0" title="0">{
                        OnlyCSPList = append(OnlyCSPList, iid)
                }</span> else<span class="cov8" title="1"> {
                        isMapped := false
                        for _, mappedInfo := range MappedList </span><span class="cov8" title="1">{
                                if iid.SystemId == mappedInfo.SystemId </span><span class="cov8" title="1">{
                                        isMapped = true
                                }</span>
                        }
                        <span class="cov8" title="1">if isMapped == false </span><span class="cov0" title="0">{
                                OnlyCSPList = append(OnlyCSPList, iid)
                        }</span>
                }
        }
        <span class="cov8" title="1">allResList.AllList.OnlyCSPList = OnlyCSPList

        return allResList, nil</span>
}

func getIIDList(iidInfoList []*iidm.IIDInfo) []*cres.IID <span class="cov0" title="0">{
        iidList := []*cres.IID{}
        for _, iidInfo := range iidInfoList </span><span class="cov0" title="0">{
                iidList = append(iidList, &amp;iidInfo.IId)
        }</span>
        <span class="cov0" title="0">return iidList</span>
}

// (1) get IID(NameId)
// (2) delete Resource(SystemId)
// (3) delete IID
func DeleteResource(connectionName string, rsType string, nameID string, force string) (bool, cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteResource()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, "", err
        }</span>

        <span class="cov8" title="1">var handler interface{}

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                handler, err = cldConn.CreateVPCHandler()</span>
        case rsSG:<span class="cov8" title="1">
                handler, err = cldConn.CreateSecurityHandler()</span>
        case rsKey:<span class="cov8" title="1">
                handler, err = cldConn.CreateKeyPairHandler()</span>
        case rsVM:<span class="cov8" title="1">
                handler, err = cldConn.CreateVMHandler()</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        handler, err = cldConn.CreateVPCHandler()
                }</span> else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, "", err
        }</span>

        <span class="cov8" title="1">switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                vpcRWLock.Lock()
                defer vpcRWLock.Unlock()</span>
        case rsSG:<span class="cov8" title="1">
                sgRWLock.Lock()
                defer sgRWLock.Unlock()</span>
        case rsKey:<span class="cov8" title="1">
                keyRWLock.Lock()
                defer keyRWLock.Unlock()</span>
        case rsVM:<span class="cov8" title="1">
                vmRWLock.Lock()
                defer vmRWLock.Unlock()</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        vpcRWLock.Lock()
                        defer vpcRWLock.Unlock()
                }</span> else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }

        // (1) get IID(NameId) for getting SystemId
        <span class="cov8" title="1">var iidInfo *iidm.IIDInfo
        if rsType == rsSG </span><span class="cov8" title="1">{
                // SG NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
                iidInfo, err = iidRWLock.FindIID(connectionName, rsType, nameID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        } else<span class="cov8" title="1"> {
                iidInfo, err = iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        }

        // get VPC IID for remove subnet
        <span class="cov8" title="1">var iidVPCInfo *iidm.IIDInfo
        if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                vpcName := strings.Replace(rsType, SUBNET_PREFIX, "", 1)
                iidVPCInfo, err = iidRWLock.GetIID(connectionName, rsVPC, cres.IID{vpcName, ""})
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        }

        // (2) delete Resource(SystemId)
        <span class="cov8" title="1">result := false
        var vmStatus cres.VMStatus
        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                result, err = handler.(cres.VPCHandler).DeleteVPC(iidInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
        case rsSG:<span class="cov8" title="1">
                result, err = handler.(cres.SecurityHandler).DeleteSecurity(iidInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
        case rsKey:<span class="cov8" title="1">
                result, err = handler.(cres.KeyPairHandler).DeleteKey(iidInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
        case rsVM:<span class="cov8" title="1">
                providerName, err := ccm.GetProviderNameByConnectionName(connectionName)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>

                <span class="cov8" title="1">regionName, zoneName, err := ccm.GetRegionNameByConnectionName(connectionName)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>

                <span class="cov8" title="1">callInfo := call.CLOUDLOGSCHEMA {
                        CloudOS: call.CLOUD_OS(providerName),
                        RegionZone: regionName + "/" + zoneName,
                        ResourceType: call.VM,
                        ResourceName: iidInfo.IId.NameId,
                        CloudOSAPI: "CB-Spider:TerminateVM()",
                        ElapsedTime: "",
                        ErrorMSG: "",
                }
                start := call.Start()
                vmStatus, err = handler.(cres.VMHandler).TerminateVM(iidInfo.IId)
                callInfo.ElapsedTime = call.Elapsed(start)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        callInfo.ErrorMSG = err.Error()
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, vmStatus, err
                        }</span>
                }
                <span class="cov8" title="1">callogger.Info(call.String(callInfo))</span>


        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        result, err = handler.(cres.VPCHandler).RemoveSubnet(iidVPCInfo.IId, iidInfo.IId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                if force != "true" </span><span class="cov0" title="0">{
                                        return false, "", err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }

        <span class="cov8" title="1">if force != "true" </span><span class="cov8" title="1">{
                if rsType != rsVM </span><span class="cov8" title="1">{
                        if result == false </span><span class="cov0" title="0">{
                                return result, "", nil
                        }</span>
                }
        }

        // (3) delete IID
        <span class="cov8" title="1">_, err = iidRWLock.DeleteIID(connectionName, rsType, iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                if force != "true" </span><span class="cov0" title="0">{
                        return false, "", err
                }</span>
        }

        // if VPC
        <span class="cov8" title="1">if rsType == rsVPC </span><span class="cov8" title="1">{
                // for Subnet list
                // key-value structure: /{ConnectionName}/SUBNET_PREFIX+{VPC-NameId}/{Subnet-IId}
                subnetInfoList, err2 := iidRWLock.ListIID(connectionName, SUBNET_PREFIX+iidInfo.IId.NameId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
                <span class="cov8" title="1">for _, subnetInfo := range subnetInfoList </span><span class="cov8" title="1">{
                        // key-value structure: /{ConnectionName}/SUBNET_PREFIX+{VPC-NameId}/{Subnet-IId}
                        _, err := iidRWLock.DeleteIID(connectionName, SUBNET_PREFIX+iidInfo.IId.NameId, subnetInfo.IId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                if force != "true" </span><span class="cov0" title="0">{
                                        return false, "", err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if rsType == rsVM </span><span class="cov8" title="1">{
                return result, vmStatus, nil
        }</span> else<span class="cov8" title="1"> {
                return result, "", nil
        }</span>
}

// (1) delete Resource(SystemId)
func DeleteCSPResource(connectionName string, rsType string, systemID string) (bool, cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteResource()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, "", err
        }</span>

        <span class="cov8" title="1">var handler interface{}

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                handler, err = cldConn.CreateVPCHandler()</span>
        case rsSG:<span class="cov8" title="1">
                handler, err = cldConn.CreateSecurityHandler()</span>
        case rsKey:<span class="cov8" title="1">
                handler, err = cldConn.CreateKeyPairHandler()</span>
        case rsVM:<span class="cov8" title="1">
                handler, err = cldConn.CreateVMHandler()</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        handler, err = cldConn.CreateVPCHandler()
                }</span> else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, "", err
        }</span>

        // get VPC IID for remove subnet
        <span class="cov8" title="1">var iidVPCInfo *iidm.IIDInfo
        if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                vpcName := strings.Replace(rsType, SUBNET_PREFIX, "", 1)
                iidVPCInfo, err = iidRWLock.GetIID(connectionName, rsVPC, cres.IID{vpcName, ""})
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        }

        <span class="cov8" title="1">iid := cres.IID{"", systemID}

        // (1) delete Resource(SystemId)
        result := false
        var vmStatus cres.VMStatus
        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                result, err = handler.(cres.VPCHandler).DeleteVPC(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        case rsSG:<span class="cov8" title="1">
                result, err = handler.(cres.SecurityHandler).DeleteSecurity(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        case rsKey:<span class="cov8" title="1">
                result, err = handler.(cres.KeyPairHandler).DeleteKey(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        case rsVM:<span class="cov8" title="1">
                vmStatus, err = handler.(cres.VMHandler).TerminateVM(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, vmStatus, err
                }</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        result, err = handler.(cres.VPCHandler).RemoveSubnet(iidVPCInfo.IId, iid)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                return false, "", err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }

        <span class="cov8" title="1">if rsType != rsVM </span><span class="cov8" title="1">{
                if result == false </span><span class="cov0" title="0">{
                        return result, "", nil
                }</span>
        }

        <span class="cov8" title="1">if rsType == rsVM </span><span class="cov8" title="1">{
                return result, vmStatus, nil
        }</span> else<span class="cov8" title="1"> {
                return result, "", nil
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "errors"
        "io"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/jaegertracer"
        "github.com/opentracing/opentracing-go"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBConnection - CB-GRPC에서 사용하는 grpc 클라이언트를 위한 Wrapper 구조
type CBConnection struct {
        Conn *grpc.ClientConn
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBConnection - 초기화된 grpc 클라이언트의 인스턴스 생성
func NewCBConnection(gConf *config.GrpcClientConfig) (*CBConnection, io.Closer, error) <span class="cov0" title="0">{

        var (
                tracer opentracing.Tracer = nil
                closer io.Closer          = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc connection config is null")
        }</span>

        <span class="cov0" title="0">if gConf.ServerAddr == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("server addr is empty")
        }</span>

        <span class="cov0" title="0">opts := []grpc.DialOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewClientTLSFromFile(gConf.TLS.TLSCA, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov0" title="0"> {
                opts = append(opts, grpc.WithInsecure())
        }</span>

        // 인터셉터 설정
        <span class="cov0" title="0">unaryIntercepters := []grpc.UnaryClientInterceptor{}
        streamIntercepters := []grpc.StreamClientInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryClientInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamClientInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                        tracingOpts := []grpc_opentracing.Option{}
                        tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                        unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryClientInterceptor(tracingOpts...))
                        streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamClientInterceptor(tracingOpts...))
                }</span>

        }

        <span class="cov0" title="0">opts = append(opts, grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(unaryIntercepters...)))
        opts = append(opts, grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(streamIntercepters...)))
        conn, err := grpc.Dial(gConf.ServerAddr, opts...)

        return &amp;CBConnection{Conn: conn}, closer, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "encoding/json"
        "strings"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"

        "gopkg.in/yaml.v2"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====s

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvertToMessage - 입력 데이터를 grpc 메시지로 변환
func ConvertToMessage(inType string, inData string, obj interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if inType == "yaml" </span><span class="cov8" title="1">{
                err := yaml.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">if inType == "json" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("json Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertToOutput - grpc 메시지를 출력포맷으로 변환
func ConvertToOutput(outType string, obj interface{}) (string, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if outType == "yaml" </span><span class="cov8" title="1">{
                // 메시지 포맷에서 불필요한 필드(XXX_로 시작하는 필드)를 제거하기 위해 json 태그를 이용하여 마샬링
                j, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // yaml 에서 지원하지 않는 control character 제거
                <span class="cov8" title="1">cleanStr := strings.Map(func(value rune) rune </span><span class="cov8" title="1">{
                        switch </span>{
                        case value == 0x09:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0A:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0D:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x20 &amp;&amp; value &lt;= 0x7E:<span class="cov8" title="1">
                                return value</span>
                        case value == 0x85:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xA0 &amp;&amp; value &lt;= 0xD7FF:<span class="cov8" title="1">
                                return value</span>
                        case value &gt;= 0xE000 &amp;&amp; value &lt;= 0xFFFD:<span class="cov8" title="1">
                                return value</span>
                        case value &gt;= 0x10000 &amp;&amp; value &lt;= 0x10FFFF:<span class="cov0" title="0">
                                return value</span>
                        default:<span class="cov0" title="0">
                                return -1</span> // control characters are not allowed
                        }
                }, string(j))

                // 필드를 소팅하지 않고 지정된 순서대로 출력하기 위해 MapSlice 이용
                <span class="cov8" title="1">jsonObj := yaml.MapSlice{}
                err2 := yaml.Unmarshal([]byte(cleanStr), &amp;jsonObj)
                if err2 != nil </span><span class="cov0" title="0">{
                        return "", err2
                }</span>

                // yaml 마샬링
                <span class="cov8" title="1">y, err3 := yaml.Marshal(jsonObj)
                if err3 != nil </span><span class="cov0" title="0">{
                        return "", err3
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Marshal: \n", string(y))

                return string(y), nil</span>
        }

        <span class="cov8" title="1">if outType == "json" </span><span class="cov8" title="1">{
                j, err := json.MarshalIndent(obj, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">outStr := string(j)

                // json.Marshal 함수는  &lt;,&gt;, &amp; 문자를 escape 함.. 다시 원래대로 변환
                outStr = strings.Replace(outStr, "\\u003c", "&lt;", -1)
                outStr = strings.Replace(outStr, "\\u003e", "&gt;", -1)
                outStr = strings.Replace(outStr, "\\u0026", "&amp;", -1)

                logger.Debug("json Marshal: \n", outStr)
                return outStr, nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// CopySrcToDest - 소스에서 타켓으로 데이터 복사
func CopySrcToDest(src interface{}, dest interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        j, err := json.MarshalIndent(src, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("source value : \n", string(j))

        err = json.Unmarshal(j, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">j, err = json.MarshalIndent(dest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("target value : \n", string(j))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/jaegertracer"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        opentracing "github.com/opentracing/opentracing-go"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBServer - CB-GRPC에서 사용하는 grpc 서버를 위한 Wrapper 구조
type CBServer struct {
        Server *grpc.Server
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBServer - 초기화된 grpc 서버의 인스턴스 생성
func NewCBServer(gConf *config.GrpcServerConfig) (*CBServer, io.Closer, error) <span class="cov8" title="1">{

        var (
                tracer      opentracing.Tracer             = nil
                closer      io.Closer                      = nil
                reg         *prometheus.Registry           = nil
                grpcMetrics *grpc_prometheus.ServerMetrics = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc server config is null")
        }</span>

        <span class="cov8" title="1">opts := []grpc.ServerOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(gConf.TLS.TLSCert, gConf.TLS.TLSKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        // 인터셉터 설정
        <span class="cov8" title="1">unaryIntercepters := []grpc.UnaryServerInterceptor{}
        streamIntercepters := []grpc.StreamServerInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamServerInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if gConf.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                                tracingOpts := []grpc_opentracing.Option{}
                                tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                                unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryServerInterceptor(tracingOpts...))
                                streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamServerInterceptor(tracingOpts...))
                        }</span>
                }

                // Prometheus Metrics 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{
                        grpcMetrics = grpc_prometheus.NewServerMetrics()
                        grpcMetrics.EnableHandlingTimeHistogram()

                        reg = prometheus.NewRegistry()
                        reg.MustRegister(grpcMetrics)
                        reg.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))
                        reg.MustRegister(prometheus.NewGoCollector())

                        unaryIntercepters = append(unaryIntercepters, grpcMetrics.UnaryServerInterceptor())
                        streamIntercepters = append(streamIntercepters, grpcMetrics.StreamServerInterceptor())
                }</span>

        }

        // recovery 인터셉터 기본 설정
        <span class="cov8" title="1">unaryIntercepters = append(unaryIntercepters, grpc_recovery.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_recovery.StreamServerInterceptor())

        opts = append(opts, grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(unaryIntercepters...)))
        opts = append(opts, grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(streamIntercepters...)))
        gs := grpc.NewServer(opts...)

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{
                if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{

                        // Create a HTTP server for prometheus.
                        httpServer := &amp;http.Server{
                                Handler: promhttp.HandlerFor(reg, promhttp.HandlerOpts{}),
                                Addr:    fmt.Sprintf("0.0.0.0:%d", gConf.Interceptors.PrometheusMetrics.ListenPort),
                        }
                        // Initialize all metrics.
                        grpcMetrics.InitializeMetrics(gs)
                        // Start your http server for prometheus.
                        go func() </span><span class="cov0" title="0">{
                                if err := httpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                                        log.Fatal("Unable to start a http server for prometheus.")
                                }</span>
                        }()

                }
        }

        <span class="cov8" title="1">return &amp;CBServer{Server: gs}, closer, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvGrpcStatusErr - GRPC 상태 코드 에러로 변환
func ConvGrpcStatusErr(err error, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        if err != nil </span><span class="cov0" title="0">{
                if errStatus, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        logger.Error(tag, " error while calling ", method, " method: ", errStatus.Message())
                        return status.Errorf(errStatus.Code(), "%s error while calling %s method: %v ", tag, method, errStatus.Message())
                }</span>
                <span class="cov0" title="0">logger.Error(tag, " error while calling ", method, " method: ", err)
                return status.Errorf(codes.Internal, "%s error while calling %s method: %v ", tag, method, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewGrpcStatusErr - GRPC 상태 코드 에러 생성
func NewGrpcStatusErr(msg string, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Error(tag, " error while calling ", method, " method: ", msg)
        return status.Errorf(codes.Internal, "%s error while calling %s method: %s ", tag, method, msg)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

// Package config - Configuration for Cloud-Barista's GRPC and provides the required process
package config

import (
        "fmt"
        "log"
        "os"
        "strings"
        "time"
)

// ===== [ Constants and Variables ] =====

const (
        // ConfigVersion - 설정 구조에 대한 버전
        ConfigVersion = 1
)

// ===== [ Types ] =====

// GrpcConfig - CB-GRPC 서비스 설정 구조
type GrpcConfig struct {
        Version int             `mapstructure:"version"`
        GSL     GrpcServiceList `mapstructure:"grpc"`
}

// GrpcServiceList - CB-GRPC 서비스 목록
type GrpcServiceList struct {
        SpiderSrv *GrpcServerConfig `mapstructure:"spidersrv"`
        SpiderCli *GrpcClientConfig `mapstructure:"spidercli"`
}

// GrpcServerConfig - CB-GRPC 서버 설정 구조
type GrpcServerConfig struct {
        Addr         string              `mapstructure:"addr"`
        Reflection   string              `mapstructure:"reflection"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// GrpcClientConfig - CB-GRPC 클라이언트 설정 구조
type GrpcClientConfig struct {
        ServerAddr   string              `mapstructure:"server_addr"`
        Timeout      time.Duration       `mapstructure:"timeout"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// TLSConfig - TLS 설정 구조
type TLSConfig struct {
        TLSCert string `mapstructure:"tls_cert"`
        TLSKey  string `mapstructure:"tls_key"`
        TLSCA   string `mapstructure:"tls_ca"`
}

// InterceptorsConfig - GRPC 인터셉터 설정 구조
type InterceptorsConfig struct {
        AuthJWT           *AuthJWTConfig           `mapstructure:"auth_jwt"`
        PrometheusMetrics *PrometheusMetricsConfig `mapstructure:"prometheus_metrics"`
        Opentracing       *OpentracingConfig       `mapstructure:"opentracing"`
}

// AuthJWTConfig - AuthJWT 설정 구조
type AuthJWTConfig struct {
        JWTKey   string `mapstructure:"jwt_key"`
        JWTToken string `mapstructure:"jwt_token"`
}

// PrometheusMetricsConfig - Prometheus Metrics 설정 구조
type PrometheusMetricsConfig struct {
        ListenPort int `mapstructure:"listen_port"`
}

// OpentracingConfig - Opentracing 설정 구조
type OpentracingConfig struct {
        Jaeger *JaegerClientConfig `mapstructure:"jaeger"`
}

// JaegerClientConfig - Jaeger Client 설정 구조
type JaegerClientConfig struct {
        Endpoint    string  `mapstructure:"endpoint"`
        ServiceName string  `mapstructure:"service_name"`
        SampleRate  float64 `mapstructure:"sample_rate"`
}

// UnsupportedVersionError - 설정 초기화 과정에서 버전 검증을 통해 반환할 오류 구조
type UnsupportedVersionError struct {
        Have int
        Want int
}

// ===== [ Implementations ] =====

// Init - 설정에 대한 검사 및 초기화
func (gConf *GrpcConfig) Init() error <span class="cov8" title="1">{
        // 설정 파일 버전 검증
        if gConf.Version != ConfigVersion </span><span class="cov0" title="0">{
                return &amp;UnsupportedVersionError{
                        Have: gConf.Version,
                        Want: ConfigVersion,
                }
        }</span>
        // 전역변수 초기화
        <span class="cov8" title="1">gConf.initGlobalParams()

        return nil</span>
}

// initGlobalParams - 전역 설정 초기화
func (gConf *GrpcConfig) initGlobalParams() <span class="cov8" title="1">{

        if gConf.GSL.SpiderSrv != nil </span><span class="cov8" title="1">{

                if gConf.GSL.SpiderSrv.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderSrv.TLS.TLSCert != "" </span><span class="cov0" title="0">{
                                gConf.GSL.SpiderSrv.TLS.TLSCert = ReplaceEnvPath(gConf.GSL.SpiderSrv.TLS.TLSCert)
                        }</span>
                        <span class="cov0" title="0">if gConf.GSL.SpiderSrv.TLS.TLSKey != "" </span><span class="cov0" title="0">{
                                gConf.GSL.SpiderSrv.TLS.TLSKey = ReplaceEnvPath(gConf.GSL.SpiderSrv.TLS.TLSKey)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.SpiderSrv.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderSrv.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.ServiceName = "grpc spider server"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

        <span class="cov8" title="1">if gConf.GSL.SpiderCli != nil </span><span class="cov8" title="1">{

                if gConf.GSL.SpiderCli.Timeout == 0 </span><span class="cov0" title="0">{
                        gConf.GSL.SpiderCli.Timeout = 90 * time.Second
                }</span>

                <span class="cov8" title="1">if gConf.GSL.SpiderCli.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderCli.TLS.TLSCA != "" </span><span class="cov0" title="0">{
                                gConf.GSL.SpiderCli.TLS.TLSCA = ReplaceEnvPath(gConf.GSL.SpiderCli.TLS.TLSCA)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.SpiderCli.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderCli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.ServiceName = "grpc spider client"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

}

// Error - 비 호환 버전에 대한 오류 문자열 반환
func (u *UnsupportedVersionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Unsupported version: %d (wanted: %d)", u.Have, u.Want)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ReplaceEnvPath - $ABC/def ==&gt; /abc/def
func ReplaceEnvPath(str string) string <span class="cov0" title="0">{
        if strings.Index(str, "$") == -1 </span><span class="cov0" title="0">{
                return str
        }</span>

        // ex) input "$CBSTORE_ROOT/meta_db/dat"
        <span class="cov0" title="0">strList := strings.Split(str, "/")
        for n, one := range strList </span><span class="cov0" title="0">{
                if strings.Index(one, "$") != -1 </span><span class="cov0" title="0">{
                        cbstoreRootPath := os.Getenv(strings.Trim(one, "$"))
                        if cbstoreRootPath == "" </span><span class="cov0" title="0">{
                                log.Fatal(one + " is not set!")
                        }</span>
                        <span class="cov0" title="0">strList[n] = cbstoreRootPath</span>
                }
        }

        <span class="cov0" title="0">var resultStr string
        for _, one := range strList </span><span class="cov0" title="0">{
                resultStr = resultStr + one + "/"
        }</span>
        // ex) "/root/go/src/github.com/cloud-barista/poc-cicd-spider/meta_db/dat/"
        <span class="cov0" title="0">resultStr = strings.TrimRight(resultStr, "/")
        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        return resultStr</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package config

import (
        "fmt"
        "os"
        "reflect"
        "unsafe"

        "github.com/spf13/viper"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Parser - Viper lib를 활용하기 위한 Parser 정의 구조 형식
type Parser struct {
        viper *viper.Viper
}

// ===== [ Implementations ] =====

// GrpcParse - Viper lib를 이용해서 지정된 CB-GRPC configuration 정보 파싱
func (p Parser) GrpcParse(configFile string) (GrpcConfig, error) <span class="cov8" title="1">{
        p.viper.SetConfigFile(configFile)
        p.viper.AutomaticEnv()
        p.viper.SetConfigType("yaml")

        var cfg GrpcConfig

        // Reading
        if err := p.viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Unmarshal to struct
        <span class="cov8" title="1">if err := p.viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Initialize
        <span class="cov8" title="1">if err := cfg.Init(); err != nil </span><span class="cov0" title="0">{
                return cfg, CheckErr(err, configFile)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// ===== [ Private Functions ] =====

// checkErr - Viper lib 처리에서 발생한 오류 반환 (Nested call)
func checkErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case viper.ConfigParseError:<span class="cov0" title="0">
                var subErr error
                re := reflect.ValueOf(&amp;e).Elem()
                rf := re.Field(0)
                rse := reflect.ValueOf(&amp;subErr).Elem()
                rf = reflect.NewAt(rf.Type(), unsafe.Pointer(rf.UnsafeAddr())).Elem()
                rse.Set(rf)
                return checkErr(subErr, configFile)</span>
        default:<span class="cov0" title="0">
                return CheckErr(err, configFile)</span>
        }
}

// ===== [ Public Functions ] =====

// CheckErr - 검증된 오류 정보 반환
func CheckErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case *os.PathError:<span class="cov0" title="0">
                return fmt.Errorf("'%s' (%s): %s", configFile, e.Op, e.Err.Error())</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("'%s': %v", configFile, err)</span>
        }
}

// MakeParser - Viber lib를 활용하는 설정 Parser 생성
func MakeParser() Parser <span class="cov8" title="1">{
        return Parser{viper.New()}
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - rpc unary call 정보를 기록하는 클라이언트 인터셉터
func UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := invoker(ctx, method, req, reply, cc, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client unary call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return err
        }</span>
}

// StreamClientInterceptor - rpc stream call 정보를 기록하는 클라이언트 인터셉터
func StreamClientInterceptor() grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                clientStream, err := streamer(ctx, desc, cc, method, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client stream call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return clientStream, err
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/peer"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - rpc unary receive 정보를 기록하는 서버 인터셉터
func UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                startTime := time.Now()
                resp, err := handler(ctx, req)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(ctx); ok </span><span class="cov8" title="1">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov8" title="1">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server unary received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return resp, err</span>
        }
}

// StreamServerInterceptor - rpc stream receive 정보를 기록하는 서버 인터셉터
func StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov8" title="1">{
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := handler(srv, stream)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(stream.Context()); ok </span><span class="cov0" title="0">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov0" title="0">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server stream received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package authjwt

import (
        "context"
        "fmt"
        "time"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        "github.com/dgrijalva/jwt-go"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

func validateToken(ctx context.Context) (bool, error) <span class="cov0" title="0">{

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.InvalidArgument, "Retrieving metadata is failed")
        }</span>

        <span class="cov0" title="0">authHeader, ok := md["authorization"]
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Authorization jwt token is not supplied")
        }</span>

        <span class="cov0" title="0">tokenStr := authHeader[0]

        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(jwtKey), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Parsing jwt token is failed")
        }</span>

        <span class="cov0" title="0">if token.Valid </span><span class="cov0" title="0">{
                logger := logger.NewLogger()
                var tokenInfo string = "{"
                for key, val := range claims </span><span class="cov0" title="0">{
                        if key == "expire" </span><span class="cov0" title="0">{

                                if getTokenRemainingValidity(val) &lt; 0 </span><span class="cov0" title="0">{
                                        return false, status.Errorf(codes.Unauthenticated, "token is expired")
                                }</span>

                                <span class="cov0" title="0">var timestamp interface{} = val
                                t := time.Unix(int64(timestamp.(float64)), 0)
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %d-%02d-%02dT%02d:%02d:%02d, remainder seconds: %d,", key,
                                        t.Year(), t.Month(), t.Day(),
                                        t.Hour(), t.Minute(), t.Second(),
                                        getTokenRemainingValidity(val),
                                )</span>

                        } else<span class="cov0" title="0"> {
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %v,", key, val)
                        }</span>
                }
                <span class="cov0" title="0">tokenInfo = tokenInfo + " }"
                logger.Debug("token parsing result : ", tokenInfo)

                return true, nil</span>
        }

        <span class="cov0" title="0">return false, status.Errorf(codes.Unauthenticated, "Authorization is failed")</span>
}

func getTokenRemainingValidity(timestamp interface{}) int <span class="cov0" title="0">{
        if validity, ok := timestamp.(float64); ok </span><span class="cov0" title="0">{
                tm := time.Unix(int64(validity), 0)
                remainder := tm.Sub(time.Now())

                return int(remainder.Seconds())
        }</span>
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtToken = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - JWT 토큰을 전달하는 Unary 클라이언트 인터셉터
func UnaryClientInterceptor(token string) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return invoker(ctx, method, req, reply, cc, opts...)</span>
        }
}

// StreamClientInterceptor - JWT 토큰을 전달하는 Stream 클라이언트 인터셉터
func StreamClientInterceptor(token string) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return streamer(ctx, desc, cc, method, opts...)</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtKey = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - authentication 을 처리하는 Unary 서버 인터셉터
func UnaryServerInterceptor(key string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// StreamServerInterceptor - authentication 을 처리하는 Stream 서버 인터셉터
func StreamServerInterceptor(key string) grpc.StreamServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(stream.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return handler(srv, stream)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package jaegertracer

import (
        "fmt"
        "io"

        opentracing "github.com/opentracing/opentracing-go"
        jaeger "github.com/uber/jaeger-client-go"
        config "github.com/uber/jaeger-client-go/config"

        grpcconfig "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
)

// InitJaeger - Jaeger Tracer 초기화
func InitJaeger(jcConf *grpcconfig.JaegerClientConfig) (opentracing.Tracer, io.Closer) <span class="cov0" title="0">{
        cfg := &amp;config.Configuration{
                Sampler: &amp;config.SamplerConfig{
                        Type:  "probabilistic",
                        Param: jcConf.SampleRate,
                },
                Reporter: &amp;config.ReporterConfig{
                        LocalAgentHostPort: jcConf.Endpoint,
                },
        }
        tracer, closer, err := cfg.New(jcConf.ServiceName, config.Logger(jaeger.NullLogger))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))</span>
        }
        <span class="cov0" title="0">return tracer, closer</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package logger

import (
        "io"
        "io/ioutil"
        "os"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Logger - CB-LOG에서 사용하는 "logrus" Logger를 위한 Wrapper 구조
type Logger struct {
        *logrus.Logger
}

// ===== [ Implementations ] =====

// SetOutput - 로그 출력기 설정
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.Logger.Out = w
}</span>

// DisableOutput - 로그 출력 비활성화
func (l *Logger) DisableOutput() <span class="cov0" title="0">{
        l.SetOutput(ioutil.Discard)
}</span>

// SetFormatter - 로그 포맷터 설정
func (l *Logger) SetFormatter(f logrus.Formatter) <span class="cov0" title="0">{
        l.Logger.Formatter = f
}</span>

// SetLogLevel - 로그 레벨 설정
func (l *Logger) SetLogLevel(lv logrus.Level) <span class="cov0" title="0">{
        l.Logger.SetLevel(lv)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewLogger - 초기화된 Logger의 인스턴스 생성
func NewLogger() *Logger <span class="cov8" title="1">{
        // CBLOG_ROOT 환경변수가 설정되어 있지 않으면 현재 경로로 환경변수 설정)
        env := os.Getenv("CBLOG_ROOT")
        if env == "" </span><span class="cov0" title="0">{
                if dir, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                        os.Setenv("CBLOG_ROOT", dir)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Logger{
                Logger: cblog.GetLogger("CB-GRPC"),
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateConnectionConfig - Connection Config 생성
func (s *CIMService) CreateConnectionConfig(ctx context.Context, req *pb.ConnectionConfigInfoRequest) (*pb.ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateConnectionConfig()")

        // GRPC 메시지에서 CIM 객체로 복사
        var cimObj ccim.ConnectionConfigInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateConnectionConfig()")
        }</span>

        <span class="cov8" title="1">connInfo, err := ccim.CreateConnectionConfigInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateConnectionConfig()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ConnectionConfigInfo
        err = gc.CopySrcToDest(&amp;connInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ConnectionConfigInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListConnectionConfig - Connection Config 목록
func (s *CIMService) ListConnectionConfig(ctx context.Context, req *pb.Empty) (*pb.ListConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListConnectionConfig()")

        infoList, err := ccim.ListConnectionConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListConnectionConfig()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.ConnectionConfigInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListConnectionConfigInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetConnectionConfig - Connection Config 조회
func (s *CIMService) GetConnectionConfig(ctx context.Context, req *pb.ConnectionConfigQryRequest) (*pb.ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetConnectionConfig()")

        connInfo, err := ccim.GetConnectionConfig(req.ConfigName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetConnectionConfig()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ConnectionConfigInfo
        err = gc.CopySrcToDest(&amp;connInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ConnectionConfigInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteConnectionConfig - Connection Config 삭제
func (s *CIMService) DeleteConnectionConfig(ctx context.Context, req *pb.ConnectionConfigQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteConnectionConfig()")

        result, err := ccim.DeleteConnectionConfig(req.ConfigName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file15" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCredential - Credential 생성
func (s *CIMService) CreateCredential(ctx context.Context, req *pb.CredentialInfoRequest) (*pb.CredentialInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateCredential()")

        // GRPC 메시지에서 CIM 객체로 복사
        var cimObj cim.CredentialInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCredential()")
        }</span>

        <span class="cov8" title="1">crdInfo, err := cim.RegisterCredentialInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCredential()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.CredentialInfo
        err = gc.CopySrcToDest(&amp;crdInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CredentialInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListCredential - Credential 목록
func (s *CIMService) ListCredential(ctx context.Context, req *pb.Empty) (*pb.ListCredentialInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListCredential()")

        infoList, err := cim.ListCredential()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCredential()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.CredentialInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListCredentialInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetCredential - Credential 조회
func (s *CIMService) GetCredential(ctx context.Context, req *pb.CredentialQryRequest) (*pb.CredentialInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetCredential()")

        crdInfo, err := cim.GetCredential(req.CredentialName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCredential()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.CredentialInfo
        err = gc.CopySrcToDest(&amp;crdInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CredentialInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteCredential - Credential 삭제
func (s *CIMService) DeleteCredential(ctx context.Context, req *pb.CredentialQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteCredential()")

        result, err := cim.UnRegisterCredential(req.CredentialName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file16" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCloudDriver - Cloud Driver 생성
func (s *CIMService) CreateCloudDriver(ctx context.Context, req *pb.CloudDriverInfoRequest) (*pb.CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateCloudDriver()")

        // GRPC 메시지에서 CIM 객체로 복사
        var cimObj dim.CloudDriverInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCloudDriver()")
        }</span>

        <span class="cov8" title="1">drvInfo, err := dim.RegisterCloudDriverInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCloudDriver()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.CloudDriverInfo
        err = gc.CopySrcToDest(&amp;drvInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CloudDriverInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListCloudDriver -Cloud Driver 목록
func (s *CIMService) ListCloudDriver(ctx context.Context, req *pb.Empty) (*pb.ListCloudDriverInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListCloudDriver()")

        infoList, err := dim.ListCloudDriver()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCloudDriver()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.CloudDriverInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListCloudDriverInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetCloudDriver - Cloud Driver 조회
func (s *CIMService) GetCloudDriver(ctx context.Context, req *pb.CloudDriverQryRequest) (*pb.CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetCloudDriver()")

        drvInfo, err := dim.GetCloudDriver(req.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCloudDriver()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.CloudDriverInfo
        err = gc.CopySrcToDest(&amp;drvInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CloudDriverInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteCloudDriver - Cloud Driver 삭제
func (s *CIMService) DeleteCloudDriver(ctx context.Context, req *pb.CloudDriverQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteCloudDriver()")

        result, err := dim.UnRegisterCloudDriver(req.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file17" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateImage - Image 생성
func (s *CCMService) CreateImage(ctx context.Context, req *pb.ImageCreateRequest) (*pb.ImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateImage()")

        // Grpc RegInfo =&gt; Driver ReqInfo
        reqInfo := cres.ImageReqInfo{
                IId: cres.IID{NameId: req.Item.Name, SystemId: ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateImage(req.ConnectionName, rsImage, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateImage()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ImageInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListImage - Image 목록
func (s *CCMService) ListImage(ctx context.Context, req *pb.ImageAllQryRequest) (*pb.ListImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListImage()")

        // Call common-runtime API
        result, err := cmrt.ListImage(req.ConnectionName, rsImage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListImage()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.ImageInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListImageInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetImage - Image 조회
func (s *CCMService) GetImage(ctx context.Context, req *pb.ImageQryRequest) (*pb.ImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetImage()")

        // Call common-runtime API
        result, err := cmrt.GetImage(req.ConnectionName, rsImage, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetImage()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ImageInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteImage - Image 삭제
func (s *CCMService) DeleteImage(ctx context.Context, req *pb.ImageQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteImage()")

        // Call common-runtime API
        result, err := cmrt.DeleteImage(req.ConnectionName, rsImage, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file18" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateKey - KeyPair 생성
func (s *CCMService) CreateKey(ctx context.Context, req *pb.KeyPairCreateRequest) (*pb.KeyPairInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateKey()")

        // Grpc RegInfo =&gt; Driver ReqInfo
        reqInfo := cres.KeyPairReqInfo{
                IId: cres.IID{NameId: req.Item.Name, SystemId: ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateKey(req.ConnectionName, rsKey, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateKey()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.KeyPairInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.KeyPairInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListKey - KeyPair 목록
func (s *CCMService) ListKey(ctx context.Context, req *pb.KeyPairAllQryRequest) (*pb.ListKeyPairInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListKey()")

        // Call common-runtime API
        result, err := cmrt.ListKey(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListKey()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.KeyPairInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListKeyPairInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetKey - KeyPair 조회
func (s *CCMService) GetKey(ctx context.Context, req *pb.KeyPairQryRequest) (*pb.KeyPairInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetKey()")

        // Call common-runtime API
        result, err := cmrt.GetKey(req.ConnectionName, rsKey, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetKey()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.KeyPairInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.KeyPairInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteKey - KeyPair 삭제
func (s *CCMService) DeleteKey(ctx context.Context, req *pb.KeyPairQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteKey()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, rsKey, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ListAllKey - 관리 Key 목록
func (s *CCMService) ListAllKey(ctx context.Context, req *pb.KeyPairAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllKey()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllKey()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllKey()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// DeleteCSPKey - CSP Key 삭제
func (s *CCMService) DeleteCSPKey(ctx context.Context, req *pb.CSPKeyPairQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteCSPKey()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsKey, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteCSPKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file19" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        im "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListCloudOS - Cloud OS 조회
func (s *CIMService) ListCloudOS(ctx context.Context, req *pb.Empty) (*pb.ListCloudOSInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListCloudOS()")

        infoList := im.ListCloudOS()

        resp := &amp;pb.ListCloudOSInfoResponse{Items: infoList}
        return resp, nil
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file20" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateRegion - Region 생성
func (s *CIMService) CreateRegion(ctx context.Context, req *pb.RegionInfoRequest) (*pb.RegionInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateRegion()")

        // GRPC 메시지에서 CIM 객체로 복사
        var cimObj rim.RegionInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateRegion()")
        }</span>

        <span class="cov8" title="1">regionInfo, err := rim.RegisterRegionInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateRegion()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.RegionInfo
        err = gc.CopySrcToDest(&amp;regionInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.RegionInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListRegion - Region 목록
func (s *CIMService) ListRegion(ctx context.Context, req *pb.Empty) (*pb.ListRegionInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListRegion()")

        infoList, err := rim.ListRegion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListRegion()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.RegionInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListRegionInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetRegion - Region 조회
func (s *CIMService) GetRegion(ctx context.Context, req *pb.RegionQryRequest) (*pb.RegionInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetRegion()")

        regionInfo, err := rim.GetRegion(req.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetRegion()")
        }</span>

        // CIM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.RegionInfo
        err = gc.CopySrcToDest(&amp;regionInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.RegionInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteRegion - Region 삭제
func (s *CIMService) DeleteRegion(ctx context.Context, req *pb.RegionQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteRegion()")

        result, err := rim.UnRegisterRegion(req.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file21" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"
        "strings"

        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSecurity - Security 생성
func (s *CCMService) CreateSecurity(ctx context.Context, req *pb.SecurityCreateRequest) (*pb.SecurityInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateSecurity()")

        // check the input Name to include the SecurityGroup Delimiter
        if strings.Contains(req.Item.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr(cm.SG_DELIMITER+" cannot be used in Security Group name!!", "", "CCMService.CreateSecurity()")
        }</span>

        // GRPC 메시지에서 CCM 객체로 복사
        <span class="cov8" title="1">var reqInfo cres.SecurityReqInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateSecurity()")
        }</span>
        // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
        // transform: SG NameID =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
        //reqInfo.IId = cres.IID{NameId: req.Item.VpcName + cm.SG_DELIMITER + req.Item.Name, SystemId: ""}
        <span class="cov8" title="1">reqInfo.IId = cres.IID{NameId: req.Item.VpcName + cm.SG_DELIMITER + req.Item.Name, SystemId: req.Item.Name} // for NCP: fixed NameID =&gt; SystemID, Driver: (1)search systemID with fixed NameID (2)replace fixed NameID into SysemID
        reqInfo.VpcIID = cres.IID{NameId: req.Item.VpcName, SystemId: ""}

        // Call common-runtime API
        result, err := cmrt.CreateSecurity(req.ConnectionName, rsSG, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateSecurity()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.SecurityInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.SecurityInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListSecurity - Security 목록
func (s *CCMService) ListSecurity(ctx context.Context, req *pb.SecurityAllQryRequest) (*pb.ListSecurityInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListSecurity()")

        // Call common-runtime API
        result, err := cmrt.ListSecurity(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListSecurity()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.SecurityInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListSecurityInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetSecurity - Security 조회
func (s *CCMService) GetSecurity(ctx context.Context, req *pb.SecurityQryRequest) (*pb.SecurityInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetSecurity()")

        // Call common-runtime API
        result, err := cmrt.GetSecurity(req.ConnectionName, rsSG, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetSecurity()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.SecurityInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.SecurityInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteSecurity - Security 삭제
func (s *CCMService) DeleteSecurity(ctx context.Context, req *pb.SecurityQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteSecurity()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, rsSG, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ListAllSecurity - 관리 Security 목록
func (s *CCMService) ListAllSecurity(ctx context.Context, req *pb.SecurityAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllSecurity()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllSecurity()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllSecurity()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// DeleteCSPSecurity - CSP Security 삭제
func (s *CCMService) DeleteCSPSecurity(ctx context.Context, req *pb.CSPSecurityQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteCSPSecurity()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsSG, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteCSPSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file22" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"
        "strings"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        sshrun "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/vm-ssh"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// SSHRun - SSH 실행
func (s *SSHService) SSHRun(ctx context.Context, req *pb.SSHRunRequest) (*pb.StringResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling SSHService.SSHRun()")

        strPrivateKey := strings.Join(req.PrivateKey[:], "\n")

        sshInfo := sshrun.SSHInfo{
                UserName:   req.UserName,
                PrivateKey: []byte(strPrivateKey),
                ServerPort: req.ServerPort,
        }

        var result string
        var err error
        if result, err = sshrun.SSHRun(sshInfo, req.Command); err != nil </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr("Error while running cmd: "+req.Command+"]"+err.Error(), "", "SSHService.SSHRun()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StringResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file23" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// StartVM - VM 시작
func (s *CCMService) StartVM(ctx context.Context, req *pb.VMCreateRequest) (*pb.VMInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.StartVM()")

        // Rest RegInfo =&gt; Driver ReqInfo
        // (1) create SecurityGroup IID List
        sgIIDList := []cres.IID{}
        for _, sgName := range req.Item.SecurityGroupNames </span><span class="cov8" title="1">{
                // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                // transform: SG NameID =&gt; {VPC NameID}-{SG NameID}
                sgIID := cres.IID{NameId: req.Item.VpcName + cm.SG_DELIMITER + sgName, SystemId: ""}
                sgIIDList = append(sgIIDList, sgIID)
        }</span>
        // (2) create VMReqInfo with SecurityGroup IID List
        <span class="cov8" title="1">reqInfo := cres.VMReqInfo{
                IId:               cres.IID{NameId: req.Item.Name, SystemId: ""},
                ImageIID:          cres.IID{NameId: req.Item.ImageName, SystemId: ""},
                VpcIID:            cres.IID{NameId: req.Item.VpcName, SystemId: ""},
                SubnetIID:         cres.IID{NameId: req.Item.SubnetName, SystemId: ""},
                SecurityGroupIIDs: sgIIDList,

                VMSpecName: req.Item.VmSpecName,
                KeyPairIID: cres.IID{NameId: req.Item.KeyPairName, SystemId: ""},

                VMUserId:     req.Item.VmUserId,
                VMUserPasswd: req.Item.VmUserPasswd,
        }

        // Call common-runtime API
        result, err := cmrt.StartVM(req.ConnectionName, rsVM, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.StartVM()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.VMInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.StartVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VMInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ControlVM - VM 제어
func (s *CCMService) ControlVM(ctx context.Context, req *pb.VMActionRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ControlVM()")

        // Call common-runtime API
        result, err := cmrt.ControlVM(req.ConnectionName, rsVM, req.Name, req.Action)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ControlVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// ListVM - VM 목록
func (s *CCMService) ListVM(ctx context.Context, req *pb.VMAllQryRequest) (*pb.ListVMInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVM()")

        // Call common-runtime API
        result, err := cmrt.ListVM(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVM()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.VMInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVMInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVM - VM 조회
func (s *CCMService) GetVM(ctx context.Context, req *pb.VMQryRequest) (*pb.VMInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVM()")

        // Call common-runtime API
        result, err := cmrt.GetVM(req.ConnectionName, rsVM, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVM()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.VMInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VMInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListVMStatus - VM 상태 목록
func (s *CCMService) ListVMStatus(ctx context.Context, req *pb.VMAllQryRequest) (*pb.ListVMStatusInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVMStatus()")

        // Call common-runtime API
        result, err := cmrt.ListVMStatus(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMStatus()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.VMStatusInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMStatus()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVMStatusInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVMStatus - VM 상태 조회
func (s *CCMService) GetVMStatus(ctx context.Context, req *pb.VMQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVMStatus()")

        // Call common-runtime API
        result, err := cmrt.GetVMStatus(req.ConnectionName, rsVM, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVMStatus()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// TerminateVM - VM 삭제
func (s *CCMService) TerminateVM(ctx context.Context, req *pb.VMQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.TerminateVM()")

        // Call common-runtime API
        _, result, err := cmrt.DeleteResource(req.ConnectionName, rsVM, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.TerminateVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// ListAllVM - 관리 VM 목록
func (s *CCMService) ListAllVM(ctx context.Context, req *pb.VMAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllVM()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVM()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVM()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// TerminateCSPVM - CSP VM 삭제
func (s *CCMService) TerminateCSPVM(ctx context.Context, req *pb.CSPVMQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.TerminateCSPVM()")

        // Call common-runtime API
        _, result, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVM, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.TerminateCSPVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file24" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListVMSpec - VM Spec 목록
func (s *CCMService) ListVMSpec(ctx context.Context, req *pb.VMSpecAllQryRequest) (*pb.ListVMSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVMSpec()")

        // Call common-runtime API
        result, err := cmrt.ListVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMSpec()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.VMSpecInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVMSpecInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVMSpec - VM Spec 조회
func (s *CCMService) GetVMSpec(ctx context.Context, req *pb.VMSpecQryRequest) (*pb.VMSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVMSpec()")

        // Call common-runtime API
        result, err := cmrt.GetVMSpec(req.ConnectionName, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVMSpec()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.VMSpecInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VMSpecInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListOrgVMSpec - 클라우드의 원래 VM Spec 목록
func (s *CCMService) ListOrgVMSpec(ctx context.Context, req *pb.VMSpecAllQryRequest) (*pb.StringResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListOrgVMSpec()")

        // Call common-runtime API
        result, err := cmrt.ListOrgVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListOrgVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StringResponse{Result: result}

        return resp, nil</span>
}

// GetOrgVMSpec - 클라우드의 원래 VM Spec 조회
func (s *CCMService) GetOrgVMSpec(ctx context.Context, req *pb.VMSpecQryRequest) (*pb.StringResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetOrgVMSpec()")

        // Call common-runtime API
        result, err := cmrt.GetOrgVMSpec(req.ConnectionName, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetOrgVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StringResponse{Result: result}

        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file25" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"
        "strings"
        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateVPC - VPC 생성
func (s *CCMService) CreateVPC(ctx context.Context, req *pb.VPCCreateRequest) (*pb.VPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateVPC()")

        // check the input Name to include the SUBNET: Prefix
        if strings.HasPrefix(req.Item.Name, cm.SUBNET_PREFIX) </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr(cm.SUBNET_PREFIX+" cannot be used for VPC name prefix!!", "", "CCMService.CreateVPC()")
        }</span>
        // check the input Name to include the SecurityGroup Delimiter
        <span class="cov8" title="1">if strings.HasPrefix(req.Item.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr(cm.SG_DELIMITER+" cannot be used in VPC name!!", "", "CCMService.CreateVPC()")
        }</span>

        // Grpc RegInfo =&gt; Driver ReqInfo
        // (1) create SubnetInfo List
        <span class="cov8" title="1">subnetInfoList := []cres.SubnetInfo{}
        for _, info := range req.Item.SubnetInfoList </span><span class="cov8" title="1">{
                subnetInfo := cres.SubnetInfo{IId: cres.IID{NameId: info.Name, SystemId: ""}, IPv4_CIDR: info.Ipv4Cidr}
                subnetInfoList = append(subnetInfoList, subnetInfo)
        }</span>
        // (2) create VPCReqInfo with SubnetInfo List
        <span class="cov8" title="1">reqInfo := cres.VPCReqInfo{
                IId:            cres.IID{NameId: req.Item.Name, SystemId: ""},
                IPv4_CIDR:      req.Item.Ipv4Cidr,
                SubnetInfoList: subnetInfoList,
        }

        // Call common-runtime API
        result, err := cmrt.CreateVPC(req.ConnectionName, rsVPC, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateVPC()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.VPCInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VPCInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListVPC - VPC 목록
func (s *CCMService) ListVPC(ctx context.Context, req *pb.VPCAllQryRequest) (*pb.ListVPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVPC()")

        // Call common-runtime API
        result, err := cmrt.ListVPC(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVPC()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj []*pb.VPCInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVPCInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVPC - VPC 조회
func (s *CCMService) GetVPC(ctx context.Context, req *pb.VPCQryRequest) (*pb.VPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVPC()")

        // Call common-runtime API
        result, err := cmrt.GetVPC(req.ConnectionName, rsVPC, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVPC()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.VPCInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VPCInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteVPC - VPC 삭제
func (s *CCMService) DeleteVPC(ctx context.Context, req *pb.VPCQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteVPC()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, rsVPC, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ListAllVPC - 관리 VPC 목록
func (s *CCMService) ListAllVPC(ctx context.Context, req *pb.VPCAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllVPC()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVPC()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVPC()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// DeleteCSPVPC - CSP VPC 삭제
func (s *CCMService) DeleteCSPVPC(ctx context.Context, req *pb.CSPVPCQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteCSPVPC()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVPC, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteCSPVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// AddSubnet - Subnet 추가
func (s *CCMService) AddSubnet(ctx context.Context, req *pb.SubnetAddRequest) (*pb.VPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.AddSubnet()")

        // Grpc RegInfo =&gt; Driver ReqInfo
        reqSubnetInfo := cres.SubnetInfo{IId: cres.IID{req.Item.Name, ""}, IPv4_CIDR: req.Item.Ipv4Cidr}

        // Call common-runtime API
        result, err := cmrt.AddSubnet(req.ConnectionName, cm.SUBNET_PREFIX+req.VpcName, req.VpcName, reqSubnetInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.AddSubnet()")
        }</span>

        // CCM 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.VPCInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.AddSubnet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VPCInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// RemoveSubnet - Subnet 삭제
func (s *CCMService) RemoveSubnet(ctx context.Context, req *pb.SubnetQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.RemoveSubnet()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, cm.SUBNET_PREFIX+req.VpcName, req.SubnetName, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.RemoveSubnet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// RemoveCSPSubnet - CSP Subnet 삭제
func (s *CCMService) RemoveCSPSubnet(ctx context.Context, req *pb.CSPSubnetQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.RemoveCSPSubnet()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, cm.SUBNET_PREFIX+req.VpcName, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.RemoveCSPSubnet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cbspider.proto

package cbspider

import (
        context "context"
        fmt "fmt"
        _ "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/gogoproto"
        proto "github.com/golang/protobuf/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Empty 메시지 정의
type Empty struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         <span class="cov8" title="1">{ *m = Empty{} }</span>
func (m *Empty) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Empty) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Empty) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{0}
}</span>
func (m *Empty) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Empty) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Empty.Merge(m, src)
}</span>
func (m *Empty) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Empty) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Empty.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Empty proto.InternalMessageInfo

// KeyValue 메시지 정의
type KeyValue struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,json=Key,proto3" json:"Key" yaml:"Key"`
        Value                string   `protobuf:"bytes,2,opt,name=value,json=Value,proto3" json:"Value" yaml:"Value"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValue) Reset()         <span class="cov0" title="0">{ *m = KeyValue{} }</span>
func (m *KeyValue) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyValue) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyValue) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{1}
}</span>
func (m *KeyValue) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyValue) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyValue.Merge(m, src)
}</span>
func (m *KeyValue) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyValue) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyValue.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyValue) GetValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// IID 메시지 정의
type IID struct {
        NameId               string   `protobuf:"bytes,1,opt,name=name_id,json=NameId,proto3" json:"NameId" yaml:"NameId"`
        SystemId             string   `protobuf:"bytes,2,opt,name=system_id,json=SystemId,proto3" json:"SystemId" yaml:"SystemId"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *IID) Reset()         <span class="cov0" title="0">{ *m = IID{} }</span>
func (m *IID) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*IID) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*IID) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{2}
}</span>
func (m *IID) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *IID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_IID.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *IID) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_IID.Merge(m, src)
}</span>
func (m *IID) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *IID) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_IID.DiscardUnknown(m)
}</span>

var xxx_messageInfo_IID proto.InternalMessageInfo

func (m *IID) GetNameId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NameId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *IID) GetSystemId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SystemId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Boolean 응답 메시지 정의
type BooleanResponse struct {
        Result               bool     `protobuf:"varint,1,opt,name=result,json=Result,proto3" json:"Result" yaml:"Result"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BooleanResponse) Reset()         <span class="cov8" title="1">{ *m = BooleanResponse{} }</span>
func (m *BooleanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BooleanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BooleanResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{3}
}</span>
func (m *BooleanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *BooleanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_BooleanResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *BooleanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BooleanResponse.Merge(m, src)
}</span>
func (m *BooleanResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *BooleanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BooleanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BooleanResponse proto.InternalMessageInfo

func (m *BooleanResponse) GetResult() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Result
        }</span>
        <span class="cov0" title="0">return false</span>
}

// StringResponse 응답 메시지 정의
type StringResponse struct {
        Result               string   `protobuf:"bytes,1,opt,name=result,json=Result,proto3" json:"Result" yaml:"Result"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *StringResponse) Reset()         <span class="cov8" title="1">{ *m = StringResponse{} }</span>
func (m *StringResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*StringResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*StringResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{4}
}</span>
func (m *StringResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *StringResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_StringResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *StringResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_StringResponse.Merge(m, src)
}</span>
func (m *StringResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *StringResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_StringResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_StringResponse proto.InternalMessageInfo

func (m *StringResponse) GetResult() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Result
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MessageResponse 응답 메시지 정의
type MessageResponse struct {
        Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message" yaml:"message"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MessageResponse) Reset()         <span class="cov0" title="0">{ *m = MessageResponse{} }</span>
func (m *MessageResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MessageResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MessageResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{5}
}</span>
func (m *MessageResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MessageResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MessageResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MessageResponse.Merge(m, src)
}</span>
func (m *MessageResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MessageResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MessageResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MessageResponse proto.InternalMessageInfo

func (m *MessageResponse) GetMessage() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Status 응답 메시지 정의
type StatusResponse struct {
        Status               string   `protobuf:"bytes,1,opt,name=status,json=Status,proto3" json:"Status" yaml:"Status"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *StatusResponse) Reset()         <span class="cov8" title="1">{ *m = StatusResponse{} }</span>
func (m *StatusResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*StatusResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*StatusResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{6}
}</span>
func (m *StatusResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_StatusResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *StatusResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_StatusResponse.Merge(m, src)
}</span>
func (m *StatusResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *StatusResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func (m *StatusResponse) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListCloudOSInfoResponse struct {
        Items                []string `protobuf:"bytes,1,rep,name=items,json=cloudos,proto3" json:"cloudos" yaml:"cloudos"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListCloudOSInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListCloudOSInfoResponse{} }</span>
func (m *ListCloudOSInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListCloudOSInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListCloudOSInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{7}
}</span>
func (m *ListCloudOSInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListCloudOSInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListCloudOSInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListCloudOSInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudOSInfoResponse.Merge(m, src)
}</span>
func (m *ListCloudOSInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListCloudOSInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudOSInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListCloudOSInfoResponse proto.InternalMessageInfo

func (m *ListCloudOSInfoResponse) GetItems() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CloudDriverInfoRequest struct {
        Item                 *CloudDriverInfo `protobuf:"bytes,1,opt,name=item,json=driver,proto3" json:"driver" yaml:"driver"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *CloudDriverInfoRequest) Reset()         <span class="cov8" title="1">{ *m = CloudDriverInfoRequest{} }</span>
func (m *CloudDriverInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{8}
}</span>
func (m *CloudDriverInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoRequest.Merge(m, src)
}</span>
func (m *CloudDriverInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverInfoRequest proto.InternalMessageInfo

func (m *CloudDriverInfoRequest) GetItem() *CloudDriverInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CloudDriverInfoResponse struct {
        Item                 *CloudDriverInfo `protobuf:"bytes,1,opt,name=item,json=driver,proto3" json:"driver" yaml:"driver"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *CloudDriverInfoResponse) Reset()         <span class="cov8" title="1">{ *m = CloudDriverInfoResponse{} }</span>
func (m *CloudDriverInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{9}
}</span>
func (m *CloudDriverInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoResponse.Merge(m, src)
}</span>
func (m *CloudDriverInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverInfoResponse proto.InternalMessageInfo

func (m *CloudDriverInfoResponse) GetItem() *CloudDriverInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListCloudDriverInfoResponse struct {
        Items                []*CloudDriverInfo `protobuf:"bytes,1,rep,name=items,json=driver,proto3" json:"driver" yaml:"driver"`
        XXX_NoUnkeyedLiteral struct{}           `json:"-"`
        XXX_unrecognized     []byte             `json:"-"`
        XXX_sizecache        int32              `json:"-"`
}

func (m *ListCloudDriverInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListCloudDriverInfoResponse{} }</span>
func (m *ListCloudDriverInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListCloudDriverInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListCloudDriverInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{10}
}</span>
func (m *ListCloudDriverInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListCloudDriverInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListCloudDriverInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListCloudDriverInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudDriverInfoResponse.Merge(m, src)
}</span>
func (m *ListCloudDriverInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListCloudDriverInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudDriverInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListCloudDriverInfoResponse proto.InternalMessageInfo

func (m *ListCloudDriverInfoResponse) GetItems() []*CloudDriverInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CloudDriverInfo struct {
        DriverName           string   `protobuf:"bytes,1,opt,name=driver_name,json=DriverName,proto3" json:"DriverName" yaml:"DriverName"`
        ProviderName         string   `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        DriverLibFileName    string   `protobuf:"bytes,3,opt,name=driver_lib_file_name,json=DriverLibFileName,proto3" json:"DriverLibFileName" yaml:"DriverLibFileName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CloudDriverInfo) Reset()         <span class="cov0" title="0">{ *m = CloudDriverInfo{} }</span>
func (m *CloudDriverInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{11}
}</span>
func (m *CloudDriverInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfo.Merge(m, src)
}</span>
func (m *CloudDriverInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverInfo proto.InternalMessageInfo

func (m *CloudDriverInfo) GetDriverName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CloudDriverInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CloudDriverInfo) GetDriverLibFileName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverLibFileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CloudDriverQryRequest struct {
        DriverName           string   `protobuf:"bytes,1,opt,name=driver_name,json=DriverName,proto3" json:"DriverName" yaml:"DriverName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CloudDriverQryRequest) Reset()         <span class="cov8" title="1">{ *m = CloudDriverQryRequest{} }</span>
func (m *CloudDriverQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{12}
}</span>
func (m *CloudDriverQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverQryRequest.Merge(m, src)
}</span>
func (m *CloudDriverQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverQryRequest proto.InternalMessageInfo

func (m *CloudDriverQryRequest) GetDriverName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CredentialInfoRequest struct {
        Item                 *CredentialInfo `protobuf:"bytes,1,opt,name=item,json=credential,proto3" json:"credential" yaml:"credential"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *CredentialInfoRequest) Reset()         <span class="cov8" title="1">{ *m = CredentialInfoRequest{} }</span>
func (m *CredentialInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{13}
}</span>
func (m *CredentialInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoRequest.Merge(m, src)
}</span>
func (m *CredentialInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialInfoRequest proto.InternalMessageInfo

func (m *CredentialInfoRequest) GetItem() *CredentialInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CredentialInfoResponse struct {
        Item                 *CredentialInfo `protobuf:"bytes,1,opt,name=item,json=credential,proto3" json:"credential" yaml:"credential"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *CredentialInfoResponse) Reset()         <span class="cov8" title="1">{ *m = CredentialInfoResponse{} }</span>
func (m *CredentialInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{14}
}</span>
func (m *CredentialInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoResponse.Merge(m, src)
}</span>
func (m *CredentialInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialInfoResponse proto.InternalMessageInfo

func (m *CredentialInfoResponse) GetItem() *CredentialInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListCredentialInfoResponse struct {
        Items                []*CredentialInfo `protobuf:"bytes,1,rep,name=items,json=credential,proto3" json:"credential" yaml:"credential"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *ListCredentialInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListCredentialInfoResponse{} }</span>
func (m *ListCredentialInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListCredentialInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListCredentialInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{15}
}</span>
func (m *ListCredentialInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListCredentialInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListCredentialInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListCredentialInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListCredentialInfoResponse.Merge(m, src)
}</span>
func (m *ListCredentialInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListCredentialInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListCredentialInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListCredentialInfoResponse proto.InternalMessageInfo

func (m *ListCredentialInfoResponse) GetItems() []*CredentialInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CredentialInfo struct {
        CredentialName       string      `protobuf:"bytes,1,opt,name=credential_name,json=CredentialName,proto3" json:"CredentialName" yaml:"CredentialName"`
        ProviderName         string      `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        KeyValueInfoList     []*KeyValue `protobuf:"bytes,3,rep,name=key_value_info_list,json=KeyValueInfoList,proto3" json:"KeyValueInfoList" yaml:"KeyValueInfoList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *CredentialInfo) Reset()         <span class="cov0" title="0">{ *m = CredentialInfo{} }</span>
func (m *CredentialInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{16}
}</span>
func (m *CredentialInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfo.Merge(m, src)
}</span>
func (m *CredentialInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialInfo proto.InternalMessageInfo

func (m *CredentialInfo) GetCredentialName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CredentialName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CredentialInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CredentialInfo) GetKeyValueInfoList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CredentialQryRequest struct {
        CredentialName       string   `protobuf:"bytes,1,opt,name=credential_name,json=CredentialName,proto3" json:"CredentialName" yaml:"CredentialName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CredentialQryRequest) Reset()         <span class="cov8" title="1">{ *m = CredentialQryRequest{} }</span>
func (m *CredentialQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{17}
}</span>
func (m *CredentialQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialQryRequest.Merge(m, src)
}</span>
func (m *CredentialQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialQryRequest proto.InternalMessageInfo

func (m *CredentialQryRequest) GetCredentialName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CredentialName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegionInfoRequest struct {
        Item                 *RegionInfo `protobuf:"bytes,1,opt,name=item,json=region,proto3" json:"region" yaml:"region"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *RegionInfoRequest) Reset()         <span class="cov8" title="1">{ *m = RegionInfoRequest{} }</span>
func (m *RegionInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{18}
}</span>
func (m *RegionInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoRequest.Merge(m, src)
}</span>
func (m *RegionInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionInfoRequest proto.InternalMessageInfo

func (m *RegionInfoRequest) GetItem() *RegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RegionInfoResponse struct {
        Item                 *RegionInfo `protobuf:"bytes,1,opt,name=item,json=region,proto3" json:"region" yaml:"region"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *RegionInfoResponse) Reset()         <span class="cov8" title="1">{ *m = RegionInfoResponse{} }</span>
func (m *RegionInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{19}
}</span>
func (m *RegionInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoResponse.Merge(m, src)
}</span>
func (m *RegionInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionInfoResponse proto.InternalMessageInfo

func (m *RegionInfoResponse) GetItem() *RegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListRegionInfoResponse struct {
        Items                []*RegionInfo `protobuf:"bytes,1,rep,name=items,json=region,proto3" json:"region" yaml:"region"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *ListRegionInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListRegionInfoResponse{} }</span>
func (m *ListRegionInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListRegionInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListRegionInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{20}
}</span>
func (m *ListRegionInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListRegionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListRegionInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListRegionInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListRegionInfoResponse.Merge(m, src)
}</span>
func (m *ListRegionInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListRegionInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListRegionInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListRegionInfoResponse proto.InternalMessageInfo

func (m *ListRegionInfoResponse) GetItems() []*RegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RegionInfo struct {
        RegionName           string      `protobuf:"bytes,1,opt,name=region_name,json=RegionName,proto3" json:"RegionName" yaml:"RegionName"`
        ProviderName         string      `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        KeyValueInfoList     []*KeyValue `protobuf:"bytes,3,rep,name=key_value_info_list,json=KeyValueInfoList,proto3" json:"KeyValueInfoList" yaml:"KeyValueInfoList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *RegionInfo) Reset()         <span class="cov0" title="0">{ *m = RegionInfo{} }</span>
func (m *RegionInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{21}
}</span>
func (m *RegionInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfo.Merge(m, src)
}</span>
func (m *RegionInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionInfo proto.InternalMessageInfo

func (m *RegionInfo) GetRegionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RegionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RegionInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RegionInfo) GetKeyValueInfoList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RegionQryRequest struct {
        RegionName           string   `protobuf:"bytes,1,opt,name=region_name,json=RegionName,proto3" json:"RegionName" yaml:"RegionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *RegionQryRequest) Reset()         <span class="cov8" title="1">{ *m = RegionQryRequest{} }</span>
func (m *RegionQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{22}
}</span>
func (m *RegionQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionQryRequest.Merge(m, src)
}</span>
func (m *RegionQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionQryRequest proto.InternalMessageInfo

func (m *RegionQryRequest) GetRegionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RegionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ConnectionConfigInfoRequest struct {
        Item                 *ConnectionConfigInfo `protobuf:"bytes,1,opt,name=item,json=connectionconfig,proto3" json:"connectionconfig" yaml:"connectionconfig"`
        XXX_NoUnkeyedLiteral struct{}              `json:"-"`
        XXX_unrecognized     []byte                `json:"-"`
        XXX_sizecache        int32                 `json:"-"`
}

func (m *ConnectionConfigInfoRequest) Reset()         <span class="cov8" title="1">{ *m = ConnectionConfigInfoRequest{} }</span>
func (m *ConnectionConfigInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{23}
}</span>
func (m *ConnectionConfigInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoRequest.Merge(m, src)
}</span>
func (m *ConnectionConfigInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigInfoRequest proto.InternalMessageInfo

func (m *ConnectionConfigInfoRequest) GetItem() *ConnectionConfigInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConnectionConfigInfoResponse struct {
        Item                 *ConnectionConfigInfo `protobuf:"bytes,1,opt,name=item,json=connectionconfig,proto3" json:"connectionconfig" yaml:"connectionconfig"`
        XXX_NoUnkeyedLiteral struct{}              `json:"-"`
        XXX_unrecognized     []byte                `json:"-"`
        XXX_sizecache        int32                 `json:"-"`
}

func (m *ConnectionConfigInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ConnectionConfigInfoResponse{} }</span>
func (m *ConnectionConfigInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{24}
}</span>
func (m *ConnectionConfigInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoResponse.Merge(m, src)
}</span>
func (m *ConnectionConfigInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigInfoResponse proto.InternalMessageInfo

func (m *ConnectionConfigInfoResponse) GetItem() *ConnectionConfigInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListConnectionConfigInfoResponse struct {
        Items                []*ConnectionConfigInfo `protobuf:"bytes,1,rep,name=items,json=connectionconfig,proto3" json:"connectionconfig" yaml:"connectionconfig"`
        XXX_NoUnkeyedLiteral struct{}                `json:"-"`
        XXX_unrecognized     []byte                  `json:"-"`
        XXX_sizecache        int32                   `json:"-"`
}

func (m *ListConnectionConfigInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListConnectionConfigInfoResponse{} }</span>
func (m *ListConnectionConfigInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListConnectionConfigInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListConnectionConfigInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{25}
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListConnectionConfigInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListConnectionConfigInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListConnectionConfigInfoResponse.Merge(m, src)
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListConnectionConfigInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListConnectionConfigInfoResponse proto.InternalMessageInfo

func (m *ListConnectionConfigInfoResponse) GetItems() []*ConnectionConfigInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConnectionConfigInfo struct {
        ConfigName           string   `protobuf:"bytes,1,opt,name=config_name,json=ConfigName,proto3" json:"ConfigName" yaml:"ConfigName"`
        ProviderName         string   `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        DriverName           string   `protobuf:"bytes,3,opt,name=driver_name,json=DriverName,proto3" json:"DriverName" yaml:"DriverName"`
        CredentialName       string   `protobuf:"bytes,4,opt,name=credential_name,json=CredentialName,proto3" json:"CredentialName" yaml:"CredentialName"`
        RegionName           string   `protobuf:"bytes,5,opt,name=region_name,json=RegionName,proto3" json:"RegionName" yaml:"RegionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionConfigInfo) Reset()         <span class="cov0" title="0">{ *m = ConnectionConfigInfo{} }</span>
func (m *ConnectionConfigInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{26}
}</span>
func (m *ConnectionConfigInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfo.Merge(m, src)
}</span>
func (m *ConnectionConfigInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigInfo proto.InternalMessageInfo

func (m *ConnectionConfigInfo) GetConfigName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConfigName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetDriverName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetCredentialName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CredentialName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetRegionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RegionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ConnectionConfigQryRequest struct {
        ConfigName           string   `protobuf:"bytes,1,opt,name=config_name,json=ConfigName,proto3" json:"ConfigName" yaml:"ConfigName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionConfigQryRequest) Reset()         <span class="cov8" title="1">{ *m = ConnectionConfigQryRequest{} }</span>
func (m *ConnectionConfigQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{27}
}</span>
func (m *ConnectionConfigQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigQryRequest.Merge(m, src)
}</span>
func (m *ConnectionConfigQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigQryRequest proto.InternalMessageInfo

func (m *ConnectionConfigQryRequest) GetConfigName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConfigName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AllResourceInfoResponse struct {
        Item                 *AllResourceInfo `protobuf:"bytes,1,opt,name=item,json=AllList,proto3" json:"AllList" yaml:"AllList"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *AllResourceInfoResponse) Reset()         <span class="cov8" title="1">{ *m = AllResourceInfoResponse{} }</span>
func (m *AllResourceInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AllResourceInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AllResourceInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{28}
}</span>
func (m *AllResourceInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AllResourceInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AllResourceInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AllResourceInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfoResponse.Merge(m, src)
}</span>
func (m *AllResourceInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AllResourceInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AllResourceInfoResponse proto.InternalMessageInfo

func (m *AllResourceInfoResponse) GetItem() *AllResourceInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AllResourceInfo struct {
        MappedList           []*IID   `protobuf:"bytes,1,rep,name=mapped_list,json=MappedList,proto3" json:"MappedList" yaml:"MappedList"`
        OnlySpiderList       []*IID   `protobuf:"bytes,2,rep,name=only_spider_list,json=OnlySpiderList,proto3" json:"OnlySpiderList" yaml:"OnlySpiderList"`
        OnlyCspList          []*IID   `protobuf:"bytes,3,rep,name=only_csp_list,json=OnlyCSPList,proto3" json:"OnlyCSPList" yaml:"OnlyCSPList"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AllResourceInfo) Reset()         <span class="cov0" title="0">{ *m = AllResourceInfo{} }</span>
func (m *AllResourceInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AllResourceInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AllResourceInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{29}
}</span>
func (m *AllResourceInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AllResourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AllResourceInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AllResourceInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfo.Merge(m, src)
}</span>
func (m *AllResourceInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AllResourceInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AllResourceInfo proto.InternalMessageInfo

func (m *AllResourceInfo) GetMappedList() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MappedList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *AllResourceInfo) GetOnlySpiderList() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.OnlySpiderList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *AllResourceInfo) GetOnlyCspList() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.OnlyCspList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageInfoResponse struct {
        Item                 *ImageInfo `protobuf:"bytes,1,opt,name=item,json=image,proto3" json:"image" yaml:"image"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *ImageInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ImageInfoResponse{} }</span>
func (m *ImageInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{30}
}</span>
func (m *ImageInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfoResponse.Merge(m, src)
}</span>
func (m *ImageInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageInfoResponse proto.InternalMessageInfo

func (m *ImageInfoResponse) GetItem() *ImageInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListImageInfoResponse struct {
        Items                []*ImageInfo `protobuf:"bytes,1,rep,name=items,json=image,proto3" json:"image" yaml:"image"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *ListImageInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListImageInfoResponse{} }</span>
func (m *ListImageInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListImageInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListImageInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{31}
}</span>
func (m *ListImageInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListImageInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListImageInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListImageInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListImageInfoResponse.Merge(m, src)
}</span>
func (m *ListImageInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListImageInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListImageInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListImageInfoResponse proto.InternalMessageInfo

func (m *ListImageInfoResponse) GetItems() []*ImageInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageInfo struct {
        Iid                  *IID        `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        GuestOs              string      `protobuf:"bytes,2,opt,name=guest_os,json=GuestOS,proto3" json:"GuestOS" yaml:"GuestOS"`
        Status               string      `protobuf:"bytes,3,opt,name=status,json=Status,proto3" json:"Status" yaml:"Status"`
        KeyValueList         []*KeyValue `protobuf:"bytes,4,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *ImageInfo) Reset()         <span class="cov0" title="0">{ *m = ImageInfo{} }</span>
func (m *ImageInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{32}
}</span>
func (m *ImageInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfo.Merge(m, src)
}</span>
func (m *ImageInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageInfo proto.InternalMessageInfo

func (m *ImageInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ImageInfo) GetGuestOs() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.GuestOs
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageInfo) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageCreateRequest struct {
        ConnectionName       string           `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *ImageCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *ImageCreateRequest) Reset()         <span class="cov8" title="1">{ *m = ImageCreateRequest{} }</span>
func (m *ImageCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{33}
}</span>
func (m *ImageCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateRequest.Merge(m, src)
}</span>
func (m *ImageCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageCreateRequest proto.InternalMessageInfo

func (m *ImageCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageCreateRequest) GetItem() *ImageCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ImageCreateInfo) Reset()         <span class="cov0" title="0">{ *m = ImageCreateInfo{} }</span>
func (m *ImageCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{34}
}</span>
func (m *ImageCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateInfo.Merge(m, src)
}</span>
func (m *ImageCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageCreateInfo proto.InternalMessageInfo

func (m *ImageCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ImageAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ImageAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = ImageAllQryRequest{} }</span>
func (m *ImageAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{35}
}</span>
func (m *ImageAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageAllQryRequest.Merge(m, src)
}</span>
func (m *ImageAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageAllQryRequest proto.InternalMessageInfo

func (m *ImageAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ImageQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ImageQryRequest) Reset()         <span class="cov8" title="1">{ *m = ImageQryRequest{} }</span>
func (m *ImageQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{36}
}</span>
func (m *ImageQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageQryRequest.Merge(m, src)
}</span>
func (m *ImageQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageQryRequest proto.InternalMessageInfo

func (m *ImageQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMSpecInfoResponse struct {
        Item                 *VMSpecInfo `protobuf:"bytes,1,opt,name=item,json=vmspec,proto3" json:"vmspec" yaml:"vmspec"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *VMSpecInfoResponse) Reset()         <span class="cov8" title="1">{ *m = VMSpecInfoResponse{} }</span>
func (m *VMSpecInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{37}
}</span>
func (m *VMSpecInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfoResponse.Merge(m, src)
}</span>
func (m *VMSpecInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecInfoResponse proto.InternalMessageInfo

func (m *VMSpecInfoResponse) GetItem() *VMSpecInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListVMSpecInfoResponse struct {
        Items                []*VMSpecInfo `protobuf:"bytes,1,rep,name=items,json=vmspec,proto3" json:"vmspec" yaml:"vmspec"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *ListVMSpecInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVMSpecInfoResponse{} }</span>
func (m *ListVMSpecInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVMSpecInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVMSpecInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{38}
}</span>
func (m *ListVMSpecInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVMSpecInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVMSpecInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVMSpecInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVMSpecInfoResponse.Merge(m, src)
}</span>
func (m *ListVMSpecInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVMSpecInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVMSpecInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVMSpecInfoResponse proto.InternalMessageInfo

func (m *ListVMSpecInfoResponse) GetItems() []*VMSpecInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMSpecInfo struct {
        Region               string      `protobuf:"bytes,1,opt,name=region,json=Region,proto3" json:"Region" yaml:"Region"`
        Name                 string      `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        VCpu                 *VCpuInfo   `protobuf:"bytes,3,opt,name=v_cpu,json=VCpu,proto3" json:"VCpu" yaml:"VCpu"`
        Mem                  string      `protobuf:"bytes,4,opt,name=mem,json=Mem,proto3" json:"Mem" yaml:"Mem"`
        Gpu                  []*GpuInfo  `protobuf:"bytes,5,rep,name=gpu,json=Gpu,proto3" json:"Gpu" yaml:"Gpu"`
        KeyValueList         []*KeyValue `protobuf:"bytes,6,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *VMSpecInfo) Reset()         <span class="cov0" title="0">{ *m = VMSpecInfo{} }</span>
func (m *VMSpecInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{39}
}</span>
func (m *VMSpecInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfo.Merge(m, src)
}</span>
func (m *VMSpecInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecInfo proto.InternalMessageInfo

func (m *VMSpecInfo) GetRegion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecInfo) GetVCpu() *VCpuInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VCpu
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMSpecInfo) GetMem() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Mem
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecInfo) GetGpu() []*GpuInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Gpu
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMSpecInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VCpuInfo struct {
        Count                string   `protobuf:"bytes,1,opt,name=count,json=Count,proto3" json:"Count" yaml:"Count"`
        Clock                string   `protobuf:"bytes,2,opt,name=clock,json=Clock,proto3" json:"Clock" yaml:"Clock"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VCpuInfo) Reset()         <span class="cov0" title="0">{ *m = VCpuInfo{} }</span>
func (m *VCpuInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VCpuInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VCpuInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{40}
}</span>
func (m *VCpuInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VCpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VCpuInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VCpuInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VCpuInfo.Merge(m, src)
}</span>
func (m *VCpuInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VCpuInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VCpuInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VCpuInfo proto.InternalMessageInfo

func (m *VCpuInfo) GetCount() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Count
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VCpuInfo) GetClock() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Clock
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GpuInfo struct {
        Count                string   `protobuf:"bytes,1,opt,name=count,json=Count,proto3" json:"Count" yaml:"Count"`
        Mfr                  string   `protobuf:"bytes,2,opt,name=mfr,json=Mfr,proto3" json:"Mfr" yaml:"Mfr"`
        Model                string   `protobuf:"bytes,3,opt,name=model,json=Model,proto3" json:"Model" yaml:"Model"`
        Mem                  string   `protobuf:"bytes,4,opt,name=mem,json=Mem,proto3" json:"Mem" yaml:"Mem"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GpuInfo) Reset()         <span class="cov0" title="0">{ *m = GpuInfo{} }</span>
func (m *GpuInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GpuInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GpuInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{41}
}</span>
func (m *GpuInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GpuInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GpuInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GpuInfo.Merge(m, src)
}</span>
func (m *GpuInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GpuInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GpuInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GpuInfo proto.InternalMessageInfo

func (m *GpuInfo) GetCount() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Count
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GpuInfo) GetMfr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Mfr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GpuInfo) GetModel() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Model
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GpuInfo) GetMem() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Mem
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMSpecAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMSpecAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMSpecAllQryRequest{} }</span>
func (m *VMSpecAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{42}
}</span>
func (m *VMSpecAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecAllQryRequest.Merge(m, src)
}</span>
func (m *VMSpecAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecAllQryRequest proto.InternalMessageInfo

func (m *VMSpecAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMSpecQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMSpecQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMSpecQryRequest{} }</span>
func (m *VMSpecQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{43}
}</span>
func (m *VMSpecQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecQryRequest.Merge(m, src)
}</span>
func (m *VMSpecQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecQryRequest proto.InternalMessageInfo

func (m *VMSpecQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VPCInfoResponse struct {
        Item                 *VPCInfo `protobuf:"bytes,1,opt,name=item,json=vpc,proto3" json:"vpc" yaml:"vpc"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VPCInfoResponse) Reset()         <span class="cov8" title="1">{ *m = VPCInfoResponse{} }</span>
func (m *VPCInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{44}
}</span>
func (m *VPCInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfoResponse.Merge(m, src)
}</span>
func (m *VPCInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCInfoResponse proto.InternalMessageInfo

func (m *VPCInfoResponse) GetItem() *VPCInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListVPCInfoResponse struct {
        Items                []*VPCInfo `protobuf:"bytes,1,rep,name=items,json=vpc,proto3" json:"vpc" yaml:"vpc"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *ListVPCInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVPCInfoResponse{} }</span>
func (m *ListVPCInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVPCInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVPCInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{45}
}</span>
func (m *ListVPCInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVPCInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVPCInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVPCInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVPCInfoResponse.Merge(m, src)
}</span>
func (m *ListVPCInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVPCInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVPCInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVPCInfoResponse proto.InternalMessageInfo

func (m *ListVPCInfoResponse) GetItems() []*VPCInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VPCInfo struct {
        Iid                  *IID          `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        Ipv4Cidr             string        `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        SubnetInfoList       []*SubnetInfo `protobuf:"bytes,3,rep,name=subnet_info_list,json=SubnetInfoList,proto3" json:"SubnetInfoList" yaml:"SubnetInfoList"`
        KeyValueList         []*KeyValue   `protobuf:"bytes,4,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *VPCInfo) Reset()         <span class="cov0" title="0">{ *m = VPCInfo{} }</span>
func (m *VPCInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{46}
}</span>
func (m *VPCInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfo.Merge(m, src)
}</span>
func (m *VPCInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCInfo proto.InternalMessageInfo

func (m *VPCInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VPCInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCInfo) GetSubnetInfoList() []*SubnetInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VPCInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SubnetInfo struct {
        Iid                  *IID        `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        Ipv4Cidr             string      `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        KeyValueList         []*KeyValue `protobuf:"bytes,3,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *SubnetInfo) Reset()         <span class="cov0" title="0">{ *m = SubnetInfo{} }</span>
func (m *SubnetInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{47}
}</span>
func (m *SubnetInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetInfo.Merge(m, src)
}</span>
func (m *SubnetInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetInfo proto.InternalMessageInfo

func (m *SubnetInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SubnetInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VPCCreateRequest struct {
        ConnectionName       string         `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *VPCCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}       `json:"-"`
        XXX_unrecognized     []byte         `json:"-"`
        XXX_sizecache        int32          `json:"-"`
}

func (m *VPCCreateRequest) Reset()         <span class="cov8" title="1">{ *m = VPCCreateRequest{} }</span>
func (m *VPCCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{48}
}</span>
func (m *VPCCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateRequest.Merge(m, src)
}</span>
func (m *VPCCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCCreateRequest proto.InternalMessageInfo

func (m *VPCCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCCreateRequest) GetItem() *VPCCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VPCCreateInfo struct {
        Name                 string              `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Ipv4Cidr             string              `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        SubnetInfoList       []*SubnetCreateInfo `protobuf:"bytes,3,rep,name=subnet_info_list,json=SubnetInfoList,proto3" json:"SubnetInfoList" yaml:"SubnetInfoList"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *VPCCreateInfo) Reset()         <span class="cov0" title="0">{ *m = VPCCreateInfo{} }</span>
func (m *VPCCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{49}
}</span>
func (m *VPCCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateInfo.Merge(m, src)
}</span>
func (m *VPCCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCCreateInfo proto.InternalMessageInfo

func (m *VPCCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCCreateInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCCreateInfo) GetSubnetInfoList() []*SubnetCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SubnetCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Ipv4Cidr             string   `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetCreateInfo) Reset()         <span class="cov0" title="0">{ *m = SubnetCreateInfo{} }</span>
func (m *SubnetCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{50}
}</span>
func (m *SubnetCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetCreateInfo.Merge(m, src)
}</span>
func (m *SubnetCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetCreateInfo proto.InternalMessageInfo

func (m *SubnetCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetCreateInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VPCAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VPCAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = VPCAllQryRequest{} }</span>
func (m *VPCAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{51}
}</span>
func (m *VPCAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCAllQryRequest.Merge(m, src)
}</span>
func (m *VPCAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCAllQryRequest proto.InternalMessageInfo

func (m *VPCAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VPCQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VPCQryRequest) Reset()         <span class="cov8" title="1">{ *m = VPCQryRequest{} }</span>
func (m *VPCQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{52}
}</span>
func (m *VPCQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCQryRequest.Merge(m, src)
}</span>
func (m *VPCQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCQryRequest proto.InternalMessageInfo

func (m *VPCQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPVPCQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPVPCQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPVPCQryRequest{} }</span>
func (m *CSPVPCQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPVPCQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPVPCQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{53}
}</span>
func (m *CSPVPCQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPVPCQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPVPCQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPVPCQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPVPCQryRequest.Merge(m, src)
}</span>
func (m *CSPVPCQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPVPCQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPVPCQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPVPCQryRequest proto.InternalMessageInfo

func (m *CSPVPCQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPVPCQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SubnetAddRequest struct {
        ConnectionName       string            `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        VpcName              string            `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        Item                 *SubnetCreateInfo `protobuf:"bytes,3,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *SubnetAddRequest) Reset()         <span class="cov8" title="1">{ *m = SubnetAddRequest{} }</span>
func (m *SubnetAddRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetAddRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetAddRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{54}
}</span>
func (m *SubnetAddRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetAddRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetAddRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetAddRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetAddRequest.Merge(m, src)
}</span>
func (m *SubnetAddRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetAddRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetAddRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetAddRequest proto.InternalMessageInfo

func (m *SubnetAddRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetAddRequest) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetAddRequest) GetItem() *SubnetCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SubnetQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        VpcName              string   `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        SubnetName           string   `protobuf:"bytes,3,opt,name=subnet_name,json=SubnetName,proto3" json:"SubnetName" yaml:"SubnetName"`
        Force                string   `protobuf:"bytes,4,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetQryRequest) Reset()         <span class="cov8" title="1">{ *m = SubnetQryRequest{} }</span>
func (m *SubnetQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{55}
}</span>
func (m *SubnetQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetQryRequest.Merge(m, src)
}</span>
func (m *SubnetQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetQryRequest proto.InternalMessageInfo

func (m *SubnetQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetQryRequest) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetQryRequest) GetSubnetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPSubnetQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        VpcName              string   `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        Id                   string   `protobuf:"bytes,3,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPSubnetQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPSubnetQryRequest{} }</span>
func (m *CSPSubnetQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPSubnetQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPSubnetQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{56}
}</span>
func (m *CSPSubnetQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPSubnetQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPSubnetQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPSubnetQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPSubnetQryRequest.Merge(m, src)
}</span>
func (m *CSPSubnetQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPSubnetQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPSubnetQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPSubnetQryRequest proto.InternalMessageInfo

func (m *CSPSubnetQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPSubnetQryRequest) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPSubnetQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SecurityInfoResponse struct {
        Item                 *SecurityInfo `protobuf:"bytes,1,opt,name=item,json=securitygroup,proto3" json:"securitygroup" yaml:"securitygroup"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *SecurityInfoResponse) Reset()         <span class="cov8" title="1">{ *m = SecurityInfoResponse{} }</span>
func (m *SecurityInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{57}
}</span>
func (m *SecurityInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfoResponse.Merge(m, src)
}</span>
func (m *SecurityInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityInfoResponse proto.InternalMessageInfo

func (m *SecurityInfoResponse) GetItem() *SecurityInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListSecurityInfoResponse struct {
        Items                []*SecurityInfo `protobuf:"bytes,1,rep,name=items,json=securitygroup,proto3" json:"securitygroup" yaml:"securitygroup"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *ListSecurityInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListSecurityInfoResponse{} }</span>
func (m *ListSecurityInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListSecurityInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListSecurityInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{58}
}</span>
func (m *ListSecurityInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListSecurityInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListSecurityInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListSecurityInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListSecurityInfoResponse.Merge(m, src)
}</span>
func (m *ListSecurityInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListSecurityInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListSecurityInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListSecurityInfoResponse proto.InternalMessageInfo

func (m *ListSecurityInfoResponse) GetItems() []*SecurityInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityInfo struct {
        Iid                  *IID                `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        VpcIid               *IID                `protobuf:"bytes,2,opt,name=vpc_iid,json=VpcIID,proto3" json:"VpcIID" yaml:"VpcIID"`
        Direction            string              `protobuf:"bytes,3,opt,name=direction,json=Direction,proto3" json:"Direction" yaml:"Direction"`
        SecurityRules        []*SecurityRuleInfo `protobuf:"bytes,4,rep,name=security_rules,json=SecurityRules,proto3" json:"SecurityRules" yaml:"SecurityRules"`
        KeyValueList         []*KeyValue         `protobuf:"bytes,5,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityInfo) Reset()         <span class="cov0" title="0">{ *m = SecurityInfo{} }</span>
func (m *SecurityInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{59}
}</span>
func (m *SecurityInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfo.Merge(m, src)
}</span>
func (m *SecurityInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityInfo proto.InternalMessageInfo

func (m *SecurityInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SecurityInfo) GetVpcIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SecurityInfo) GetDirection() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Direction
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityInfo) GetSecurityRules() []*SecurityRuleInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityRules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SecurityInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityRuleInfo struct {
        FromPort             string   `protobuf:"bytes,1,opt,name=from_port,json=FromPort,proto3" json:"FromPort" yaml:"FromPort"`
        ToPort               string   `protobuf:"bytes,2,opt,name=to_port,json=ToPort,proto3" json:"ToPort" yaml:"ToPort"`
        IpProtocol           string   `protobuf:"bytes,3,opt,name=ip_protocol,json=IPProtocol,proto3" json:"IPProtocol" yaml:"IPProtocol"`
        Direction            string   `protobuf:"bytes,4,opt,name=direction,json=Direction,proto3" json:"Direction" yaml:"Direction"`
        Cidr                 string   `protobuf:"bytes,5,opt,name=cidr,json=CIDR,proto3" json:"CIDR" yaml:"CIDR"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityRuleInfo) Reset()         <span class="cov0" title="0">{ *m = SecurityRuleInfo{} }</span>
func (m *SecurityRuleInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityRuleInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityRuleInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{60}
}</span>
func (m *SecurityRuleInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityRuleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityRuleInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityRuleInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityRuleInfo.Merge(m, src)
}</span>
func (m *SecurityRuleInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityRuleInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityRuleInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityRuleInfo proto.InternalMessageInfo

func (m *SecurityRuleInfo) GetFromPort() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FromPort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetToPort() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ToPort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetIpProtocol() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IpProtocol
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetDirection() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Direction
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetCidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SecurityCreateRequest struct {
        ConnectionName       string              `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *SecurityCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityCreateRequest) Reset()         <span class="cov8" title="1">{ *m = SecurityCreateRequest{} }</span>
func (m *SecurityCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{61}
}</span>
func (m *SecurityCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateRequest.Merge(m, src)
}</span>
func (m *SecurityCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityCreateRequest proto.InternalMessageInfo

func (m *SecurityCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateRequest) GetItem() *SecurityCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityCreateInfo struct {
        Name                 string              `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        VpcName              string              `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        Direction            string              `protobuf:"bytes,3,opt,name=direction,json=Direction,proto3" json:"Direction" yaml:"Direction"`
        SecurityRules        []*SecurityRuleInfo `protobuf:"bytes,4,rep,name=security_rules,json=SecurityRules,proto3" json:"SecurityRules" yaml:"SecurityRules"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityCreateInfo) Reset()         <span class="cov0" title="0">{ *m = SecurityCreateInfo{} }</span>
func (m *SecurityCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{62}
}</span>
func (m *SecurityCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateInfo.Merge(m, src)
}</span>
func (m *SecurityCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityCreateInfo proto.InternalMessageInfo

func (m *SecurityCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateInfo) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateInfo) GetDirection() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Direction
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateInfo) GetSecurityRules() []*SecurityRuleInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityRules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = SecurityAllQryRequest{} }</span>
func (m *SecurityAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{63}
}</span>
func (m *SecurityAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityAllQryRequest.Merge(m, src)
}</span>
func (m *SecurityAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityAllQryRequest proto.InternalMessageInfo

func (m *SecurityAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SecurityQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityQryRequest) Reset()         <span class="cov8" title="1">{ *m = SecurityQryRequest{} }</span>
func (m *SecurityQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{64}
}</span>
func (m *SecurityQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityQryRequest.Merge(m, src)
}</span>
func (m *SecurityQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityQryRequest proto.InternalMessageInfo

func (m *SecurityQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPSecurityQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPSecurityQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPSecurityQryRequest{} }</span>
func (m *CSPSecurityQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPSecurityQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPSecurityQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{65}
}</span>
func (m *CSPSecurityQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPSecurityQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPSecurityQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPSecurityQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPSecurityQryRequest.Merge(m, src)
}</span>
func (m *CSPSecurityQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPSecurityQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPSecurityQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPSecurityQryRequest proto.InternalMessageInfo

func (m *CSPSecurityQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPSecurityQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KeyPairInfoResponse struct {
        Item                 *KeyPairInfo `protobuf:"bytes,1,opt,name=item,json=keypair,proto3" json:"keypair" yaml:"keypair"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *KeyPairInfoResponse) Reset()         <span class="cov8" title="1">{ *m = KeyPairInfoResponse{} }</span>
func (m *KeyPairInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{66}
}</span>
func (m *KeyPairInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfoResponse.Merge(m, src)
}</span>
func (m *KeyPairInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairInfoResponse proto.InternalMessageInfo

func (m *KeyPairInfoResponse) GetItem() *KeyPairInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListKeyPairInfoResponse struct {
        Items                []*KeyPairInfo `protobuf:"bytes,1,rep,name=items,json=keypair,proto3" json:"keypair" yaml:"keypair"`
        XXX_NoUnkeyedLiteral struct{}       `json:"-"`
        XXX_unrecognized     []byte         `json:"-"`
        XXX_sizecache        int32          `json:"-"`
}

func (m *ListKeyPairInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListKeyPairInfoResponse{} }</span>
func (m *ListKeyPairInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListKeyPairInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListKeyPairInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{67}
}</span>
func (m *ListKeyPairInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListKeyPairInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListKeyPairInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListKeyPairInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListKeyPairInfoResponse.Merge(m, src)
}</span>
func (m *ListKeyPairInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListKeyPairInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListKeyPairInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListKeyPairInfoResponse proto.InternalMessageInfo

func (m *ListKeyPairInfoResponse) GetItems() []*KeyPairInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type KeyPairInfo struct {
        Iid                  *IID        `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        Fingerprint          string      `protobuf:"bytes,2,opt,name=fingerprint,json=Fingerprint,proto3" json:"Fingerprint" yaml:"Fingerprint"`
        PublicKey            string      `protobuf:"bytes,3,opt,name=public_key,json=PublicKey,proto3" json:"PublicKey" yaml:"PublicKey"`
        PrivateKey           string      `protobuf:"bytes,4,opt,name=private_key,json=PrivateKey,proto3" json:"PrivateKey" yaml:"PrivateKey"`
        VmUserId             string      `protobuf:"bytes,5,opt,name=vm_user_id,json=VMUserID,proto3" json:"VMUserID" yaml:"VMUserID"`
        KeyValueList         []*KeyValue `protobuf:"bytes,6,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *KeyPairInfo) Reset()         <span class="cov0" title="0">{ *m = KeyPairInfo{} }</span>
func (m *KeyPairInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{68}
}</span>
func (m *KeyPairInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfo.Merge(m, src)
}</span>
func (m *KeyPairInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairInfo proto.InternalMessageInfo

func (m *KeyPairInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *KeyPairInfo) GetFingerprint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Fingerprint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetPublicKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetPrivateKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetVmUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type KeyPairCreateRequest struct {
        ConnectionName       string             `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *KeyPairCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}           `json:"-"`
        XXX_unrecognized     []byte             `json:"-"`
        XXX_sizecache        int32              `json:"-"`
}

func (m *KeyPairCreateRequest) Reset()         <span class="cov8" title="1">{ *m = KeyPairCreateRequest{} }</span>
func (m *KeyPairCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{69}
}</span>
func (m *KeyPairCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateRequest.Merge(m, src)
}</span>
func (m *KeyPairCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairCreateRequest proto.InternalMessageInfo

func (m *KeyPairCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairCreateRequest) GetItem() *KeyPairCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type KeyPairCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyPairCreateInfo) Reset()         <span class="cov0" title="0">{ *m = KeyPairCreateInfo{} }</span>
func (m *KeyPairCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{70}
}</span>
func (m *KeyPairCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateInfo.Merge(m, src)
}</span>
func (m *KeyPairCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairCreateInfo proto.InternalMessageInfo

func (m *KeyPairCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KeyPairAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyPairAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = KeyPairAllQryRequest{} }</span>
func (m *KeyPairAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{71}
}</span>
func (m *KeyPairAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairAllQryRequest.Merge(m, src)
}</span>
func (m *KeyPairAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairAllQryRequest proto.InternalMessageInfo

func (m *KeyPairAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KeyPairQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyPairQryRequest) Reset()         <span class="cov8" title="1">{ *m = KeyPairQryRequest{} }</span>
func (m *KeyPairQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{72}
}</span>
func (m *KeyPairQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairQryRequest.Merge(m, src)
}</span>
func (m *KeyPairQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairQryRequest proto.InternalMessageInfo

func (m *KeyPairQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPKeyPairQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPKeyPairQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPKeyPairQryRequest{} }</span>
func (m *CSPKeyPairQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPKeyPairQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPKeyPairQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{73}
}</span>
func (m *CSPKeyPairQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPKeyPairQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPKeyPairQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPKeyPairQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPKeyPairQryRequest.Merge(m, src)
}</span>
func (m *CSPKeyPairQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPKeyPairQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPKeyPairQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPKeyPairQryRequest proto.InternalMessageInfo

func (m *CSPKeyPairQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPKeyPairQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListVMStatusInfoResponse struct {
        Items                []*VMStatusInfo `protobuf:"bytes,1,rep,name=items,json=vmstatus,proto3" json:"vmstatus" yaml:"vmstatus"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *ListVMStatusInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVMStatusInfoResponse{} }</span>
func (m *ListVMStatusInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVMStatusInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVMStatusInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{74}
}</span>
func (m *ListVMStatusInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVMStatusInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVMStatusInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVMStatusInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVMStatusInfoResponse.Merge(m, src)
}</span>
func (m *ListVMStatusInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVMStatusInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVMStatusInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVMStatusInfoResponse proto.InternalMessageInfo

func (m *ListVMStatusInfoResponse) GetItems() []*VMStatusInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMStatusInfo struct {
        Iid                  *IID     `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        VmStatus             string   `protobuf:"bytes,2,opt,name=vm_status,json=VmStatus,proto3" json:"VmStatus" yaml:"VmStatus"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMStatusInfo) Reset()         <span class="cov0" title="0">{ *m = VMStatusInfo{} }</span>
func (m *VMStatusInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMStatusInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMStatusInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{75}
}</span>
func (m *VMStatusInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMStatusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMStatusInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMStatusInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMStatusInfo.Merge(m, src)
}</span>
func (m *VMStatusInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMStatusInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMStatusInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMStatusInfo proto.InternalMessageInfo

func (m *VMStatusInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMStatusInfo) GetVmStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmStatus
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMInfoResponse struct {
        Item                 *VMInfo  `protobuf:"bytes,1,opt,name=item,json=vm,proto3" json:"vm" yaml:"vm"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMInfoResponse) Reset()         <span class="cov8" title="1">{ *m = VMInfoResponse{} }</span>
func (m *VMInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{76}
}</span>
func (m *VMInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMInfoResponse.Merge(m, src)
}</span>
func (m *VMInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMInfoResponse proto.InternalMessageInfo

func (m *VMInfoResponse) GetItem() *VMInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListVMInfoResponse struct {
        Items                []*VMInfo `protobuf:"bytes,1,rep,name=items,json=vm,proto3" json:"vm" yaml:"vm"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListVMInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVMInfoResponse{} }</span>
func (m *ListVMInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVMInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVMInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{77}
}</span>
func (m *ListVMInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVMInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVMInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVMInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVMInfoResponse.Merge(m, src)
}</span>
func (m *ListVMInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVMInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVMInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVMInfoResponse proto.InternalMessageInfo

func (m *ListVMInfoResponse) GetItems() []*VMInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMInfo struct {
        Iid                  *IID          `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        StartTime            string        `protobuf:"bytes,2,opt,name=start_time,json=StartTime,proto3" json:"StartTime" yaml:"StartTime"`
        Region               *VMRegionInfo `protobuf:"bytes,3,opt,name=region,json=Region,proto3" json:"Region" yaml:"Region"`
        ImageIid             *IID          `protobuf:"bytes,4,opt,name=image_iid,json=ImageIId,proto3" json:"ImageIId" yaml:"ImageIId"`
        VmSpecName           string        `protobuf:"bytes,5,opt,name=vm_spec_name,json=VMSpecName,proto3" json:"VMSpecName" yaml:"VMSpecName"`
        VpcIid               *IID          `protobuf:"bytes,6,opt,name=vpc_iid,json=VpcIID,proto3" json:"VpcIID" yaml:"VpcIID"`
        SubnetIid            *IID          `protobuf:"bytes,7,opt,name=subnet_iid,json=SubnetIID,proto3" json:"SubnetIID" yaml:"SubnetIID"`
        SecurityGroupIids    []*IID        `protobuf:"bytes,8,rep,name=security_group_iids,json=SecurityGroupIIds,proto3" json:"SecurityGroupIIds" yaml:"SecurityGroupIIds"`
        KeyPairIid           *IID          `protobuf:"bytes,9,opt,name=key_pair_iid,json=KeyPairIId,proto3" json:"KeyPairIId" yaml:"KeyPairIId"`
        VmUserId             string        `protobuf:"bytes,10,opt,name=vm_user_id,json=VMUserId,proto3" json:"VMUserId" yaml:"VMUserId"`
        VmUserPasswd         string        `protobuf:"bytes,11,opt,name=vm_user_passwd,json=VMUserPasswd,proto3" json:"VMUserPasswd" yaml:"VMUserPasswd"`
        NetworkInterface     string        `protobuf:"bytes,12,opt,name=network_interface,json=NetworkInterface,proto3" json:"NetworkInterface" yaml:"NetworkInterface"`
        PublicIp             string        `protobuf:"bytes,13,opt,name=public_ip,json=PublicIP,proto3" json:"PublicIP" yaml:"PublicIP"`
        PublicDns            string        `protobuf:"bytes,14,opt,name=public_dns,json=PublicDNS,proto3" json:"PublicDNS" yaml:"PublicDNS"`
        PrivateIp            string        `protobuf:"bytes,15,opt,name=private_ip,json=PrivateIP,proto3" json:"PrivateIP" yaml:"PrivateIP"`
        PrivateDns           string        `protobuf:"bytes,16,opt,name=private_dns,json=PrivateDNS,proto3" json:"PrivateDNS" yaml:"PrivateDNS"`
        VmBootDisk           string        `protobuf:"bytes,17,opt,name=vm_boot_disk,json=VMBootDisk,proto3" json:"VMBootDisk" yaml:"VMBootDisk"`
        VmBlockDisk          string        `protobuf:"bytes,18,opt,name=vm_block_disk,json=VMBlockDisk,proto3" json:"VMBlockDisk" yaml:"VMBlockDisk"`
        SshAccessPoint       string        `protobuf:"bytes,19,opt,name=ssh_access_point,json=SSHAccessPoint,proto3" json:"SSHAccessPoint" yaml:"SSHAccessPoint"`
        KeyValueList         []*KeyValue   `protobuf:"bytes,20,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *VMInfo) Reset()         <span class="cov0" title="0">{ *m = VMInfo{} }</span>
func (m *VMInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{78}
}</span>
func (m *VMInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMInfo.Merge(m, src)
}</span>
func (m *VMInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMInfo proto.InternalMessageInfo

func (m *VMInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetStartTime() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StartTime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetRegion() *VMRegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetImageIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ImageIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetVmSpecName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmSpecName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVpcIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetSubnetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetSecurityGroupIids() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityGroupIids
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetKeyPairIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyPairIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetVmUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVmUserPasswd() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserPasswd
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetNetworkInterface() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NetworkInterface
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPublicIp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicIp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPublicDns() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicDns
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPrivateIp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateIp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPrivateDns() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateDns
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVmBootDisk() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmBootDisk
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVmBlockDisk() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmBlockDisk
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetSshAccessPoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SshAccessPoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMRegionInfo struct {
        Region               string   `protobuf:"bytes,1,opt,name=region,json=Region,proto3" json:"Region" yaml:"Region"`
        Zone                 string   `protobuf:"bytes,2,opt,name=zone,json=Zone,proto3" json:"Zone" yaml:"Zone"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMRegionInfo) Reset()         <span class="cov0" title="0">{ *m = VMRegionInfo{} }</span>
func (m *VMRegionInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMRegionInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMRegionInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{79}
}</span>
func (m *VMRegionInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMRegionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMRegionInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMRegionInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMRegionInfo.Merge(m, src)
}</span>
func (m *VMRegionInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMRegionInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMRegionInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMRegionInfo proto.InternalMessageInfo

func (m *VMRegionInfo) GetRegion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMRegionInfo) GetZone() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Zone
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMCreateRequest struct {
        ConnectionName       string        `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *VMCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *VMCreateRequest) Reset()         <span class="cov8" title="1">{ *m = VMCreateRequest{} }</span>
func (m *VMCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{80}
}</span>
func (m *VMCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateRequest.Merge(m, src)
}</span>
func (m *VMCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMCreateRequest proto.InternalMessageInfo

func (m *VMCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateRequest) GetItem() *VMCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        ImageName            string   `protobuf:"bytes,2,opt,name=image_name,json=ImageName,proto3" json:"ImageName" yaml:"ImageName"`
        VpcName              string   `protobuf:"bytes,3,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        SubnetName           string   `protobuf:"bytes,4,opt,name=subnet_name,json=SubnetName,proto3" json:"SubnetName" yaml:"SubnetName"`
        SecurityGroupNames   []string `protobuf:"bytes,5,rep,name=security_group_names,json=SecurityGroupNames,proto3" json:"SecurityGroupNames" yaml:"SecurityGroupNames"`
        VmSpecName           string   `protobuf:"bytes,6,opt,name=vm_spec_name,json=VMSpecName,proto3" json:"VMSpecName" yaml:"VMSpecName"`
        KeyPairName          string   `protobuf:"bytes,7,opt,name=key_pair_name,json=KeyPairName,proto3" json:"KeyPairName" yaml:"KeyPairName"`
        VmUserId             string   `protobuf:"bytes,8,opt,name=vm_user_id,json=VMUserId,proto3" json:"VMUserId" yaml:"VMUserId"`
        VmUserPasswd         string   `protobuf:"bytes,9,opt,name=vm_user_passwd,json=VMUserPasswd,proto3" json:"VMUserPasswd" yaml:"VMUserPasswd"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMCreateInfo) Reset()         <span class="cov0" title="0">{ *m = VMCreateInfo{} }</span>
func (m *VMCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{81}
}</span>
func (m *VMCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateInfo.Merge(m, src)
}</span>
func (m *VMCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMCreateInfo proto.InternalMessageInfo

func (m *VMCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetImageName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ImageName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetSubnetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetSecurityGroupNames() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityGroupNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMCreateInfo) GetVmSpecName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmSpecName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetKeyPairName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyPairName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetVmUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetVmUserPasswd() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserPasswd
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMAllQryRequest{} }</span>
func (m *VMAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{82}
}</span>
func (m *VMAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMAllQryRequest.Merge(m, src)
}</span>
func (m *VMAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMAllQryRequest proto.InternalMessageInfo

func (m *VMAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMQryRequest{} }</span>
func (m *VMQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{83}
}</span>
func (m *VMQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMQryRequest.Merge(m, src)
}</span>
func (m *VMQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMQryRequest proto.InternalMessageInfo

func (m *VMQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPVMQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPVMQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPVMQryRequest{} }</span>
func (m *CSPVMQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPVMQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPVMQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{84}
}</span>
func (m *CSPVMQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPVMQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPVMQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPVMQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPVMQryRequest.Merge(m, src)
}</span>
func (m *CSPVMQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPVMQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPVMQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPVMQryRequest proto.InternalMessageInfo

func (m *CSPVMQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPVMQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMActionRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Action               string   `protobuf:"bytes,3,opt,name=action,proto3" json:"action" yaml:"action"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMActionRequest) Reset()         <span class="cov8" title="1">{ *m = VMActionRequest{} }</span>
func (m *VMActionRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMActionRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMActionRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{85}
}</span>
func (m *VMActionRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMActionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMActionRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMActionRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMActionRequest.Merge(m, src)
}</span>
func (m *VMActionRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMActionRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMActionRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMActionRequest proto.InternalMessageInfo

func (m *VMActionRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMActionRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMActionRequest) GetAction() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Action
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SSHRunRequest struct {
        UserName             string   `protobuf:"bytes,1,opt,name=user_name,json=UserName,proto3" json:"UserName" yaml:"UserName"`
        PrivateKey           []string `protobuf:"bytes,2,rep,name=private_key,json=PrivateKey,proto3" json:"PrivateKey" yaml:"PrivateKey"`
        ServerPort           string   `protobuf:"bytes,3,opt,name=server_port,json=ServerPort,proto3" json:"ServerPort" yaml:"ServerPort"`
        Command              string   `protobuf:"bytes,4,opt,name=command,json=Command,proto3" json:"Command" yaml:"Command"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SSHRunRequest) Reset()         <span class="cov8" title="1">{ *m = SSHRunRequest{} }</span>
func (m *SSHRunRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SSHRunRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SSHRunRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{86}
}</span>
func (m *SSHRunRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SSHRunRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SSHRunRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SSHRunRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SSHRunRequest.Merge(m, src)
}</span>
func (m *SSHRunRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SSHRunRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SSHRunRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SSHRunRequest proto.InternalMessageInfo

func (m *SSHRunRequest) GetUserName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SSHRunRequest) GetPrivateKey() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SSHRunRequest) GetServerPort() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ServerPort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SSHRunRequest) GetCommand() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Command
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Empty)(nil), "cbspider.Empty")
        proto.RegisterType((*KeyValue)(nil), "cbspider.KeyValue")
        proto.RegisterType((*IID)(nil), "cbspider.IID")
        proto.RegisterType((*BooleanResponse)(nil), "cbspider.BooleanResponse")
        proto.RegisterType((*StringResponse)(nil), "cbspider.StringResponse")
        proto.RegisterType((*MessageResponse)(nil), "cbspider.MessageResponse")
        proto.RegisterType((*StatusResponse)(nil), "cbspider.StatusResponse")
        proto.RegisterType((*ListCloudOSInfoResponse)(nil), "cbspider.ListCloudOSInfoResponse")
        proto.RegisterType((*CloudDriverInfoRequest)(nil), "cbspider.CloudDriverInfoRequest")
        proto.RegisterType((*CloudDriverInfoResponse)(nil), "cbspider.CloudDriverInfoResponse")
        proto.RegisterType((*ListCloudDriverInfoResponse)(nil), "cbspider.ListCloudDriverInfoResponse")
        proto.RegisterType((*CloudDriverInfo)(nil), "cbspider.CloudDriverInfo")
        proto.RegisterType((*CloudDriverQryRequest)(nil), "cbspider.CloudDriverQryRequest")
        proto.RegisterType((*CredentialInfoRequest)(nil), "cbspider.CredentialInfoRequest")
        proto.RegisterType((*CredentialInfoResponse)(nil), "cbspider.CredentialInfoResponse")
        proto.RegisterType((*ListCredentialInfoResponse)(nil), "cbspider.ListCredentialInfoResponse")
        proto.RegisterType((*CredentialInfo)(nil), "cbspider.CredentialInfo")
        proto.RegisterType((*CredentialQryRequest)(nil), "cbspider.CredentialQryRequest")
        proto.RegisterType((*RegionInfoRequest)(nil), "cbspider.RegionInfoRequest")
        proto.RegisterType((*RegionInfoResponse)(nil), "cbspider.RegionInfoResponse")
        proto.RegisterType((*ListRegionInfoResponse)(nil), "cbspider.ListRegionInfoResponse")
        proto.RegisterType((*RegionInfo)(nil), "cbspider.RegionInfo")
        proto.RegisterType((*RegionQryRequest)(nil), "cbspider.RegionQryRequest")
        proto.RegisterType((*ConnectionConfigInfoRequest)(nil), "cbspider.ConnectionConfigInfoRequest")
        proto.RegisterType((*ConnectionConfigInfoResponse)(nil), "cbspider.ConnectionConfigInfoResponse")
        proto.RegisterType((*ListConnectionConfigInfoResponse)(nil), "cbspider.ListConnectionConfigInfoResponse")
        proto.RegisterType((*ConnectionConfigInfo)(nil), "cbspider.ConnectionConfigInfo")
        proto.RegisterType((*ConnectionConfigQryRequest)(nil), "cbspider.ConnectionConfigQryRequest")
        proto.RegisterType((*AllResourceInfoResponse)(nil), "cbspider.AllResourceInfoResponse")
        proto.RegisterType((*AllResourceInfo)(nil), "cbspider.AllResourceInfo")
        proto.RegisterType((*ImageInfoResponse)(nil), "cbspider.ImageInfoResponse")
        proto.RegisterType((*ListImageInfoResponse)(nil), "cbspider.ListImageInfoResponse")
        proto.RegisterType((*ImageInfo)(nil), "cbspider.ImageInfo")
        proto.RegisterType((*ImageCreateRequest)(nil), "cbspider.ImageCreateRequest")
        proto.RegisterType((*ImageCreateInfo)(nil), "cbspider.ImageCreateInfo")
        proto.RegisterType((*ImageAllQryRequest)(nil), "cbspider.ImageAllQryRequest")
        proto.RegisterType((*ImageQryRequest)(nil), "cbspider.ImageQryRequest")
        proto.RegisterType((*VMSpecInfoResponse)(nil), "cbspider.VMSpecInfoResponse")
        proto.RegisterType((*ListVMSpecInfoResponse)(nil), "cbspider.ListVMSpecInfoResponse")
        proto.RegisterType((*VMSpecInfo)(nil), "cbspider.VMSpecInfo")
        proto.RegisterType((*VCpuInfo)(nil), "cbspider.VCpuInfo")
        proto.RegisterType((*GpuInfo)(nil), "cbspider.GpuInfo")
        proto.RegisterType((*VMSpecAllQryRequest)(nil), "cbspider.VMSpecAllQryRequest")
        proto.RegisterType((*VMSpecQryRequest)(nil), "cbspider.VMSpecQryRequest")
        proto.RegisterType((*VPCInfoResponse)(nil), "cbspider.VPCInfoResponse")
        proto.RegisterType((*ListVPCInfoResponse)(nil), "cbspider.ListVPCInfoResponse")
        proto.RegisterType((*VPCInfo)(nil), "cbspider.VPCInfo")
        proto.RegisterType((*SubnetInfo)(nil), "cbspider.SubnetInfo")
        proto.RegisterType((*VPCCreateRequest)(nil), "cbspider.VPCCreateRequest")
        proto.RegisterType((*VPCCreateInfo)(nil), "cbspider.VPCCreateInfo")
        proto.RegisterType((*SubnetCreateInfo)(nil), "cbspider.SubnetCreateInfo")
        proto.RegisterType((*VPCAllQryRequest)(nil), "cbspider.VPCAllQryRequest")
        proto.RegisterType((*VPCQryRequest)(nil), "cbspider.VPCQryRequest")
        proto.RegisterType((*CSPVPCQryRequest)(nil), "cbspider.CSPVPCQryRequest")
        proto.RegisterType((*SubnetAddRequest)(nil), "cbspider.SubnetAddRequest")
        proto.RegisterType((*SubnetQryRequest)(nil), "cbspider.SubnetQryRequest")
        proto.RegisterType((*CSPSubnetQryRequest)(nil), "cbspider.CSPSubnetQryRequest")
        proto.RegisterType((*SecurityInfoResponse)(nil), "cbspider.SecurityInfoResponse")
        proto.RegisterType((*ListSecurityInfoResponse)(nil), "cbspider.ListSecurityInfoResponse")
        proto.RegisterType((*SecurityInfo)(nil), "cbspider.SecurityInfo")
        proto.RegisterType((*SecurityRuleInfo)(nil), "cbspider.SecurityRuleInfo")
        proto.RegisterType((*SecurityCreateRequest)(nil), "cbspider.SecurityCreateRequest")
        proto.RegisterType((*SecurityCreateInfo)(nil), "cbspider.SecurityCreateInfo")
        proto.RegisterType((*SecurityAllQryRequest)(nil), "cbspider.SecurityAllQryRequest")
        proto.RegisterType((*SecurityQryRequest)(nil), "cbspider.SecurityQryRequest")
        proto.RegisterType((*CSPSecurityQryRequest)(nil), "cbspider.CSPSecurityQryRequest")
        proto.RegisterType((*KeyPairInfoResponse)(nil), "cbspider.KeyPairInfoResponse")
        proto.RegisterType((*ListKeyPairInfoResponse)(nil), "cbspider.ListKeyPairInfoResponse")
        proto.RegisterType((*KeyPairInfo)(nil), "cbspider.KeyPairInfo")
        proto.RegisterType((*KeyPairCreateRequest)(nil), "cbspider.KeyPairCreateRequest")
        proto.RegisterType((*KeyPairCreateInfo)(nil), "cbspider.KeyPairCreateInfo")
        proto.RegisterType((*KeyPairAllQryRequest)(nil), "cbspider.KeyPairAllQryRequest")
        proto.RegisterType((*KeyPairQryRequest)(nil), "cbspider.KeyPairQryRequest")
        proto.RegisterType((*CSPKeyPairQryRequest)(nil), "cbspider.CSPKeyPairQryRequest")
        proto.RegisterType((*ListVMStatusInfoResponse)(nil), "cbspider.ListVMStatusInfoResponse")
        proto.RegisterType((*VMStatusInfo)(nil), "cbspider.VMStatusInfo")
        proto.RegisterType((*VMInfoResponse)(nil), "cbspider.VMInfoResponse")
        proto.RegisterType((*ListVMInfoResponse)(nil), "cbspider.ListVMInfoResponse")
        proto.RegisterType((*VMInfo)(nil), "cbspider.VMInfo")
        proto.RegisterType((*VMRegionInfo)(nil), "cbspider.VMRegionInfo")
        proto.RegisterType((*VMCreateRequest)(nil), "cbspider.VMCreateRequest")
        proto.RegisterType((*VMCreateInfo)(nil), "cbspider.VMCreateInfo")
        proto.RegisterType((*VMAllQryRequest)(nil), "cbspider.VMAllQryRequest")
        proto.RegisterType((*VMQryRequest)(nil), "cbspider.VMQryRequest")
        proto.RegisterType((*CSPVMQryRequest)(nil), "cbspider.CSPVMQryRequest")
        proto.RegisterType((*VMActionRequest)(nil), "cbspider.VMActionRequest")
        proto.RegisterType((*SSHRunRequest)(nil), "cbspider.SSHRunRequest")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("cbspider.proto", fileDescriptor_024d57f2826cd0d0) }</span>

var fileDescriptor_024d57f2826cd0d0 = []byte{
        // 4103 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5c, 0xcd, 0x8f, 0x23, 0x49,
        0x56, 0x6f, 0xdb, 0xf5, 0xe5, 0x57, 0x5f, 0xae, 0xa8, 0xea, 0xee, 0x9a, 0xea, 0x9e, 0x76, 0x4f,
        0xec, 0x0e, 0x03, 0x8c, 0xb4, 0x23, 0x66, 0x06, 0x66, 0xb4, 0xdb, 0xbb, 0x74, 0x95, 0xdd, 0xed,
        0xf1, 0x54, 0xbb, 0xdb, 0x13, 0xee, 0xf1, 0x8e, 0x96, 0x1d, 0x2c, 0x97, 0x1d, 0x55, 0x9b, 0x54,
        0xda, 0x99, 0x93, 0x69, 0x7b, 0x65, 0xb8, 0x80, 0xb4, 0x17, 0xa4, 0xe5, 0x6b, 0xb5, 0x2b, 0xe0,
        0xc0, 0x15, 0x21, 0xee, 0x08, 0x04, 0x42, 0x08, 0x38, 0xb0, 0x70, 0x42, 0xfc, 0x01, 0x16, 0x1a,
        0x2e, 0xc8, 0x27, 0xd4, 0xe2, 0xc0, 0x11, 0xc5, 0x47, 0x66, 0x44, 0x64, 0xa6, 0x5d, 0x2e, 0x57,
        0xb5, 0x99, 0xe1, 0x54, 0x15, 0x2f, 0x5e, 0xfc, 0xe2, 0xc5, 0x8b, 0x17, 0xef, 0xbd, 0x88, 0x8c,
        0x30, 0x6c, 0xb5, 0x4e, 0x7c, 0xd7, 0x6a, 0x53, 0xef, 0x6b, 0xae, 0xe7, 0xf4, 0x1c, 0xb4, 0x16,
        0x94, 0x0f, 0xe0, 0xcc, 0x39, 0x73, 0x04, 0x15, 0xaf, 0xc2, 0xf2, 0xa3, 0x8e, 0xdb, 0x1b, 0xe2,
        0x36, 0xac, 0x1d, 0xd3, 0x61, 0xbd, 0x69, 0xf7, 0x29, 0x7a, 0x03, 0x32, 0xe7, 0x74, 0xb8, 0x9f,
        0xba, 0x9f, 0xfa, 0xd9, 0xec, 0xd1, 0xcd, 0xf1, 0x28, 0x9f, 0x39, 0xa6, 0xc3, 0x17, 0xa3, 0x3c,
        0x0c, 0x9b, 0x1d, 0xfb, 0xeb, 0xf8, 0x98, 0x0e, 0x31, 0x61, 0x24, 0xf4, 0x16, 0x2c, 0x0f, 0x58,
        0x8b, 0xfd, 0x34, 0x67, 0x7d, 0x65, 0x3c, 0xca, 0x2f, 0x73, 0x88, 0x17, 0xa3, 0xfc, 0x86, 0x60,
        0xe6, 0x45, 0x4c, 0x04, 0x19, 0x0f, 0x21, 0x53, 0x2e, 0x17, 0xd1, 0xbb, 0xb0, 0xda, 0x6d, 0x76,
        0x68, 0xc3, 0x6a, 0xcb, 0x4e, 0xee, 0x8c, 0x47, 0xf9, 0x95, 0xa7, 0xcd, 0x0e, 0x2d, 0xb7, 0x5f,
        0x8c, 0xf2, 0x9b, 0xa2, 0xa9, 0x28, 0x63, 0x22, 0x2b, 0xd0, 0x03, 0xc8, 0xfa, 0x43, 0xbf, 0x47,
        0x3b, 0xac, 0x9d, 0xe8, 0x31, 0x3f, 0x1e, 0xe5, 0xd7, 0x6a, 0x9c, 0xc8, 0x5b, 0x6e, 0x8b, 0x96,
        0x01, 0x05, 0x93, 0xb0, 0x12, 0x3f, 0x86, 0xed, 0x23, 0xc7, 0xb1, 0x69, 0xb3, 0x4b, 0xa8, 0xef,
        0x3a, 0x5d, 0x9f, 0xa2, 0x77, 0x60, 0xc5, 0xa3, 0x7e, 0xdf, 0xee, 0x71, 0x29, 0xd6, 0x84, 0x14,
        0x84, 0x53, 0x94, 0x14, 0xa2, 0x8c, 0x89, 0xac, 0xc0, 0x8f, 0x60, 0xab, 0xd6, 0xf3, 0xac, 0xee,
        0xd9, 0x04, 0x98, 0xec, 0x6c, 0x30, 0x1f, 0xc2, 0x76, 0x85, 0xfa, 0x7e, 0xf3, 0x8c, 0x86, 0x38,
        0xef, 0xc1, 0x6a, 0x47, 0x90, 0x24, 0xd0, 0xab, 0xe3, 0x51, 0x3e, 0x20, 0xbd, 0x18, 0xe5, 0xb7,
        0x04, 0x92, 0x24, 0x60, 0x12, 0x54, 0x09, 0x91, 0x9a, 0xbd, 0xbe, 0xaf, 0x8b, 0xe4, 0x73, 0x8a,
        0x2e, 0x92, 0xe0, 0x51, 0x22, 0x89, 0x32, 0x26, 0xb2, 0x02, 0x57, 0xe1, 0xf6, 0x13, 0xcb, 0xef,
        0x15, 0x6c, 0xa7, 0xdf, 0x7e, 0x56, 0x2b, 0x77, 0x4f, 0x9d, 0x10, 0xef, 0x17, 0x61, 0xd9, 0xea,
        0xd1, 0x0e, 0x83, 0xcb, 0x04, 0x82, 0xb5, 0x18, 0x9f, 0xe3, 0x2b, 0xc1, 0x24, 0x01, 0x93, 0xa0,
        0x0a, 0x9f, 0xc2, 0x2d, 0x8e, 0x56, 0xf4, 0xac, 0x01, 0xf5, 0x04, 0xe2, 0x67, 0x7d, 0xea, 0xf7,
        0xd0, 0x13, 0x58, 0x62, 0x80, 0x5c, 0xbc, 0xf5, 0xb7, 0x5f, 0xf9, 0x5a, 0x68, 0xac, 0x11, 0x7e,
        0x21, 0x79, 0x9b, 0x97, 0x95, 0xe4, 0xa2, 0x8c, 0x89, 0xac, 0xc0, 0x67, 0x70, 0x3b, 0xd6, 0x8f,
        0x94, 0xfc, 0x7a, 0x3b, 0xb2, 0xe1, 0x4e, 0xa8, 0xa2, 0x84, 0xce, 0x2a, 0xba, 0x9a, 0xae, 0xde,
        0xdb, 0x6f, 0xa7, 0x61, 0x3b, 0xd2, 0x10, 0x15, 0x61, 0x5d, 0xd4, 0x36, 0xd8, 0x0a, 0x92, 0xd3,
        0xfb, 0x95, 0xf1, 0x28, 0x0f, 0x82, 0x89, 0xad, 0x95, 0x17, 0xa3, 0xfc, 0x8e, 0x40, 0x54, 0x34,
        0x4c, 0x34, 0x06, 0xf4, 0x04, 0x36, 0x5d, 0xcf, 0x19, 0x30, 0xd1, 0x04, 0x8e, 0x58, 0x4e, 0x6f,
        0x8c, 0x47, 0xf9, 0x8d, 0xaa, 0xac, 0x90, 0x48, 0xbb, 0x02, 0x49, 0xa7, 0x62, 0x62, 0x30, 0xa1,
        0x13, 0xd8, 0x93, 0x32, 0xd9, 0xd6, 0x49, 0xe3, 0xd4, 0xb2, 0xa9, 0x00, 0xcd, 0x70, 0xd0, 0x5f,
        0x18, 0x8f, 0xf2, 0x3b, 0xa2, 0xef, 0x27, 0xd6, 0xc9, 0x63, 0xcb, 0xa6, 0x12, 0x79, 0x5f, 0x97,
        0x51, 0xab, 0xc2, 0x24, 0xce, 0x8e, 0x3f, 0x85, 0x9b, 0x9a, 0x2a, 0x3e, 0xf2, 0x86, 0x81, 0x25,
        0x5d, 0x8b, 0x42, 0xb0, 0x0b, 0x37, 0x0b, 0x1e, 0x6d, 0xd3, 0x6e, 0xcf, 0x6a, 0xda, 0xba, 0xa1,
        0x7e, 0xdb, 0xb0, 0x9f, 0x7d, 0x6d, 0x46, 0x0d, 0x76, 0xd1, 0x63, 0x2b, 0xa4, 0xa9, 0x1e, 0x15,
        0x0d, 0x13, 0x8d, 0x01, 0x7f, 0x06, 0xb7, 0xa2, 0x3d, 0x4a, 0x2b, 0x7a, 0x69, 0x5d, 0x0e, 0xe0,
        0x80, 0x5b, 0x6f, 0x72, 0xb7, 0x9f, 0x98, 0xc6, 0x7b, 0x8d, 0xfd, 0xfe, 0x59, 0x1a, 0xb6, 0x4c,
        0x0c, 0xf4, 0x1c, 0xb6, 0x15, 0x83, 0x3e, 0x73, 0x6f, 0x8e, 0x47, 0x79, 0x8d, 0x59, 0xce, 0xde,
        0x4d, 0xd1, 0x81, 0x49, 0xc7, 0x24, 0xc2, 0x78, 0xcd, 0x66, 0xed, 0xc1, 0xee, 0x39, 0x1d, 0x36,
        0x78, 0x84, 0x6b, 0x58, 0xdd, 0x53, 0xa7, 0x61, 0x5b, 0x7e, 0x6f, 0x3f, 0xc3, 0xd5, 0x83, 0x94,
        0x7a, 0x82, 0xb8, 0x79, 0xf4, 0xd6, 0x78, 0x94, 0xcf, 0x05, 0x25, 0x36, 0x4c, 0xa6, 0xed, 0x17,
        0xa3, 0xfc, 0xed, 0x30, 0x6e, 0x1a, 0x35, 0x98, 0xc4, 0x98, 0xb1, 0x0d, 0x7b, 0x6a, 0x4c, 0x9a,
        0x95, 0xbf, 0x14, 0x7d, 0xe1, 0xef, 0xc2, 0x0e, 0xa1, 0x67, 0x96, 0xd3, 0xd5, 0x2d, 0xbe, 0x64,
        0x98, 0xdf, 0x9e, 0x1a, 0xa7, 0x62, 0x15, 0xee, 0xcb, 0xe3, 0x65, 0xe5, 0xbe, 0x44, 0x19, 0x13,
        0x59, 0x81, 0x3f, 0x05, 0xa4, 0xa3, 0x4b, 0x33, 0xbb, 0x36, 0xf8, 0x13, 0xb8, 0xc5, 0x54, 0x96,
        0xd0, 0xc5, 0x07, 0xa6, 0x25, 0x5f, 0xa1, 0x8f, 0x1f, 0xa7, 0x01, 0x54, 0x1b, 0xe6, 0x6b, 0x44,
        0x45, 0xcc, 0xd7, 0x08, 0x26, 0xd3, 0xd7, 0x28, 0x1a, 0x26, 0x1a, 0xc3, 0xff, 0x03, 0x2b, 0xfd,
        0x04, 0x72, 0x62, 0x3c, 0xa6, 0x1f, 0xbe, 0xba, 0x6e, 0xf0, 0xef, 0xa6, 0xe0, 0x4e, 0xc1, 0xe9,
        0x76, 0x69, 0xab, 0x67, 0x39, 0xdd, 0x82, 0xd3, 0x3d, 0xb5, 0xce, 0x74, 0xe3, 0x74, 0x0c, 0xeb,
        0xb9, 0xa7, 0xf9, 0xa8, 0x84, 0x46, 0x62, 0xa8, 0xad, 0xb0, 0xa6, 0xc5, 0x6b, 0xd4, 0x50, 0xa3,
        0x35, 0x98, 0xc4, 0x98, 0xf1, 0xef, 0xa5, 0xe0, 0x6e, 0xb2, 0x40, 0xd2, 0xd8, 0x16, 0x2e, 0xd1,
        0x8f, 0x53, 0x70, 0x9f, 0xbb, 0xf1, 0x69, 0x52, 0xb9, 0xe6, 0x12, 0x58, 0x80, 0x58, 0x3f, 0xcc,
        0xc0, 0x5e, 0x12, 0x36, 0x33, 0x0c, 0xc1, 0x12, 0x33, 0x0c, 0xc1, 0x64, 0x1a, 0x86, 0xa2, 0x61,
        0xa2, 0x31, 0x5c, 0xf3, 0xa2, 0x89, 0x24, 0x0d, 0x99, 0xf9, 0xb2, 0xa8, 0x04, 0xa7, 0xbc, 0x74,
        0xf5, 0x20, 0x16, 0x59, 0x48, 0xcb, 0xf3, 0x2d, 0xa4, 0x13, 0x38, 0x88, 0xce, 0x86, 0xb9, 0x58,
        0xaf, 0x3e, 0x27, 0xf8, 0xd7, 0xe0, 0xf6, 0xa1, 0x6d, 0x13, 0xea, 0x3b, 0x7d, 0xaf, 0x45, 0x0d,
        0xfb, 0x7b, 0x36, 0x29, 0xed, 0x8e, 0x34, 0x10, 0x5b, 0x89, 0x43, 0xdb, 0x96, 0x4e, 0x48, 0x6e,
        0x25, 0x24, 0x01, 0x93, 0xa0, 0x0a, 0xff, 0x69, 0x1a, 0xb6, 0x23, 0x6d, 0x51, 0x0d, 0xd6, 0x3b,
        0x4d, 0xd7, 0xa5, 0x6d, 0xe1, 0xf2, 0x84, 0xa9, 0x6f, 0xaa, 0xbe, 0xca, 0xe5, 0xa2, 0x18, 0x54,
        0x85, 0x73, 0xc9, 0x2e, 0xe4, 0xa0, 0x14, 0x0d, 0x13, 0x8d, 0x01, 0xb5, 0x21, 0xe7, 0x74, 0xed,
        0x61, 0x43, 0x60, 0x08, 0xe4, 0x74, 0x12, 0x32, 0x9f, 0xe4, 0x67, 0x5d, 0x7b, 0x58, 0xe3, 0x34,
        0x89, 0x2e, 0x27, 0xd9, 0xa4, 0x63, 0x12, 0x61, 0x44, 0x9f, 0xc0, 0x26, 0xef, 0xa5, 0xe5, 0xbb,
        0xba, 0xbf, 0x8e, 0x74, 0xf1, 0xfa, 0x78, 0x94, 0x5f, 0x67, 0x2d, 0x0b, 0xb5, 0xaa, 0xc4, 0x47,
        0x0a, 0x5f, 0x12, 0x31, 0xd1, 0x59, 0xf0, 0x27, 0xb0, 0x53, 0xee, 0x34, 0xcf, 0xcc, 0xe9, 0x28,
        0x18, 0xd3, 0xb1, 0xab, 0xf5, 0x12, 0xb0, 0x8a, 0xcd, 0xbb, 0xd5, 0x11, 0x5b, 0x4d, 0xb9, 0x79,
        0xe7, 0x45, 0x4c, 0x04, 0x99, 0xa5, 0xe0, 0xac, 0x87, 0x38, 0x7a, 0xd1, 0x74, 0x36, 0x73, 0xc2,
        0xff, 0x24, 0x0d, 0xd9, 0x90, 0x1f, 0xfd, 0x12, 0x64, 0x2c, 0x79, 0x3c, 0x10, 0x53, 0x0b, 0x3f,
        0x92, 0x28, 0xf3, 0x0d, 0xbf, 0x3c, 0x92, 0x28, 0xb3, 0xbd, 0x3e, 0x23, 0xa1, 0xf7, 0x61, 0xed,
        0x8c, 0x99, 0x78, 0xc3, 0xf1, 0xa5, 0x8b, 0xe0, 0x16, 0x56, 0x62, 0xb4, 0x67, 0x35, 0x65, 0x61,
        0x92, 0x80, 0x49, 0x50, 0xa5, 0xed, 0x99, 0x33, 0x33, 0xef, 0x99, 0x51, 0x13, 0xb6, 0x54, 0xf4,
        0xe5, 0x13, 0xb9, 0x34, 0x31, 0xf0, 0x72, 0x5f, 0x15, 0x94, 0xe4, 0x74, 0xee, 0x9a, 0x41, 0x57,
        0xcc, 0xa7, 0xc1, 0x84, 0xff, 0x26, 0x05, 0x88, 0xeb, 0xa5, 0xe0, 0xd1, 0x66, 0x8f, 0xea, 0x19,
        0x61, 0xb8, 0xc0, 0xe3, 0x19, 0x61, 0x58, 0x15, 0x71, 0x3e, 0x06, 0x9d, 0x39, 0x1f, 0x83, 0x10,
        0xae, 0xdb, 0x74, 0x74, 0xdd, 0x6a, 0x12, 0xa8, 0x75, 0x4b, 0xe8, 0x67, 0xac, 0xa0, 0xb4, 0x2a,
        0x09, 0x98, 0x04, 0x55, 0xf8, 0x5b, 0xb0, 0x1d, 0x69, 0x8a, 0xde, 0x84, 0x25, 0x4d, 0xdc, 0xdb,
        0xe3, 0x51, 0x7e, 0x49, 0x0a, 0xb9, 0xae, 0x0e, 0x7e, 0x30, 0x59, 0x92, 0x3e, 0x46, 0x0c, 0xfe,
        0xd0, 0x8e, 0xa6, 0xc3, 0xd7, 0x3e, 0x78, 0x16, 0x59, 0x85, 0xb0, 0x2f, 0xbb, 0xa7, 0x50, 0x05,
        0xe9, 0x59, 0x54, 0xf0, 0x29, 0xa0, 0x7a, 0xa5, 0xe6, 0xd2, 0xd6, 0x6c, 0x79, 0xb4, 0xe2, 0x15,
        0x26, 0x3c, 0xe8, 0xf8, 0x2e, 0x6d, 0x29, 0x13, 0x16, 0x65, 0x4c, 0x64, 0x45, 0x90, 0x47, 0x27,
        0x74, 0x31, 0x39, 0x8f, 0xbe, 0x6c, 0x1f, 0xff, 0x93, 0x06, 0x50, 0x6d, 0xc4, 0x89, 0x19, 0x0b,
        0x55, 0xe6, 0x89, 0x99, 0x99, 0x8b, 0x93, 0x20, 0x17, 0x17, 0xff, 0x5c, 0x4a, 0x67, 0xe8, 0x21,
        0x2c, 0x0f, 0x1a, 0x2d, 0xb7, 0xcf, 0xd7, 0xb2, 0xb1, 0x1c, 0xeb, 0x05, 0xb7, 0xcf, 0x05, 0xe7,
        0x08, 0xac, 0xa4, 0x10, 0x58, 0x09, 0x13, 0x4e, 0x44, 0x6f, 0x40, 0xa6, 0x43, 0x3b, 0x32, 0xa0,
        0x73, 0x8f, 0x53, 0xa1, 0x1d, 0xe5, 0x71, 0x2a, 0xb4, 0x83, 0x09, 0x23, 0xa1, 0xaf, 0x43, 0xe6,
        0xcc, 0xed, 0xef, 0x2f, 0x73, 0x1d, 0xed, 0xa8, 0x8e, 0x4a, 0xb2, 0x1f, 0xde, 0xb6, 0xc4, 0xbb,
        0x91, 0x6d, 0x4b, 0xac, 0x17, 0x46, 0x4a, 0x70, 0x1f, 0x2b, 0xd7, 0xed, 0x3e, 0x6c, 0x58, 0x0b,
        0x86, 0x8c, 0xde, 0x82, 0xe5, 0x96, 0xd3, 0xef, 0x06, 0x07, 0x95, 0xdc, 0x27, 0x17, 0x18, 0x41,
        0xf9, 0x64, 0x5e, 0xc4, 0x44, 0x90, 0x79, 0x03, 0xdb, 0x69, 0x9d, 0xeb, 0x07, 0xbc, 0x05, 0x46,
        0xd0, 0x1a, 0xb0, 0x22, 0x6b, 0xc0, 0xff, 0xfe, 0x6d, 0x0a, 0x56, 0x4b, 0xf3, 0xf6, 0xc6, 0x54,
        0x7e, 0xea, 0xc9, 0xbe, 0x84, 0xca, 0x4f, 0x3d, 0x4d, 0xe5, 0xa7, 0x1e, 0x53, 0xf9, 0xa9, 0xc7,
        0x90, 0x3b, 0x4e, 0x9b, 0xda, 0xd2, 0x53, 0x73, 0xe4, 0x0a, 0x23, 0x28, 0x64, 0x5e, 0xc4, 0x44,
        0x90, 0x67, 0x9e, 0x4c, 0x7c, 0x0e, 0xbb, 0xc2, 0x4e, 0x17, 0xe1, 0x6f, 0x7e, 0x92, 0x82, 0x9c,
        0xe8, 0xed, 0x8b, 0xe5, 0x70, 0x9e, 0xc2, 0x76, 0xbd, 0x5a, 0x30, 0x5c, 0xc1, 0x37, 0x0c, 0x6f,
        0xa3, 0x59, 0xb9, 0x64, 0x14, 0x4a, 0x1d, 0xb8, 0x2d, 0xa5, 0xd4, 0x81, 0xdb, 0xc2, 0x84, 0x91,
        0x70, 0x0d, 0x76, 0xb9, 0x87, 0x89, 0x60, 0x3e, 0x30, 0xdd, 0xcb, 0x25, 0x41, 0xff, 0x2d, 0x0d,
        0xab, 0x92, 0x6f, 0xee, 0x64, 0xe1, 0x97, 0x21, 0x6b, 0xb9, 0x83, 0x77, 0x1b, 0x2d, 0xab, 0x1d,
        0x98, 0xdd, 0x6b, 0xe3, 0x51, 0x3e, 0x5b, 0xae, 0x0e, 0xde, 0x6d, 0x14, 0xca, 0x45, 0xf2, 0x62,
        0x94, 0xcf, 0xc9, 0x46, 0x01, 0x09, 0x13, 0x55, 0x8d, 0xce, 0x21, 0xe7, 0xf7, 0x4f, 0xba, 0xb4,
        0x17, 0xdb, 0x79, 0x6b, 0xce, 0xb2, 0xc6, 0x39, 0xf8, 0x80, 0xf8, 0x1c, 0xaa, 0xb2, 0x99, 0x33,
        0x9a, 0x74, 0x4c, 0x22, 0x8c, 0x8b, 0xc8, 0x35, 0xfe, 0x33, 0x05, 0xa0, 0x7a, 0xfd, 0xbf, 0xd3,
        0x6b, 0x7c, 0xa8, 0x99, 0xeb, 0x1e, 0xea, 0x5f, 0xb2, 0xc5, 0x57, 0x2d, 0x2c, 0x22, 0xa9, 0xaa,
        0x18, 0x49, 0xd5, 0x6d, 0xc3, 0xce, 0xe7, 0x48, 0xa9, 0xfe, 0x2b, 0x05, 0x9b, 0x46, 0xcb, 0x4b,
        0x65, 0x54, 0x57, 0x9f, 0x9c, 0xcf, 0x26, 0x1a, 0xfd, 0x41, 0xd4, 0xe8, 0xb5, 0xd1, 0x5d, 0xc5,
        0xf4, 0xf1, 0x6f, 0xa6, 0x20, 0x17, 0x45, 0x5c, 0xec, 0xa8, 0xf1, 0xf7, 0xb8, 0xb9, 0x2c, 0x22,
        0x2c, 0xfc, 0xa3, 0x98, 0xdf, 0x2f, 0x54, 0x4c, 0x60, 0x21, 0xf7, 0xd4, 0xf1, 0x5a, 0x54, 0x0f,
        0xb9, 0x9c, 0xa0, 0x42, 0x2e, 0x2f, 0x62, 0x22, 0xc8, 0xf8, 0x77, 0x52, 0x90, 0x2b, 0xd4, 0xaa,
        0x8b, 0x18, 0xc8, 0x57, 0x20, 0x1d, 0x7e, 0x11, 0xde, 0x1d, 0x8f, 0xf2, 0x69, 0xee, 0x95, 0xb2,
        0x72, 0x36, 0xdb, 0x98, 0xa4, 0xcb, 0x6d, 0xfc, 0xdf, 0xa1, 0x09, 0x1d, 0xb6, 0xdb, 0x2f, 0x57,
        0x9e, 0xf7, 0x61, 0x6d, 0xe0, 0xb6, 0xf4, 0x63, 0x2a, 0xbe, 0xb4, 0xeb, 0xd5, 0x82, 0xc4, 0x91,
        0x4b, 0x5b, 0x12, 0x30, 0x09, 0xaa, 0x50, 0x55, 0x7a, 0x0a, 0x91, 0xb5, 0x4e, 0x5b, 0x4e, 0xb3,
        0x3a, 0x8b, 0x3f, 0x4e, 0x07, 0xc3, 0x7e, 0xe9, 0xd3, 0x30, 0xff, 0xb0, 0x8b, 0xb0, 0x2e, 0x3d,
        0x4a, 0xf4, 0x38, 0x4e, 0x88, 0x6e, 0x1e, 0x47, 0x29, 0x1a, 0x26, 0x1a, 0x83, 0x32, 0xd1, 0xa5,
        0x19, 0x4d, 0xf4, 0x5f, 0x52, 0xb0, 0x5b, 0xa8, 0x55, 0xbf, 0xf0, 0xea, 0x11, 0xf6, 0x9d, 0x99,
        0x6e, 0xdf, 0x03, 0xd8, 0xab, 0xd1, 0x56, 0xdf, 0xb3, 0x7a, 0x43, 0x23, 0xcb, 0xfa, 0x55, 0x23,
        0x73, 0xbb, 0xa5, 0x99, 0x94, 0xc6, 0x7d, 0xf4, 0x73, 0xe3, 0x51, 0x7e, 0xd3, 0x97, 0x94, 0x33,
        0xcf, 0xe9, 0xbb, 0x2f, 0x46, 0xf9, 0x3d, 0xd1, 0x83, 0x41, 0xc6, 0xc4, 0x64, 0xc3, 0xbf, 0x01,
        0xfb, 0xcc, 0x45, 0x27, 0xf6, 0xdd, 0x30, 0x33, 0xbc, 0xeb, 0xef, 0xfc, 0x4f, 0x32, 0xb0, 0xa1,
        0x43, 0xcd, 0x9d, 0xb1, 0x14, 0x60, 0x95, 0x4d, 0x8e, 0x25, 0xfd, 0x48, 0xac, 0x2d, 0xdf, 0xa1,
        0xd6, 0xdd, 0x56, 0xb9, 0x5c, 0x54, 0x3b, 0x54, 0x51, 0xc6, 0x44, 0x56, 0xb0, 0x18, 0xd3, 0xb6,
        0x3c, 0x31, 0xe5, 0x72, 0xba, 0x78, 0x8c, 0x29, 0x06, 0x44, 0x15, 0x63, 0x42, 0x12, 0x26, 0xaa,
        0x1a, 0xd9, 0xb0, 0x15, 0x8c, 0xaf, 0xe1, 0xf5, 0x6d, 0xea, 0xcb, 0x0c, 0xef, 0x20, 0xae, 0x38,
        0xd2, 0xb7, 0xa9, 0x52, 0x9e, 0x4e, 0xf5, 0x95, 0xf2, 0x0c, 0x32, 0x26, 0x26, 0x5b, 0x42, 0x92,
        0xb5, 0x7c, 0xdd, 0x49, 0xd6, 0x5f, 0x33, 0xef, 0x13, 0x91, 0x18, 0x3d, 0x80, 0xec, 0xa9, 0xe7,
        0x74, 0x1a, 0xae, 0xe3, 0x05, 0x7b, 0x43, 0x7e, 0x8f, 0xe7, 0xb1, 0xe7, 0x74, 0xaa, 0x8e, 0xd7,
        0x53, 0xf7, 0x78, 0x02, 0x0a, 0x26, 0x61, 0x25, 0x7a, 0x17, 0x56, 0x7b, 0x8e, 0x68, 0x9b, 0x56,
        0x87, 0x07, 0xcf, 0x1d, 0xd9, 0x52, 0x4e, 0x8d, 0x28, 0x63, 0x22, 0x2b, 0x98, 0x87, 0xb1, 0xdc,
        0x06, 0xbf, 0xf3, 0xd4, 0x72, 0x6c, 0xdd, 0xc3, 0x94, 0xab, 0x55, 0x49, 0x55, 0x1e, 0x46, 0xd1,
        0x30, 0xd1, 0x18, 0xcc, 0x09, 0x5e, 0x9a, 0x63, 0x82, 0xdf, 0x84, 0x25, 0x9e, 0x80, 0x2c, 0xab,
        0x90, 0x2b, 0x73, 0x0f, 0x19, 0x72, 0x45, 0xda, 0xc1, 0x89, 0xf8, 0xef, 0x53, 0x70, 0x33, 0x50,
        0xde, 0x22, 0xd2, 0x54, 0x62, 0xa4, 0xa9, 0x77, 0xe3, 0x36, 0x37, 0x47, 0xf8, 0xf9, 0xf3, 0x34,
        0xa0, 0x78, 0xf3, 0xcb, 0xa5, 0x6e, 0xf3, 0x3b, 0xce, 0x2f, 0xd7, 0x82, 0xc4, 0x1d, 0x35, 0xdf,
        0x8b, 0xc8, 0x33, 0x7f, 0x9a, 0x52, 0x73, 0xf3, 0x25, 0x4f, 0x36, 0x7f, 0x94, 0x82, 0x9b, 0x2c,
        0x92, 0x2f, 0x6a, 0x34, 0x33, 0x65, 0x9c, 0x27, 0xb0, 0x7b, 0x4c, 0x87, 0xd5, 0xa6, 0x65, 0x5e,
        0x12, 0x3b, 0x36, 0x02, 0xf2, 0x4d, 0xc3, 0xd9, 0x06, 0xcc, 0xc2, 0xc2, 0xcf, 0xe9, 0xd0, 0x6d,
        0x5a, 0x9e, 0xb2, 0x70, 0x49, 0xc0, 0x24, 0xa8, 0xc2, 0x67, 0xe2, 0xce, 0x5e, 0x52, 0x3f, 0x4f,
        0xcc, 0xe0, 0x7b, 0xc5, 0x8e, 0xfe, 0x2a, 0x03, 0xeb, 0x5a, 0xbb, 0xb9, 0x03, 0x6d, 0x09, 0xd6,
        0x4f, 0xad, 0xee, 0x19, 0xf5, 0x5c, 0xcf, 0xea, 0x06, 0x2e, 0x9c, 0x7f, 0xe7, 0x7a, 0xac, 0xc8,
        0xea, 0x3b, 0x97, 0x46, 0xc4, 0x44, 0x67, 0x41, 0x0f, 0x01, 0xdc, 0xfe, 0x89, 0x6d, 0xb5, 0x1a,
        0xe7, 0x74, 0xa8, 0x2f, 0xee, 0x2a, 0xa7, 0x8a, 0x1b, 0xab, 0x72, 0x71, 0x87, 0x24, 0x4c, 0x54,
        0x35, 0x8b, 0x09, 0xae, 0x67, 0x0d, 0x9a, 0x3d, 0xca, 0x21, 0x96, 0x54, 0x4c, 0xa8, 0x0a, 0xb2,
        0xc0, 0xd8, 0x09, 0x3e, 0x27, 0x07, 0x34, 0x4c, 0x34, 0x06, 0xf4, 0x4d, 0x80, 0x41, 0xa7, 0xd1,
        0xf7, 0xa9, 0xd7, 0xb0, 0xda, 0xd2, 0xb1, 0xf3, 0x70, 0x56, 0xaf, 0x7c, 0xec, 0x53, 0x8f, 0xe7,
        0x0b, 0x32, 0x9c, 0x05, 0x14, 0x4c, 0xc2, 0xca, 0x45, 0x9c, 0x00, 0xff, 0x5d, 0x0a, 0xf6, 0xe4,
        0xd4, 0x2d, 0x22, 0x8c, 0x7c, 0x64, 0x84, 0x91, 0x3b, 0x31, 0xb3, 0x9b, 0x23, 0x8a, 0x3c, 0x84,
        0x9d, 0x58, 0xe3, 0xcb, 0x7d, 0x46, 0xb2, 0x43, 0x15, 0x2c, 0xc2, 0xb3, 0xfe, 0x53, 0x2a, 0x14,
        0xf8, 0x4b, 0xee, 0x58, 0xff, 0x20, 0x05, 0x7b, 0x85, 0x5a, 0x75, 0x51, 0x83, 0x99, 0xc9, 0xaf,
        0xda, 0x62, 0xc7, 0x51, 0xaf, 0x88, 0x6f, 0xb0, 0x86, 0xd3, 0xab, 0x4e, 0xdc, 0x71, 0xe8, 0xec,
        0x62, 0x81, 0x0e, 0x3a, 0x7e, 0xf0, 0x75, 0x77, 0x3b, 0xfc, 0x6c, 0x25, 0xbf, 0xef, 0x86, 0x95,
        0xf8, 0x07, 0x29, 0xd8, 0xd0, 0xdb, 0xce, 0xed, 0xf9, 0x1e, 0x40, 0x76, 0xd0, 0x69, 0xc8, 0x4f,
        0xcc, 0xda, 0xf5, 0xf5, 0x7a, 0xa7, 0x16, 0x11, 0x23, 0xa0, 0x30, 0x3f, 0x11, 0xfc, 0x5b, 0x86,
        0xad, 0x7a, 0xc5, 0x18, 0xea, 0x7b, 0x46, 0x1c, 0xc9, 0xe9, 0x23, 0xe5, 0x63, 0xe4, 0xfa, 0x1b,
        0x74, 0x94, 0xfe, 0x06, 0x1d, 0x4c, 0xd2, 0x83, 0x0e, 0x7e, 0x0a, 0x48, 0xe8, 0xcf, 0x80, 0x7b,
        0xdf, 0xd4, 0xdc, 0x25, 0xf0, 0x7e, 0x6b, 0x03, 0x56, 0x04, 0xcf, 0xdc, 0xba, 0x79, 0x08, 0xe0,
        0xf7, 0x9a, 0x5e, 0xaf, 0xd1, 0xb3, 0x42, 0x53, 0xe6, 0xce, 0xbc, 0xc6, 0xa8, 0xcf, 0x2d, 0x6e,
        0x43, 0xb9, 0xf0, 0x13, 0xbc, 0x20, 0x61, 0xa2, 0xaa, 0xd1, 0x71, 0xf8, 0x49, 0x31, 0x13, 0xdd,
        0xe8, 0xd6, 0x2b, 0xd1, 0x6b, 0x7f, 0x17, 0x7d, 0x6a, 0x3c, 0x86, 0x2c, 0xbf, 0x93, 0xc0, 0xf7,
        0x83, 0x4b, 0x49, 0x83, 0xe1, 0x33, 0x27, 0x6e, 0x2b, 0xe8, 0x0f, 0x0f, 0x02, 0x0a, 0x26, 0x61,
        0x25, 0x7a, 0x04, 0x1b, 0x6c, 0xde, 0x5d, 0xda, 0x8a, 0x5d, 0xe8, 0x11, 0x1f, 0x7f, 0xcc, 0xd3,
        0x0d, 0x45, 0xc3, 0x44, 0x63, 0xd0, 0x77, 0xa8, 0x2b, 0x73, 0xef, 0x50, 0x9f, 0x01, 0x04, 0x47,
        0xb7, 0x56, 0x7b, 0x7f, 0x35, 0x09, 0x47, 0xa8, 0x5d, 0x1c, 0xbf, 0x72, 0xa8, 0x9c, 0x71, 0x44,
        0xcb, 0xd0, 0x54, 0x35, 0x72, 0x61, 0x37, 0x4c, 0x90, 0xf9, 0x96, 0x9c, 0x01, 0xfb, 0xfb, 0x6b,
        0x49, 0xb7, 0x59, 0xf8, 0x45, 0xf0, 0x20, 0x45, 0x2b, 0x31, 0xe6, 0x72, 0xb9, 0xed, 0xab, 0x8b,
        0xe0, 0xb1, 0x2a, 0x4c, 0xe2, 0xec, 0xe8, 0x39, 0x6c, 0xb0, 0x80, 0xc9, 0x92, 0x12, 0x3e, 0x88,
        0x6c, 0xd2, 0x20, 0xb8, 0x76, 0x83, 0x74, 0x85, 0x4f, 0xd0, 0x4e, 0x18, 0x27, 0x25, 0x0d, 0x13,
        0x8d, 0x21, 0x12, 0xc5, 0x21, 0x16, 0xc5, 0xdb, 0xb1, 0x28, 0xde, 0x56, 0x51, 0xbc, 0x8d, 0x2a,
        0xb0, 0x15, 0x34, 0x77, 0x9b, 0xbe, 0xff, 0xfd, 0xf6, 0xfe, 0xba, 0xba, 0x9e, 0x26, 0xb8, 0xaa,
        0x9c, 0xae, 0x22, 0xb6, 0x4e, 0xc5, 0xc4, 0x60, 0x42, 0xdf, 0x85, 0x9d, 0x2e, 0xed, 0x7d, 0xdf,
        0xf1, 0xce, 0x1b, 0x56, 0xb7, 0x47, 0xbd, 0xd3, 0x66, 0x8b, 0xee, 0x6f, 0x70, 0x44, 0x7e, 0x53,
        0xef, 0xa9, 0xa8, 0x2c, 0x07, 0x75, 0xea, 0xa6, 0x5e, 0xb4, 0x06, 0x93, 0x18, 0x33, 0x73, 0x44,
        0x32, 0x73, 0xb2, 0xdc, 0xfd, 0x4d, 0x35, 0x54, 0x91, 0x19, 0x95, 0xab, 0x6a, 0xa8, 0x01, 0x05,
        0x93, 0xb0, 0x52, 0xcb, 0xbb, 0xda, 0x5d, 0x7f, 0x7f, 0x2b, 0x9a, 0x77, 0x15, 0x9f, 0xd6, 0xa2,
        0x79, 0x57, 0xf1, 0x69, 0x2d, 0xcc, 0xbb, 0x8a, 0x4f, 0x6b, 0x1c, 0x41, 0xe6, 0x5d, 0x96, 0xbb,
        0xbf, 0xad, 0x21, 0x08, 0x2a, 0x97, 0x20, 0x67, 0x64, 0x5d, 0x4c, 0x04, 0x55, 0xad, 0x67, 0x6e,
        0x4c, 0x88, 0x5c, 0x2c, 0x73, 0x13, 0x52, 0x98, 0x99, 0x1b, 0x17, 0x43, 0x63, 0x90, 0x0b, 0xf3,
        0xc4, 0x71, 0x7a, 0x8d, 0xb6, 0xe5, 0x9f, 0xef, 0xef, 0xe8, 0x0b, 0xf3, 0xc8, 0x71, 0x7a, 0x45,
        0xcb, 0x3f, 0xd7, 0x17, 0x66, 0x40, 0xe3, 0x0b, 0x33, 0x28, 0xa0, 0x32, 0x6c, 0x32, 0x18, 0xdb,
        0x69, 0x9d, 0x0b, 0x1c, 0xa4, 0x72, 0xda, 0x7a, 0xe5, 0x88, 0xd1, 0x25, 0x10, 0x0a, 0x81, 0x02,
        0x22, 0x26, 0x3a, 0x0b, 0xfa, 0x18, 0x72, 0xbe, 0xff, 0xbd, 0x46, 0xb3, 0xd5, 0xa2, 0xbe, 0xdf,
        0x70, 0x1d, 0x96, 0x21, 0xef, 0xaa, 0xa8, 0x5a, 0xab, 0x7d, 0x70, 0xc8, 0xab, 0xaa, 0x8e, 0x48,
        0x92, 0x83, 0xaf, 0x27, 0x06, 0x1d, 0x93, 0x08, 0x63, 0x42, 0x8e, 0xb9, 0x77, 0xdd, 0x39, 0xa6,
        0xcb, 0x82, 0xa4, 0x76, 0x53, 0x7a, 0xde, 0x1b, 0x1e, 0xbf, 0xee, 0x74, 0x8d, 0x54, 0xe6, 0x3b,
        0x4e, 0x57, 0x4b, 0x65, 0x58, 0x09, 0x13, 0x4e, 0xc4, 0x7f, 0x91, 0x82, 0xed, 0x7a, 0x65, 0x11,
        0x09, 0xed, 0x13, 0x23, 0xa1, 0x35, 0x02, 0xcb, 0x1c, 0xb9, 0xec, 0x0f, 0x96, 0x99, 0xaa, 0xe6,
        0x3d, 0x0b, 0x79, 0x08, 0x20, 0x22, 0x93, 0x96, 0xf3, 0x89, 0xef, 0x58, 0x8c, 0x2a, 0xdb, 0xe5,
        0xb4, 0x60, 0x24, 0x1a, 0xab, 0x6a, 0xe3, 0x34, 0x25, 0x73, 0x95, 0x53, 0xfa, 0xa5, 0xf9, 0x4e,
        0xe9, 0x29, 0xec, 0x45, 0x22, 0x06, 0x43, 0xf3, 0xf9, 0xd9, 0x63, 0xf6, 0xe8, 0x9d, 0xf1, 0x28,
        0x8f, 0x0c, 0xa7, 0xcf, 0x1a, 0xb1, 0x20, 0xf1, 0x4a, 0x42, 0x90, 0xe0, 0x75, 0x98, 0x24, 0x34,
        0x88, 0x45, 0xdd, 0x95, 0xf9, 0xa2, 0x6e, 0x19, 0x36, 0xc3, 0x68, 0xc3, 0x71, 0x56, 0xd5, 0xe2,
        0x96, 0xe1, 0x43, 0x02, 0x21, 0x23, 0xc0, 0x08, 0x24, 0x9d, 0x25, 0x12, 0x62, 0xd6, 0xae, 0x1e,
        0x62, 0xb2, 0x57, 0x08, 0x31, 0xf8, 0x8c, 0xad, 0x9e, 0x45, 0xec, 0x85, 0xfe, 0x81, 0xe7, 0xcf,
        0x5f, 0xf2, 0x6d, 0xd0, 0x0f, 0x53, 0xb0, 0x5d, 0xa8, 0x55, 0x17, 0x30, 0x8e, 0x99, 0x76, 0x40,
        0xff, 0xcc, 0x7d, 0xdf, 0x21, 0x6f, 0xf5, 0x05, 0x52, 0xeb, 0x3b, 0xb0, 0xd2, 0xd4, 0xcf, 0x5a,
        0xb9, 0xd3, 0x6f, 0x06, 0x07, 0xad, 0xd2, 0xe9, 0x37, 0xe5, 0x29, 0xab, 0xac, 0xc0, 0x3f, 0x4a,
        0xc3, 0x66, 0xad, 0xf6, 0x01, 0xe9, 0x87, 0x23, 0x79, 0x00, 0x59, 0x6e, 0xe6, 0xda, 0x18, 0xf8,
        0x3a, 0x61, 0xd6, 0x2b, 0x3b, 0x97, 0xeb, 0x24, 0xa0, 0x60, 0x12, 0x56, 0x46, 0x4f, 0x75, 0xd2,
        0xdc, 0xad, 0x5c, 0xfa, 0x54, 0x87, 0xf9, 0x3a, 0xea, 0x0d, 0xd8, 0x62, 0x73, 0xbc, 0x9e, 0xf1,
        0x45, 0x92, 0x93, 0xe5, 0xd7, 0x86, 0xc0, 0xd7, 0x85, 0x34, 0xe6, 0xeb, 0xc2, 0x02, 0x7a, 0x0f,
        0x56, 0x5b, 0x4e, 0xa7, 0xd3, 0xec, 0xb6, 0xa5, 0xb7, 0xe4, 0xae, 0xb6, 0x20, 0x48, 0xca, 0xd5,
        0x4a, 0x02, 0x26, 0x41, 0xd5, 0xdb, 0xbf, 0xbf, 0x0e, 0x99, 0x42, 0xb9, 0x82, 0x0a, 0xb0, 0xae,
        0x3d, 0xc9, 0x45, 0xdb, 0x2a, 0xf6, 0xf0, 0x57, 0xdb, 0x07, 0xaf, 0x29, 0xc2, 0x84, 0xa7, 0xbb,
        0xf8, 0x06, 0xfa, 0x0e, 0xec, 0x88, 0x70, 0xa3, 0x3d, 0xa0, 0x44, 0xf7, 0x27, 0xbe, 0x4d, 0x95,
        0xd3, 0xa0, 0x63, 0x4f, 0x78, 0xef, 0x8a, 0x6f, 0xa0, 0x63, 0xd8, 0x8e, 0x3c, 0x88, 0x8d, 0x0b,
        0xf9, 0x7a, 0x82, 0x90, 0x89, 0x60, 0x75, 0xd8, 0x2a, 0x51, 0x03, 0x2b, 0x9f, 0x28, 0x83, 0x5a,
        0x84, 0xb3, 0x09, 0xf9, 0x11, 0xec, 0x14, 0xa9, 0x4d, 0x4d, 0x05, 0x5c, 0x08, 0xad, 0x5d, 0x7e,
        0x8e, 0x3c, 0x1c, 0xc7, 0x37, 0xd0, 0xb7, 0x21, 0x27, 0x75, 0x1a, 0x3e, 0xde, 0x30, 0x10, 0x93,
        0xde, 0x92, 0x1e, 0xdc, 0x9f, 0xcc, 0x10, 0x02, 0x97, 0x61, 0xcb, 0x7c, 0xa3, 0x19, 0xd7, 0xe7,
        0x57, 0x23, 0xfa, 0x9c, 0x04, 0x55, 0x83, 0xcd, 0x12, 0xd5, 0x91, 0xee, 0x25, 0xf5, 0xaf, 0x8d,
        0x78, 0x16, 0xf9, 0x9e, 0x41, 0x4e, 0xea, 0x72, 0x76, 0xdc, 0xa9, 0x9a, 0x3c, 0x86, 0x8d, 0x20,
        0x89, 0xe3, 0x49, 0xe0, 0x9d, 0xa4, 0xd7, 0x7a, 0x01, 0xd2, 0xdd, 0xe4, 0xca, 0x10, 0xec, 0x10,
        0x40, 0xbd, 0x09, 0x8c, 0x6b, 0xee, 0xbe, 0xa9, 0xb9, 0x44, 0x88, 0x12, 0x64, 0x4b, 0x34, 0x40,
        0x38, 0x88, 0xf6, 0xa7, 0x8d, 0xea, 0x22, 0x59, 0x4a, 0xb0, 0x21, 0x34, 0x35, 0x03, 0xd6, 0x54,
        0x0d, 0x59, 0xfc, 0xa5, 0x30, 0xb3, 0xb5, 0xc8, 0x83, 0x1e, 0xf4, 0xfa, 0xf4, 0x67, 0x5d, 0x01,
        0xfa, 0xcf, 0x5c, 0xc4, 0x16, 0x76, 0xf5, 0x31, 0xec, 0x25, 0x3d, 0x2d, 0x8b, 0x6b, 0xf2, 0xe7,
        0x23, 0x36, 0x38, 0x1d, 0x96, 0xc2, 0x2e, 0xb3, 0xc4, 0x28, 0xea, 0x57, 0x27, 0xcb, 0xa5, 0xe9,
        0x66, 0x76, 0xe9, 0x7f, 0x05, 0x6e, 0x49, 0xdb, 0x9c, 0xaf, 0xa7, 0x69, 0xb3, 0xf0, 0xf6, 0x1f,
        0xde, 0x82, 0x4c, 0xa1, 0x50, 0x41, 0x1f, 0xc2, 0xba, 0x4c, 0xde, 0x59, 0x4a, 0x8d, 0xee, 0x26,
        0x3e, 0x91, 0x08, 0x10, 0xef, 0x24, 0x3c, 0x85, 0xd1, 0x04, 0x7e, 0x02, 0xd9, 0xf0, 0x45, 0x4d,
        0x0c, 0xc9, 0x48, 0xce, 0x0e, 0xf2, 0xa6, 0xc2, 0x93, 0xd0, 0x8a, 0xb0, 0x56, 0xa2, 0x12, 0x2c,
        0xfa, 0x72, 0x43, 0x43, 0xba, 0x40, 0xa6, 0x47, 0xb0, 0x2e, 0x94, 0x78, 0x21, 0xd0, 0x54, 0xa3,
        0x7d, 0x26, 0x56, 0xa2, 0x48, 0xa5, 0xd1, 0xab, 0xd1, 0xa7, 0x03, 0xe6, 0xe0, 0x22, 0xeb, 0x32,
        0xfe, 0x14, 0x21, 0x5c, 0x97, 0x12, 0xef, 0x20, 0x8a, 0x97, 0xbc, 0x2e, 0x13, 0x81, 0x3e, 0x84,
        0x4d, 0xd6, 0xc9, 0x33, 0xef, 0x6c, 0x36, 0xe1, 0xb4, 0x87, 0xf0, 0xe6, 0x0f, 0x7f, 0xe0, 0x1b,
        0xe8, 0x31, 0x6c, 0x94, 0xa8, 0x06, 0x35, 0x4d, 0xae, 0x69, 0x38, 0x45, 0xc8, 0x0a, 0xc3, 0xa9,
        0x57, 0x0b, 0x06, 0x48, 0xe4, 0x82, 0xaa, 0xae, 0xf3, 0xc8, 0x75, 0x6a, 0x2e, 0xcd, 0xaa, 0xbc,
        0x67, 0x1d, 0xc1, 0x30, 0x07, 0xf4, 0x6a, 0x44, 0xdb, 0x31, 0x9c, 0x6f, 0xc1, 0x0a, 0x53, 0x75,
        0xb5, 0x80, 0xcc, 0xbb, 0xaa, 0xc9, 0x73, 0x1f, 0x6f, 0x7f, 0x08, 0x59, 0x61, 0x42, 0xb3, 0x42,
        0xc4, 0xcd, 0xa7, 0x22, 0xcc, 0xe7, 0xd0, 0xb6, 0x2f, 0x1a, 0xcd, 0x6b, 0x13, 0xdf, 0x16, 0x26,
        0xf9, 0x62, 0x71, 0x23, 0x51, 0x07, 0x8c, 0xde, 0x51, 0x9c, 0x2e, 0x57, 0x11, 0xb2, 0x87, 0xed,
        0xb6, 0xd8, 0xce, 0xa2, 0xd8, 0xfd, 0x3c, 0x75, 0xb3, 0x70, 0xba, 0x82, 0x4a, 0xb0, 0x41, 0x68,
        0xc7, 0x19, 0xd0, 0x49, 0x40, 0xb3, 0xab, 0x69, 0x5b, 0x00, 0x85, 0xd7, 0xd8, 0x74, 0x6b, 0x4e,
        0xb8, 0xdb, 0x36, 0x1d, 0xae, 0xc6, 0x7f, 0xa7, 0xa1, 0xd9, 0xa3, 0xc1, 0x86, 0x5a, 0xcf, 0x69,
        0x12, 0xaf, 0xa2, 0x1c, 0xdc, 0x4b, 0xbe, 0xd3, 0x65, 0xc4, 0x94, 0x0d, 0xfd, 0x82, 0x58, 0x12,
        0xa4, 0x39, 0xa3, 0xd8, 0xb4, 0xcf, 0x09, 0xb0, 0x15, 0x58, 0x2f, 0x51, 0x85, 0x9a, 0x70, 0x5d,
        0x45, 0x83, 0xbc, 0x58, 0xca, 0x63, 0xd8, 0x12, 0x16, 0x32, 0x23, 0xe2, 0x05, 0xd9, 0xe1, 0xb6,
        0xb4, 0xde, 0xd9, 0x47, 0x3d, 0x93, 0x1d, 0xab, 0x4c, 0x56, 0x5d, 0x76, 0x30, 0xf2, 0xce, 0xa4,
        0x3b, 0x10, 0xd3, 0x65, 0x7d, 0x12, 0xb8, 0x1e, 0xb6, 0xed, 0xb9, 0x37, 0xe1, 0x6b, 0x6d, 0x82,
        0xeb, 0x48, 0xb8, 0x72, 0x80, 0x6f, 0xa0, 0xa7, 0xc2, 0x05, 0x25, 0x63, 0x4d, 0x1c, 0xf0, 0x84,
        0x2b, 0x0c, 0xdc, 0xa5, 0x31, 0x57, 0xc4, 0xe0, 0xe2, 0x1f, 0x92, 0x93, 0x5d, 0x5a, 0x32, 0xce,
        0xa3, 0xc0, 0x25, 0x5d, 0x08, 0x35, 0x55, 0x59, 0x1f, 0x85, 0x6e, 0xe9, 0x92, 0x23, 0x9c, 0x3c,
        0xa5, 0xc7, 0x9a, 0x6b, 0x8a, 0x80, 0x26, 0x7d, 0x78, 0x9d, 0x2e, 0xdf, 0x43, 0x58, 0xe5, 0x9f,
        0xc4, 0xea, 0x15, 0x3d, 0x70, 0x47, 0x8e, 0x49, 0xf5, 0x48, 0x64, 0x7e, 0x04, 0xc4, 0x37, 0xd0,
        0x11, 0x64, 0x0b, 0x4e, 0xb7, 0xe7, 0x39, 0x76, 0x14, 0xc3, 0x38, 0x6e, 0x30, 0xa3, 0x99, 0xfe,
        0xdb, 0x53, 0x3c, 0xf6, 0x6f, 0xe8, 0x1f, 0x68, 0x23, 0x30, 0xd3, 0xd6, 0x7a, 0xd2, 0x37, 0x5d,
        0x1e, 0x50, 0xd6, 0x45, 0xec, 0x17, 0x78, 0xc6, 0x11, 0xec, 0xa4, 0x08, 0x1b, 0x91, 0xa9, 0x00,
        0x2b, 0xa2, 0x83, 0x69, 0xd2, 0xdc, 0x8d, 0x4a, 0x13, 0x91, 0xe3, 0x1b, 0xb0, 0xcc, 0xe5, 0x98,
        0x45, 0x82, 0x58, 0xe3, 0x43, 0x58, 0x7f, 0x4e, 0xbd, 0x8e, 0xd5, 0x65, 0x61, 0xbe, 0x32, 0xd7,
        0x20, 0x8e, 0x45, 0xbe, 0xc8, 0xa2, 0xe2, 0xd4, 0x71, 0xcc, 0x18, 0x13, 0xb7, 0x42, 0x79, 0xf8,
        0xd9, 0x96, 0x8e, 0x18, 0x39, 0xec, 0x9a, 0x26, 0xd5, 0xdb, 0x45, 0xc8, 0xd4, 0x6a, 0x1f, 0xa0,
        0x6f, 0xc2, 0x8a, 0x38, 0xc7, 0xd1, 0x43, 0xbe, 0x71, 0xb2, 0x33, 0x2d, 0x05, 0x3a, 0xca, 0xfd,
        0xf4, 0xf3, 0x7b, 0xa9, 0x7f, 0xfd, 0xfc, 0x5e, 0xea, 0xdf, 0x3f, 0xbf, 0x97, 0xfa, 0xa3, 0xff,
        0xb8, 0x77, 0xe3, 0x64, 0x85, 0x5f, 0xd7, 0x7c, 0xe7, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb5,
        0x76, 0xe2, 0xc3, 0xca, 0x4e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CIMClient is the client API for CIM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CIMClient interface {
        ListCloudOS(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudOSInfoResponse, error)
        CreateCloudDriver(ctx context.Context, in *CloudDriverInfoRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error)
        ListCloudDriver(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudDriverInfoResponse, error)
        GetCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error)
        DeleteCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateCredential(ctx context.Context, in *CredentialInfoRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error)
        ListCredential(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCredentialInfoResponse, error)
        GetCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error)
        DeleteCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateRegion(ctx context.Context, in *RegionInfoRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error)
        ListRegion(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListRegionInfoResponse, error)
        GetRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error)
        DeleteRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateConnectionConfig(ctx context.Context, in *ConnectionConfigInfoRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error)
        ListConnectionConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListConnectionConfigInfoResponse, error)
        GetConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error)
        DeleteConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
}

type cIMClient struct {
        cc *grpc.ClientConn
}

func NewCIMClient(cc *grpc.ClientConn) CIMClient <span class="cov8" title="1">{
        return &amp;cIMClient{cc}
}</span>

func (c *cIMClient) ListCloudOS(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudOSInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListCloudOSInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListCloudOS", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateCloudDriver(ctx context.Context, in *CloudDriverInfoRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        out := new(CloudDriverInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListCloudDriver(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudDriverInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListCloudDriverInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        out := new(CloudDriverInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateCredential(ctx context.Context, in *CredentialInfoRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error) <span class="cov8" title="1">{
        out := new(CredentialInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListCredential(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCredentialInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListCredentialInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error) <span class="cov8" title="1">{
        out := new(CredentialInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateRegion(ctx context.Context, in *RegionInfoRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error) <span class="cov8" title="1">{
        out := new(RegionInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListRegion(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListRegionInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListRegionInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error) <span class="cov8" title="1">{
        out := new(RegionInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateConnectionConfig(ctx context.Context, in *ConnectionConfigInfoRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        out := new(ConnectionConfigInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListConnectionConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListConnectionConfigInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        out := new(ConnectionConfigInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// CIMServer is the server API for CIM service.
type CIMServer interface {
        ListCloudOS(context.Context, *Empty) (*ListCloudOSInfoResponse, error)
        CreateCloudDriver(context.Context, *CloudDriverInfoRequest) (*CloudDriverInfoResponse, error)
        ListCloudDriver(context.Context, *Empty) (*ListCloudDriverInfoResponse, error)
        GetCloudDriver(context.Context, *CloudDriverQryRequest) (*CloudDriverInfoResponse, error)
        DeleteCloudDriver(context.Context, *CloudDriverQryRequest) (*BooleanResponse, error)
        CreateCredential(context.Context, *CredentialInfoRequest) (*CredentialInfoResponse, error)
        ListCredential(context.Context, *Empty) (*ListCredentialInfoResponse, error)
        GetCredential(context.Context, *CredentialQryRequest) (*CredentialInfoResponse, error)
        DeleteCredential(context.Context, *CredentialQryRequest) (*BooleanResponse, error)
        CreateRegion(context.Context, *RegionInfoRequest) (*RegionInfoResponse, error)
        ListRegion(context.Context, *Empty) (*ListRegionInfoResponse, error)
        GetRegion(context.Context, *RegionQryRequest) (*RegionInfoResponse, error)
        DeleteRegion(context.Context, *RegionQryRequest) (*BooleanResponse, error)
        CreateConnectionConfig(context.Context, *ConnectionConfigInfoRequest) (*ConnectionConfigInfoResponse, error)
        ListConnectionConfig(context.Context, *Empty) (*ListConnectionConfigInfoResponse, error)
        GetConnectionConfig(context.Context, *ConnectionConfigQryRequest) (*ConnectionConfigInfoResponse, error)
        DeleteConnectionConfig(context.Context, *ConnectionConfigQryRequest) (*BooleanResponse, error)
}

// UnimplementedCIMServer can be embedded to have forward compatible implementations.
type UnimplementedCIMServer struct {
}

func (*UnimplementedCIMServer) ListCloudOS(ctx context.Context, req *Empty) (*ListCloudOSInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCloudOS not implemented")
}</span>
func (*UnimplementedCIMServer) CreateCloudDriver(ctx context.Context, req *CloudDriverInfoRequest) (*CloudDriverInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) ListCloudDriver(ctx context.Context, req *Empty) (*ListCloudDriverInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) GetCloudDriver(ctx context.Context, req *CloudDriverQryRequest) (*CloudDriverInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteCloudDriver(ctx context.Context, req *CloudDriverQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) CreateCredential(ctx context.Context, req *CredentialInfoRequest) (*CredentialInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateCredential not implemented")
}</span>
func (*UnimplementedCIMServer) ListCredential(ctx context.Context, req *Empty) (*ListCredentialInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCredential not implemented")
}</span>
func (*UnimplementedCIMServer) GetCredential(ctx context.Context, req *CredentialQryRequest) (*CredentialInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCredential not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteCredential(ctx context.Context, req *CredentialQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCredential not implemented")
}</span>
func (*UnimplementedCIMServer) CreateRegion(ctx context.Context, req *RegionInfoRequest) (*RegionInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateRegion not implemented")
}</span>
func (*UnimplementedCIMServer) ListRegion(ctx context.Context, req *Empty) (*ListRegionInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListRegion not implemented")
}</span>
func (*UnimplementedCIMServer) GetRegion(ctx context.Context, req *RegionQryRequest) (*RegionInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetRegion not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteRegion(ctx context.Context, req *RegionQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteRegion not implemented")
}</span>
func (*UnimplementedCIMServer) CreateConnectionConfig(ctx context.Context, req *ConnectionConfigInfoRequest) (*ConnectionConfigInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateConnectionConfig not implemented")
}</span>
func (*UnimplementedCIMServer) ListConnectionConfig(ctx context.Context, req *Empty) (*ListConnectionConfigInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListConnectionConfig not implemented")
}</span>
func (*UnimplementedCIMServer) GetConnectionConfig(ctx context.Context, req *ConnectionConfigQryRequest) (*ConnectionConfigInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetConnectionConfig not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteConnectionConfig(ctx context.Context, req *ConnectionConfigQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteConnectionConfig not implemented")
}</span>

func RegisterCIMServer(s *grpc.Server, srv CIMServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_CIM_serviceDesc, srv)
}</span>

func _CIM_ListCloudOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListCloudOS(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListCloudOS",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListCloudOS(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CloudDriverInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateCloudDriver(ctx, req.(*CloudDriverInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListCloudDriver(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CloudDriverQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetCloudDriver(ctx, req.(*CloudDriverQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CloudDriverQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteCloudDriver(ctx, req.(*CloudDriverQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CredentialInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateCredential(ctx, req.(*CredentialInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListCredential(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CredentialQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetCredential(ctx, req.(*CredentialQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CredentialQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteCredential(ctx, req.(*CredentialQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RegionInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateRegion(ctx, req.(*RegionInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListRegion(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RegionQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetRegion(ctx, req.(*RegionQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RegionQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteRegion(ctx, req.(*RegionQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ConnectionConfigInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateConnectionConfig(ctx, req.(*ConnectionConfigInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListConnectionConfig(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ConnectionConfigQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetConnectionConfig(ctx, req.(*ConnectionConfigQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ConnectionConfigQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteConnectionConfig(ctx, req.(*ConnectionConfigQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

var _CIM_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cbspider.CIM",
        HandlerType: (*CIMServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "ListCloudOS",
                        Handler:    _CIM_ListCloudOS_Handler,
                },
                {
                        MethodName: "CreateCloudDriver",
                        Handler:    _CIM_CreateCloudDriver_Handler,
                },
                {
                        MethodName: "ListCloudDriver",
                        Handler:    _CIM_ListCloudDriver_Handler,
                },
                {
                        MethodName: "GetCloudDriver",
                        Handler:    _CIM_GetCloudDriver_Handler,
                },
                {
                        MethodName: "DeleteCloudDriver",
                        Handler:    _CIM_DeleteCloudDriver_Handler,
                },
                {
                        MethodName: "CreateCredential",
                        Handler:    _CIM_CreateCredential_Handler,
                },
                {
                        MethodName: "ListCredential",
                        Handler:    _CIM_ListCredential_Handler,
                },
                {
                        MethodName: "GetCredential",
                        Handler:    _CIM_GetCredential_Handler,
                },
                {
                        MethodName: "DeleteCredential",
                        Handler:    _CIM_DeleteCredential_Handler,
                },
                {
                        MethodName: "CreateRegion",
                        Handler:    _CIM_CreateRegion_Handler,
                },
                {
                        MethodName: "ListRegion",
                        Handler:    _CIM_ListRegion_Handler,
                },
                {
                        MethodName: "GetRegion",
                        Handler:    _CIM_GetRegion_Handler,
                },
                {
                        MethodName: "DeleteRegion",
                        Handler:    _CIM_DeleteRegion_Handler,
                },
                {
                        MethodName: "CreateConnectionConfig",
                        Handler:    _CIM_CreateConnectionConfig_Handler,
                },
                {
                        MethodName: "ListConnectionConfig",
                        Handler:    _CIM_ListConnectionConfig_Handler,
                },
                {
                        MethodName: "GetConnectionConfig",
                        Handler:    _CIM_GetConnectionConfig_Handler,
                },
                {
                        MethodName: "DeleteConnectionConfig",
                        Handler:    _CIM_DeleteConnectionConfig_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cbspider.proto",
}

// CCMClient is the client API for CCM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CCMClient interface {
        CreateImage(ctx context.Context, in *ImageCreateRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error)
        ListImage(ctx context.Context, in *ImageAllQryRequest, opts ...grpc.CallOption) (*ListImageInfoResponse, error)
        GetImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error)
        DeleteImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*ListVMSpecInfoResponse, error)
        GetVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*VMSpecInfoResponse, error)
        ListOrgVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*StringResponse, error)
        GetOrgVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*StringResponse, error)
        CreateVPC(ctx context.Context, in *VPCCreateRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error)
        ListVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*ListVPCInfoResponse, error)
        GetVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error)
        DeleteVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListAllVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        DeleteCSPVPC(ctx context.Context, in *CSPVPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        AddSubnet(ctx context.Context, in *SubnetAddRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error)
        RemoveSubnet(ctx context.Context, in *SubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        RemoveCSPSubnet(ctx context.Context, in *CSPSubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateSecurity(ctx context.Context, in *SecurityCreateRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error)
        ListSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*ListSecurityInfoResponse, error)
        GetSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error)
        DeleteSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListAllSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        DeleteCSPSecurity(ctx context.Context, in *CSPSecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateKey(ctx context.Context, in *KeyPairCreateRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error)
        ListKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*ListKeyPairInfoResponse, error)
        GetKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error)
        DeleteKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListAllKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        DeleteCSPKey(ctx context.Context, in *CSPKeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        StartVM(ctx context.Context, in *VMCreateRequest, opts ...grpc.CallOption) (*VMInfoResponse, error)
        ControlVM(ctx context.Context, in *VMActionRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        ListVMStatus(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMStatusInfoResponse, error)
        GetVMStatus(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        ListVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMInfoResponse, error)
        GetVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*VMInfoResponse, error)
        TerminateVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        ListAllVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        TerminateCSPVM(ctx context.Context, in *CSPVMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type cCMClient struct {
        cc *grpc.ClientConn
}

func NewCCMClient(cc *grpc.ClientConn) CCMClient <span class="cov8" title="1">{
        return &amp;cCMClient{cc}
}</span>

func (c *cCMClient) CreateImage(ctx context.Context, in *ImageCreateRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error) <span class="cov8" title="1">{
        out := new(ImageInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListImage(ctx context.Context, in *ImageAllQryRequest, opts ...grpc.CallOption) (*ListImageInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListImageInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error) <span class="cov8" title="1">{
        out := new(ImageInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*ListVMSpecInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVMSpecInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*VMSpecInfoResponse, error) <span class="cov8" title="1">{
        out := new(VMSpecInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListOrgVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*StringResponse, error) <span class="cov8" title="1">{
        out := new(StringResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListOrgVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetOrgVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*StringResponse, error) <span class="cov8" title="1">{
        out := new(StringResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetOrgVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) CreateVPC(ctx context.Context, in *VPCCreateRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(VPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*ListVPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(VPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteCSPVPC(ctx context.Context, in *CSPVPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteCSPVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) AddSubnet(ctx context.Context, in *SubnetAddRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(VPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/AddSubnet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) RemoveSubnet(ctx context.Context, in *SubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/RemoveSubnet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) RemoveCSPSubnet(ctx context.Context, in *CSPSubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/RemoveCSPSubnet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) CreateSecurity(ctx context.Context, in *SecurityCreateRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error) <span class="cov8" title="1">{
        out := new(SecurityInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*ListSecurityInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListSecurityInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error) <span class="cov8" title="1">{
        out := new(SecurityInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteCSPSecurity(ctx context.Context, in *CSPSecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteCSPSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) CreateKey(ctx context.Context, in *KeyPairCreateRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error) <span class="cov8" title="1">{
        out := new(KeyPairInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*ListKeyPairInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListKeyPairInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error) <span class="cov8" title="1">{
        out := new(KeyPairInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteCSPKey(ctx context.Context, in *CSPKeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteCSPKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) StartVM(ctx context.Context, in *VMCreateRequest, opts ...grpc.CallOption) (*VMInfoResponse, error) <span class="cov8" title="1">{
        out := new(VMInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/StartVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ControlVM(ctx context.Context, in *VMActionRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ControlVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVMStatus(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMStatusInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVMStatusInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVMStatus", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVMStatus(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVMStatus", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVMInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*VMInfoResponse, error) <span class="cov8" title="1">{
        out := new(VMInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) TerminateVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/TerminateVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) TerminateCSPVM(ctx context.Context, in *CSPVMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/TerminateCSPVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// CCMServer is the server API for CCM service.
type CCMServer interface {
        CreateImage(context.Context, *ImageCreateRequest) (*ImageInfoResponse, error)
        ListImage(context.Context, *ImageAllQryRequest) (*ListImageInfoResponse, error)
        GetImage(context.Context, *ImageQryRequest) (*ImageInfoResponse, error)
        DeleteImage(context.Context, *ImageQryRequest) (*BooleanResponse, error)
        ListVMSpec(context.Context, *VMSpecAllQryRequest) (*ListVMSpecInfoResponse, error)
        GetVMSpec(context.Context, *VMSpecQryRequest) (*VMSpecInfoResponse, error)
        ListOrgVMSpec(context.Context, *VMSpecAllQryRequest) (*StringResponse, error)
        GetOrgVMSpec(context.Context, *VMSpecQryRequest) (*StringResponse, error)
        CreateVPC(context.Context, *VPCCreateRequest) (*VPCInfoResponse, error)
        ListVPC(context.Context, *VPCAllQryRequest) (*ListVPCInfoResponse, error)
        GetVPC(context.Context, *VPCQryRequest) (*VPCInfoResponse, error)
        DeleteVPC(context.Context, *VPCQryRequest) (*BooleanResponse, error)
        ListAllVPC(context.Context, *VPCAllQryRequest) (*AllResourceInfoResponse, error)
        DeleteCSPVPC(context.Context, *CSPVPCQryRequest) (*BooleanResponse, error)
        AddSubnet(context.Context, *SubnetAddRequest) (*VPCInfoResponse, error)
        RemoveSubnet(context.Context, *SubnetQryRequest) (*BooleanResponse, error)
        RemoveCSPSubnet(context.Context, *CSPSubnetQryRequest) (*BooleanResponse, error)
        CreateSecurity(context.Context, *SecurityCreateRequest) (*SecurityInfoResponse, error)
        ListSecurity(context.Context, *SecurityAllQryRequest) (*ListSecurityInfoResponse, error)
        GetSecurity(context.Context, *SecurityQryRequest) (*SecurityInfoResponse, error)
        DeleteSecurity(context.Context, *SecurityQryRequest) (*BooleanResponse, error)
        ListAllSecurity(context.Context, *SecurityAllQryRequest) (*AllResourceInfoResponse, error)
        DeleteCSPSecurity(context.Context, *CSPSecurityQryRequest) (*BooleanResponse, error)
        CreateKey(context.Context, *KeyPairCreateRequest) (*KeyPairInfoResponse, error)
        ListKey(context.Context, *KeyPairAllQryRequest) (*ListKeyPairInfoResponse, error)
        GetKey(context.Context, *KeyPairQryRequest) (*KeyPairInfoResponse, error)
        DeleteKey(context.Context, *KeyPairQryRequest) (*BooleanResponse, error)
        ListAllKey(context.Context, *KeyPairAllQryRequest) (*AllResourceInfoResponse, error)
        DeleteCSPKey(context.Context, *CSPKeyPairQryRequest) (*BooleanResponse, error)
        StartVM(context.Context, *VMCreateRequest) (*VMInfoResponse, error)
        ControlVM(context.Context, *VMActionRequest) (*StatusResponse, error)
        ListVMStatus(context.Context, *VMAllQryRequest) (*ListVMStatusInfoResponse, error)
        GetVMStatus(context.Context, *VMQryRequest) (*StatusResponse, error)
        ListVM(context.Context, *VMAllQryRequest) (*ListVMInfoResponse, error)
        GetVM(context.Context, *VMQryRequest) (*VMInfoResponse, error)
        TerminateVM(context.Context, *VMQryRequest) (*StatusResponse, error)
        ListAllVM(context.Context, *VMAllQryRequest) (*AllResourceInfoResponse, error)
        TerminateCSPVM(context.Context, *CSPVMQryRequest) (*StatusResponse, error)
}

// UnimplementedCCMServer can be embedded to have forward compatible implementations.
type UnimplementedCCMServer struct {
}

func (*UnimplementedCCMServer) CreateImage(ctx context.Context, req *ImageCreateRequest) (*ImageInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateImage not implemented")
}</span>
func (*UnimplementedCCMServer) ListImage(ctx context.Context, req *ImageAllQryRequest) (*ListImageInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListImage not implemented")
}</span>
func (*UnimplementedCCMServer) GetImage(ctx context.Context, req *ImageQryRequest) (*ImageInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetImage not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteImage(ctx context.Context, req *ImageQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}</span>
func (*UnimplementedCCMServer) ListVMSpec(ctx context.Context, req *VMSpecAllQryRequest) (*ListVMSpecInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) GetVMSpec(ctx context.Context, req *VMSpecQryRequest) (*VMSpecInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) ListOrgVMSpec(ctx context.Context, req *VMSpecAllQryRequest) (*StringResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListOrgVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) GetOrgVMSpec(ctx context.Context, req *VMSpecQryRequest) (*StringResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOrgVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) CreateVPC(ctx context.Context, req *VPCCreateRequest) (*VPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateVPC not implemented")
}</span>
func (*UnimplementedCCMServer) ListVPC(ctx context.Context, req *VPCAllQryRequest) (*ListVPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVPC not implemented")
}</span>
func (*UnimplementedCCMServer) GetVPC(ctx context.Context, req *VPCQryRequest) (*VPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVPC not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteVPC(ctx context.Context, req *VPCQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteVPC not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllVPC(ctx context.Context, req *VPCAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllVPC not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteCSPVPC(ctx context.Context, req *CSPVPCQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCSPVPC not implemented")
}</span>
func (*UnimplementedCCMServer) AddSubnet(ctx context.Context, req *SubnetAddRequest) (*VPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddSubnet not implemented")
}</span>
func (*UnimplementedCCMServer) RemoveSubnet(ctx context.Context, req *SubnetQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveSubnet not implemented")
}</span>
func (*UnimplementedCCMServer) RemoveCSPSubnet(ctx context.Context, req *CSPSubnetQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveCSPSubnet not implemented")
}</span>
func (*UnimplementedCCMServer) CreateSecurity(ctx context.Context, req *SecurityCreateRequest) (*SecurityInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) ListSecurity(ctx context.Context, req *SecurityAllQryRequest) (*ListSecurityInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) GetSecurity(ctx context.Context, req *SecurityQryRequest) (*SecurityInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteSecurity(ctx context.Context, req *SecurityQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllSecurity(ctx context.Context, req *SecurityAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteCSPSecurity(ctx context.Context, req *CSPSecurityQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCSPSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) CreateKey(ctx context.Context, req *KeyPairCreateRequest) (*KeyPairInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateKey not implemented")
}</span>
func (*UnimplementedCCMServer) ListKey(ctx context.Context, req *KeyPairAllQryRequest) (*ListKeyPairInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListKey not implemented")
}</span>
func (*UnimplementedCCMServer) GetKey(ctx context.Context, req *KeyPairQryRequest) (*KeyPairInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteKey(ctx context.Context, req *KeyPairQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteKey not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllKey(ctx context.Context, req *KeyPairAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllKey not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteCSPKey(ctx context.Context, req *CSPKeyPairQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCSPKey not implemented")
}</span>
func (*UnimplementedCCMServer) StartVM(ctx context.Context, req *VMCreateRequest) (*VMInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StartVM not implemented")
}</span>
func (*UnimplementedCCMServer) ControlVM(ctx context.Context, req *VMActionRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ControlVM not implemented")
}</span>
func (*UnimplementedCCMServer) ListVMStatus(ctx context.Context, req *VMAllQryRequest) (*ListVMStatusInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVMStatus not implemented")
}</span>
func (*UnimplementedCCMServer) GetVMStatus(ctx context.Context, req *VMQryRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVMStatus not implemented")
}</span>
func (*UnimplementedCCMServer) ListVM(ctx context.Context, req *VMAllQryRequest) (*ListVMInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVM not implemented")
}</span>
func (*UnimplementedCCMServer) GetVM(ctx context.Context, req *VMQryRequest) (*VMInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVM not implemented")
}</span>
func (*UnimplementedCCMServer) TerminateVM(ctx context.Context, req *VMQryRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TerminateVM not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllVM(ctx context.Context, req *VMAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllVM not implemented")
}</span>
func (*UnimplementedCCMServer) TerminateCSPVM(ctx context.Context, req *CSPVMQryRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TerminateCSPVM not implemented")
}</span>

func RegisterCCMServer(s *grpc.Server, srv CCMServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_CCM_serviceDesc, srv)
}</span>

func _CCM_CreateImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateImage(ctx, req.(*ImageCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListImage(ctx, req.(*ImageAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetImage(ctx, req.(*ImageQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteImage(ctx, req.(*ImageQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVMSpec(ctx, req.(*VMSpecAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVMSpec(ctx, req.(*VMSpecQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListOrgVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListOrgVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListOrgVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListOrgVMSpec(ctx, req.(*VMSpecAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetOrgVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetOrgVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetOrgVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetOrgVMSpec(ctx, req.(*VMSpecQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_CreateVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateVPC(ctx, req.(*VPCCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVPC(ctx, req.(*VPCAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVPC(ctx, req.(*VPCQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteVPC(ctx, req.(*VPCQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllVPC(ctx, req.(*VPCAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteCSPVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPVPCQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteCSPVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteCSPVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteCSPVPC(ctx, req.(*CSPVPCQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_AddSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SubnetAddRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).AddSubnet(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/AddSubnet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).AddSubnet(ctx, req.(*SubnetAddRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_RemoveSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SubnetQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).RemoveSubnet(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/RemoveSubnet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).RemoveSubnet(ctx, req.(*SubnetQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_RemoveCSPSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPSubnetQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).RemoveCSPSubnet(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/RemoveCSPSubnet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).RemoveCSPSubnet(ctx, req.(*CSPSubnetQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_CreateSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateSecurity(ctx, req.(*SecurityCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListSecurity(ctx, req.(*SecurityAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetSecurity(ctx, req.(*SecurityQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteSecurity(ctx, req.(*SecurityQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllSecurity(ctx, req.(*SecurityAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteCSPSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPSecurityQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteCSPSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteCSPSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteCSPSecurity(ctx, req.(*CSPSecurityQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateKey(ctx, req.(*KeyPairCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListKey(ctx, req.(*KeyPairAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetKey(ctx, req.(*KeyPairQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteKey(ctx, req.(*KeyPairQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllKey(ctx, req.(*KeyPairAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteCSPKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPKeyPairQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteCSPKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteCSPKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteCSPKey(ctx, req.(*CSPKeyPairQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_StartVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).StartVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/StartVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).StartVM(ctx, req.(*VMCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ControlVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMActionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ControlVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ControlVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ControlVM(ctx, req.(*VMActionRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVMStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVMStatus(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVMStatus",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVMStatus(ctx, req.(*VMAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVMStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVMStatus(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVMStatus",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVMStatus(ctx, req.(*VMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVM(ctx, req.(*VMAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVM(ctx, req.(*VMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_TerminateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).TerminateVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/TerminateVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).TerminateVM(ctx, req.(*VMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllVM(ctx, req.(*VMAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_TerminateCSPVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPVMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).TerminateCSPVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/TerminateCSPVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).TerminateCSPVM(ctx, req.(*CSPVMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

var _CCM_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cbspider.CCM",
        HandlerType: (*CCMServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateImage",
                        Handler:    _CCM_CreateImage_Handler,
                },
                {
                        MethodName: "ListImage",
                        Handler:    _CCM_ListImage_Handler,
                },
                {
                        MethodName: "GetImage",
                        Handler:    _CCM_GetImage_Handler,
                },
                {
                        MethodName: "DeleteImage",
                        Handler:    _CCM_DeleteImage_Handler,
                },
                {
                        MethodName: "ListVMSpec",
                        Handler:    _CCM_ListVMSpec_Handler,
                },
                {
                        MethodName: "GetVMSpec",
                        Handler:    _CCM_GetVMSpec_Handler,
                },
                {
                        MethodName: "ListOrgVMSpec",
                        Handler:    _CCM_ListOrgVMSpec_Handler,
                },
                {
                        MethodName: "GetOrgVMSpec",
                        Handler:    _CCM_GetOrgVMSpec_Handler,
                },
                {
                        MethodName: "CreateVPC",
                        Handler:    _CCM_CreateVPC_Handler,
                },
                {
                        MethodName: "ListVPC",
                        Handler:    _CCM_ListVPC_Handler,
                },
                {
                        MethodName: "GetVPC",
                        Handler:    _CCM_GetVPC_Handler,
                },
                {
                        MethodName: "DeleteVPC",
                        Handler:    _CCM_DeleteVPC_Handler,
                },
                {
                        MethodName: "ListAllVPC",
                        Handler:    _CCM_ListAllVPC_Handler,
                },
                {
                        MethodName: "DeleteCSPVPC",
                        Handler:    _CCM_DeleteCSPVPC_Handler,
                },
                {
                        MethodName: "AddSubnet",
                        Handler:    _CCM_AddSubnet_Handler,
                },
                {
                        MethodName: "RemoveSubnet",
                        Handler:    _CCM_RemoveSubnet_Handler,
                },
                {
                        MethodName: "RemoveCSPSubnet",
                        Handler:    _CCM_RemoveCSPSubnet_Handler,
                },
                {
                        MethodName: "CreateSecurity",
                        Handler:    _CCM_CreateSecurity_Handler,
                },
                {
                        MethodName: "ListSecurity",
                        Handler:    _CCM_ListSecurity_Handler,
                },
                {
                        MethodName: "GetSecurity",
                        Handler:    _CCM_GetSecurity_Handler,
                },
                {
                        MethodName: "DeleteSecurity",
                        Handler:    _CCM_DeleteSecurity_Handler,
                },
                {
                        MethodName: "ListAllSecurity",
                        Handler:    _CCM_ListAllSecurity_Handler,
                },
                {
                        MethodName: "DeleteCSPSecurity",
                        Handler:    _CCM_DeleteCSPSecurity_Handler,
                },
                {
                        MethodName: "CreateKey",
                        Handler:    _CCM_CreateKey_Handler,
                },
                {
                        MethodName: "ListKey",
                        Handler:    _CCM_ListKey_Handler,
                },
                {
                        MethodName: "GetKey",
                        Handler:    _CCM_GetKey_Handler,
                },
                {
                        MethodName: "DeleteKey",
                        Handler:    _CCM_DeleteKey_Handler,
                },
                {
                        MethodName: "ListAllKey",
                        Handler:    _CCM_ListAllKey_Handler,
                },
                {
                        MethodName: "DeleteCSPKey",
                        Handler:    _CCM_DeleteCSPKey_Handler,
                },
                {
                        MethodName: "StartVM",
                        Handler:    _CCM_StartVM_Handler,
                },
                {
                        MethodName: "ControlVM",
                        Handler:    _CCM_ControlVM_Handler,
                },
                {
                        MethodName: "ListVMStatus",
                        Handler:    _CCM_ListVMStatus_Handler,
                },
                {
                        MethodName: "GetVMStatus",
                        Handler:    _CCM_GetVMStatus_Handler,
                },
                {
                        MethodName: "ListVM",
                        Handler:    _CCM_ListVM_Handler,
                },
                {
                        MethodName: "GetVM",
                        Handler:    _CCM_GetVM_Handler,
                },
                {
                        MethodName: "TerminateVM",
                        Handler:    _CCM_TerminateVM_Handler,
                },
                {
                        MethodName: "ListAllVM",
                        Handler:    _CCM_ListAllVM_Handler,
                },
                {
                        MethodName: "TerminateCSPVM",
                        Handler:    _CCM_TerminateCSPVM_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cbspider.proto",
}

// SSHClient is the client API for SSH service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SSHClient interface {
        SSHRun(ctx context.Context, in *SSHRunRequest, opts ...grpc.CallOption) (*StringResponse, error)
}

type sSHClient struct {
        cc *grpc.ClientConn
}

func NewSSHClient(cc *grpc.ClientConn) SSHClient <span class="cov8" title="1">{
        return &amp;sSHClient{cc}
}</span>

func (c *sSHClient) SSHRun(ctx context.Context, in *SSHRunRequest, opts ...grpc.CallOption) (*StringResponse, error) <span class="cov8" title="1">{
        out := new(StringResponse)
        err := c.cc.Invoke(ctx, "/cbspider.SSH/SSHRun", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SSHServer is the server API for SSH service.
type SSHServer interface {
        SSHRun(context.Context, *SSHRunRequest) (*StringResponse, error)
}

// UnimplementedSSHServer can be embedded to have forward compatible implementations.
type UnimplementedSSHServer struct {
}

func (*UnimplementedSSHServer) SSHRun(ctx context.Context, req *SSHRunRequest) (*StringResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SSHRun not implemented")
}</span>

func RegisterSSHServer(s *grpc.Server, srv SSHServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_SSH_serviceDesc, srv)
}</span>

func _SSH_SSHRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SSHRunRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SSHServer).SSHRun(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.SSH/SSHRun",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(SSHServer).SSHRun(ctx, req.(*SSHRunRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

var _SSH_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cbspider.SSH",
        HandlerType: (*SSHServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "SSHRun",
                        Handler:    _SSH_SSHRun_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cbspider.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Value) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Value)
                copy(dAtA[i:], m.Value)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Value)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Key) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Key)
                copy(dAtA[i:], m.Key)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Key)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *IID) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *IID) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *IID) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.SystemId) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SystemId)
                copy(dAtA[i:], m.SystemId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SystemId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.NameId) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.NameId)
                copy(dAtA[i:], m.NameId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.NameId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *BooleanResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *BooleanResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *BooleanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Result </span><span class="cov8" title="1">{
                i--
                if m.Result </span><span class="cov8" title="1">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov8" title="1">i--
                dAtA[i] = 0x8</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *StringResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *StringResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *StringResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Result) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Result)
                copy(dAtA[i:], m.Result)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Result)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *MessageResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MessageResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov0" title="0">if len(m.Message) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Message)
                copy(dAtA[i:], m.Message)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Message)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *StatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Status) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Status)
                copy(dAtA[i:], m.Status)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Status)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListCloudOSInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListCloudOSInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListCloudOSInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        i -= len(m.Items[iNdEx])
                        copy(dAtA[i:], m.Items[iNdEx])
                        i = encodeVarintCbspider(dAtA, i, uint64(len(m.Items[iNdEx])))
                        i--
                        dAtA[i] = 0xa
                }</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CloudDriverInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CloudDriverInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListCloudDriverInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListCloudDriverInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListCloudDriverInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CloudDriverInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.DriverLibFileName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverLibFileName)
                copy(dAtA[i:], m.DriverLibFileName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverLibFileName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.DriverName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverName)
                copy(dAtA[i:], m.DriverName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CloudDriverQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.DriverName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverName)
                copy(dAtA[i:], m.DriverName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CredentialInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CredentialInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListCredentialInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListCredentialInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListCredentialInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CredentialInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.KeyValueInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.KeyValueInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.CredentialName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.CredentialName)
                copy(dAtA[i:], m.CredentialName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.CredentialName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CredentialQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.CredentialName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.CredentialName)
                copy(dAtA[i:], m.CredentialName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.CredentialName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *RegionInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *RegionInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListRegionInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListRegionInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListRegionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *RegionInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.KeyValueInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.KeyValueInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.RegionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.RegionName)
                copy(dAtA[i:], m.RegionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.RegionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *RegionQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.RegionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.RegionName)
                copy(dAtA[i:], m.RegionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.RegionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListConnectionConfigInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListConnectionConfigInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListConnectionConfigInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.RegionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.RegionName)
                copy(dAtA[i:], m.RegionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.RegionName)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if len(m.CredentialName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.CredentialName)
                copy(dAtA[i:], m.CredentialName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.CredentialName)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.DriverName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverName)
                copy(dAtA[i:], m.DriverName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConfigName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConfigName)
                copy(dAtA[i:], m.ConfigName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConfigName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConfigName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConfigName)
                copy(dAtA[i:], m.ConfigName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConfigName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *AllResourceInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *AllResourceInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AllResourceInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *AllResourceInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AllResourceInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AllResourceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.OnlyCspList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.OnlyCspList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.OnlyCspList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.OnlySpiderList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.OnlySpiderList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.OnlySpiderList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x12</span>
                }
        }
        <span class="cov8" title="1">if len(m.MappedList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.MappedList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.MappedList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListImageInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListImageInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListImageInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ImageInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.Status) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Status)
                copy(dAtA[i:], m.Status)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Status)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.GuestOs) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.GuestOs)
                copy(dAtA[i:], m.GuestOs)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.GuestOs)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ImageCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMSpecInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVMSpecInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVMSpecInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVMSpecInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMSpecInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x32</span>
                }
        }
        <span class="cov8" title="1">if len(m.Gpu) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Gpu) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Gpu[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x2a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Mem) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Mem)
                copy(dAtA[i:], m.Mem)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Mem)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if m.VCpu != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.VCpu.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Region) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Region)
                copy(dAtA[i:], m.Region)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Region)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VCpuInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VCpuInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VCpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Clock) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Clock)
                copy(dAtA[i:], m.Clock)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Clock)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Count) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Count)
                copy(dAtA[i:], m.Count)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Count)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *GpuInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GpuInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Mem) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Mem)
                copy(dAtA[i:], m.Mem)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Mem)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.Model) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Model)
                copy(dAtA[i:], m.Model)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Model)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Mfr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Mfr)
                copy(dAtA[i:], m.Mfr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Mfr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Count) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Count)
                copy(dAtA[i:], m.Count)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Count)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMSpecAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMSpecQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVPCInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVPCInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVPCInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VPCInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SubnetInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SubnetInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SubnetInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VPCCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SubnetInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SubnetInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SubnetCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPVPCQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPVPCQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPVPCQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetAddRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SubnetAddRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetAddRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SubnetQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.SubnetName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SubnetName)
                copy(dAtA[i:], m.SubnetName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SubnetName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPSubnetQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPSubnetQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPSubnetQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListSecurityInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListSecurityInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListSecurityInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SecurityInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x2a</span>
                }
        }
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityRules) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SecurityRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.Direction) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Direction)
                copy(dAtA[i:], m.Direction)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Direction)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.VpcIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityRuleInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SecurityRuleInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityRuleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Cidr)
                copy(dAtA[i:], m.Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Cidr)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if len(m.Direction) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Direction)
                copy(dAtA[i:], m.Direction)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Direction)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.IpProtocol) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.IpProtocol)
                copy(dAtA[i:], m.IpProtocol)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.IpProtocol)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ToPort) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ToPort)
                copy(dAtA[i:], m.ToPort)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ToPort)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.FromPort) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.FromPort)
                copy(dAtA[i:], m.FromPort)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.FromPort)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SecurityCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityRules) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SecurityRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.Direction) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Direction)
                copy(dAtA[i:], m.Direction)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Direction)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPSecurityQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPSecurityQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPSecurityQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListKeyPairInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListKeyPairInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListKeyPairInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyPairInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x32</span>
                }
        }
        <span class="cov8" title="1">if len(m.VmUserId) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmUserId)
                copy(dAtA[i:], m.VmUserId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserId)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if len(m.PrivateKey) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PrivateKey)
                copy(dAtA[i:], m.PrivateKey)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateKey)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.PublicKey) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PublicKey)
                copy(dAtA[i:], m.PublicKey)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PublicKey)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Fingerprint) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Fingerprint)
                copy(dAtA[i:], m.Fingerprint)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Fingerprint)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyPairCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPKeyPairQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPKeyPairQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPKeyPairQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVMStatusInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVMStatusInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVMStatusInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMStatusInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMStatusInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMStatusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.VmStatus) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmStatus)
                copy(dAtA[i:], m.VmStatus)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmStatus)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVMInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVMInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVMInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1
                        i--
                        dAtA[i] = 0xa2</span>
                }
        }
        <span class="cov8" title="1">if len(m.SshAccessPoint) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SshAccessPoint)
                copy(dAtA[i:], m.SshAccessPoint)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SshAccessPoint)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x9a
        }</span>
        <span class="cov8" title="1">if len(m.VmBlockDisk) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmBlockDisk)
                copy(dAtA[i:], m.VmBlockDisk)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmBlockDisk)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x92
        }</span>
        <span class="cov8" title="1">if len(m.VmBootDisk) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmBootDisk)
                copy(dAtA[i:], m.VmBootDisk)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmBootDisk)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x8a
        }</span>
        <span class="cov8" title="1">if len(m.PrivateDns) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PrivateDns)
                copy(dAtA[i:], m.PrivateDns)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateDns)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x82
        }</span>
        <span class="cov8" title="1">if len(m.PrivateIp) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PrivateIp)
                copy(dAtA[i:], m.PrivateIp)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateIp)))
                i--
                dAtA[i] = 0x7a
        }</span>
        <span class="cov8" title="1">if len(m.PublicDns) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PublicDns)
                copy(dAtA[i:], m.PublicDns)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PublicDns)))
                i--
                dAtA[i] = 0x72
        }</span>
        <span class="cov8" title="1">if len(m.PublicIp) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PublicIp)
                copy(dAtA[i:], m.PublicIp)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PublicIp)))
                i--
                dAtA[i] = 0x6a
        }</span>
        <span class="cov8" title="1">if len(m.NetworkInterface) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.NetworkInterface)
                copy(dAtA[i:], m.NetworkInterface)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.NetworkInterface)))
                i--
                dAtA[i] = 0x62
        }</span>
        <span class="cov8" title="1">if len(m.VmUserPasswd) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserPasswd)
                copy(dAtA[i:], m.VmUserPasswd)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserPasswd)))
                i--
                dAtA[i] = 0x5a
        }</span>
        <span class="cov8" title="1">if len(m.VmUserId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserId)
                copy(dAtA[i:], m.VmUserId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserId)))
                i--
                dAtA[i] = 0x52
        }</span>
        <span class="cov8" title="1">if m.KeyPairIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.KeyPairIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x4a</span>
        }
        <span class="cov8" title="1">if len(m.SecurityGroupIids) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityGroupIids) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SecurityGroupIids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x42</span>
                }
        }
        <span class="cov8" title="1">if m.SubnetIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.SubnetIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x3a</span>
        }
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.VpcIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x32</span>
        }
        <span class="cov8" title="1">if len(m.VmSpecName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmSpecName)
                copy(dAtA[i:], m.VmSpecName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmSpecName)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if m.ImageIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.ImageIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x22</span>
        }
        <span class="cov8" title="1">if m.Region != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov8" title="1">if len(m.StartTime) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.StartTime)
                copy(dAtA[i:], m.StartTime)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.StartTime)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMRegionInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMRegionInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMRegionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Zone) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Zone)
                copy(dAtA[i:], m.Zone)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Zone)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Region) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Region)
                copy(dAtA[i:], m.Region)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Region)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.VmUserPasswd) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserPasswd)
                copy(dAtA[i:], m.VmUserPasswd)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserPasswd)))
                i--
                dAtA[i] = 0x4a
        }</span>
        <span class="cov8" title="1">if len(m.VmUserId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserId)
                copy(dAtA[i:], m.VmUserId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserId)))
                i--
                dAtA[i] = 0x42
        }</span>
        <span class="cov8" title="1">if len(m.KeyPairName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.KeyPairName)
                copy(dAtA[i:], m.KeyPairName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.KeyPairName)))
                i--
                dAtA[i] = 0x3a
        }</span>
        <span class="cov8" title="1">if len(m.VmSpecName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmSpecName)
                copy(dAtA[i:], m.VmSpecName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmSpecName)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov8" title="1">if len(m.SecurityGroupNames) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityGroupNames) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        i -= len(m.SecurityGroupNames[iNdEx])
                        copy(dAtA[i:], m.SecurityGroupNames[iNdEx])
                        i = encodeVarintCbspider(dAtA, i, uint64(len(m.SecurityGroupNames[iNdEx])))
                        i--
                        dAtA[i] = 0x2a
                }</span>
        }
        <span class="cov8" title="1">if len(m.SubnetName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SubnetName)
                copy(dAtA[i:], m.SubnetName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SubnetName)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ImageName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ImageName)
                copy(dAtA[i:], m.ImageName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ImageName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPVMQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPVMQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPVMQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMActionRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMActionRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMActionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Action) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Action)
                copy(dAtA[i:], m.Action)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Action)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SSHRunRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SSHRunRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SSHRunRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Command) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Command)
                copy(dAtA[i:], m.Command)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Command)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.ServerPort) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ServerPort)
                copy(dAtA[i:], m.ServerPort)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ServerPort)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.PrivateKey) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.PrivateKey) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.PrivateKey[iNdEx])
                        copy(dAtA[i:], m.PrivateKey[iNdEx])
                        i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateKey[iNdEx])))
                        i--
                        dAtA[i] = 0x12
                }</span>
        }
        <span class="cov8" title="1">if len(m.UserName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.UserName)
                copy(dAtA[i:], m.UserName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.UserName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func encodeVarintCbspider(dAtA []byte, offset int, v uint64) int <span class="cov8" title="1">{
        offset -= sovCbspider(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov8" title="1">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov8" title="1">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Empty) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyValue) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Key)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Value)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *IID) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.NameId)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SystemId)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *BooleanResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Result </span><span class="cov8" title="1">{
                n += 2
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *StringResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Result)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *MessageResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Message)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *StatusResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Status)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListCloudOSInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, s := range m.Items </span><span class="cov8" title="1">{
                        l = len(s)
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListCloudDriverInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.DriverName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.DriverLibFileName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.DriverName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListCredentialInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.CredentialName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.KeyValueInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.CredentialName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListRegionInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.RegionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.KeyValueInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.RegionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListConnectionConfigInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConfigName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.DriverName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.CredentialName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.RegionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConfigName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *AllResourceInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *AllResourceInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.MappedList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.MappedList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.OnlySpiderList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.OnlySpiderList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.OnlyCspList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.OnlyCspList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListImageInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.GuestOs)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Status)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVMSpecInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Region)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.VCpu != nil </span><span class="cov8" title="1">{
                l = m.VCpu.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Mem)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.Gpu) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Gpu </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VCpuInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Count)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Clock)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *GpuInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Count)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Mfr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Model)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Mem)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVPCInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SubnetInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SubnetInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPVPCQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetAddRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SubnetName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPSubnetQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListSecurityInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                l = m.VpcIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Direction)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SecurityRules </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityRuleInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.FromPort)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ToPort)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.IpProtocol)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Direction)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Direction)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SecurityRules </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPSecurityQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListKeyPairInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Fingerprint)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PublicKey)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PrivateKey)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserId)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPKeyPairQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVMStatusInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMStatusInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmStatus)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVMInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.StartTime)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Region != nil </span><span class="cov8" title="1">{
                l = m.Region.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.ImageIid != nil </span><span class="cov8" title="1">{
                l = m.ImageIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmSpecName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                l = m.VpcIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.SubnetIid != nil </span><span class="cov8" title="1">{
                l = m.SubnetIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityGroupIids) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SecurityGroupIids </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.KeyPairIid != nil </span><span class="cov8" title="1">{
                l = m.KeyPairIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserPasswd)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.NetworkInterface)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PublicIp)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PublicDns)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PrivateIp)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PrivateDns)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmBootDisk)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmBlockDisk)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SshAccessPoint)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 2 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMRegionInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Region)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Zone)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ImageName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SubnetName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityGroupNames) &gt; 0 </span><span class="cov8" title="1">{
                for _, s := range m.SecurityGroupNames </span><span class="cov8" title="1">{
                        l = len(s)
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">l = len(m.VmSpecName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.KeyPairName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserPasswd)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPVMQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMActionRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Action)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SSHRunRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.UserName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.PrivateKey) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.PrivateKey </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">l = len(m.ServerPort)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Command)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func sovCbspider(x uint64) (n int) <span class="cov8" title="1">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozCbspider(x uint64) (n int) <span class="cov0" title="0">{
        return sovCbspider(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Empty) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Empty: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyValue) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Key = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Value = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *IID) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: IID: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: IID: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NameId", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.NameId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SystemId", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SystemId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *BooleanResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BooleanResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BooleanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
                        }</span>
                        <span class="cov8" title="1">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">m.Result = bool(v != 0)</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *StringResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StringResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StringResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Result = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *MessageResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MessageResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Message = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Status = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListCloudOSInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudOSInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudOSInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CloudDriverInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CloudDriverInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListCloudDriverInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudDriverInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudDriverInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;CloudDriverInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverLibFileName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverLibFileName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CredentialInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CredentialInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListCredentialInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCredentialInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCredentialInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;CredentialInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.CredentialName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.KeyValueInfoList = append(m.KeyValueInfoList, &amp;KeyValue{})
                        if err := m.KeyValueInfoList[len(m.KeyValueInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.CredentialName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;RegionInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;RegionInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListRegionInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListRegionInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListRegionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;RegionInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.RegionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.KeyValueInfoList = append(m.KeyValueInfoList, &amp;KeyValue{})
                        if err := m.KeyValueInfoList[len(m.KeyValueInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.RegionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ConnectionConfigInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ConnectionConfigInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListConnectionConfigInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListConnectionConfigInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListConnectionConfigInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;ConnectionConfigInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConfigName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConfigName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.CredentialName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.RegionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConfigName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConfigName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *AllResourceInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;AllResourceInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *AllResourceInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MappedList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.MappedList = append(m.MappedList, &amp;IID{})
                        if err := m.MappedList[len(m.MappedList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field OnlySpiderList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.OnlySpiderList = append(m.OnlySpiderList, &amp;IID{})
                        if err := m.OnlySpiderList[len(m.OnlySpiderList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field OnlyCspList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.OnlyCspList = append(m.OnlyCspList, &amp;IID{})
                        if err := m.OnlyCspList[len(m.OnlyCspList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ImageInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListImageInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListImageInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListImageInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;ImageInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field GuestOs", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.GuestOs = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Status = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ImageCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VMSpecInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVMSpecInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMSpecInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMSpecInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VMSpecInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Region = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VCpu", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.VCpu == nil </span><span class="cov8" title="1">{
                                m.VCpu = &amp;VCpuInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.VCpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Mem", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Mem = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Gpu = append(m.Gpu, &amp;GpuInfo{})
                        if err := m.Gpu[len(m.Gpu)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VCpuInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VCpuInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VCpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Count = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Clock = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *GpuInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GpuInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Count = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Mfr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Mfr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Model = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Mem", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Mem = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VPCInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVPCInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVPCInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVPCInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VPCInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetInfoList = append(m.SubnetInfoList, &amp;SubnetInfo{})
                        if err := m.SubnetInfoList[len(m.SubnetInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VPCCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetInfoList = append(m.SubnetInfoList, &amp;SubnetCreateInfo{})
                        if err := m.SubnetInfoList[len(m.SubnetInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPVPCQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVPCQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVPCQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetAddRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetAddRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetAddRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;SubnetCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPSubnetQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSubnetQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSubnetQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;SecurityInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListSecurityInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListSecurityInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListSecurityInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;SecurityInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.VpcIid == nil </span><span class="cov8" title="1">{
                                m.VpcIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.VpcIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Direction = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityRules", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityRules = append(m.SecurityRules, &amp;SecurityRuleInfo{})
                        if err := m.SecurityRules[len(m.SecurityRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityRuleInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityRuleInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityRuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FromPort", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.FromPort = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ToPort", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ToPort = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.IpProtocol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Direction = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;SecurityCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Direction = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityRules", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityRules = append(m.SecurityRules, &amp;SecurityRuleInfo{})
                        if err := m.SecurityRules[len(m.SecurityRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPSecurityQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSecurityQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSecurityQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;KeyPairInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListKeyPairInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListKeyPairInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListKeyPairInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;KeyPairInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Fingerprint = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PublicKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PrivateKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserId", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmUserId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;KeyPairCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPKeyPairQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPKeyPairQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPKeyPairQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVMStatusInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMStatusInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMStatusInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VMStatusInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMStatusInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMStatusInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMStatusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmStatus", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmStatus = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VMInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVMInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VMInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.StartTime = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Region == nil </span><span class="cov8" title="1">{
                                m.Region = &amp;VMRegionInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ImageIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.ImageIid == nil </span><span class="cov8" title="1">{
                                m.ImageIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.ImageIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmSpecName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmSpecName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.VpcIid == nil </span><span class="cov8" title="1">{
                                m.VpcIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.VpcIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 7:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.SubnetIid == nil </span><span class="cov8" title="1">{
                                m.SubnetIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.SubnetIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 8:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupIids", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityGroupIids = append(m.SecurityGroupIids, &amp;IID{})
                        if err := m.SecurityGroupIids[len(m.SecurityGroupIids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 9:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyPairIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.KeyPairIid == nil </span><span class="cov8" title="1">{
                                m.KeyPairIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.KeyPairIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 10:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 11:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserPasswd", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserPasswd = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 12:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.NetworkInterface = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 13:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PublicIp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 14:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicDns", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PublicDns = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 15:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateIp", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PrivateIp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 16:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateDns", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PrivateDns = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 17:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmBootDisk", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmBootDisk = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 18:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmBlockDisk", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmBlockDisk = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 19:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SshAccessPoint", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SshAccessPoint = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 20:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMRegionInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMRegionInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMRegionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Region = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Zone = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VMCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ImageName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupNames", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityGroupNames = append(m.SecurityGroupNames, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 6:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmSpecName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmSpecName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 7:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyPairName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.KeyPairName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 9:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserPasswd", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserPasswd = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPVMQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVMQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVMQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMActionRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMActionRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMActionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Action = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SSHRunRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SSHRunRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SSHRunRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.UserName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PrivateKey = append(m.PrivateKey, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ServerPort = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Command = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func skipCbspider(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowCbspider
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupCbspider
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthCbspider
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthCbspider        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowCbspider          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupCbspider = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gogo.proto

package gogoproto

import (
        fmt "fmt"
        descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
        proto "github.com/golang/protobuf/proto"
        math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

var E_GoprotoEnumPrefix = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62001,
        Name:          "gogoproto.goproto_enum_prefix",
        Tag:           "varint,62001,opt,name=goproto_enum_prefix",
        Filename:      "gogo.proto",
}

var E_GoprotoEnumStringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62021,
        Name:          "gogoproto.goproto_enum_stringer",
        Tag:           "varint,62021,opt,name=goproto_enum_stringer",
        Filename:      "gogo.proto",
}

var E_EnumStringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62022,
        Name:          "gogoproto.enum_stringer",
        Tag:           "varint,62022,opt,name=enum_stringer",
        Filename:      "gogo.proto",
}

var E_EnumCustomname = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         62023,
        Name:          "gogoproto.enum_customname",
        Tag:           "bytes,62023,opt,name=enum_customname",
        Filename:      "gogo.proto",
}

var E_Enumdecl = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62024,
        Name:          "gogoproto.enumdecl",
        Tag:           "varint,62024,opt,name=enumdecl",
        Filename:      "gogo.proto",
}

var E_EnumvalueCustomname = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumValueOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         66001,
        Name:          "gogoproto.enumvalue_customname",
        Tag:           "bytes,66001,opt,name=enumvalue_customname",
        Filename:      "gogo.proto",
}

var E_GoprotoGettersAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63001,
        Name:          "gogoproto.goproto_getters_all",
        Tag:           "varint,63001,opt,name=goproto_getters_all",
        Filename:      "gogo.proto",
}

var E_GoprotoEnumPrefixAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63002,
        Name:          "gogoproto.goproto_enum_prefix_all",
        Tag:           "varint,63002,opt,name=goproto_enum_prefix_all",
        Filename:      "gogo.proto",
}

var E_GoprotoStringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63003,
        Name:          "gogoproto.goproto_stringer_all",
        Tag:           "varint,63003,opt,name=goproto_stringer_all",
        Filename:      "gogo.proto",
}

var E_VerboseEqualAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63004,
        Name:          "gogoproto.verbose_equal_all",
        Tag:           "varint,63004,opt,name=verbose_equal_all",
        Filename:      "gogo.proto",
}

var E_FaceAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63005,
        Name:          "gogoproto.face_all",
        Tag:           "varint,63005,opt,name=face_all",
        Filename:      "gogo.proto",
}

var E_GostringAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63006,
        Name:          "gogoproto.gostring_all",
        Tag:           "varint,63006,opt,name=gostring_all",
        Filename:      "gogo.proto",
}

var E_PopulateAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63007,
        Name:          "gogoproto.populate_all",
        Tag:           "varint,63007,opt,name=populate_all",
        Filename:      "gogo.proto",
}

var E_StringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63008,
        Name:          "gogoproto.stringer_all",
        Tag:           "varint,63008,opt,name=stringer_all",
        Filename:      "gogo.proto",
}

var E_OnlyoneAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63009,
        Name:          "gogoproto.onlyone_all",
        Tag:           "varint,63009,opt,name=onlyone_all",
        Filename:      "gogo.proto",
}

var E_EqualAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63013,
        Name:          "gogoproto.equal_all",
        Tag:           "varint,63013,opt,name=equal_all",
        Filename:      "gogo.proto",
}

var E_DescriptionAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63014,
        Name:          "gogoproto.description_all",
        Tag:           "varint,63014,opt,name=description_all",
        Filename:      "gogo.proto",
}

var E_TestgenAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63015,
        Name:          "gogoproto.testgen_all",
        Tag:           "varint,63015,opt,name=testgen_all",
        Filename:      "gogo.proto",
}

var E_BenchgenAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63016,
        Name:          "gogoproto.benchgen_all",
        Tag:           "varint,63016,opt,name=benchgen_all",
        Filename:      "gogo.proto",
}

var E_MarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63017,
        Name:          "gogoproto.marshaler_all",
        Tag:           "varint,63017,opt,name=marshaler_all",
        Filename:      "gogo.proto",
}

var E_UnmarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63018,
        Name:          "gogoproto.unmarshaler_all",
        Tag:           "varint,63018,opt,name=unmarshaler_all",
        Filename:      "gogo.proto",
}

var E_StableMarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63019,
        Name:          "gogoproto.stable_marshaler_all",
        Tag:           "varint,63019,opt,name=stable_marshaler_all",
        Filename:      "gogo.proto",
}

var E_SizerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63020,
        Name:          "gogoproto.sizer_all",
        Tag:           "varint,63020,opt,name=sizer_all",
        Filename:      "gogo.proto",
}

var E_GoprotoEnumStringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63021,
        Name:          "gogoproto.goproto_enum_stringer_all",
        Tag:           "varint,63021,opt,name=goproto_enum_stringer_all",
        Filename:      "gogo.proto",
}

var E_EnumStringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63022,
        Name:          "gogoproto.enum_stringer_all",
        Tag:           "varint,63022,opt,name=enum_stringer_all",
        Filename:      "gogo.proto",
}

var E_UnsafeMarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63023,
        Name:          "gogoproto.unsafe_marshaler_all",
        Tag:           "varint,63023,opt,name=unsafe_marshaler_all",
        Filename:      "gogo.proto",
}

var E_UnsafeUnmarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63024,
        Name:          "gogoproto.unsafe_unmarshaler_all",
        Tag:           "varint,63024,opt,name=unsafe_unmarshaler_all",
        Filename:      "gogo.proto",
}

var E_GoprotoExtensionsMapAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63025,
        Name:          "gogoproto.goproto_extensions_map_all",
        Tag:           "varint,63025,opt,name=goproto_extensions_map_all",
        Filename:      "gogo.proto",
}

var E_GoprotoUnrecognizedAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63026,
        Name:          "gogoproto.goproto_unrecognized_all",
        Tag:           "varint,63026,opt,name=goproto_unrecognized_all",
        Filename:      "gogo.proto",
}

var E_GogoprotoImport = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63027,
        Name:          "gogoproto.gogoproto_import",
        Tag:           "varint,63027,opt,name=gogoproto_import",
        Filename:      "gogo.proto",
}

var E_ProtosizerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63028,
        Name:          "gogoproto.protosizer_all",
        Tag:           "varint,63028,opt,name=protosizer_all",
        Filename:      "gogo.proto",
}

var E_CompareAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63029,
        Name:          "gogoproto.compare_all",
        Tag:           "varint,63029,opt,name=compare_all",
        Filename:      "gogo.proto",
}

var E_TypedeclAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63030,
        Name:          "gogoproto.typedecl_all",
        Tag:           "varint,63030,opt,name=typedecl_all",
        Filename:      "gogo.proto",
}

var E_EnumdeclAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63031,
        Name:          "gogoproto.enumdecl_all",
        Tag:           "varint,63031,opt,name=enumdecl_all",
        Filename:      "gogo.proto",
}

var E_GoprotoRegistration = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63032,
        Name:          "gogoproto.goproto_registration",
        Tag:           "varint,63032,opt,name=goproto_registration",
        Filename:      "gogo.proto",
}

var E_MessagenameAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63033,
        Name:          "gogoproto.messagename_all",
        Tag:           "varint,63033,opt,name=messagename_all",
        Filename:      "gogo.proto",
}

var E_GoprotoSizecacheAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63034,
        Name:          "gogoproto.goproto_sizecache_all",
        Tag:           "varint,63034,opt,name=goproto_sizecache_all",
        Filename:      "gogo.proto",
}

var E_GoprotoUnkeyedAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63035,
        Name:          "gogoproto.goproto_unkeyed_all",
        Tag:           "varint,63035,opt,name=goproto_unkeyed_all",
        Filename:      "gogo.proto",
}

var E_GoprotoGetters = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64001,
        Name:          "gogoproto.goproto_getters",
        Tag:           "varint,64001,opt,name=goproto_getters",
        Filename:      "gogo.proto",
}

var E_GoprotoStringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64003,
        Name:          "gogoproto.goproto_stringer",
        Tag:           "varint,64003,opt,name=goproto_stringer",
        Filename:      "gogo.proto",
}

var E_VerboseEqual = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64004,
        Name:          "gogoproto.verbose_equal",
        Tag:           "varint,64004,opt,name=verbose_equal",
        Filename:      "gogo.proto",
}

var E_Face = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64005,
        Name:          "gogoproto.face",
        Tag:           "varint,64005,opt,name=face",
        Filename:      "gogo.proto",
}

var E_Gostring = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64006,
        Name:          "gogoproto.gostring",
        Tag:           "varint,64006,opt,name=gostring",
        Filename:      "gogo.proto",
}

var E_Populate = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64007,
        Name:          "gogoproto.populate",
        Tag:           "varint,64007,opt,name=populate",
        Filename:      "gogo.proto",
}

var E_Stringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         67008,
        Name:          "gogoproto.stringer",
        Tag:           "varint,67008,opt,name=stringer",
        Filename:      "gogo.proto",
}

var E_Onlyone = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64009,
        Name:          "gogoproto.onlyone",
        Tag:           "varint,64009,opt,name=onlyone",
        Filename:      "gogo.proto",
}

var E_Equal = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64013,
        Name:          "gogoproto.equal",
        Tag:           "varint,64013,opt,name=equal",
        Filename:      "gogo.proto",
}

var E_Description = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64014,
        Name:          "gogoproto.description",
        Tag:           "varint,64014,opt,name=description",
        Filename:      "gogo.proto",
}

var E_Testgen = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64015,
        Name:          "gogoproto.testgen",
        Tag:           "varint,64015,opt,name=testgen",
        Filename:      "gogo.proto",
}

var E_Benchgen = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64016,
        Name:          "gogoproto.benchgen",
        Tag:           "varint,64016,opt,name=benchgen",
        Filename:      "gogo.proto",
}

var E_Marshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64017,
        Name:          "gogoproto.marshaler",
        Tag:           "varint,64017,opt,name=marshaler",
        Filename:      "gogo.proto",
}

var E_Unmarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64018,
        Name:          "gogoproto.unmarshaler",
        Tag:           "varint,64018,opt,name=unmarshaler",
        Filename:      "gogo.proto",
}

var E_StableMarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64019,
        Name:          "gogoproto.stable_marshaler",
        Tag:           "varint,64019,opt,name=stable_marshaler",
        Filename:      "gogo.proto",
}

var E_Sizer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64020,
        Name:          "gogoproto.sizer",
        Tag:           "varint,64020,opt,name=sizer",
        Filename:      "gogo.proto",
}

var E_UnsafeMarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64023,
        Name:          "gogoproto.unsafe_marshaler",
        Tag:           "varint,64023,opt,name=unsafe_marshaler",
        Filename:      "gogo.proto",
}

var E_UnsafeUnmarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64024,
        Name:          "gogoproto.unsafe_unmarshaler",
        Tag:           "varint,64024,opt,name=unsafe_unmarshaler",
        Filename:      "gogo.proto",
}

var E_GoprotoExtensionsMap = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64025,
        Name:          "gogoproto.goproto_extensions_map",
        Tag:           "varint,64025,opt,name=goproto_extensions_map",
        Filename:      "gogo.proto",
}

var E_GoprotoUnrecognized = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64026,
        Name:          "gogoproto.goproto_unrecognized",
        Tag:           "varint,64026,opt,name=goproto_unrecognized",
        Filename:      "gogo.proto",
}

var E_Protosizer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64028,
        Name:          "gogoproto.protosizer",
        Tag:           "varint,64028,opt,name=protosizer",
        Filename:      "gogo.proto",
}

var E_Compare = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64029,
        Name:          "gogoproto.compare",
        Tag:           "varint,64029,opt,name=compare",
        Filename:      "gogo.proto",
}

var E_Typedecl = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64030,
        Name:          "gogoproto.typedecl",
        Tag:           "varint,64030,opt,name=typedecl",
        Filename:      "gogo.proto",
}

var E_Messagename = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64033,
        Name:          "gogoproto.messagename",
        Tag:           "varint,64033,opt,name=messagename",
        Filename:      "gogo.proto",
}

var E_GoprotoSizecache = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64034,
        Name:          "gogoproto.goproto_sizecache",
        Tag:           "varint,64034,opt,name=goproto_sizecache",
        Filename:      "gogo.proto",
}

var E_GoprotoUnkeyed = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64035,
        Name:          "gogoproto.goproto_unkeyed",
        Tag:           "varint,64035,opt,name=goproto_unkeyed",
        Filename:      "gogo.proto",
}

var E_Nullable = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65001,
        Name:          "gogoproto.nullable",
        Tag:           "varint,65001,opt,name=nullable",
        Filename:      "gogo.proto",
}

var E_Embed = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65002,
        Name:          "gogoproto.embed",
        Tag:           "varint,65002,opt,name=embed",
        Filename:      "gogo.proto",
}

var E_Customtype = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65003,
        Name:          "gogoproto.customtype",
        Tag:           "bytes,65003,opt,name=customtype",
        Filename:      "gogo.proto",
}

var E_Customname = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65004,
        Name:          "gogoproto.customname",
        Tag:           "bytes,65004,opt,name=customname",
        Filename:      "gogo.proto",
}

var E_Jsontag = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65005,
        Name:          "gogoproto.jsontag",
        Tag:           "bytes,65005,opt,name=jsontag",
        Filename:      "gogo.proto",
}

var E_Moretags = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65006,
        Name:          "gogoproto.moretags",
        Tag:           "bytes,65006,opt,name=moretags",
        Filename:      "gogo.proto",
}

var E_Casttype = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65007,
        Name:          "gogoproto.casttype",
        Tag:           "bytes,65007,opt,name=casttype",
        Filename:      "gogo.proto",
}

var E_Castkey = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65008,
        Name:          "gogoproto.castkey",
        Tag:           "bytes,65008,opt,name=castkey",
        Filename:      "gogo.proto",
}

var E_Castvalue = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65009,
        Name:          "gogoproto.castvalue",
        Tag:           "bytes,65009,opt,name=castvalue",
        Filename:      "gogo.proto",
}

var E_Stdtime = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65010,
        Name:          "gogoproto.stdtime",
        Tag:           "varint,65010,opt,name=stdtime",
        Filename:      "gogo.proto",
}

var E_Stdduration = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65011,
        Name:          "gogoproto.stdduration",
        Tag:           "varint,65011,opt,name=stdduration",
        Filename:      "gogo.proto",
}

var E_Wktpointer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65012,
        Name:          "gogoproto.wktpointer",
        Tag:           "varint,65012,opt,name=wktpointer",
        Filename:      "gogo.proto",
}

func init() <span class="cov8" title="1">{
        proto.RegisterExtension(E_GoprotoEnumPrefix)
        proto.RegisterExtension(E_GoprotoEnumStringer)
        proto.RegisterExtension(E_EnumStringer)
        proto.RegisterExtension(E_EnumCustomname)
        proto.RegisterExtension(E_Enumdecl)
        proto.RegisterExtension(E_EnumvalueCustomname)
        proto.RegisterExtension(E_GoprotoGettersAll)
        proto.RegisterExtension(E_GoprotoEnumPrefixAll)
        proto.RegisterExtension(E_GoprotoStringerAll)
        proto.RegisterExtension(E_VerboseEqualAll)
        proto.RegisterExtension(E_FaceAll)
        proto.RegisterExtension(E_GostringAll)
        proto.RegisterExtension(E_PopulateAll)
        proto.RegisterExtension(E_StringerAll)
        proto.RegisterExtension(E_OnlyoneAll)
        proto.RegisterExtension(E_EqualAll)
        proto.RegisterExtension(E_DescriptionAll)
        proto.RegisterExtension(E_TestgenAll)
        proto.RegisterExtension(E_BenchgenAll)
        proto.RegisterExtension(E_MarshalerAll)
        proto.RegisterExtension(E_UnmarshalerAll)
        proto.RegisterExtension(E_StableMarshalerAll)
        proto.RegisterExtension(E_SizerAll)
        proto.RegisterExtension(E_GoprotoEnumStringerAll)
        proto.RegisterExtension(E_EnumStringerAll)
        proto.RegisterExtension(E_UnsafeMarshalerAll)
        proto.RegisterExtension(E_UnsafeUnmarshalerAll)
        proto.RegisterExtension(E_GoprotoExtensionsMapAll)
        proto.RegisterExtension(E_GoprotoUnrecognizedAll)
        proto.RegisterExtension(E_GogoprotoImport)
        proto.RegisterExtension(E_ProtosizerAll)
        proto.RegisterExtension(E_CompareAll)
        proto.RegisterExtension(E_TypedeclAll)
        proto.RegisterExtension(E_EnumdeclAll)
        proto.RegisterExtension(E_GoprotoRegistration)
        proto.RegisterExtension(E_MessagenameAll)
        proto.RegisterExtension(E_GoprotoSizecacheAll)
        proto.RegisterExtension(E_GoprotoUnkeyedAll)
        proto.RegisterExtension(E_GoprotoGetters)
        proto.RegisterExtension(E_GoprotoStringer)
        proto.RegisterExtension(E_VerboseEqual)
        proto.RegisterExtension(E_Face)
        proto.RegisterExtension(E_Gostring)
        proto.RegisterExtension(E_Populate)
        proto.RegisterExtension(E_Stringer)
        proto.RegisterExtension(E_Onlyone)
        proto.RegisterExtension(E_Equal)
        proto.RegisterExtension(E_Description)
        proto.RegisterExtension(E_Testgen)
        proto.RegisterExtension(E_Benchgen)
        proto.RegisterExtension(E_Marshaler)
        proto.RegisterExtension(E_Unmarshaler)
        proto.RegisterExtension(E_StableMarshaler)
        proto.RegisterExtension(E_Sizer)
        proto.RegisterExtension(E_UnsafeMarshaler)
        proto.RegisterExtension(E_UnsafeUnmarshaler)
        proto.RegisterExtension(E_GoprotoExtensionsMap)
        proto.RegisterExtension(E_GoprotoUnrecognized)
        proto.RegisterExtension(E_Protosizer)
        proto.RegisterExtension(E_Compare)
        proto.RegisterExtension(E_Typedecl)
        proto.RegisterExtension(E_Messagename)
        proto.RegisterExtension(E_GoprotoSizecache)
        proto.RegisterExtension(E_GoprotoUnkeyed)
        proto.RegisterExtension(E_Nullable)
        proto.RegisterExtension(E_Embed)
        proto.RegisterExtension(E_Customtype)
        proto.RegisterExtension(E_Customname)
        proto.RegisterExtension(E_Jsontag)
        proto.RegisterExtension(E_Moretags)
        proto.RegisterExtension(E_Casttype)
        proto.RegisterExtension(E_Castkey)
        proto.RegisterExtension(E_Castvalue)
        proto.RegisterExtension(E_Stdtime)
        proto.RegisterExtension(E_Stdduration)
        proto.RegisterExtension(E_Wktpointer)
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("gogo.proto", fileDescriptor_592445b5231bc2b9) }</span>

var fileDescriptor_592445b5231bc2b9 = []byte{
        // 1383 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x98, 0x49, 0x6f, 0x1c, 0x45,
        0x14, 0x80, 0xb1, 0x48, 0x14, 0xbb, 0x6c, 0xc7, 0xb1, 0x1d, 0x42, 0x88, 0xc0, 0x84, 0x1b, 0x97,
        0x78, 0x4e, 0x11, 0x4a, 0x59, 0x51, 0xe4, 0x58, 0x8e, 0x95, 0x88, 0x04, 0xe3, 0xc4, 0x61, 0x3b,
        0x8c, 0x7a, 0x7a, 0xca, 0xed, 0x26, 0xdd, 0x5d, 0x4d, 0x77, 0x75, 0x88, 0x23, 0x71, 0x40, 0x61,
        0x11, 0x42, 0xec, 0x48, 0x24, 0x21, 0x09, 0x04, 0xc4, 0xbe, 0x86, 0x7d, 0xb9, 0x70, 0x01, 0x72,
        0x84, 0x7f, 0x80, 0x02, 0x17, 0xc0, 0xec, 0xbe, 0xf9, 0x82, 0x5e, 0xf7, 0x7b, 0x3d, 0x35, 0xed,
        0x91, 0xaa, 0xe6, 0xd6, 0x63, 0xd7, 0xf7, 0xb9, 0xfa, 0xbd, 0xaa, 0xf7, 0x9e, 0x87, 0x31, 0x4f,
        0x7a, 0x72, 0x3c, 0x4e, 0xa4, 0x92, 0x23, 0x7d, 0xf0, 0x9c, 0x3f, 0x6e, 0xdb, 0xee, 0x49, 0xe9,
        0x05, 0xa2, 0x96, 0x7f, 0x6a, 0x64, 0x0b, 0xb5, 0xa6, 0x48, 0xdd, 0xc4, 0x8f, 0x95, 0x4c, 0x8a,
        0xc5, 0xfc, 0x10, 0x1b, 0xc5, 0xc5, 0x75, 0x11, 0x65, 0x61, 0x3d, 0x4e, 0xc4, 0x82, 0x7f, 0x62,
        0xe4, 0xfa, 0xf1, 0x82, 0x1c, 0x27, 0x72, 0x7c, 0x3a, 0xca, 0xc2, 0xdb, 0x62, 0xe5, 0xcb, 0x28,
        0xdd, 0x7a, 0xe9, 0x97, 0xab, 0xb7, 0xf7, 0xdc, 0xdc, 0x3b, 0x37, 0x8c, 0x28, 0xfc, 0x6e, 0x36,
        0x07, 0xf9, 0x1c, 0xbb, 0xa6, 0xcd, 0x97, 0xaa, 0xc4, 0x8f, 0x3c, 0x91, 0x18, 0x8c, 0xdf, 0xa2,
        0x71, 0x54, 0x33, 0x1e, 0x46, 0x94, 0x4f, 0xb1, 0xc1, 0x6e, 0x5c, 0xdf, 0xa1, 0x6b, 0x40, 0xe8,
        0x92, 0x19, 0x36, 0x94, 0x4b, 0xdc, 0x2c, 0x55, 0x32, 0x8c, 0x9c, 0x50, 0x18, 0x34, 0xdf, 0xe7,
        0x9a, 0xbe, 0xb9, 0x8d, 0x80, 0x4d, 0x95, 0x14, 0xe7, 0xac, 0x17, 0x7e, 0xd2, 0x14, 0x6e, 0x60,
        0x30, 0x5c, 0xc6, 0x8d, 0x94, 0xeb, 0xf9, 0x51, 0xb6, 0x19, 0x9e, 0x8f, 0x3b, 0x41, 0x26, 0xf4,
        0x9d, 0xdc, 0xd4, 0xd1, 0x73, 0x14, 0x96, 0x91, 0xec, 0xc7, 0x53, 0xeb, 0xf2, 0xed, 0x8c, 0x96,
        0x02, 0x6d, 0x4f, 0x5a, 0x16, 0x3d, 0xa1, 0x94, 0x48, 0xd2, 0xba, 0x13, 0x74, 0xda, 0xde, 0x3e,
        0x3f, 0x28, 0x8d, 0x67, 0x96, 0xdb, 0xb3, 0x38, 0x53, 0x90, 0x93, 0x41, 0xc0, 0xe7, 0xd9, 0xb5,
        0x1d, 0x4e, 0x85, 0x85, 0xf3, 0x2c, 0x3a, 0x37, 0xaf, 0x39, 0x19, 0xa0, 0x9d, 0x65, 0xf4, 0xf3,
        0x32, 0x97, 0x16, 0xce, 0x17, 0xd1, 0x39, 0x82, 0x2c, 0xa5, 0x14, 0x8c, 0x07, 0xd8, 0xf0, 0x71,
        0x91, 0x34, 0x64, 0x2a, 0xea, 0xe2, 0xbe, 0xcc, 0x09, 0x2c, 0x74, 0xe7, 0x50, 0x37, 0x84, 0xe0,
        0x34, 0x70, 0xe0, 0xda, 0xc5, 0x7a, 0x17, 0x1c, 0x57, 0x58, 0x28, 0xce, 0xa3, 0x62, 0x03, 0xac,
        0x07, 0x74, 0x92, 0x0d, 0x78, 0xb2, 0x78, 0x25, 0x0b, 0xfc, 0x02, 0xe2, 0xfd, 0xc4, 0xa0, 0x22,
        0x96, 0x71, 0x16, 0x38, 0xca, 0x66, 0x07, 0x2f, 0x91, 0x82, 0x18, 0x54, 0x74, 0x11, 0xd6, 0x97,
        0x49, 0x91, 0x6a, 0xf1, 0xdc, 0xc3, 0xfa, 0x65, 0x14, 0x2c, 0xc9, 0xc8, 0x66, 0x13, 0x17, 0xd1,
        0xc0, 0x10, 0x01, 0xc1, 0x04, 0xeb, 0xb3, 0x4d, 0xc4, 0x6b, 0xcb, 0x74, 0x3d, 0x28, 0x03, 0x33,
        0x6c, 0x88, 0x0a, 0x94, 0x2f, 0x23, 0x0b, 0xc5, 0xeb, 0xa8, 0xd8, 0xa8, 0x61, 0xf8, 0x1a, 0x4a,
        0xa4, 0xca, 0x13, 0x36, 0x92, 0x37, 0xe8, 0x35, 0x10, 0xc1, 0x50, 0x36, 0x44, 0xe4, 0x2e, 0xda,
        0x19, 0xde, 0xa4, 0x50, 0x12, 0x03, 0x8a, 0x29, 0x36, 0x18, 0x3a, 0x49, 0xba, 0xe8, 0x04, 0x56,
        0xe9, 0x78, 0x0b, 0x1d, 0x03, 0x25, 0x84, 0x11, 0xc9, 0xa2, 0x6e, 0x34, 0x6f, 0x53, 0x44, 0x34,
        0x0c, 0xaf, 0x5e, 0xaa, 0x9c, 0x46, 0x20, 0xea, 0xdd, 0xd8, 0xde, 0xa1, 0xab, 0x57, 0xb0, 0x07,
        0x75, 0xe3, 0x04, 0xeb, 0x4b, 0xfd, 0x93, 0x56, 0x9a, 0x77, 0x29, 0xd3, 0x39, 0x00, 0xf0, 0x5d,
        0xec, 0xba, 0x8e, 0x6d, 0xc2, 0x42, 0xf6, 0x1e, 0xca, 0xb6, 0x74, 0x68, 0x15, 0x58, 0x12, 0xba,
        0x55, 0xbe, 0x4f, 0x25, 0x41, 0x54, 0x5c, 0xb3, 0x6c, 0x73, 0x16, 0xa5, 0xce, 0x42, 0x77, 0x51,
        0xfb, 0x80, 0xa2, 0x56, 0xb0, 0x6d, 0x51, 0x3b, 0xc2, 0xb6, 0xa0, 0xb1, 0xbb, 0xbc, 0x7e, 0x48,
        0x85, 0xb5, 0xa0, 0xe7, 0xdb, 0xb3, 0x7b, 0x0f, 0xdb, 0x56, 0x86, 0xf3, 0x84, 0x12, 0x51, 0x0a,
        0x4c, 0x3d, 0x74, 0x62, 0x0b, 0xf3, 0x25, 0x34, 0x53, 0xc5, 0x9f, 0x2e, 0x05, 0x07, 0x9d, 0x18,
        0xe4, 0x77, 0xb2, 0xad, 0x24, 0xcf, 0xa2, 0x44, 0xb8, 0xd2, 0x8b, 0xfc, 0x93, 0xa2, 0x69, 0xa1,
        0xfe, 0xa8, 0x92, 0xaa, 0x79, 0x0d, 0x07, 0xf3, 0x7e, 0xb6, 0xa9, 0x9c, 0x55, 0xea, 0x7e, 0x18,
        0xcb, 0x44, 0x19, 0x8c, 0x1f, 0x53, 0xa6, 0x4a, 0x6e, 0x7f, 0x8e, 0xf1, 0x69, 0xb6, 0x31, 0xff,
        0x68, 0x7b, 0x24, 0x3f, 0x41, 0xd1, 0x60, 0x8b, 0xc2, 0xc2, 0xe1, 0xca, 0x30, 0x76, 0x12, 0x9b,
        0xfa, 0xf7, 0x29, 0x15, 0x0e, 0x44, 0xb0, 0x70, 0xa8, 0xa5, 0x58, 0x40, 0xb7, 0xb7, 0x30, 0x7c,
        0x46, 0x85, 0x83, 0x18, 0x54, 0xd0, 0xc0, 0x60, 0xa1, 0xf8, 0x9c, 0x14, 0xc4, 0x80, 0xe2, 0xf6,
        0x56, 0xa3, 0x4d, 0x84, 0xe7, 0xa7, 0x2a, 0x71, 0x60, 0xb5, 0x41, 0xf5, 0xc5, 0x72, 0xfb, 0x10,
        0x36, 0xa7, 0xa1, 0x50, 0x89, 0x42, 0x91, 0xa6, 0x8e, 0x27, 0x60, 0xe2, 0xb0, 0xd8, 0xd8, 0x97,
        0x54, 0x89, 0x34, 0x0c, 0xf6, 0xa6, 0x4d, 0x88, 0x10, 0x76, 0xd7, 0x71, 0x17, 0x6d, 0x74, 0x5f,
        0x55, 0x36, 0x77, 0x98, 0x58, 0x70, 0x6a, 0xf3, 0x4f, 0x16, 0x1d, 0x13, 0x4b, 0x56, 0xa7, 0xf3,
        0xeb, 0xca, 0xfc, 0x33, 0x5f, 0x90, 0x45, 0x0d, 0x19, 0xaa, 0xcc, 0x53, 0x23, 0x37, 0xae, 0x71,
        0x1d, 0x2c, 0xde, 0x8b, 0x74, 0x0f, 0xae, 0xe0, 0xfb, 0xb6, 0x8f, 0x53, 0xfc, 0x56, 0x38, 0xe4,
        0xed, 0x43, 0x8f, 0x59, 0x76, 0x6a, 0xa5, 0x3c, 0xe7, 0x6d, 0x33, 0x0f, 0xdf, 0xc7, 0x06, 0xdb,
        0x06, 0x1e, 0xb3, 0xea, 0x21, 0x54, 0x0d, 0xe8, 0xf3, 0x0e, 0xdf, 0xc9, 0xd6, 0xc1, 0xf0, 0x62,
        0xc6, 0x1f, 0x46, 0x3c, 0x5f, 0xce, 0x77, 0xb3, 0x5e, 0x1a, 0x5a, 0xcc, 0xe8, 0x23, 0x88, 0x96,
        0x08, 0xe0, 0x34, 0xb0, 0x98, 0xf1, 0x47, 0x09, 0x27, 0x04, 0x70, 0xfb, 0x10, 0x7e, 0xf3, 0xf8,
        0x3a, 0x6c, 0x3a, 0x14, 0xbb, 0x09, 0xb6, 0x01, 0x27, 0x15, 0x33, 0xfd, 0x18, 0xfe, 0x71, 0x22,
        0xf8, 0x2d, 0x6c, 0xbd, 0x65, 0xc0, 0x9f, 0x40, 0xb4, 0x58, 0xcf, 0xa7, 0x58, 0xbf, 0x36, 0x9d,
        0x98, 0xf1, 0x27, 0x11, 0xd7, 0x29, 0xd8, 0x3a, 0x4e, 0x27, 0x66, 0xc1, 0x53, 0xb4, 0x75, 0x24,
        0x20, 0x6c, 0x34, 0x98, 0x98, 0xe9, 0xa7, 0x29, 0xea, 0x84, 0xf0, 0x3d, 0xac, 0xaf, 0x6c, 0x36,
        0x66, 0xfe, 0x19, 0xe4, 0x5b, 0x0c, 0x44, 0x40, 0x6b, 0x76, 0x66, 0xc5, 0xb3, 0x14, 0x01, 0x8d,
        0x82, 0x6b, 0x54, 0x1d, 0x60, 0xcc, 0xa6, 0xe7, 0xe8, 0x1a, 0x55, 0xe6, 0x17, 0xc8, 0x66, 0x5e,
        0xf3, 0xcd, 0x8a, 0xe7, 0x29, 0x9b, 0xf9, 0x7a, 0xd8, 0x46, 0x75, 0x22, 0x30, 0x3b, 0x5e, 0xa0,
        0x6d, 0x54, 0x06, 0x02, 0x3e, 0xcb, 0x46, 0xd6, 0x4e, 0x03, 0x66, 0xdf, 0x69, 0xf4, 0x0d, 0xaf,
        0x19, 0x06, 0xf8, 0x1d, 0x6c, 0x4b, 0xe7, 0x49, 0xc0, 0x6c, 0x3d, 0xb3, 0x52, 0xf9, 0xdf, 0x4d,
        0x1f, 0x04, 0xf8, 0x91, 0x56, 0x4b, 0xd1, 0xa7, 0x00, 0xb3, 0xf6, 0xec, 0x4a, 0x7b, 0xe1, 0xd6,
        0x87, 0x00, 0x3e, 0xc9, 0x58, 0xab, 0x01, 0x9b, 0x5d, 0xe7, 0xd0, 0xa5, 0x41, 0x70, 0x35, 0xb0,
        0xff, 0x9a, 0xf9, 0xf3, 0x74, 0x35, 0x90, 0x80, 0xab, 0x41, 0xad, 0xd7, 0x4c, 0x5f, 0xa0, 0xab,
        0x41, 0x08, 0x9c, 0x6c, 0xad, 0xbb, 0x99, 0x0d, 0x17, 0xe9, 0x64, 0x6b, 0x14, 0x3f, 0xc4, 0x86,
        0xd7, 0x34, 0x44, 0xb3, 0xea, 0x15, 0x54, 0x6d, 0xaa, 0xf6, 0x43, 0xbd, 0x79, 0x61, 0x33, 0x34,
        0xdb, 0x5e, 0xad, 0x34, 0x2f, 0xec, 0x85, 0x7c, 0x82, 0xf5, 0x46, 0x59, 0x10, 0xc0, 0xe5, 0x19,
        0xb9, 0xa1, 0x43, 0x37, 0x15, 0x41, 0x93, 0x14, 0xbf, 0xae, 0x62, 0x74, 0x08, 0xe0, 0x3b, 0xd9,
        0x7a, 0x11, 0x36, 0x44, 0xd3, 0x44, 0xfe, 0xb6, 0x4a, 0x05, 0x13, 0x56, 0xf3, 0x3d, 0x8c, 0x15,
        0x5f, 0x8d, 0x40, 0x98, 0x4d, 0xec, 0xef, 0xab, 0xc5, 0xb7, 0x34, 0x1a, 0xd2, 0x12, 0xe4, 0x49,
        0x31, 0x08, 0x96, 0xdb, 0x05, 0x79, 0x46, 0x76, 0xb1, 0x0d, 0xf7, 0xa6, 0x32, 0x52, 0x8e, 0x67,
        0xa2, 0xff, 0x40, 0x9a, 0xd6, 0x43, 0xc0, 0x42, 0x99, 0x08, 0xe5, 0x78, 0xa9, 0x89, 0xfd, 0x13,
        0xd9, 0x12, 0x00, 0xd8, 0x75, 0x52, 0x65, 0xf3, 0xde, 0x7f, 0x11, 0x4c, 0x00, 0x6c, 0x1a, 0x9e,
        0x8f, 0x89, 0x25, 0x13, 0xfb, 0x37, 0x6d, 0x1a, 0xd7, 0xf3, 0xdd, 0xac, 0x0f, 0x1e, 0xf3, 0x6f,
        0x95, 0x4c, 0xf0, 0x3f, 0x08, 0xb7, 0x08, 0xf8, 0xcb, 0xa9, 0x6a, 0x2a, 0xdf, 0x1c, 0xec, 0x7f,
        0x31, 0xd3, 0xb4, 0x9e, 0x4f, 0xb2, 0xfe, 0x54, 0x35, 0x9b, 0x19, 0xce, 0xa7, 0x06, 0xfc, 0xbf,
        0xd5, 0xf2, 0x2b, 0x8b, 0x92, 0x81, 0x6c, 0xdf, 0x7f, 0x4c, 0xc5, 0xd2, 0x8f, 0x94, 0x48, 0x4c,
        0x86, 0x15, 0x34, 0x68, 0xc8, 0xde, 0x07, 0x2e, 0x5f, 0x19, 0xeb, 0xf9, 0xe1, 0xca, 0x58, 0xcf,
        0x4f, 0x57, 0xc6, 0x7a, 0x4e, 0xff, 0x3c, 0x76, 0x15, 0x1b, 0x75, 0x65, 0x58, 0xf5, 0xec, 0x65,
        0x33, 0x72, 0x46, 0xce, 0xe6, 0x75, 0xe7, 0xee, 0x03, 0x9e, 0xaf, 0x16, 0xb3, 0xc6, 0xb8, 0x2b,
        0xc3, 0x9a, 0x1b, 0xc8, 0xac, 0xb9, 0xa3, 0xe1, 0x24, 0x7e, 0xaa, 0x9c, 0x9a, 0xdb, 0xd8, 0x91,
        0xc6, 0x7e, 0x53, 0x24, 0x35, 0x27, 0xf6, 0x77, 0x24, 0x59, 0x04, 0xaf, 0x59, 0xf3, 0x92, 0xd8,
        0x2d, 0x3f, 0xa4, 0x2a, 0x6b, 0xd4, 0xca, 0xff, 0x5f, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xe7,
        0x7c, 0x8d, 0x64, 0xbb, 0x15, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Rest Runtime Server of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.

package restruntime

import (
        "crypto/subtle"
        "fmt"
        "strings"
        "time"

        "net/http"
        "os"

        "github.com/chyeh/pubip"

        "github.com/cloud-barista/cb-store/config"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        aw "github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web"
        "github.com/sirupsen/logrus"

        // REST API (echo)
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"

        // echo-swagger middleware
        _ "github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/docs"
        echoSwagger "github.com/swaggo/echo-swagger"
)

var cblog *logrus.Logger

// @title CB-Spider REST API
// @version latest
// @description CB-Spider REST API

// @contact.name API Support
// @contact.url http://cloud-barista.github.io
// @contact.email contact-to-cloud-barista@googlegroups.com

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:1024
// @BasePath /spider

// @securityDefinitions.basic BasicAuth

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
        currentTime := time.Now()
        cr.StartTime = currentTime.Format("2006.01.02 15:04:05 Mon")
        cr.MiddleStartTime = currentTime.Format("2006.01.02.15:04:05")
        cr.ShortStartTime = fmt.Sprintf("T%02d:%02d:%02d", currentTime.Hour(), currentTime.Minute(), currentTime.Second())

        // REST and GO SERVER_ADDRESS since v0.4.4
        cr.ServerIPorName = getServerIPorName("SERVER_ADDRESS")
        cr.ServerPort = getServerPort("SERVER_ADDRESS")

        // REST SERVICE_ADDRESS for AdminWeb since v0.4.4
        cr.ServiceIPorName = getServiceIPorName("SERVICE_ADDRESS")
        cr.ServicePort = getServicePort("SERVICE_ADDRESS")
}</span>

// REST API Return struct for boolean type
type BooleanInfo struct {
        Result string // true or false
}

type StatusInfo struct {
        Status string // PENDING | RUNNING | SUSPENDING | SUSPENDED | REBOOTING | TERMINATING | TERMINATED
}

//ex) {"POST", "/driver", registerCloudDriver}
type route struct {
        method, path string
        function     echo.HandlerFunc
}

// JSON Simple message struct
type SimpleMsg struct {
        Message string `json:"message" example:"Any message"`
}

//// CB-Spider Servcie Address Configuration
////   cf)  https://github.com/cloud-barista/poc-cicd-spider/wiki/CB-Spider-Service-Address-Configuration

// REST and GO SERVER_ADDRESS since v0.4.4

// unset                           # default: like 'curl ifconfig.co':1024
// SERVER_ADDRESS="1.2.3.4:3000"  # =&gt; 1.2.3.4:3000
// SERVER_ADDRESS=":3000"         # =&gt; like 'curl ifconfig.co':3000
// SERVER_ADDRESS="localhost"      # =&gt; localhost:1024
// SERVER_ADDRESS="1.2.3.4:3000"        # =&gt; 1.2.3.4::3000
func getServerIPorName(env string) string <span class="cov8" title="1">{

        hostEnv := os.Getenv(env) // SERVER_ADDRESS or SERVICE_ADDRESS

        if hostEnv == "" </span><span class="cov8" title="1">{
                return getPublicIP()
        }</span>

        // "1.2.3.4" or "localhost"
        <span class="cov0" title="0">if !strings.Contains(hostEnv, ":") </span><span class="cov0" title="0">{
                return hostEnv
        }</span>

        <span class="cov0" title="0">strs := strings.Split(hostEnv, ":")
        fmt.Println(len(strs))
        if strs[0] == "" </span><span class="cov0" title="0">{ // ":31024"
                return getPublicIP()
        }</span> else<span class="cov0" title="0"> { // "1.2.3.4:31024" or "localhost:31024"
                return strs[0]
        }</span>
}

func getPublicIP() string <span class="cov8" title="1">{
        ip, err := pubip.Get()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                hostName, err := os.Hostname()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                }</span>
                <span class="cov0" title="0">return hostName</span>
        }

        <span class="cov8" title="1">return ip.String()</span>
}

func getServerPort(env string) string <span class="cov8" title="1">{
        // default REST Service Port
        servicePort := ":1024"

        hostEnv := os.Getenv(env) // SERVER_ADDRESS or SERVICE_ADDRESS
        if hostEnv == "" </span><span class="cov8" title="1">{
                return servicePort
        }</span>

        // "1.2.3.4" or "localhost"
        <span class="cov0" title="0">if !strings.Contains(hostEnv, ":") </span><span class="cov0" title="0">{
                return servicePort
        }</span>

        // ":31024" or "1.2.3.4:31024" or "localhost:31024"
        <span class="cov0" title="0">strs := strings.Split(hostEnv, ":")
        servicePort = ":" + strs[1]

        return servicePort</span>
}

// unset  SERVER_ADDRESS =&gt; SERVICE_ADDRESS
func getServiceIPorName(env string) string <span class="cov8" title="1">{
        hostEnv := os.Getenv(env)
        if hostEnv == "" </span><span class="cov8" title="1">{
                return cr.ServerIPorName
        }</span>
        <span class="cov0" title="0">return getServerIPorName(env)</span>
}

// unset  SERVER_ADDRESS =&gt; SERVICE_ADDRESS
func getServicePort(env string) string <span class="cov8" title="1">{
        hostEnv := os.Getenv(env)
        if hostEnv == "" </span><span class="cov8" title="1">{
                return cr.ServerPort
        }</span>
        <span class="cov0" title="0">return getServerPort(env)</span>
}

func RunServer() <span class="cov0" title="0">{

        //======================================= setup routes
        routes := []route{
                //----------root
                {"GET", "", aw.SpiderInfo},
                {"GET", "/", aw.SpiderInfo},

                //----------Swagger
                {"GET", "/swagger/*", echoSwagger.WrapHandler},

                //----------EndpointInfo
                {"GET", "/endpointinfo", EndpointInfo},

                //----------CloudOS
                {"GET", "/cloudos", ListCloudOS},

                //----------CloudDriverInfo
                {"POST", "/driver", RegisterCloudDriver},
                {"GET", "/driver", ListCloudDriver},
                {"GET", "/driver/:DriverName", GetCloudDriver},
                {"DELETE", "/driver/:DriverName", UnRegisterCloudDriver},

                //----------CredentialInfo
                {"POST", "/credential", RegisterCredential},
                {"GET", "/credential", ListCredential},
                {"GET", "/credential/:CredentialName", GetCredential},
                {"DELETE", "/credential/:CredentialName", UnRegisterCredential},

                //----------RegionInfo
                {"POST", "/region", RegisterRegion},
                {"GET", "/region", ListRegion},
                {"GET", "/region/:RegionName", GetRegion},
                {"DELETE", "/region/:RegionName", UnRegisterRegion},

                //----------ConnectionConfigInfo
                {"POST", "/connectionconfig", CreateConnectionConfig},
                {"GET", "/connectionconfig", ListConnectionConfig},
                {"GET", "/connectionconfig/:ConfigName", GetConnectionConfig},
                {"DELETE", "/connectionconfig/:ConfigName", DeleteConnectionConfig},

                //-------------------------------------------------------------------//

                //----------Image Handler
                {"POST", "/vmimage", CreateImage},
                {"GET", "/vmimage", ListImage},
                {"GET", "/vmimage/:Name", GetImage},
                {"DELETE", "/vmimage/:Name", DeleteImage},

                //----------VMSpec Handler
                {"GET", "/vmspec", ListVMSpec},
                {"GET", "/vmspec/:Name", GetVMSpec},
                {"GET", "/vmorgspec", ListOrgVMSpec},
                {"GET", "/vmorgspec/:Name", GetOrgVMSpec},

                //----------VPC Handler
                {"POST", "/vpc", CreateVPC},
                {"GET", "/vpc", ListVPC},
                {"GET", "/vpc/:Name", GetVPC},
                {"DELETE", "/vpc/:Name", DeleteVPC},
                //-- for subnet
                {"POST", "/vpc/:VPCName/subnet", AddSubnet},
                {"DELETE", "/vpc/:VPCName/subnet/:SubnetName", RemoveSubnet},
                {"DELETE", "/vpc/:VPCName/cspsubnet/:Id", RemoveCSPSubnet},
                //-- for management
                {"GET", "/allvpc", ListAllVPC},
                {"DELETE", "/cspvpc/:Id", DeleteCSPVPC},

                //----------SecurityGroup Handler
                {"POST", "/securitygroup", CreateSecurity},
                {"GET", "/securitygroup", ListSecurity},
                {"GET", "/securitygroup/:Name", GetSecurity},
                {"DELETE", "/securitygroup/:Name", DeleteSecurity},
                //-- for management
                {"GET", "/allsecuritygroup", ListAllSecurity},
                {"DELETE", "/cspsecuritygroup/:Id", DeleteCSPSecurity},

                //----------KeyPair Handler
                {"POST", "/keypair", CreateKey},
                {"GET", "/keypair", ListKey},
                {"GET", "/keypair/:Name", GetKey},
                {"DELETE", "/keypair/:Name", DeleteKey},
                //-- for management
                {"GET", "/allkeypair", ListAllKey},
                {"DELETE", "/cspkeypair/:Id", DeleteCSPKey},
                /*
                        //----------VNic Handler
                        {"POST", "/vnic", createVNic},
                        {"GET", "/vnic", listVNic},
                        {"GET", "/vnic/:VNicId", getVNic},
                        {"DELETE", "/vnic/:VNicId", deleteVNic},

                        //----------PublicIP Handler
                        {"POST", "/publicip", createPublicIP},
                        {"GET", "/publicip", listPublicIP},
                        {"GET", "/publicip/:PublicIPId", getPublicIP},
                        {"DELETE", "/publicip/:PublicIPId", deletePublicIP},
                */
                //----------VM Handler
                {"POST", "/vm", StartVM},
                {"GET", "/vm", ListVM},
                {"GET", "/vm/:Name", GetVM},
                {"DELETE", "/vm/:Name", TerminateVM},
                //-- for management
                {"GET", "/allvm", ListAllVM},
                {"DELETE", "/cspvm/:Id", TerminateCSPVM},

                {"GET", "/vmstatus", ListVMStatus},
                {"GET", "/vmstatus/:Name", GetVMStatus},

                {"GET", "/controlvm/:Name", ControlVM}, // suspend, resume, reboot

                //-------------------------------------------------------------------//
                //----------SSH RUN
                {"POST", "/sshrun", SSHRun},

                //----------AdminWeb Handler
                {"GET", "/adminweb", aw.Frame},
                {"GET", "/adminweb/top", aw.Top},
                {"GET", "/adminweb/driver", aw.Driver},
                {"GET", "/adminweb/credential", aw.Credential},
                {"GET", "/adminweb/region", aw.Region},
                {"GET", "/adminweb/connectionconfig", aw.Connectionconfig},
                {"GET", "/adminweb/spiderinfo", aw.SpiderInfo},

                {"GET", "/adminweb/vpc/:ConnectConfig", aw.VPC},
                {"GET", "/adminweb/vpcmgmt/:ConnectConfig", aw.VPCMgmt},
                {"GET", "/adminweb/securitygroup/:ConnectConfig", aw.SecurityGroup},
                {"GET", "/adminweb/securitygroupmgmt/:ConnectConfig", aw.SecurityGroupMgmt},
                {"GET", "/adminweb/keypair/:ConnectConfig", aw.KeyPair},
                {"GET", "/adminweb/keypairmgmt/:ConnectConfig", aw.KeyPairMgmt},
                {"GET", "/adminweb/vm/:ConnectConfig", aw.VM},
                {"GET", "/adminweb/vmmgmt/:ConnectConfig", aw.VMMgmt},

                {"GET", "/adminweb/vmimage/:ConnectConfig", aw.VMImage},
                {"GET", "/adminweb/vmspec/:ConnectConfig", aw.VMSpec},
        }
        //======================================= setup routes

        // Run API Server
        ApiServer(routes)

}</span>

//================ REST API Server: setup &amp; start
func ApiServer(routes []route) <span class="cov0" title="0">{
        e := echo.New()

        // Middleware
        e.Use(middleware.CORS())
        e.Use(middleware.Logger())
        e.Use(middleware.Recover())

        API_USERNAME := os.Getenv("API_USERNAME")
        API_PASSWORD := os.Getenv("API_PASSWORD")

        if API_USERNAME != "" &amp;&amp; API_PASSWORD != "" </span><span class="cov0" title="0">{
                cblog.Info("**** Rest Auth Enabled ****")
                e.Use(middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) </span><span class="cov0" title="0">{
                        // Be careful to use constant time comparison to prevent timing attacks
                        if subtle.ConstantTimeCompare([]byte(username), []byte(API_USERNAME)) == 1 &amp;&amp;
                                subtle.ConstantTimeCompare([]byte(password), []byte(API_PASSWORD)) == 1 </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">return false, nil</span>
                }))
        } else<span class="cov0" title="0"> {
                cblog.Info("**** Rest Auth Disabled ****")
        }</span>

        <span class="cov0" title="0">for _, route := range routes </span><span class="cov0" title="0">{
                // /driver =&gt; /spider/driver
                route.path = "/spider" + route.path
                switch route.method </span>{
                case "POST":<span class="cov0" title="0">
                        e.POST(route.path, route.function)</span>
                case "GET":<span class="cov0" title="0">
                        e.GET(route.path, route.function)</span>
                case "PUT":<span class="cov0" title="0">
                        e.PUT(route.path, route.function)</span>
                case "DELETE":<span class="cov0" title="0">
                        e.DELETE(route.path, route.function)</span>

                }
        }

        // for spider logo
        <span class="cov0" title="0">cbspiderRoot := os.Getenv("CBSPIDER_ROOT")
        e.File("/spider/adminweb/images/logo.png", cbspiderRoot+"/api-runtime/rest-runtime/admin-web/images/cb-spider-circle-logo.png")

        e.HideBanner = true
        e.HidePort = true

        spiderBanner()

        e.Logger.Fatal(e.Start(cr.ServerPort))</span>
}

//================ API Info
func apiInfo(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call apiInfo()")

        apiInfo := "api info"
        return c.String(http.StatusOK, apiInfo)
}</span>

//================ Endpoint Info
func EndpointInfo(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call endpointInfo()")

        endpointInfo := fmt.Sprintf("\n  &lt;CB-Spider&gt; Multi-Cloud Infrastructure Federation Framework\n")
        adminWebURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/adminweb"
        endpointInfo += fmt.Sprintf("     - AdminWeb: %s\n", adminWebURL)
        restEndPoint := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider"
        endpointInfo += fmt.Sprintf("     - REST API: %s\n", restEndPoint)
        // swaggerURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/swagger/index.html"
        // endpointInfo += fmt.Sprintf("     - Swagger : %s\n", swaggerURL)
        gRPCServer := "grpc://" + cr.ServiceIPorName + cr.GoServicePort
        endpointInfo += fmt.Sprintf("     - Go   API: %s\n", gRPCServer)

        return c.String(http.StatusOK, endpointInfo)
}</span>

func spiderBanner() <span class="cov0" title="0">{
        fmt.Println("\n  &lt;CB-Spider&gt; Multi-Cloud Infrastructure Federation Framework")

        // AdminWeb
        adminWebURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/adminweb"
        fmt.Printf("     - AdminWeb: %s\n", adminWebURL)

        // REST API EndPoint
        restEndPoint := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider"
        fmt.Printf("     - REST API: %s\n", restEndPoint)

        // Swagger
        // swaggerURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/swagger/index.html"
        // fmt.Printf("     - Swagger : %s\n", swaggerURL)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Cloud Control Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.04.
// by CB-Spider Team, 2019.10.

package restruntime

import (
        "fmt"

        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        // REST API (echo)
        "net/http"
        "net/url"

        "github.com/labstack/echo/v4"

        "strconv"
        "strings"
)

// define string of resource types
const (
        rsImage string = "image"
        rsVPC   string = "vpc"
        // rsSubnet = cm.SUBNET:{VPC NameID} =&gt; cook in code
        rsSG  string = "sg"
        rsKey string = "keypair"
        rsVM  string = "vm"
)

//================ Image Handler
func CreateImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createImage()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">reqInfo := cres.ImageReqInfo{
                IId: cres.IID{req.ReqInfo.Name, ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateImage(req.ConnectionName, rsImage, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listImage()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListImage(req.ConnectionName, rsImage)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.ImageInfo `json:"image"`
        }

        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getImage()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">encodededImageName := c.Param("Name")
        decodedImageName, err := url.QueryUnescape(encodededImageName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Fatal(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">result, err := cmrt.GetImage(req.ConnectionName, rsImage, decodedImageName)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func DeleteImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteImage()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.DeleteImage(req.ConnectionName, rsImage, c.Param("Name"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ VMSpec Handler
func ListVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VMSpecInfo `json:"vmspec"`
        }
        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVMSpec(req.ConnectionName, c.Param("Name"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListOrgVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listOrgVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListOrgVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.String(http.StatusOK, result)</span>
}

func GetOrgVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getOrgVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetOrgVMSpec(req.ConnectionName, c.Param("Name"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.String(http.StatusOK, result)</span>
}

type vpcCreateReq struct {
        ConnectionName string
        ReqInfo        struct {
                Name           string
                IPv4_CIDR      string
                SubnetInfoList []struct {
                        Name      string
                        IPv4_CIDR string
                }
        }
}

// createVPC godoc
// @Summary Create VPC
// @Description Create VPC
// @Tags [CCM] VPC management
// @Accept  json
// @Produce  json
// @Param vpcCreateReq body vpcCreateReq true "Request body to create VPC"
// @Success 200 {object} resources.VPCInfo
// @Failure 404 {object} SimpleMsg
// @Failure 500 {object} SimpleMsg
// @Router /vpc [post]
func CreateVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createVPC()")

        req := vpcCreateReq{}

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // check the input Name to include the SUBNET: Prefix
        <span class="cov8" title="1">if strings.HasPrefix(req.ReqInfo.Name, cm.SUBNET_PREFIX) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, fmt.Errorf(cm.SUBNET_PREFIX+" cannot be used for VPC name prefix!!"))
        }</span>
        // check the input Name to include the SecurityGroup Delimiter
        <span class="cov8" title="1">if strings.HasPrefix(req.ReqInfo.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, fmt.Errorf(cm.SG_DELIMITER+" cannot be used in VPC name!!"))
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        // (1) create SubnetInfo List
        <span class="cov8" title="1">subnetInfoList := []cres.SubnetInfo{}
        for _, info := range req.ReqInfo.SubnetInfoList </span><span class="cov8" title="1">{
                subnetInfo := cres.SubnetInfo{IId: cres.IID{info.Name, ""}, IPv4_CIDR: info.IPv4_CIDR}
                subnetInfoList = append(subnetInfoList, subnetInfo)
        }</span>
        // (2) create VPCReqInfo with SubnetInfo List
        <span class="cov8" title="1">reqInfo := cres.VPCReqInfo{
                IId:            cres.IID{req.ReqInfo.Name, ""},
                IPv4_CIDR:      req.ReqInfo.IPv4_CIDR,
                SubnetInfoList: subnetInfoList,
        }

        // Call common-runtime API
        result, err := cmrt.CreateVPC(req.ConnectionName, rsVPC, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVPC(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VPCInfo `json:"vpc"`
        }
        jsonResult.Result = result

        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all VPCs for management
// (1) get args from REST Call
// (2) get all VPC List by common-runtime API
// (3) return REST Json Format
func ListAllVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVPC(req.ConnectionName, rsVPC, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, rsVPC, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteCSPVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVPC, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get subnet info from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func AddSubnet(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call addSubnet()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name      string
                        IPv4_CIDR string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        <span class="cov8" title="1">reqSubnetInfo := cres.SubnetInfo{IId: cres.IID{req.ReqInfo.Name, ""}, IPv4_CIDR: req.ReqInfo.IPv4_CIDR}

        // Call common-runtime API
        result, err := cmrt.AddSubnet(req.ConnectionName, cm.SUBNET_PREFIX+c.Param("VPCName"), c.Param("VPCName"), reqSubnetInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func RemoveSubnet(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call removeSubnet()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, cm.SUBNET_PREFIX+c.Param("VPCName"), c.Param("SubnetName"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func RemoveCSPSubnet(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, cm.SUBNET_PREFIX+c.Param("VPCName"), c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

type securityGroupCreateReq struct {
        ConnectionName string
        ReqInfo        struct {
                Name          string
                VPCName       string
                Direction     string
                SecurityRules *[]cres.SecurityRuleInfo
        }
}

/* // createSecurity godoc
// @Summary Create Security Group
// @Description Create Security Group
// @Tags [CCM] Security Group management
// @Accept  json
// @Produce  json
// @Param securityGroupCreateReq body securityGroupCreateReq true "Request body to create Security Group"
// @Success 200 {object} resources.SecurityInfo
// @Failure 404 {object} SimpleMsg
// @Failure 500 {object} SimpleMsg
// @Router /securitygroup [post] */
func CreateSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createSecurity()")

        req := securityGroupCreateReq{}

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // check the input Name to include the SecurityGroup Delimiter
        <span class="cov8" title="1">if strings.Contains(req.ReqInfo.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, fmt.Errorf(cm.SG_DELIMITER+" cannot be used in Security Group name!!"))
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        <span class="cov8" title="1">reqInfo := cres.SecurityReqInfo{
                // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                // transform: SG NameID =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                //IId:           cres.IID{req.ReqInfo.VPCName + cm.SG_DELIMITER + req.ReqInfo.Name, ""},
                IId:           cres.IID{req.ReqInfo.VPCName + cm.SG_DELIMITER + req.ReqInfo.Name, req.ReqInfo.Name}, // for NCP: fixed NameID =&gt; SystemID, Driver: (1)search systemID with fixed NameID (2)replace fixed NameID into SysemID
                VpcIID:        cres.IID{req.ReqInfo.VPCName, ""},
                Direction:     req.ReqInfo.Direction,
                SecurityRules: req.ReqInfo.SecurityRules,
        }

        // Call common-runtime API
        result, err := cmrt.CreateSecurity(req.ConnectionName, rsSG, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListSecurity(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.SecurityInfo `json:"securitygroup"`
        }
        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all SGs for management
// (1) get args from REST Call
// (2) get all SG List by common-runtime API
// (3) return REST Json Format
func ListAllSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetSecurity(req.ConnectionName, rsSG, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, rsSG, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteCSPSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsSG, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// type keyPairCreateReq struct {
//         ConnectionName string
//         ReqInfo        struct {
//                 Name string
//         }
// }

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

// createKey godoc
// @Summary Create SSH Key
// @Description Create SSH Key
// @Tags [CCM] Access key management
// @Accept  json
// @Produce  json
// @Param keyPairCreateReq body JSONResult{ConnectionName=string,ReqInfo=JSONResult{Name=string}} true "Request body to create key"
// @Success 200 {object} resources.KeyPairInfo
// @Failure 404 {object} SimpleMsg
// @Failure 500 {object} SimpleMsg
// @Router /keypair [post]
func CreateKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createKey()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        <span class="cov8" title="1">reqInfo := cres.KeyPairReqInfo{
                IId: cres.IID{req.ReqInfo.Name, ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateKey(req.ConnectionName, rsKey, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListKey(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.KeyPairInfo `json:"keypair"`
        }
        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all KeyPairs for management
// (1) get args from REST Call
// (2) get all KeyPair List by common-runtime API
// (3) return REST Json Format
func ListAllKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetKey(req.ConnectionName, rsKey, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, rsKey, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteCSPKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsKey, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

/****************************
//================ VNic Handler
func createVNic(c echo.Context) error {
        cblog.Info("call createVNic()")

        var req struct {
                ConnectionName string
                ReqInfo cres.VNicReqInfo
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.CreateVNic(req.ReqInfo)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func listVNic(c echo.Context) error {
        cblog.Info("call listVNic()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        infoList, err := handler.ListVNic()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        var jsonResult struct {
                Result []*cres.VNicInfo `json:"vnic"`
        }
        if infoList == nil {
                infoList = []*cres.VNicInfo{}
        }
        jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)
}

func getVNic(c echo.Context) error {
        cblog.Info("call getVNic()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.GetVNic(c.Param("VNicId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func deleteVNic(c echo.Context) error {
        cblog.Info("call deleteVNic()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        result, err := handler.DeleteVNic(c.Param("VNicId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)
}

//================ PublicIP Handler
func createPublicIP(c echo.Context) error {
        cblog.Info("call createPublicIP()")

        var req struct {
                ConnectionName string
                ReqInfo cres.PublicIPReqInfo
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.CreatePublicIP(req.ReqInfo)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func listPublicIP(c echo.Context) error {
        cblog.Info("call listPublicIP()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        infoList, err := handler.ListPublicIP()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        var jsonResult struct {
                Result []*cres.PublicIPInfo `json:"publicip"`
        }
        if infoList == nil {
                infoList = []*cres.PublicIPInfo{}
        }
        jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)
}

func getPublicIP(c echo.Context) error {
        cblog.Info("call getPublicIP()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.GetPublicIP(c.Param("PublicIPId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func deletePublicIP(c echo.Context) error {
        cblog.Info("call deletePublicIP()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        result, err := handler.DeletePublicIP(c.Param("PublicIPId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)
}
****************************/

//================ VM Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func StartVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call startVM()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name               string
                        ImageName          string
                        VPCName            string
                        SubnetName         string
                        SecurityGroupNames []string
                        VMSpecName         string
                        KeyPairName        string

                        VMUserId     string
                        VMUserPasswd string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        // (1) create SecurityGroup IID List
        <span class="cov8" title="1">sgIIDList := []cres.IID{}
        for _, sgName := range req.ReqInfo.SecurityGroupNames </span><span class="cov8" title="1">{
                // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                // transform: SG NameID =&gt; {VPC NameID}-{SG NameID}
                sgIID := cres.IID{req.ReqInfo.VPCName + cm.SG_DELIMITER + sgName, ""}
                sgIIDList = append(sgIIDList, sgIID)
        }</span>
        // (2) create VMReqInfo with SecurityGroup IID List
        <span class="cov8" title="1">reqInfo := cres.VMReqInfo{
                IId:               cres.IID{req.ReqInfo.Name, ""},
                ImageIID:          cres.IID{req.ReqInfo.ImageName, ""},
                VpcIID:            cres.IID{req.ReqInfo.VPCName, ""},
                SubnetIID:         cres.IID{req.ReqInfo.SubnetName, ""},
                SecurityGroupIIDs: sgIIDList,

                VMSpecName: req.ReqInfo.VMSpecName,
                KeyPairIID: cres.IID{req.ReqInfo.KeyPairName, ""},

                VMUserId:     req.ReqInfo.VMUserId,
                VMUserPasswd: req.ReqInfo.VMUserPasswd,
        }

        // Call common-runtime API
        result, err := cmrt.StartVM(req.ConnectionName, rsVM, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVM(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VMInfo `json:"vm"`
        }
        jsonResult.Result = result

        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all VMs for management
// (1) get args from REST Call
// (2) get all VM List by common-runtime API
// (3) return REST Json Format
func ListAllVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVM(req.ConnectionName, rsVM, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func TerminateVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call terminateVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">_, result, err := cmrt.DeleteResource(req.ConnectionName, rsVM, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func TerminateCSPVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call terminateCSPVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">_, result, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVM, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

func ListVMStatus(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVMStatus()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVMStatus(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VMStatusInfo `json:"vmstatus"`
        }
        jsonResult.Result = result

        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetVMStatus(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVMStatus()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVMStatus(req.ConnectionName, rsVM, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

func ControlVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call controlVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ControlVM(req.ConnectionName, rsVM, c.Param("Name"), c.QueryParam("action"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package restruntime

import (
        "strconv"

        im "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager"
        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"

        // REST API (echo)
        "net/http"

        "github.com/labstack/echo/v4"
)

//================ List of support CloudOS
func ListCloudOS(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listCloudOS()")

        infoList := im.ListCloudOS()

        var jsonResult struct {
                Result []string `json:"cloudos"`
        }
        jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)
}</span>

//================ CloudDriver Handler
func RegisterCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerCloudDriver()")
        req := &amp;dim.CloudDriverInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">cldinfoList, err := dim.RegisterCloudDriverInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;cldinfoList)</span>
}

func ListCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listCloudDriver()")

        infoList, err := dim.ListCloudDriver()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*dim.CloudDriverInfo `json:"driver"`
        }
        if infoList == nil </span><span class="cov0" title="0">{
                infoList = []*dim.CloudDriverInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>

}

func GetCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getCloudDriver()")

        cldinfo, err := dim.GetCloudDriver(c.Param("DriverName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;cldinfo)</span>
}

func UnRegisterCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call unRegisterCloudDriver()")

        result, err := dim.UnRegisterCloudDriver(c.Param("DriverName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ Credential Handler
func RegisterCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerCredential()")

        req := &amp;cim.CredentialInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">crdinfoList, err := cim.RegisterCredentialInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfoList)</span>
}

func ListCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listCredential()")

        infoList, err := cim.ListCredential()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cim.CredentialInfo `json:"credential"`
        }
        if infoList == nil </span><span class="cov8" title="1">{
                infoList = []*cim.CredentialInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getCredential()")

        crdinfo, err := cim.GetCredential(c.Param("CredentialName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfo)</span>
}

func UnRegisterCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call unRegisterCredential()")

        result, err := cim.UnRegisterCredential(c.Param("CredentialName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ Region Handler
func RegisterRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerRegion()")

        req := &amp;rim.RegionInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">crdinfoList, err := rim.RegisterRegionInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfoList)</span>
}

func ListRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listRegion()")

        infoList, err := rim.ListRegion()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*rim.RegionInfo `json:"region"`
        }
        if infoList == nil </span><span class="cov8" title="1">{
                infoList = []*rim.RegionInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getRegion()")

        crdinfo, err := rim.GetRegion(c.Param("RegionName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfo)</span>
}

func UnRegisterRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call unRegisterRegion()")

        result, err := rim.UnRegisterRegion(c.Param("RegionName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ ConnectionConfig Handler
func CreateConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerConnectionConfig()")

        req := &amp;ccim.ConnectionConfigInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">crdinfoList, err := ccim.CreateConnectionConfigInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfoList)</span>
}

func ListConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listConnectionConfig()")

        infoList, err := ccim.ListConnectionConfig()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*ccim.ConnectionConfigInfo `json:"connectionconfig"`
        }
        if infoList == nil </span><span class="cov0" title="0">{
                infoList = []*ccim.ConnectionConfigInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getConnectionConfig()")

        crdinfo, err := ccim.GetConnectionConfig(c.Param("ConfigName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfo)</span>
}

func DeleteConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteConnectionConfig()")

        result, err := ccim.DeleteConnectionConfig(c.Param("ConfigName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Rest Runtime Server for VM's SSH and SCP of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.

package restruntime

import (
        sshrun "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/vm-ssh"

        "strings"
        // REST API (echo)
        "net/http"

        "github.com/labstack/echo/v4"
)

type SSHRUNReqInfo struct {
        UserName   string   // ex) "root"
        PrivateKey []string // ex)   ["-----BEGIN RSA PRIVATE KEY-----",
        //          "MIIEoQIBAAKCAQEArVNOLwMIp5VmZ4VPZotcoCHdEzimKalAsz+ccLfvAA1Y2ELH",
        //          "..."]
        ServerPort string // ex) "node12:22"
        Command    string // ex) "hostname"
}

//================ SSH RUN
func SSHRun(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call sshRun()")

        req := &amp;SSHRUNReqInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov8" title="1">strPrivateKey := strings.Join(req.PrivateKey[:], "\n")

        sshInfo := sshrun.SSHInfo{
                UserName:   req.UserName,
                PrivateKey: []byte(strPrivateKey),
                ServerPort: req.ServerPort,
        }
        var result string
        var err error
        if result, err = sshrun.SSHRun(sshInfo, req.Command); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, "Error while running cmd: "+req.Command+"]"+err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"

        "strconv"
        "net/http"
        "strings"
        "github.com/labstack/echo/v4"
        "encoding/json"
)

// number, Spider's NameId, CSP's SystemId, checkbox
func makeMgmtTRList_html(bgcolor string, height string, fontSize string, infoList cr.AllResourceList) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td $$NAMEIDSTYLE$$&gt;
                            &lt;font size=%s&gt;$$NAMEID$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td $$SYTEMIDSTYLE$$&gt;
                            &lt;font size=%s&gt;$$SYTEMID$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$ID$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList.AllList.MappedList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$NAMEID$$", one.NameId)
                str = strings.ReplaceAll(str, "$$SYTEMID$$", one.SystemId)
                str = strings.ReplaceAll(str, "$$ID$$", "::NAMEID::" + one.NameId) // MappedList: contain "::NAMEID::"
                str = strings.ReplaceAll(str, "$$NAMEIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                str = strings.ReplaceAll(str, "$$SYTEMIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                strData += str
        }</span>
        <span class="cov0" title="0">for i, one := range infoList.AllList.OnlySpiderList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$NAMEID$$", one.NameId)
                str = strings.ReplaceAll(str, "$$SYTEMID$$", "( " + one.SystemId + " )")
                str = strings.ReplaceAll(str, "$$ID$$", "::NAMEID::" + one.NameId) // OnlySpiderList: contain "::NAMEID::"

                str = strings.ReplaceAll(str, "$$NAMEIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                str = strings.ReplaceAll(str, "$$SYTEMIDSTYLE$$", ``)
                strData += str
        }</span>
        <span class="cov0" title="0">for i, one := range infoList.AllList.OnlyCSPList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$NAMEID$$", "( " + one.NameId + " )")
                str = strings.ReplaceAll(str, "$$SYTEMID$$", one.SystemId)
                str = strings.ReplaceAll(str, "$$ID$$", one.SystemId) // OnlyCSPList: not contain "::NAMEID::"

                str = strings.ReplaceAll(str, "$$NAMEIDSTYLE$$", ``)
                str = strings.ReplaceAll(str, "$$SYTEMIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                strData += str
        }</span>        

        <span class="cov0" title="0">return strData</span>
}

//====================================== VPC

// make the string of javascript function
func makeDeleteVPCMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/vpc/vpc-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspvpc/vpc-0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteVPCMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vpc/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspvpc/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VPCMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VPCMgmt()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr :=  `
                        &lt;html&gt;
                        &lt;head&gt;
                            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                            &lt;script type="text/javascript"&gt;
                                alert(connConfig)
                            &lt;/script&gt;
                        &lt;/head&gt;
                        &lt;body&gt;
                                &lt;br&gt;
                                &lt;br&gt;
                                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;        
                        &lt;/body&gt;
                `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>
        
        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()                
                htmlStr += makeDeleteVPCMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "vpc", "deleteVPCMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteVPCMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},                    
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list 
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "vpc")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                
                <span class="cov0" title="0">var info cr.AllResourceList
                
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== Security Group

// make the string of javascript function
func makeDeleteSecurityGroupMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/securitygroup/sg-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspsecuritygroup/sg-0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteSecurityGroupMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // if MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/securitygroup/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspsecuritygroup/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func SecurityGroupMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call SecurityGroupMgmt()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr :=  `
                        &lt;html&gt;
                        &lt;head&gt;
                            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                            &lt;script type="text/javascript"&gt;
                                alert(connConfig)
                            &lt;/script&gt;
                        &lt;/head&gt;
                        &lt;body&gt;
                                &lt;br&gt;
                                &lt;br&gt;
                                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;
                        &lt;/body&gt;
                `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makeDeleteSecurityGroupMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "vpc", "deleteSecurityGroupMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteSecurityGroupMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "securitygroup")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">var info cr.AllResourceList

                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== KeyPair

// make the string of javascript function
func makeDeleteKeyPairMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/keypair/keypair-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspkeypair/0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteKeyPairMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/keypair/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspkeypair/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func KeyPairMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call KeyPairMgmt()")

    connConfig := c.Param("ConnectConfig")
    if connConfig == "region not set" </span><span class="cov0" title="0">{
        htmlStr :=  `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

        return c.HTML(http.StatusOK, htmlStr)
    }</span>
    
        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()                
                htmlStr += makeDeleteKeyPairMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "keypair", "deleteKeyPairMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteKeyPairMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},                    
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list 
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "keypair")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                
                <span class="cov0" title="0">var info cr.AllResourceList
                
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VM

// make the string of javascript function
func makeDeleteVMMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/vm/vm-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspvm/0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteVMMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vm/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspvm/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VMMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VMMgmt()")

    connConfig := c.Param("ConnectConfig")
    if connConfig == "region not set" </span><span class="cov0" title="0">{
        htmlStr :=  `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;
            &lt;/body&gt;
        `

        return c.HTML(http.StatusOK, htmlStr)
    }</span>

        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makeDeleteVMMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "vm", "deleteVMMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteVMMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "vm")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">var info cr.AllResourceList

                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

</pre>
		
		<pre class="file" id="file33" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"

        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        "strconv"

        "encoding/json"
        "net/http"
        "strings"

        "github.com/labstack/echo/v4"
)

//====================================== VPC

// number, VPC Name, VPC CIDR, SUBNET Info, Additional Info, checkbox
func makeVPCTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.VPCInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPCNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPCCIDR$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SUBNETINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$VPCNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strRemoveSubnet := fmt.Sprintf(`
                &lt;a href="javascript:$$REMOVESUBNET$$;"&gt;
                        &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;X&lt;/b&gt;&lt;/font&gt;
                &lt;/a&gt;
                `, fontSize)

        strAddSubnet := fmt.Sprintf(`
                &lt;textarea style="font-size:12px;text-align:center;" name="subnet_text_box" id="subnet_text_box" cols=40&gt;{ "Name": "subnet-xx", "IPv4_CIDR": "192.168.xx.xx/24"}&lt;/textarea&gt;
                &lt;a href="javascript:$$ADDSUBNET$$;"&gt;
                        &lt;font size=%s&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                &lt;/a&gt;
                                                                `, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VPCNAME$$", one.IId.NameId)
                str = strings.ReplaceAll(str, "$$VPCCIDR$$", one.IPv4_CIDR)

                var vpcName = one.IId.NameId

                // for subnet
                strSubnetList := ""
                for _, one := range one.SubnetInfoList </span><span class="cov0" title="0">{
                        strSubnetList += one.IId.NameId + ", "
                        strSubnetList += "CIDR:" + one.IPv4_CIDR + ", {"
                        for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                                strSubnetList += kv.Key + ":" + kv.Value + ", "
                        }</span>
                        <span class="cov0" title="0">strSubnetList += "}"

                        var subnetName = one.IId.NameId
                        strSubnetList += strings.ReplaceAll(strRemoveSubnet, "$$REMOVESUBNET$$", "deleteSubnet('"+vpcName+"', '"+subnetName+"')")

                        strSubnetList += "&lt;br&gt;"</span>
                }
                <span class="cov0" title="0">strSubnetList += strings.ReplaceAll(strAddSubnet, "$$ADDSUBNET$$", "postSubnet('"+vpcName+"')")
                str = strings.ReplaceAll(str, "$$SUBNETINFO$$", strSubnetList)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostVPCFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/vpc -H 'Content-Type: application/json'
        //      -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "vpc-01", "IPv4_CIDR": "192.168.0.0/16",
        //              "SubnetInfoList": [ { "Name": "subnet-01", "IPv4_CIDR": "192.168.1.0/24"} ] } }'

        strFunc := `
                function postVPC() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$VPCNAME$$", "IPv4_CIDR" : "$$VPCCIDR$$", "SubnetInfoList" : $$SUBNETINFOLIST$$ }}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$VPCNAME$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$VPCCIDR$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$SUBNETINFOLIST$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/vpc", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makePostSubnetFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/vpc/vpc-01/subnet -H 'Content-Type: application/json'
        //      -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "subnet-02", "IPv4_CIDR": "192.168.2.0/24" } }'

        strFunc := `
                function postSubnet(vpcName) {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textbox = document.getElementById('subnet_text_box');
                        sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" :  $$SUBNETINFO$$ }'

                        sendJson = sendJson.replace("$$SUBNETINFO$$", textbox.value);

                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/vpc/" + vpcName + "/subnet", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteVPCFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/vpc/vpc-01 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteVPC() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vpc/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteSubnetFunc_js() string <span class="cov0" title="0">{
        //curl -sX DELETE http://localhost:1024/spider/vpc/vpc-01/subnet/subnet-02 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteSubnet(vpcName, subnetName) {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var xhr = new XMLHttpRequest();
                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vpc/" + vpcName + "/subnet/" + subnetName, false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                        xhr.send(sendJson);

                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VPC(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VPC()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
                        &lt;html&gt;
                        &lt;head&gt;
                            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                            &lt;script type="text/javascript"&gt;
                                alert(connConfig)
                            &lt;/script&gt;
                        &lt;/head&gt;
                        &lt;body&gt;
                                &lt;br&gt;
                                &lt;br&gt;
                                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;        
                        &lt;/body&gt;
                `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostVPCFunc_js()
        htmlStr += makeDeleteVPCFunc_js()
        htmlStr += makePostSubnetFunc_js()
        htmlStr += makeDeleteSubnetFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        //htmlStr += makeActionTR_html("6", "vpc", "deleteVPC()", "2")
        htmlStr += makeActionTR_html("6", "", "deleteVPC()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VPC Name", "200"},
                {"VPC CIDR", "200"},
                {"Subnet Info", "300"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vpc")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.VPCInfo `json:"vpc"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVPCTRList_html("", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="vpc-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" value="192.168.0.0/16"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="3" cols=50&gt;[ { "Name": "subnet-01", "IPv4_CIDR": "192.168.1.0/24"} ]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" disabled value="N/A"&gt;
                            &lt;/td&gt;                            
                            &lt;td&gt;
                                &lt;a href="javascript:postVPC()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== Security Group

// number, VPC Name, SecurityGroup Name, Security Rules, Additional Info, checkbox
func makeSecurityGroupTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.SecurityInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPCNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SGNAME$$&lt;/font&gt;
                    &lt;/td&gt;                    
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SECURITYRULES$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$SGNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VPCNAME$$", one.VpcIID.NameId)
                str = strings.ReplaceAll(str, "$$SGNAME$$", one.IId.NameId)

                // for security rules info
                strSRList := ""
                for _, one := range *one.SecurityRules </span><span class="cov0" title="0">{
                        strSRList += "FromPort:" + one.FromPort + ", "
                        strSRList += "ToPort:" + one.ToPort + ", "
                        strSRList += "IPProtocol:" + one.IPProtocol + ", "
                        strSRList += "Direction:" + one.Direction + ", "
                        strSRList += "CIDR:" + one.CIDR + ", "
                        strSRList += "}&lt;br&gt;"
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$SECURITYRULES$$", strSRList)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostSecurityGroupFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/securitygroup -H 'Content-Type: application/json'
        //  -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "sg-01", "VPCName": "vpc-01",
        //      "SecurityRules": [ {"FromPort": "1", "ToPort" : "65535", "IPProtocol" : "tcp", "Direction" : "inbound", "CIDR" : "0.0.0.0/0" } ] } }'

        strFunc := `
                function postSecurityGroup() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$SGNAME$$", "VPCName" : "$$VPCNAME$$", "SecurityRules" : $$SECURITYRULES$$ }}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$VPCNAME$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$SGNAME$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$SECURITYRULES$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/securitygroup", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteSecurityGroupFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/securitygroup/sg-01 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteSecurityGroup() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/securitygroup/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func SecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call SecurityGroup()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostSecurityGroupFunc_js()
        htmlStr += makeDeleteSecurityGroupFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        //htmlStr += makeActionTR_html("6", "securitygroup", "deleteSecurityGroup()", "2")
        htmlStr += makeActionTR_html("6", "", "deleteSecurityGroup()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VPC Name", "200"},
                {"SecurityGroup Name", "200"},
                {"Security Rules", "300"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "securitygroup")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.SecurityInfo `json:"securitygroup"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeSecurityGroupTRList_html("", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        nameList := vpcList(connConfig)

        htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                `
        // Select format of CloudOS  name=text_box, id=1
        htmlStr += makeSelect_html("onchangeVPC", nameList, "1")

        htmlStr += `
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" value="sg-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="3" cols=50 rows=3&gt;[ {"FromPort": "1", "ToPort" : "65535", "IPProtocol" : "tcp", "Direction" : "inbound", "CIDR" : "0.0.0.0/0" } ]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" disabled value="N/A"&gt;                            
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postSecurityGroup()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== KeyPair

// number, KeyPair Name, KeyPair Info, Key User, Additional Info, checkbox
func makeKeyPairTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.KeyPairInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$KEYPAIRNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$KEYINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$KEYUSER$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$KEYPAIRNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$KEYPAIRNAME$$", one.IId.NameId)
                // KeyPair Info: Fingerprint, PrivateKey, PublicKey
                runes := []rune(one.Fingerprint)
                fingerPrint := string(runes[0:12]) + "XXXXXXXXXXX"
                runes = []rune(one.PrivateKey)
                privateKey := string(runes[0:12]) + "XXXXXXXXXXX"
                runes = []rune(one.PublicKey)
                publicKey := string(runes[0:12]) + "XXXXXXXXXXX"
                keyInfo := "&amp;nbsp;* Fingerprint: " + fingerPrint + "&lt;br&gt;"
                keyInfo += "&amp;nbsp;* PrivateKey: " + privateKey + "&lt;br&gt;"
                keyInfo += "&amp;nbsp;* PublicKey: " + publicKey
                str = strings.ReplaceAll(str, "$$KEYINFO$$", keyInfo)
                str = strings.ReplaceAll(str, "$$KEYUSER$$", one.VMUserID)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostKeyPairFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/keypair -H 'Content-Type: application/json'
        //      -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "keypair-01" } }'

        strFunc := `
                function postKeyPair() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$KEYPAIRNAME$$"}}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$KEYPAIRNAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/keypair", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteKeyPairFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/keypair/keypair-01 -H 'Content-Type: application/json'
        //           -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteKeyPair() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/keypair/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func KeyPair(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call KeyPair()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostKeyPairFunc_js()
        htmlStr += makeDeleteKeyPairFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        //htmlStr += makeActionTR_html("6", "keypair", "deleteKeyPair()", "2")
        htmlStr += makeActionTR_html("6", "", "deleteKeyPair()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"KeyPair Name", "200"},
                {"KeyPair Info", "300"},
                {"Key User", "200"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "keypair")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.KeyPairInfo `json:"keypair"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeKeyPairTRList_html("", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="keypair-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postKeyPair()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VM

// number, VM Name/Control, VMStatus/Last Start Time, VMImage/VMSpec, VPC/Subnet/Security Group,
//         Network Interface/IP, DNS, Boot Disk/Block Disk, SSH AccessPoint/Access Key/Access User Name, Additional Info, checkbox
func makeVMTRList_html(connConfig string, bgcolor string, height string, fontSize string, infoList []*cres.VMInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMSTATUS$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$LASTSTARTTIME$$&lt;/font&gt;
                    &lt;/td&gt;                    
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$IMAGE$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$SPEC$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPC$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$SUBNET$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$SECURITYGROUP$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NETWORKINTERFACE$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$PUBLICIP$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$PRIVATEIP$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$PUBLICDNS$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$PRIVATEDNS$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$BOOTDISK$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$BLOCKDISK$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SSHACCESSPOINT$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$ACCESSKEY$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$ACCESSUSER$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$VMNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize,
                fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VMNAME$$", one.IId.NameId)
                status := vmStatus(connConfig, one.IId.NameId)
                str = strings.ReplaceAll(str, "$$VMSTATUS$$", status)
                str = strings.ReplaceAll(str, "$$LASTSTARTTIME$$", one.StartTime.Format("2006.01.02 15:04:05 Mon"))

                // for Image &amp; Spec
                str = strings.ReplaceAll(str, "$$IMAGE$$", one.ImageIId.NameId)
                str = strings.ReplaceAll(str, "$$SPEC$$", one.VMSpecName)

                // for VPC &amp; Subnet
                str = strings.ReplaceAll(str, "$$VPC$$", one.VpcIID.NameId)
                str = strings.ReplaceAll(str, "$$SUBNET$$", one.SubnetIID.NameId)

                // for security rules info
                strSRList := ""
                for _, one := range one.SecurityGroupIIds </span><span class="cov0" title="0">{
                        resBody, err := getResource_with_Connection_JsonByte(connConfig, "securitygroup", one.NameId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                break</span>
                        }
                        <span class="cov0" title="0">var secInfo cres.SecurityInfo
                        json.Unmarshal(resBody, &amp;secInfo)

                        strSRList += "["
                        for _, secRuleInfo := range *secInfo.SecurityRules </span><span class="cov0" title="0">{
                                strSRList += "{FromPort:" + secRuleInfo.FromPort + ", "
                                strSRList += "ToPort:" + secRuleInfo.ToPort + ", "
                                strSRList += "IPProtocol:" + secRuleInfo.IPProtocol + ", "
                                strSRList += "Direction:" + secRuleInfo.Direction + ", "
                                strSRList += "CIDR:" + secRuleInfo.CIDR
                                strSRList += "},&lt;br&gt;"
                        }</span>
                        <span class="cov0" title="0">strSRList += "]"</span>
                }
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$SECURITYGROUP$$", strSRList)

                // for Network Interface &amp; PublicIP &amp; PrivateIP
                str = strings.ReplaceAll(str, "$$NETWORKINTERFACE$$", one.NetworkInterface)
                str = strings.ReplaceAll(str, "$$PUBLICIP$$", one.PublicIP)
                str = strings.ReplaceAll(str, "$$PRIVATEIP$$", one.PrivateIP)

                // for Public DNS &amp; Private DNS
                str = strings.ReplaceAll(str, "$$PUBLICDNS$$", one.PublicDNS)
                str = strings.ReplaceAll(str, "$$PRIVATEDNS$$", one.PrivateDNS)

                // for Boot Disk &amp; Block Disk
                str = strings.ReplaceAll(str, "$$BOOTDISK$$", one.VMBootDisk)
                str = strings.ReplaceAll(str, "$$BLOCKDISK$$", one.VMBlockDisk)

                // for SSH AccessPoint &amp; Access Key &amp; Access User
                str = strings.ReplaceAll(str, "$$SSHACCESSPOINT$$", one.SSHAccessPoint)
                str = strings.ReplaceAll(str, "$$ACCESSKEY$$", one.KeyPairIId.NameId)
                str = strings.ReplaceAll(str, "$$ACCESSUSER$$", one.VMUserId)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostVMFunc_js() string <span class="cov0" title="0">{

        // curl -sX POST http://localhost:1024/spider/vm -H 'Content-Type: application/json'
        //  -d '{ "ConnectionName": "'${CONN_CONFIG}'",
        //  "ReqInfo": { "Name": "vm-01", "ImageName": "ami-0bbe28eb2173f6167", "VPCName": "vpc-01",
        //  "SubnetName": "subnet-01", "SecurityGroupNames": [ "sg-01" ], "VMSpecName": "t2.micro", "KeyPairName": "keypair-01"} }'

        strFunc := `
                function postVM() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$VMNAME$$", \
                                "ImageName" : "$$IMAGE$$", "VMSpecName" : "$$SPEC$$", "VPCName" : "$$VPC$$", "SubnetName" : "$$SUBNET$$", \
                                "SecurityGroupNames" : $$SECURITYGROUP$$, "KeyPairName" : "$$ACCESSKEY$$", "VMUserId" : "$$ACCESSUSER$$", "VMUserPasswd" : "$$ACCESSPASSWD$$" }}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$VMNAME$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$IMAGE$$", textboxes[i].value);
                                                break;
                                        case "4":
                                                sendJson = sendJson.replace("$$SPEC$$", textboxes[i].value);
                                                break;
                                        case "5":
                                                sendJson = sendJson.replace("$$VPC$$", textboxes[i].value);
                                                break;
                                        case "6":
                                                sendJson = sendJson.replace("$$SUBNET$$", textboxes[i].value);
                                                break;
                                        case "7":
                                                sendJson = sendJson.replace("$$SECURITYGROUP$$", textboxes[i].value);
                                                break;
                                        case "11":
                                                sendJson = sendJson.replace("$$ACCESSKEY$$", textboxes[i].value);
                                                break;
                                        case "12":
                                                sendJson = sendJson.replace("$$ACCESSUSER$$", textboxes[i].value);
                                                break;
                                        case "13":
                                                sendJson = sendJson.replace("$$ACCESSPASSWD$$", textboxes[i].value);
                                                break;

                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/vm", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteVMFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/vm/vm-01 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteVM() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vm/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VM(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VM()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostVMFunc_js()
        htmlStr += makeDeleteVMFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        htmlStr += makeActionTR_html("11", "", "deleteVM()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VM Name / Control", "200"},
                {"VM Status / Last Start Time", "200"},
                {"VM Image / VM Spec", "200"},
                {"VPC / Subnet / Security Group", "400"},
                {"NetworkInterface / PublicIP / PrivateIP", "400"},
                {"PublicDNS / PrivateDNS", "400"},
                {"BootDisk / BlockDisk", "200"},
                {"SSH AccessPoint / Access Key / Access User", "200"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vm")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.VMInfo `json:"vm"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVMTRList_html(connConfig, "", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        nameList := vpcList(connConfig)
        keyNameList := keyPairList(connConfig)
        providerName, _ := getProviderName(connConfig)

        imageName := ""
        specName := ""
        subnetName := ""
        sgName := ""
        vmUser := "" // AWS:ec2-user, Azure&amp;GCP:cb-user, Alibaba&amp;Cloudit:root, OpenStack: ubuntu
        switch providerName </span>{
        case "AWS":<span class="cov0" title="0">
                imageName = "ami-0bbe28eb2173f6167"
                specName = "t2.micro"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "ec2-user"</span>
        case "AZURE":<span class="cov0" title="0">
                imageName = "Canonical:UbuntuServer:18.04-LTS:latest"
                specName = "Standard_B1ls"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "cb-user"</span>
        case "GCP":<span class="cov0" title="0">
                imageName = "https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/ubuntu-minimal-1804-bionic-v20191024"
                specName = "f1-micro"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "cb-user"</span>
        case "ALIBABA":<span class="cov0" title="0">
                imageName = "ubuntu_18_04_x64_20G_alibase_20200220.vhd"
                specName = "ecs.t5-lc1m2.small"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "root"</span>
        case "CLOUDIT":<span class="cov0" title="0">
                imageName = "CentOS-7"
                specName = "small-2"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "root"</span>
        case "OPENSTACK":<span class="cov0" title="0">
                imageName = "Ubuntu16.04_2"
                specName = "nano.1"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "ubuntu"</span>
        case "DOCKER":<span class="cov0" title="0">
                imageName = "nginx:latest"
                subnetName = ""
                sgName = `[]`
                specName = ""
                vmUser = ""</span>
        case "MOCK":<span class="cov0" title="0">
                imageName = "mock-vmimage-01"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                specName = "mock-vmspec-01"
                vmUser = "cb-user"</span>
        case "CLOUDTWIN":<span class="cov0" title="0">
                imageName = "ubuntu18.04-sshd-systemd"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                specName = "spec-1"
                vmUser = "cb-user"</span>
        default:<span class="cov0" title="0">
                imageName = "ami-0bbe28eb2173f6167"
                specName = "t2.micro"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "ec2-user"</span>
        }

        <span class="cov0" title="0">htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="vm-01"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="$$IMAGENAME$$"&gt;
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" value="$$SPECNAME$$"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                            `
        // Select format of VPC  name=text_box, id=5
        htmlStr += makeSelect_html("onchangeVPC", nameList, "5")

        htmlStr += `

                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="6" value="$$SUBNETNAME$$"&gt;
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="7" value=$$SGNAME$$&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="8" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="9" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="10" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                            `
        // Select format of KeyPair  name=text_box, id=11
        htmlStr += makeKeyPairSelect_html("onchangeKeyPair", keyNameList, "11")

        htmlStr += `
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="12" value="$$VMUSER$$"&gt;
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="password" name="text_box" id="13" value=""&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="14" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postVM()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `

        // set imageName &amp; specName &amp; vmUser
        htmlStr = strings.ReplaceAll(htmlStr, "$$IMAGENAME$$", imageName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$SPECNAME$$", specName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$SUBNETNAME$$", subnetName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$SGNAME$$", sgName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$VMUSER$$", vmUser)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VMImage

// number, VMImage Name, GuestOS, VMImage Status, KeyValueList
func makeVMImageTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.ImageInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMIMAGENAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$GUESTOS$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMIMAGESTATUS$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VMIMAGENAME$$", one.IId.NameId)
                str = strings.ReplaceAll(str, "$$GUESTOS$$", one.GuestOS)
                str = strings.ReplaceAll(str, "$$VMIMAGESTATUS$$", one.Status)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

func VMImage(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VMImage()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;/head&gt;

                &lt;body&gt;
        &lt;br&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VMImage Name", "200"},
                {"GuestOS", "300"},
                {"VMImage Status", "200"},
                {"Additional Info", "400"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, false)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vmimage")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.ImageInfo `json:"image"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVMImageTRList_html("", "", "", info.ResultList)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VMSpec

// number, VMSpec Name, VCPU, Memory, GPU, KeyValueList
func makeVMSpecTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.VMSpecInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMSPECNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$VCPUINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$MEMINFO$$ MB&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$GPUINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VMSPECNAME$$", one.Name)
                // VCPU Info: count, GHz
                vcpuInfo := "&amp;nbsp;* Count: " + one.VCpu.Count + "&lt;br&gt;"
                vcpuInfo += "&amp;nbsp;* Clock: " + one.VCpu.Clock + "GHz" + "&lt;br&gt;"
                str = strings.ReplaceAll(str, "$$VCPUINFO$$", vcpuInfo)

                // Mem Info
                str = strings.ReplaceAll(str, "$$MEMINFO$$", one.Mem)

                // GPU Info: Mfr, Model, Mem, Count
                gpuInfo := ""
                for _, gpu := range one.Gpu </span><span class="cov0" title="0">{
                        gpuInfo += "&amp;nbsp;* Mfr: " + gpu.Mfr + "&lt;br&gt;"
                        gpuInfo += "&amp;nbsp;* Model: " + gpu.Model + "&lt;br&gt;"
                        gpuInfo += "&amp;nbsp;* Memory: " + gpu.Mem + " MB" + "&lt;br&gt;"
                        gpuInfo += "&amp;nbsp;* Count: " + gpu.Count + "&lt;br&gt;&lt;br&gt;"
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$GPUINFO$$", gpuInfo)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

func VMSpec(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VMSpec()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;/head&gt;

                &lt;body&gt;
        &lt;br&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VMSpec Name", "200"},
                {"VCPU", "300"},
                {"Memory", "200"},
                {"GPU", "300"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, false)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vmspec")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.VMSpecInfo `json:"vmspec"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVMSpecTRList_html("", "", "", info.ResultList)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"
        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
        "strconv"

        "net/http"
        "strings"
        "github.com/labstack/echo/v4"
        "encoding/json"
)

// number, Provider Name, Driver File, Driver Name, checkbox
func makeDriverTRList_html(bgcolor string, height string, fontSize string, infoList []*dim.CloudDriverInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S1$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$S3$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                       `, bgcolor, height, fontSize, fontSize, fontSize, fontSize) 

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$S1$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$S2$$", one.DriverLibFileName)
                str = strings.ReplaceAll(str, "$$S3$$", one.DriverName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makeOnchangeDriverProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
                document.getElementById('2').value= providerName.toLowerCase() + "-driver-v1.0.so";
                document.getElementById('3').value= providerName.toLowerCase() + "-driver-01";
              }
        `

        return strFunc
}</span>

// make the string of javascript function
func makeCheckBoxToggleFunc_js() string <span class="cov0" title="0">{

        strFunc := `
              function toggle(source) {
                var checkboxes = document.getElementsByName('check_box');
                for (var i = 0; i &lt; checkboxes.length; i++) {
                  checkboxes[i].checked = source.checked;
                }
              }
        `

        return strFunc
}</span>

// make the string of javascript function
func makePostDriverFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/driver -H 'Content-Type: application/json'  -d '{"DriverName":"aws-driver01","ProviderName":"AWS", "DriverLibFileName":"aws-driver-v1.0.so"}'

        strFunc := `
                function postDriver() {
                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ProviderName" : "$$PROVIDER$$", "DriverLibFileName" : "$$$DRVFILE$$", "DriverName" : "$$NAME$$" }'
                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$$DRVFILE$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/driver", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        //xhr.send(JSON.stringify({ "DriverName": driverName, "ProviderName": providerName, "DriverLibFileName": driverLibFileName}));
                        //xhr.send(JSON.stringify(sendJson));
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteDriverFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/driver/gcp-driver01 -H 'Content-Type: application/json'

        strFunc := `
                function deleteDriver() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/driver/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

//================ Driver Info Management
// create driver page
func Driver(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Driver()")

        // make page header
        htmlStr :=  ` 
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeOnchangeDriverProviderFunc_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostDriverFunc_js()
                htmlStr += makeDeleteDriverFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;      
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("5", "driver", "deleteDriver()", "2")


        // (3) make Table Header TR
                
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Driver Library Name", "300"},
                    {"Driver Name", "200"},
                }        
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("driver")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*dim.CloudDriverInfo `json:"driver"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeDriverTRList_html("", "", "", info.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
                `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")

                htmlStr += `
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" value="aws-driver-v1.0.so"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="aws-driver-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postDriver()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

// make the string of javascript function
func makeOnchangeCredentialProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
                // for credential info
                switch(providerName) {
                  case "AWS":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]'
                    break;
                  case "AZURE":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXX-XXXX"}, {"Key":"ClientSecret", "Value":"xxxx-xxxx"}, {"Key":"TenantId", "Value":"xxxx-xxxx"}, {"Key":"SubscriptionId", "Value":"xxxx-xxxx"}]'
                    break;
                  case "GCP":
                        credentialInfo = '[{"Key":"PrivateKey", "Value":"-----BEGIN PRIVATE KEY-----\nXXXX\n-----END PRIVATE KEY-----\n"},{"Key":"ProjectID", "Value":"powerkimhub"}, {"Key":"ClientEmail", "Value":"xxxx@xxxx.iam.gserviceaccount.com"}]'
                    break;
                  case "ALIBABA":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]'
                    break;
                  case "CLOUDIT":
                        credentialInfo = '[{"Key":"IdentityEndpoint", "Value":"http://xxx.xxx.co.kr:9090"}, {"Key":"AuthToken", "Value":"xxxx"}, {"Key":"Username", "Value":"xxxx"}, {"Key":"Password", "Value":"xxxx"}, {"Key":"TenantId", "Value":"tnt0009"}]'
                    break;
                  case "OPENSTACK":
                        credentialInfo = '[{"Key":"IdentityEndpoint", "Value":"http://123.456.789.123:5000/v3"}, {"Key":"Username", "Value":"etri"}, {"Key":"Password", "Value":"xxxx"}, {"Key":"DomainName", "Value":"default"}, {"Key":"ProjectID", "Value":"xxxx"}]'
                    break;
                  case "DOCKER":
                        credentialInfo = '[{"Key":"Host", "Value":"http://123.456.789.123:1004"}, {"Key":"APIVersion", "Value":"v1.38"}]'
                    break;

                  case "NCP":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXXXXXXXXXXXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXXXXXXXXXXXXXXXXXXXXXXX"}]'
                    break;
                  case "MOCK":
                        credentialInfo = '[{"Key":"MockName", "Value":"mock_name00"}]'
                    break;
                  case "CLOUDTWIN":
                        credentialInfo = '[{"Key":"IdentityEndpoint", "Value":"http://123.456.789.123:8192"}, {"Key":"DomainName", "Value":"cloud-1"}, {"Key":"MockName", "Value":"mock_name01"}]'
                    break;
                  default:
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]'
                }
                document.getElementById('2').value= credentialInfo

                // for credential name
                document.getElementById('3').value= providerName.toLowerCase() + "-credential-01";
              }
        `
        return strFunc
}</span>

// number, Provider Name, Credential Info, Credential Name, checkbox
func makeCredentialTRList_html(bgcolor string, height string, fontSize string, infoList []*cim.CredentialInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S1$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$S3$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$S1$$", one.ProviderName)
                strKeyList := ""
                for _, kv := range one.KeyValueInfoList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":xxxx, "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$S2$$", strKeyList)
                str = strings.ReplaceAll(str, "$$S3$$", one.CredentialName)
                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostCredentialFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/credential -H 'Content-Type: application/json' '{"CredentialName":"aws-credential-01","ProviderName":"AWS", "KeyValueInfoList": [{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]}'

        strFunc := `
                function postCredential() {
                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ProviderName" : "$$PROVIDER$$", "KeyValueInfoList" : $$CREDENTIALINFO$$, "CredentialName" : "$$NAME$$" }'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$CREDENTIALINFO$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/credential", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        //xhr.send(JSON.stringify({ "CredentialName": credentialName, "ProviderName": providerName, "KeyValueInfoList": credentialInfo}));
                        //xhr.send(JSON.stringify(sendJson));
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteCredentialFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/credential/aws-credential-01 -H 'Content-Type: application/json'

        strFunc := `
                function deleteCredential() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/credential/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

//================ Credential Info Management
// create credential page
func Credential(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Credential()")

        // make page header
        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeOnchangeCredentialProviderFunc_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostCredentialFunc_js()
                htmlStr += makeDeleteCredentialFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("5", "credential", "deleteCredential()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Credential Info", "300"},
                    {"Credential Name", "200"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("credential")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*cim.CredentialInfo `json:"credential"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeCredentialTRList_html("", "", "", info.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
                `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")
                        
                htmlStr += `        
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="2" cols=50&gt;[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="aws-credential-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postCredential()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

// make the string of javascript function
func makeOnchangeRegionProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
        // for region info
        switch(providerName) {
          case "AWS":
            regionInfo = '[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]'
            region = '(ohio)us-east-2'
            zone = ''
            break;
          case "AZURE":
            regionInfo = '[{"Key":"location", "Value":"northeurope"}, {"Key":"ResourceGroup", "Value":"CB-GROUP-POWERKIM"}]'
            region = 'northeurope'
            zone = ''            
            break;
          case "GCP":
            regionInfo = '[{"Key":"Region", "Value":"us-central1"},{"Key":"Zone", "Value":"us-central1-a"}]'
            region = 'us-central1'
            zone = 'us-central1-a'             
            break;
          case "ALIBABA":
            regionInfo = '[{"Key":"Region", "Value":"ap-northeast-1"}, {"Key":"Zone", "Value":"ap-northeast-1a"}]'
            region = 'ap-northeast-1'
            zone = 'ap-northeast-1a'             
            break;
          case "CLOUDIT":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = ''            
            break;
          case "OPENSTACK":
            regionInfo = '[{"Key":"Region", "Value":"RegionOne"}]'
            region = 'RegionOne'
            zone = 'RegionOne'            
            break;
          case "DOCKER":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = ''             
            break;

          case "NCP":
            regionInfo = '[{"Key":"region", "Value":"KR"}]'
            region = 'KR'
            zone = ''             
            break;

          case "MOCK":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = ''             
            break;
          case "CLOUDTWIN":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = '' 
            break;
          default:
            regionInfo = '[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]'
            region = '(ohio)us-east-2'
            zone = ''
        }
                document.getElementById('2').value= regionInfo

        // for region-zone name
                document.getElementById('3').value= providerName.toLowerCase() + "-" + region + "-" + zone;
              }
        `
        return strFunc
}</span>

// number, Provider Name, Region Info, Region Name, checkbox
func makeRegionTRList_html(bgcolor string, height string, fontSize string, infoList []*rim.RegionInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S1$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$S3$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$S1$$", one.ProviderName)
        strKeyList := ""
                for _, kv := range one.KeyValueInfoList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$S2$$", strKeyList)
                str = strings.ReplaceAll(str, "$$S3$$", one.RegionName)
                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostRegionFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/region -H 'Content-Type: application/json' 
//      -d '{"RegionName":"aws-(ohio)us-east-2","ProviderName":"AWS", "KeyValueInfoList": 
//.       '[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]'}'

        strFunc := `
                function postRegion() {
                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ProviderName" : "$$PROVIDER$$", "KeyValueInfoList" : $$REGIONINFO$$, "RegionName" : "$$NAME$$" }'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$REGIONINFO$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/region", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        //xhr.send(JSON.stringify({ "RegionName": regionName, "ProviderName": providerName, "KeyValueInfoList": regionInfo}));
                        //xhr.send(JSON.stringify(sendJson));
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteRegionFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/region/aws-(ohio)us-east-2 -H 'Content-Type: application/json'

        strFunc := `
                function deleteRegion() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/region/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

//================ Region Info Management
// create region page
func Region(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Region()")

        // make page header
        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeOnchangeRegionProviderFunc_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostRegionFunc_js()
                htmlStr += makeDeleteRegionFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("5", "region", "deleteRegion()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Region Info", "300"},
                    {"Region Name", "200"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("region")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*rim.RegionInfo `json:"region"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeRegionTRList_html("", "", "", info.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
        `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")
            
        htmlStr += `    
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="2" cols=50&gt;[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="aws-(ohio)us-east-2"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postRegion()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

// make the string of javascript function
func makeOnInitialInputBoxSetup_js() string <span class="cov0" title="0">{
        strFunc := `
              function onInitialSetup() {
                 cspSelect = document.getElementById('1')
                 onchangeProvider(cspSelect) 
              }
        `
        return strFunc
}</span>

// make the string of javascript function
func makeOnchangeConnectionConfigProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
        // for credential info
        var driverNameList = []
        var credentialNameList
        var regionNameList
        switch(providerName) {
          case "AWS":
            driverNameList = document.getElementsByName('driverName-AWS');
            credentialNameList = document.getElementsByName('credentialName-AWS');
            regionNameList = document.getElementsByName('regionName-AWS');
            break;
          case "AZURE":
            driverNameList = document.getElementsByName('driverName-AZURE');
            credentialNameList = document.getElementsByName('credentialName-AZURE');
            regionNameList = document.getElementsByName('regionName-AZURE');
            break;
          case "GCP":
            driverNameList = document.getElementsByName('driverName-GCP');
            credentialNameList = document.getElementsByName('credentialName-GCP');
            regionNameList = document.getElementsByName('regionName-GCP');
            break;
          case "ALIBABA":
            driverNameList = document.getElementsByName('driverName-ALIBABA');
            credentialNameList = document.getElementsByName('credentialName-ALIBABA');
            regionNameList = document.getElementsByName('regionName-ALIBABA');
            break;
          case "CLOUDIT":
            driverNameList = document.getElementsByName('driverName-CLOUDIT');
            credentialNameList = document.getElementsByName('credentialName-CLOUDIT');
            regionNameList = document.getElementsByName('regionName-CLOUDIT');
            break;
          case "OPENSTACK":
            driverNameList = document.getElementsByName('driverName-OPENSTACK');
            credentialNameList = document.getElementsByName('credentialName-OPENSTACK');
            regionNameList = document.getElementsByName('regionName-OPENSTACK');
            break;
          case "DOCKER":
            driverNameList = document.getElementsByName('driverName-DOCKER');
            credentialNameList = document.getElementsByName('credentialName-DOCKER');
            regionNameList = document.getElementsByName('regionName-DOCKER');
            break;
          case "NCP":
            driverNameList = document.getElementsByName('driverName-NCP');
            credentialNameList = document.getElementsByName('credentialName-NCP');
            regionNameList = document.getElementsByName('regionName-NCP');
            break;
          case "MOCK":
            driverNameList = document.getElementsByName('driverName-MOCK');
            credentialNameList = document.getElementsByName('credentialName-MOCK');
            regionNameList = document.getElementsByName('regionName-MOCK');
            break;
          case "CLOUDTWIN":
            driverNameList = document.getElementsByName('driverName-CLOUDTWIN');
            credentialNameList = document.getElementsByName('credentialName-CLOUDTWIN');
            regionNameList = document.getElementsByName('regionName-CLOUDTWIN');
            break;
          default:
            driverNameList = document.getElementsByName('driverName-AWS');
            credentialNameList = document.getElementsByName('credentialName-AWS');
            regionNameList = document.getElementsByName('regionName-AWS');
        }

        // Select Tag for drivers
        //  options remove &amp; create
        var len = document.getElementById('2').options.length
        for (var i=0; i &lt; len; i++) {
                document.getElementById('2').remove(0);
        }
        for (var i=0; i &lt; driverNameList.length; i++) {
                document.getElementById('2').options.add(new Option(driverNameList[i].innerHTML, driverNameList[i].innerHTML));
        }

        // Select Tag for Credentials
        //  options remove &amp; create
        var len = document.getElementById('3').options.length
        for (var i=0; i &lt; len; i++) {
                document.getElementById('3').remove(0);
        }
        for (var i=0; i &lt; credentialNameList.length; i++) {
                document.getElementById('3').options.add(new Option(credentialNameList[i].innerHTML, credentialNameList[i].innerHTML));
        }

        // Select Tag for Regions
        //  options remove &amp; create
        var len = document.getElementById('4').options.length
        for (var i=0; i &lt; len; i++) {
                document.getElementById('4').remove(0);
        }
        for (var i=0; i &lt; regionNameList.length; i++) {
                document.getElementById('4').options.add(new Option(regionNameList[i].innerHTML, regionNameList[i].innerHTML));
        }

        document.getElementById('5').value= providerName.toLowerCase() + "-" +  document.getElementById('4').value + "-connection-config-01";

              }
        `
        return strFunc
}</span>

func getProviderName(connConfig string) (string, error) <span class="cov0" title="0">{
        resBody, err := getResource_JsonByte("connectionconfig", connConfig)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">var configInfo ccim.ConnectionConfigInfo
        json.Unmarshal(resBody, &amp;configInfo)

        return configInfo.ProviderName, nil</span>
}

func getRegionZone(regionName string) (string, string, error) <span class="cov0" title="0">{
        // Region Name List
        resBody, err := getResource_JsonByte("region", regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", "", err 
        }</span>
        <span class="cov0" title="0">var regionInfo rim.RegionInfo
        json.Unmarshal(resBody, &amp;regionInfo)

        region := ""
        zone := ""
        // get the region &amp; zone
        for _, one := range regionInfo.KeyValueInfoList </span><span class="cov0" title="0">{
                if one.Key == "Region" || one.Key == "region" </span><span class="cov0" title="0">{
                        region = one.Value
                }</span>
                <span class="cov0" title="0">if one.Key == "location" </span><span class="cov0" title="0">{
                        region = one.Value
                }</span>
                <span class="cov0" title="0">if one.Key == "Zone" || one.Key == "zone" </span><span class="cov0" title="0">{
                        zone = one.Value
                }</span>
                
        }
        <span class="cov0" title="0">return region, zone, nil</span>
}

// make the string of javascript function
func makeSetupConnectionConfigFunc_js() string <span class="cov0" title="0">{

        strFunc := `
                function setupConnectionConfig(configName, providerName, region, zone) {
                        var connConfigLabel = parent.frames["top_frame"].document.getElementById("connConfig");
                        connConfigLabel.innerHTML = configName

                        var cspText = parent.frames["top_frame"].document.getElementById("connDisplay");
                        if (zone) {
                                cspText.value = providerName + ": " + region + " / " + zone
                        } else {
                                cspText.value = providerName + ": " + region
                        }

                        // for vpc
                        var a = parent.frames["top_frame"].document.getElementById("vpcHref");
                        a.href = "vpc/" + configName
                        a = parent.frames["top_frame"].document.getElementById("vpcmgmtHref");
                        a.href = "vpcmgmt/" + configName

                        // for securitygroup
                        a = parent.frames["top_frame"].document.getElementById("securitygroupHref");
                        a.href = "securitygroup/" + configName
                        a = parent.frames["top_frame"].document.getElementById("securitygroupmgmtHref");
                        a.href = "securitygroupmgmt/" + configName

                        // for KeyPair
                        a = parent.frames["top_frame"].document.getElementById("keypairHref");
                        a.href = "keypair/" + configName
                        a = parent.frames["top_frame"].document.getElementById("keypairmgmtHref");
                        a.href = "keypairmgmt/" + configName

                        // for vm
                        a = parent.frames["top_frame"].document.getElementById("vmHref");
                        a.href = "vm/" + configName
                        a = parent.frames["top_frame"].document.getElementById("vmmgmtHref");
                        a.href = "vmmgmt/" + configName


                    // for VMImage
                    a = parent.frames["top_frame"].document.getElementById("vmimageHref");
                    a.href = "vmimage/" + configName

                    // for VMSpec
                    a = parent.frames["top_frame"].document.getElementById("vmspecHref");
                    a.href = "vmspec/" + configName

                }
        `
        return strFunc
}</span>

// number, Provider Name, Driver Name, Credential Name, Region Name, Connection Name, checkbox
func makeConnectionConfigTRList_html(bgcolor string, height string, fontSize string, infoList []*ccim.ConnectionConfigInfo) (string, error) <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$PROVIDERNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S4$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;                                       &lt;!-- configName, CSP, Region, Zone --&gt;
                        &lt;a href="javascript:setupConnectionConfig('$$CONFIGNAME$$', '$$PROVIDERNAME$$', '$$REGION$$', '$$ZONE$$')"&gt;
                            &lt;font size=%s&gt;$$CONFIGNAME$$&lt;/font&gt;
                        &lt;/a&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$CONFIGNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$PROVIDERNAME$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$S2$$", one.DriverName)
                str = strings.ReplaceAll(str, "$$S3$$", one.CredentialName)
                str = strings.ReplaceAll(str, "$$S4$$", one.RegionName)
                str = strings.ReplaceAll(str, "$$CONFIGNAME$$", one.ConfigName)

                region, zone, err := getRegionZone(one.RegionName)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return "", err
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$REGION$$", region)
                str = strings.ReplaceAll(str, "$$ZONE$$", zone)
        
                strData += str</span>
        }

        <span class="cov0" title="0">return strData, nil</span>
}

// make the string of javascript function
func makePostConnectionConfigFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/connectionconfig -H 'Content-Type: application/json' 
//    -d '{"ProviderName":"AWS", "DriverName":"aws-driver01", "CredentialName":"aws-credential-01", "RegionName":"aws-ohio", "ConfigName":"aws-ohio-config",}'

        strFunc := `
                function postConnectionConfig() {
                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ProviderName" : "$$PROVIDER$$", "DriverName" : "$$DRIVERNAME$$", "CredentialName" : "$$CREDENTIALNAME$$", \
                                                "RegionName" : "$$REGIONNAME$$", "ConfigName" : "$$NAME$$" }'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$DRIVERNAME$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$CREDENTIALNAME$$", textboxes[i].value);
                                                break;
                                        case "4":
                                                sendJson = sendJson.replace("$$REGIONNAME$$", textboxes[i].value);
                                                break;                                                
                                        case "5":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/connectionconfig", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteConnectionConfigFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/connectionconfig/aws-connection01 -H 'Content-Type: application/json'

        strFunc := `
                function deleteConnectionConfig() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/connectionconfig/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func makeDriverNameHiddenTRList_html(infoList []*dim.CloudDriverInfo) string <span class="cov0" title="0">{

        // make base Label frame for info list
        strTR := `&lt;label name="driverName-$$CSP$$" hidden&gt;$$DRIVERNAME$$&lt;/label&gt;`

        strData := ""
        // set data and make TR list
        for _, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$CSP$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$DRIVERNAME$$", one.DriverName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

func makeCredentialNameHiddenTRList_html(infoList []*cim.CredentialInfo) string <span class="cov0" title="0">{

        // make base Label frame for info list
        strTR := `&lt;label name="credentialName-$$CSP$$" hidden&gt;$$CREDENTIALNAME$$&lt;/label&gt;`

        strData := ""
        // set data and make TR list
        for _, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$CSP$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$CREDENTIALNAME$$", one.CredentialName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

func makeRegionNameHiddenTRList_html(infoList []*rim.RegionInfo) string <span class="cov0" title="0">{

        // make base Label frame for info list
        strTR := `&lt;label name="regionName-$$CSP$$" hidden&gt;$$REGIONNAME$$&lt;/label&gt;`

        strData := ""
        // set data and make TR list
        for _, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$CSP$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$REGIONNAME$$", one.RegionName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

//================ Connection Config Info Management
// create Connection page
func Connectionconfig(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Connectionconfig()")

        // make page header
        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeOnchangeConnectionConfigProviderFunc_js()
                htmlStr += makeSetupConnectionConfigFunc_js()
                htmlStr += makeOnInitialInputBoxSetup_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostConnectionConfigFunc_js()
                htmlStr += makeDeleteConnectionConfigFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body onload=onInitialSetup()&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("7", "connectionconfig", "deleteConnectionConfig()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Driver Name", "200"},
                    {"Credential Name", "200"},
                    {"Region Name", "200"},
                    {"Connection Config Name", "200"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("connectionconfig")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*ccim.ConnectionConfigInfo `json:"connectionconfig"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                trStrList, err :=  makeConnectionConfigTRList_html("", "", "", info.ResultList)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">htmlStr += trStrList

        // (4-3) make hidden TR list with info list
                // (a) Driver Name Hidden List
                resBody, err = getResourceList_JsonByte("driver")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var driverInfo struct {
                        ResultList []*dim.CloudDriverInfo `json:"driver"`
                }
                json.Unmarshal(resBody, &amp;driverInfo)
                htmlStr += makeDriverNameHiddenTRList_html(driverInfo.ResultList)

                // (b) Credential Name Hidden List
                resBody, err = getResourceList_JsonByte("credential")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var credentialInfo struct {
                        ResultList []*cim.CredentialInfo `json:"credential"`
                }
                json.Unmarshal(resBody, &amp;credentialInfo)
                htmlStr += makeCredentialNameHiddenTRList_html(credentialInfo.ResultList)

                // (c) Region Name Hidden List
                resBody, err = getResourceList_JsonByte("region")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var regionInfo struct {
                        ResultList []*rim.RegionInfo `json:"region"`
                }
                json.Unmarshal(resBody, &amp;regionInfo)
                htmlStr += makeRegionNameHiddenTRList_html(regionInfo.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
        `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")
            
        htmlStr += `    
                            &lt;/td&gt;
                            &lt;!-- value is set up by '&lt;body onload()=onInitialSetup()&gt;' --&gt;
                            &lt;td&gt;
                                &lt;select style="font-size:12px;text-align:center;" name="text_box" id="2" value="aws-driver-v1.0"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;select style="font-size:12px;text-align:center;" name="text_box" id="3" value="aws-credential-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;select style="font-size:12px;text-align:center;" name="text_box" id="4" value="aws-region01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="5" value="aws-connection-config01"&gt;
                            &lt;/td&gt;

                            &lt;td&gt;
                                &lt;a href="javascript:postConnectionConfig()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//================ This Spider Info
func SpiderInfo(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call SpiderInfo()")


        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;/head&gt;

                &lt;body&gt;

                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                                &lt;tr bgcolor="#DDDDDD" align="center"&gt;
                                    &lt;td width="200"&gt;
                                            &lt;font size=2&gt;Server Start Time&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;Server Version&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;API Version&lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;$$STARTTIME$$&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;CB-Spider v0.4.0 (CafeMocha)&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;REST API v0.4.0 (CafeMocha)&lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;

                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;br&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                                &lt;tr bgcolor="#DDDDDD" align="center"&gt;
                                    &lt;td width="240"&gt;
                                            &lt;font size=2&gt;API EndPoint&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="420"&gt;
                                            &lt;font size=2&gt;API Docs&lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                &lt;tr bgcolor="#FFFFFF" align="left" height="30"&gt;
                                    &lt;td width="240"&gt;
                                            &lt;font size=2&gt;$$APIENDPOINT$$&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="420"&gt;
                                            &lt;font size=2&gt;
                                            &amp;nbsp;&amp;nbsp;&lt;a href='https://github.com/cloud-barista/poc-cicd-spider/wiki/CB-Spider-User-Interface' target='_blank'&gt;
                                                            CB-Spider User Interface
                                                &lt;/a&gt;
                                            &lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;

                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
                `

        htmlStr = strings.ReplaceAll(htmlStr, "$$STARTTIME$$", cr.StartTime)
        htmlStr = strings.ReplaceAll(htmlStr, "$$APIENDPOINT$$", "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider") // cr.ServicePort = ":1024"

        return c.HTML(http.StatusOK, htmlStr)
}</span>

</pre>
		
		<pre class="file" id="file35" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"
        "bytes"
        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"

        "net/http"
        "io/ioutil"
        "strings"
        "github.com/labstack/echo/v4"
        "encoding/json"
)

var cblog *logrus.Logger
func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

type NameWidth struct {
        Name string
        Width string
}


func cloudosList() []string <span class="cov0" title="0">{
        resBody, err := getResourceList_JsonByte("cloudos")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []string `json:"cloudos"`
        }
        json.Unmarshal(resBody, &amp;info)

        return info.ResultList</span>
}

func vpcList(connConfig string) []string <span class="cov0" title="0">{
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vpc")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []cres.VPCInfo `json:"vpc"`
        }
        json.Unmarshal(resBody, &amp;info)

        var nameList []string
        for _, vpc := range info.ResultList </span><span class="cov0" title="0">{
                nameList = append(nameList, vpc.IId.NameId)
        }</span>
        <span class="cov0" title="0">return nameList</span>
}

func vmStatus(connConfig string, vmName string) string <span class="cov0" title="0">{
        resBody, err := getResource_with_Connection_JsonByte(connConfig, "vmstatus", vmName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        //var info cres.VMStatusInfo 
        <span class="cov0" title="0">var info struct {
                Status string
        }
        json.Unmarshal(resBody, &amp;info)
        //return fmt.Sprint(info.Status)
        return info.Status</span>
}

func subnetList(connConfig string, vpcName string) []string <span class="cov0" title="0">{
        resBody, err := getResource_with_Connection_JsonByte(connConfig, "vpc", vpcName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info cres.VPCInfo
        json.Unmarshal(resBody, &amp;info)

        var nameList []string
        for _, subnetInfo := range info.SubnetInfoList </span><span class="cov0" title="0">{
                nameList = append(nameList, subnetInfo.IId.NameId)
        }</span>
        <span class="cov0" title="0">return nameList</span>
}


func keyPairList(connConfig string) []string <span class="cov0" title="0">{
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "keypair")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []cres.VPCInfo `json:"keypair"`
        }
        json.Unmarshal(resBody, &amp;info)

        var nameList []string
        for _, keypair := range info.ResultList </span><span class="cov0" title="0">{
                nameList = append(nameList, keypair.IId.NameId)
        }</span>
        <span class="cov0" title="0">return nameList</span>
}

//================ Frame
func Frame(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Frame()")

        htmlStr :=  `
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;CB-Spider Admin Web Tool ....__^..^__....&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
  &lt;/head&gt;
 &lt;!--   &lt;frameset rows="66,*" frameborder="Yes" border=1"&gt; --&gt;
    &lt;frameset rows="100,*" frameborder="Yes" border=1"&gt;
        &lt;frame src="adminweb/top" name="top_frame" scrolling="auto" noresize marginwidth="0" marginheight="0"/&gt;
        &lt;frameset frameborder="Yes" border=1"&gt;
            &lt;frame src="adminweb/driver" name="main_frame" scrolling="auto" noresize marginwidth="5" marginheight="0"/&gt; 
        &lt;/frameset&gt;
    &lt;/frameset&gt;
    &lt;noframes&gt;
    &lt;body&gt;
    
    
    &lt;/body&gt;
    &lt;/noframes&gt;
&lt;/html&gt;
        `

        return c.HTML(http.StatusOK, htmlStr)
}</span>

//================ Top
func Top(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Top()")

        htmlStr :=  ` 
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- &lt;table border="0" bordercolordark="#FFFFFF" cellpadding="0" cellspacing="2" bgcolor="#FFFFFF" width="320" style="font-size:small;"&gt; --&gt;
    &lt;table border="0" bordercolordark="#FFFFFF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;      
        &lt;tr bgcolor="#FFFFFF" align="left"&gt;
            &lt;td rowspan="2" width="70" bgcolor="#FFFFFF" align="center"&gt;
                &lt;!-- CB-Spider Logo --&gt;
                &lt;a href="../adminweb" target="_top"&gt;
                  &lt;!-- &lt;img height="45" width="42" src="https://cloud-barista.github.io/assets/img/frameworks/cb-spider.png" border='0' hspace='0' vspace='1' align="middle"&gt; --&gt;
                  &lt;img height="45" width="45" src="./images/logo.png" border='0' hspace='0' vspace='1' align="middle"&gt;
                &lt;/a&gt;
                &lt;font size=1&gt;$$TIME$$&lt;/font&gt;        
            &lt;/td&gt;

            &lt;td width="160"&gt; 
                &lt;!-- Drivers Management --&gt; 
                &lt;a href="driver" target="main_frame"&gt;            
                    &lt;font size=2&gt;1.driver&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="200"&gt;       
                &lt;!-- Credential Management --&gt;
                &lt;a href="credential" target="main_frame"&gt;            
                    &lt;font size=2&gt;1.credential&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- Regions Management --&gt;
                &lt;a href="region" target="main_frame"&gt;            
                    &lt;font size=2&gt;1.region&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- Connection Management --&gt;
                &lt;a href="connectionconfig" target="main_frame"&gt;            
                    &lt;font size=2&gt;2.CONNECTION&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="230"&gt;
                &lt;!-- Display Connection Config --&gt;
                &lt;label id="connConfig" hidden&gt;&lt;/label&gt;
                &lt;input style="font-size:11px;font-weight:bold;text-align:center;background-color:#EDF7F9;" type="text" id="connDisplay" name="connDisplay" size = 24 disabled value="CloudOS: Region / Zone"&gt;

            &lt;/td&gt;
            &lt;td rowspan="2" width="60"&gt;       
                &lt;!-- This CB-Spider Info --&gt;
                &lt;a href="spiderinfo" target="main_frame"&gt;            
                    &lt;font size=2&gt;info&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr bgcolor="#FFFFFF" align="left"&gt;
            &lt;td width="160"&gt;
                &lt;!-- VPC/Subnet Management --&gt;
                &lt;a href="vpc/region not set" target="main_frame" id="vpcHref"&gt;
                    &lt;font size=2&gt;1.vpc/subnet&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="vpcmgmt/region not set" target="main_frame" id="vpcmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;                
            &lt;/td&gt;
            &lt;td width="200"&gt;
                &lt;!-- SecurityGroup Management --&gt;
                &lt;a href="securitygroup/region not set" target="main_frame" id="securitygroupHref"&gt;
                    &lt;font size=2&gt;1.1.security group&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="securitygroupmgmt/region not set" target="main_frame" id="securitygroupmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- KeyPair Management --&gt;
                &lt;a href="keypair/region not set" target="main_frame" id="keypairHref"&gt;
                    &lt;font size=2&gt;1.keypair&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="keypairmgmt/region not set" target="main_frame" id="keypairmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- VM Management --&gt;
                &lt;a href="vm/region not set" target="main_frame" id="vmHref"&gt;
                    &lt;font size=2&gt;2.VM&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="vmmgmt/region not set" target="main_frame" id="vmmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="230"&gt;
                &lt;!-- Image Management --&gt;
                &lt;a href="vmimage/region not set" target="main_frame" id="vmimageHref"&gt;
                    &lt;font size=2&gt;vmimage&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
                &lt;!-- Spec Management --&gt;
                &lt;a href="vmspec/region not set" target="main_frame" id="vmspecHref"&gt;
                    &lt;font size=2&gt;vmspec&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;

    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
        `

        
        htmlStr = strings.ReplaceAll(htmlStr, "$$TIME$$", cr.ShortStartTime)
        return c.HTML(http.StatusOK, htmlStr)
}</span>

func makeSelect_html(onchangeFunctionName string, strList []string, id string) string <span class="cov0" title="0">{

        strSelect := `&lt;select name="text_box" id="` + id + `" onchange="` + onchangeFunctionName + `(this)"&gt;`
        for _, one := range strList </span><span class="cov0" title="0">{
                if one == "AWS" </span><span class="cov0" title="0">{
                        strSelect += `&lt;option value="` + one + `" selected&gt;` + one + `&lt;/option&gt;`
                }</span> else<span class="cov0" title="0"> {
                        strSelect += `&lt;option value="` + one + `"&gt;` + one + `&lt;/option&gt;`
                }</span>
        }

        <span class="cov0" title="0">strSelect += `
                &lt;/select&gt;
        `


        return strSelect</span>
}

func makeKeyPairSelect_html(onchangeFunctionName string, strList []string, id string) string <span class="cov0" title="0">{

        strSelect := `&lt;select name="text_box" id="` + id + `" onchange="` + onchangeFunctionName + `(this)"&gt;`
        for _, one := range strList </span><span class="cov0" title="0">{
                strSelect += `&lt;option value="` + one + `"&gt;` + one + `&lt;/option&gt;`
        }</span>
        // add one more not to use Key but to use password
        <span class="cov0" title="0">strSelect += `&lt;option value=""&lt;/option&gt;`

        strSelect += `
                &lt;/select&gt;
        `


        return strSelect</span>
}


func getResourceList_JsonByte(resourceName string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName

        // get object list
        res, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(res.Body)
        res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getResourceList_with_Connection_JsonByte(connConfig string, resourceName string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName
        // get object list
        var reqBody struct {
                Value string `json:"ConnectionName"`
        }        
        reqBody.Value = connConfig

        jsonValue, _ := json.Marshal(reqBody)
        request, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonValue))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")

        client := http.Client{}
        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getAllResourceList_with_Connection_JsonByte(connConfig string, resourceName string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/all" + resourceName
        // get object list
        var reqBody struct {
                Value string `json:"ConnectionName"`
        }
        reqBody.Value = connConfig

        jsonValue, _ := json.Marshal(reqBody)
        request, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonValue))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")

        client := http.Client{}
        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getResource_JsonByte(resourceName string, name string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName + "/" + name

        // get object list
        res, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(res.Body)
        res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getResource_with_Connection_JsonByte(connConfig string, resourceName string, name string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName + "/" + name
        // get object list
        var reqBody struct {
                Value string `json:"ConnectionName"`
        }
        reqBody.Value = connConfig

        jsonValue, _ := json.Marshal(reqBody)
        request, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonValue))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")

        client := http.Client{}
        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

// F5, X ("5", "driver", "deleteDriver()", "2")
func makeActionTR_html(colspan string, f5_href string,  delete_href string, fontSize string) string <span class="cov0" title="0">{
        if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="#FFFFFF" align="right"&gt;
                    &lt;td colspan="%s"&gt;
                        &lt;a href="%s"&gt;
                            &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;F5&lt;/b&gt;&lt;/font&gt;
                        &lt;/a&gt;
                        &amp;nbsp;
                        &lt;a href="javascript:%s;"&gt;
                            &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;X&lt;/b&gt;&lt;/font&gt;
                        &lt;/a&gt;
                        &amp;nbsp;
                    &lt;/td&gt;
                &lt;/tr&gt;
                       `, colspan, f5_href, fontSize, delete_href, fontSize) 

        return strTR</span>
}

//         fieldName-width
// number, fieldName0-200, fieldName1-400, ... , checkbox
func makeTitleTRList_html(bgcolor string, fontSize string, nameWidthList []NameWidth, hasCheckBox bool) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#DDDDDD" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // (1) header number field
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center"&gt;
                    &lt;td width="15"&gt;
                            &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;#&lt;/b&gt;&lt;/font&gt;
                    &lt;/td&gt;
                `, bgcolor, fontSize)

        // (2) header title field
        for _, one := range nameWidthList </span><span class="cov0" title="0">{
                str := fmt.Sprintf(`
                            &lt;td width="%s"&gt;
                                    &lt;font size=2&gt;%s&lt;/font&gt;
                            &lt;/td&gt;
                        `, one.Width, one.Name)
                strTR += str
        }</span>

        <span class="cov0" title="0">if hasCheckBox </span><span class="cov0" title="0">{        
                // (3) header checkbox field
                strTR += `
                            &lt;td width="15"&gt;
                                    &lt;input type="checkbox" onclick="toggle(this);" /&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                        `
        }</span>
        <span class="cov0" title="0">return strTR</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
// This file was generated by swaggo/swag

package docs

import (
        "bytes"
        "encoding/json"
        "strings"

        "github.com/alecthomas/template"
        "github.com/swaggo/swag"
)

var doc = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{.Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "API Support",
            "url": "http://cloud-barista.github.io",
            "email": "contact-to-cloud-barista@googlegroups.com"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/keypair": {
            "post": {
                "description": "Create SSH Key",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "[CCM] Access key management"
                ],
                "summary": "Create SSH Key",
                "parameters": [
                    {
                        "description": "Request body to create key",
                        "name": "keyPairCreateReq",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/restruntime.JSONResult"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "ConnectionName": {
                                            "type": "string"
                                        },
                                        "ReqInfo": {
                                            "allOf": [
                                                {
                                                    "$ref": "#/definitions/restruntime.JSONResult"
                                                },
                                                {
                                                    "type": "object",
                                                    "properties": {
                                                        "Name": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/resources.KeyPairInfo"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    }
                }
            }
        },
        "/vpc": {
            "post": {
                "description": "Create VPC",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "[CCM] VPC management"
                ],
                "summary": "Create VPC",
                "parameters": [
                    {
                        "description": "Request body to create VPC",
                        "name": "vpcCreateReq",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/restruntime.vpcCreateReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/resources.VPCInfo"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "resources.IID": {
            "type": "object",
            "properties": {
                "nameId": {
                    "description": "NameID by user",
                    "type": "string"
                },
                "systemId": {
                    "description": "SystemID by CloudOS",
                    "type": "string"
                }
            }
        },
        "resources.KeyPairInfo": {
            "type": "object",
            "properties": {
                "fingerprint": {
                    "type": "string"
                },
                "iid": {
                    "description": "{NameId, SystemId}",
                    "$ref": "#/definitions/resources.IID"
                },
                "keyValueList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.KeyValue"
                    }
                },
                "privateKey": {
                    "type": "string"
                },
                "publicKey": {
                    "type": "string"
                },
                "vmuserID": {
                    "type": "string"
                }
            }
        },
        "resources.KeyValue": {
            "type": "object",
            "properties": {
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "resources.SubnetInfo": {
            "type": "object",
            "properties": {
                "iid": {
                    "description": "{NameId, SystemId}",
                    "$ref": "#/definitions/resources.IID"
                },
                "ipv4_CIDR": {
                    "type": "string"
                },
                "keyValueList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.KeyValue"
                    }
                }
            }
        },
        "resources.VPCInfo": {
            "type": "object",
            "properties": {
                "iid": {
                    "description": "{NameId, SystemId}",
                    "$ref": "#/definitions/resources.IID"
                },
                "ipv4_CIDR": {
                    "type": "string"
                },
                "keyValueList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.KeyValue"
                    }
                },
                "subnetInfoList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.SubnetInfo"
                    }
                }
            }
        },
        "restruntime.JSONResult": {
            "type": "object"
        },
        "restruntime.SimpleMsg": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "example": "Any message"
                }
            }
        },
        "restruntime.vpcCreateReq": {
            "type": "object",
            "properties": {
                "connectionName": {
                    "type": "string"
                },
                "reqInfo": {
                    "type": "object",
                    "properties": {
                        "ipv4_CIDR": {
                            "type": "string"
                        },
                        "name": {
                            "type": "string"
                        },
                        "subnetInfoList": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "ipv4_CIDR": {
                                        "type": "string"
                                    },
                                    "name": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "securityDefinitions": {
        "BasicAuth": {
            "type": "basic"
        }
    }
}`

type swaggerInfo struct {
        Version     string
        Host        string
        BasePath    string
        Schemes     []string
        Title       string
        Description string
}

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = swaggerInfo{
        Version:     "latest",
        Host:        "localhost:1024",
        BasePath:    "/spider",
        Schemes:     []string{},
        Title:       "CB-Spider REST API",
        Description: "CB-Spider REST API",
}

type s struct{}

func (s *s) ReadDoc() string <span class="cov0" title="0">{
        sInfo := SwaggerInfo
        sInfo.Description = strings.Replace(sInfo.Description, "\n", "\\n", -1)

        t, err := template.New("swagger_info").Funcs(template.FuncMap{
                "marshal": func(v interface{}) string </span><span class="cov0" title="0">{
                        a, _ := json.Marshal(v)
                        return string(a)
                }</span>,
        }).Parse(doc)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return doc
        }</span>

        <span class="cov0" title="0">var tpl bytes.Buffer
        if err := t.Execute(&amp;tpl, sInfo); err != nil </span><span class="cov0" title="0">{
                return doc
        }</span>

        <span class="cov0" title="0">return tpl.String()</span>
}

func init() <span class="cov8" title="1">{
        swag.Register(swag.Name, &amp;s{})
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// +build !dyna

// Cloud Driver Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.12.

package clouddriverhandler

import (
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        alibabadrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba"
        awsdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws"
        azuredrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure"
        clouditdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit"
        dockerdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker"
        gcpdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp"
        mockdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock"
        openstackdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack"
        tencentdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent"

        // ncpdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/ncp" // NCP
        // ncpvpcdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/ncpvpc" // NCP-VPC

        icbs "github.com/cloud-barista/cb-store/interfaces"

        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"

        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"

        //"encoding/json"
        "fmt"
        //"net/http"
        "os"
        "plugin"
        "strings"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

/*
func ListCloudDriver() []string {
        var cloudDriverList []string
        // @todo get list from storage
        return cloudDriverList
}
*/

// 1. get the ConnectionConfig Info
// 2. get the driver info
// 3. load driver library
// 4. get CloudDriver
func GetCloudDriver(cloudConnectName string) (idrv.CloudDriver, error) <span class="cov0" title="0">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cldDrvInfo, err := dim.GetCloudDriver(cccInfo.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pluginSW := os.Getenv("PLUGIN_SW")
        if strings.ToUpper(pluginSW) == "OFF" </span><span class="cov0" title="0">{
                return getStaticCloudDriver(*cldDrvInfo)
        }</span> else<span class="cov0" title="0"> {
                return getCloudDriver(*cldDrvInfo)
        }</span>
}

// 1. get credential info
// 2. get region info
// 3. get CloudConneciton
func GetCloudConnection(cloudConnectName string) (icon.CloudConnection, error) <span class="cov8" title="1">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cldDrvInfo, err := dim.GetCloudDriver(cccInfo.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pluginSW := os.Getenv("PLUGIN_SW")
        var cldDriver idrv.CloudDriver
        if strings.ToUpper(pluginSW) == "OFF" </span><span class="cov8" title="1">{
                cldDriver, err = getStaticCloudDriver(*cldDrvInfo)
        }</span> else<span class="cov0" title="0"> {
                cldDriver, err = getCloudDriver(*cldDrvInfo)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">crdInfo, err := cim.GetCredentialDecrypt(cccInfo.CredentialName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rgnInfo, err := rim.GetRegion(cccInfo.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        //cblog.Info(cldDriver)
        //cblog.Info(crdInfo)
        //cblog.Info(rgnInfo)

        <span class="cov8" title="1">regionName, zoneName, err := GetRegionNameByRegionInfo(rgnInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">connectionInfo := idrv.ConnectionInfo{ // @todo powerkim
                CredentialInfo: idrv.CredentialInfo{
                        ClientId:         getValue(crdInfo.KeyValueInfoList, "ClientId"),
                        ClientSecret:     getValue(crdInfo.KeyValueInfoList, "ClientSecret"),
                        TenantId:         getValue(crdInfo.KeyValueInfoList, "TenantId"),
                        SubscriptionId:   getValue(crdInfo.KeyValueInfoList, "SubscriptionId"),
                        IdentityEndpoint: getValue(crdInfo.KeyValueInfoList, "IdentityEndpoint"),
                        Username:         getValue(crdInfo.KeyValueInfoList, "Username"),
                        Password:         getValue(crdInfo.KeyValueInfoList, "Password"),
                        DomainName:       getValue(crdInfo.KeyValueInfoList, "DomainName"),
                        ProjectID:        getValue(crdInfo.KeyValueInfoList, "ProjectID"),
                        AuthToken:        getValue(crdInfo.KeyValueInfoList, "AuthToken"),
                        ClientEmail:      getValue(crdInfo.KeyValueInfoList, "ClientEmail"),
                        PrivateKey:       getValue(crdInfo.KeyValueInfoList, "PrivateKey"),
                        Host:             getValue(crdInfo.KeyValueInfoList, "Host"),
                        APIVersion:       getValue(crdInfo.KeyValueInfoList, "APIVersion"),
                        MockName:         getValue(crdInfo.KeyValueInfoList, "MockName"),
                },
                RegionInfo: idrv.RegionInfo{ // @todo powerkim
                        Region:        regionName,
                        Zone:          zoneName,
                        ResourceGroup: getValue(rgnInfo.KeyValueInfoList, "ResourceGroup"),
                },
        }

        cldConnection, err := cldDriver.ConnectCloud(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cldConnection, nil</span>
}

func getValue(keyValueInfoList []icbs.KeyValue, key string) string <span class="cov8" title="1">{
        for _, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                if kv.Key == key </span><span class="cov8" title="1">{
                        return kv.Value
                }</span>
        }
        <span class="cov8" title="1">return "Not set"</span>
}

func GetProviderNameByConnectionName(cloudConnectName string) (string, error) <span class="cov8" title="1">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">rgnInfo, err := rim.GetRegion(cccInfo.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return rgnInfo.ProviderName, nil</span>
}

func GetRegionNameByConnectionName(cloudConnectName string) (string, string, error) <span class="cov8" title="1">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">rgnInfo, err := rim.GetRegion(cccInfo.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return GetRegionNameByRegionInfo(rgnInfo)</span>
}

func GetRegionNameByRegionInfo(rgnInfo *rim.RegionInfo) (string, string, error) <span class="cov8" title="1">{

        // @todo should move KeyValueList into XXXDriver.go, powerkim
        var regionName string
        var zoneName string
        switch strings.ToUpper(rgnInfo.ProviderName) </span>{
        case "AZURE":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "location")</span>
        case "AWS":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        case "ALIBABA":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        case "GCP":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        case "OPENSTACK":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "CLOUDIT":<span class="cov0" title="0">
                // Cloudit do not use Region, But set default @todo 2019.10.28. by powerkim.
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "DOCKER":<span class="cov0" title="0">
                // docker do not use Region, But set default @todo 2020.05.06. by powerkim.
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "NCP":<span class="cov0" title="0"> // NCP
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region") // NCP
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>     // NCP
        case "NCPVPC":<span class="cov0" title="0"> // NCP-VPC
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region") // NCP-VPC
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>     // NCP-VPC
        case "CLOUDTWIN":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "MOCK":<span class="cov8" title="1">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "TENCENT":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        default:<span class="cov0" title="0">
                errmsg := rgnInfo.ProviderName + " is not a valid ProviderName!!"
                return "", "", fmt.Errorf(errmsg)</span>
        }

        <span class="cov8" title="1">return regionName, zoneName, nil</span>
}

func getCloudDriver(cldDrvInfo dim.CloudDriverInfo) (idrv.CloudDriver, error) <span class="cov0" title="0">{
        // $CBSPIDER_ROOT/cloud-driver-libs/*
        cbspiderRoot := os.Getenv("CBSPIDER_ROOT")
        if cbspiderRoot == "" </span><span class="cov0" title="0">{
                cblog.Error("$CBSPIDER_ROOT is not set!!")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">driverLibPath := cbspiderRoot + "/cloud-driver-libs/"

        driverFile := cldDrvInfo.DriverLibFileName // ex) "aws-test-driver-v0.5.so"
        if driverFile == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q: driver library file can't nil or empty!!", cldDrvInfo.DriverName)
        }</span>
        <span class="cov0" title="0">driverPath := driverLibPath + driverFile

        cblog.Info(cldDrvInfo.DriverName + ": driver path - " + driverPath)

        /*---------------
                A plugin is only initialized once, and cannot be closed.
                ref) https://golang.org/pkg/plugin/
        -----------------*/

        //var plug *plugin.Plugin
        plug, err := plugin.Open(driverPath)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Errorf("plugin.Open: %v\n", err)
                return nil, err
        }</span>
        //      fmt.Printf("plug: %#v\n\n", plug)

        //driver, err := plug.Lookup(cccInfo.DriverName)
        <span class="cov0" title="0">driver, err := plug.Lookup("CloudDriver")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Errorf("plug.Lookup: %v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">cloudDriver, ok := driver.(idrv.CloudDriver)
        if !ok </span><span class="cov0" title="0">{
                cblog.Error("Not CloudDriver interface!!")
                return nil, err
        }</span>

        <span class="cov0" title="0">return cloudDriver, nil</span>
}

func getStaticCloudDriver(cldDrvInfo dim.CloudDriverInfo) (idrv.CloudDriver, error) <span class="cov8" title="1">{
        cblog.Info("CloudDriverHandler: called getStaticCloudDriver() - " + cldDrvInfo.DriverName)

        var cloudDriver idrv.CloudDriver

        // select driver
        switch cldDrvInfo.ProviderName </span>{
        case "AWS":<span class="cov0" title="0">
                cloudDriver = new(awsdrv.AwsDriver)</span>
        case "AZURE":<span class="cov0" title="0">
                cloudDriver = new(azuredrv.AzureDriver)</span>
        case "GCP":<span class="cov0" title="0">
                cloudDriver = new(gcpdrv.GCPDriver)</span>
        case "ALIBABA":<span class="cov0" title="0">
                cloudDriver = new(alibabadrv.AlibabaDriver)</span>
        case "OPENSTACK":<span class="cov0" title="0">
                cloudDriver = new(openstackdrv.OpenStackDriver)</span>
        case "CLOUDIT":<span class="cov0" title="0">
                cloudDriver = new(clouditdrv.ClouditDriver)</span>
        case "DOCKER":<span class="cov0" title="0">
                cloudDriver = new(dockerdrv.DockerDriver)</span>
        case "TENCENT":<span class="cov0" title="0">
                cloudDriver = new(tencentdrv.TencentDriver)</span>
        // case "NCP": // NCP
        //  cloudDriver = new(ncpdrv.NcpDriver) // NCP
        // case "NCPVPC": // NCP-VPC
        //  cloudDriver = new(ncpvpcdrv.NcpVpcDriver) // NCP-VPC
        case "MOCK":<span class="cov8" title="1">
                cloudDriver = new(mockdrv.MockDriver)</span>

        default:<span class="cov0" title="0">
                errmsg := cldDrvInfo.ProviderName + " is not supported static Cloud Driver!!"
                return cloudDriver, fmt.Errorf(errmsg)</span>
        }

        <span class="cov8" title="1">return cloudDriver, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Call-Log: calling logger of Cloud &amp; VM in CB-Spider
//           Referred to cb-log
//
//      * Cloud-Barista: https://github.com/cloud-barista
//      * CB-Spider: https://github.com/cloud-barista/cb-spider
//      * cb-log: https://github.com/cloud-barista/cb-log
//
// load and set config file
//
// ref) https://github.com/go-yaml/yaml/tree/v3
//      https://godoc.org/gopkg.in/yaml.v3
//
// by CB-Spider Team, 2020.09.

package calllog

import (
        "fmt"
        "os"
        "reflect"
        "strings"
        "time"

        "github.com/chyeh/pubip"
        calllogformatter "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/formatter"
        "github.com/sirupsen/logrus"
        "github.com/snowzach/rotatefilehook"
)

type CLOUD_OS string
type RES_TYPE string

const (
        //=========== CloudOS (ref: cb-spider/conf/cloudos.yaml)
        AWS       CLOUD_OS = "AWS"
        GCP       CLOUD_OS = "GCP"
        AZURE     CLOUD_OS = "AZURE"
        OPENSTACK CLOUD_OS = "OPENSTACK"
        CLOUDIT   CLOUD_OS = "CLOUDIT"
        ALIBABA   CLOUD_OS = "ALIBABA"
        DOCKER    CLOUD_OS = "DOCKER"
        CLOUDTWIN CLOUD_OS = "CLOUDTWIN"
        NCP       CLOUD_OS = "NCP"
        MOCK      CLOUD_OS = "MOCK"
        TENCENT   CLOUD_OS = "TENCENT"
        IBM       CLOUD_OS = "IBM"

        //=========== ResourceType
        VMIMAGE       RES_TYPE = "VMIMAGE"
        VMSPEC        RES_TYPE = "VMSPEC"
        VPCSUBNET     RES_TYPE = "VPC/SUBNET"
        SECURITYGROUP RES_TYPE = "SECURITYGROUP"
        VMKEYPAIR     RES_TYPE = "VMKEYPAIR"
        VM            RES_TYPE = "VM"
)

type CALLLogger struct {
        loggerName string
        logrus     *logrus.Logger
}

// global var.
var (
        HostIPorName  string
        callLogger    *CALLLogger
        callFormatter *calllogformatter.Formatter
        calllogConfig CALLLOGCONFIG
)

func init() <span class="cov8" title="1">{
        HostIPorName = getHostIPorName()
}</span>

func getHostIPorName() string <span class="cov8" title="1">{
        ip, err := pubip.Get()
        if err != nil </span><span class="cov0" title="0">{
                logrus.Error(err)
                hostName, err := os.Hostname()
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Error(err)
                }</span>
                <span class="cov0" title="0">return hostName</span>
        }

        <span class="cov8" title="1">return ip.String()</span>
}

func GetLogger(loggerName string) *logrus.Logger <span class="cov8" title="1">{
        if callLogger != nil </span><span class="cov0" title="0">{
                return callLogger.logrus
        }</span>
        <span class="cov8" title="1">callLogger = new(CALLLogger)
        callLogger.loggerName = loggerName
        callLogger.logrus = &amp;logrus.Logger{
                Level:     logrus.InfoLevel,
                Out:       os.Stderr,
                Hooks:     make(logrus.LevelHooks),
                Formatter: getFormatter(loggerName),
        }

        // set config.
        setup(loggerName)
        return callLogger.logrus</span>
}

func setup(loggerName string) <span class="cov8" title="1">{
        calllogConfig = GetConfigInfos()
        callLogger.logrus.SetReportCaller(true)

        if calllogConfig.CALLLOG.LOOPCHECK </span><span class="cov0" title="0">{
                SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
                go levelSetupLoop(loggerName)
        }</span> else<span class="cov8" title="1"> {
                SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
        }</span>

        <span class="cov8" title="1">if calllogConfig.CALLLOG.LOGFILE </span><span class="cov0" title="0">{
                setRotateFileHook(loggerName, &amp;calllogConfig)
        }</span>
}

// Now, this method is busy wait.
// @TODO must change this  with file watch&amp;event.
// ref) https://github.com/fsnotify/fsnotify/blob/master/example_test.go
func levelSetupLoop(loggerName string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                calllogConfig = GetConfigInfos()
                SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
                time.Sleep(time.Second * 2)
        }</span>
}

func setRotateFileHook(loggerName string, logConfig *CALLLOGCONFIG) <span class="cov0" title="0">{
        level, _ := logrus.ParseLevel(logConfig.CALLLOG.LOGLEVEL)

        rotateFileHook, err := rotatefilehook.NewRotateFileHook(rotatefilehook.RotateFileConfig{
                Filename:   logConfig.LOGFILEINFO.FILENAME,
                MaxSize:    logConfig.LOGFILEINFO.MAXSIZE, // megabytes
                MaxBackups: logConfig.LOGFILEINFO.MAXBACKUPS,
                MaxAge:     logConfig.LOGFILEINFO.MAXAGE, //days
                Level:      level,
                Formatter:  getFormatter(loggerName),
        })

        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to initialize file rotate hook: %v", err)
        }</span>
        <span class="cov0" title="0">callLogger.logrus.AddHook(rotateFileHook)</span>
}

func SetLevel(strLevel string) <span class="cov8" title="1">{
        err := checkLevel(strLevel)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Errorf("Failed to set log level: %v", err)
        }</span>
        <span class="cov8" title="1">level, _ := logrus.ParseLevel(strLevel)
        callLogger.logrus.SetLevel(level)</span>
}

func checkLevel(lvl string) error <span class="cov8" title="1">{
        switch strings.ToLower(lvl) </span>{
        case "error":<span class="cov8" title="1">
                return nil</span>
        case "info":<span class="cov0" title="0">
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("not a valid calllog Level: %q", lvl)</span>
}

func GetLevel() string <span class="cov0" title="0">{
        return callLogger.logrus.GetLevel().String()
}</span>

func getFormatter(loggerName string) *calllogformatter.Formatter <span class="cov8" title="1">{

        if callFormatter != nil </span><span class="cov0" title="0">{
                return callFormatter
        }</span>
        <span class="cov8" title="1">callFormatter = &amp;calllogformatter.Formatter{
                TimestampFormat: "2006-01-02 15:04:05",
                LogFormat:       "[" + loggerName + "].[" + HostIPorName + "] %time% (%weekday%) %func% - %msg%\n",
        }
        return callFormatter</span>
}

//=========================
type CLOUDLOGSCHEMA struct {
        CloudOS      CLOUD_OS // ex) AWS | AZURE | ALIBABA | GCP | OPENSTACK | CLOUDTWIN | CLOUDIT | DOCKER | NCP | MOCK | IBM
        RegionZone   string   // ex) us-east1/us-east1-c
        ResourceType RES_TYPE // ex) VMIMAGE | VMSPEC | VPCSUBNET | SECURITYGROUP | VMKEYPAIR | VM
        ResourceName string   // ex) vpc-01
        CloudOSAPI   string   // ex) CreateKeyPair()
        ElapsedTime  string   // ex) 2.0201 (sec)
        ErrorMSG     string   // if success, ""
}

/* TBD or Do not support.
type VMLOGSCHEMA struct {
}
*/

func Start() time.Time <span class="cov8" title="1">{
        return time.Now()
}</span>

func Elapsed(start time.Time) string <span class="cov8" title="1">{
        return fmt.Sprintf("%.4f", time.Since(start).Seconds())
}</span>

func String(logInfo interface{}) string <span class="cov8" title="1">{
        t := reflect.TypeOf(logInfo)
        v := reflect.ValueOf(logInfo)

        msg := ""
        for idx := 0; idx &lt; t.NumField(); idx++ </span><span class="cov8" title="1">{
                typeOne := t.Field(idx)
                one := v.Field(idx)
                if idx &lt; (t.NumField() - 1) </span><span class="cov8" title="1">{
                        msg += fmt.Sprintf("\"%s\" : \"%s\", ", typeOne.Name, one)
                }</span> else<span class="cov8" title="1"> {
                        msg += fmt.Sprintf("\"%s\" : \"%s\"", typeOne.Name, one)
                }</span>
        }

        <span class="cov8" title="1">return msg</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Call-Log: calling logger of Cloud &amp; VM in CB-Spider
//           Referred to cb-log
//
//      * Cloud-Barista: https://github.com/cloud-barista
//      * CB-Spider: https://github.com/cloud-barista/cb-spider
//      * cb-log: https://github.com/cloud-barista/cb-log
//
// load and set config file
//
// ref) https://github.com/go-yaml/yaml/tree/v3
//        https://godoc.org/gopkg.in/yaml.v3
//
// by CB-Spider Team, 2020.09.


package calllog

import (
    "os"
    "strings"
    "io/ioutil"
    "log"

    "gopkg.in/yaml.v3"
)

type CALLLOGCONFIG struct {
        CALLLOG struct {
                LOOPCHECK bool
                LOGLEVEL string
                LOGFILE bool
        }

        LOGFILEINFO struct {
                FILENAME string
                MAXSIZE int
                MAXBACKUPS int
                MAXAGE int
        }
}

func load(filePath string) ([]byte, error) <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filePath)
        return data, err
}</span>

func GetConfigInfos() CALLLOGCONFIG <span class="cov8" title="1">{
        calllogRootPath := os.Getenv("CBSPIDER_ROOT")
        if calllogRootPath == "" </span><span class="cov0" title="0">{
                log.Fatalf("$CBSPIDER_ROOT is not set!!")
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">data, err := load(calllogRootPath + "/conf/calllog_conf.yaml")

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: %v", err)
        }</span>

        <span class="cov8" title="1">configInfos := CALLLOGCONFIG{}
        err = yaml.Unmarshal([]byte(data), &amp;configInfos)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: %v", err)
        }</span>

        <span class="cov8" title="1">configInfos.LOGFILEINFO.FILENAME = ReplaceEnvPath(configInfos.LOGFILEINFO.FILENAME)
        return configInfos</span>
}

// $ABC/def ==&gt; /abc/def
func ReplaceEnvPath(str string) string <span class="cov8" title="1">{
        if strings.Index(str, "$") == -1 </span><span class="cov0" title="0">{
                return str
        }</span>

        // ex) input "$CBSTORE_ROOT/meta_db/dat"
        <span class="cov8" title="1">strList := strings.Split(str, "/")
        for n, one := range strList </span><span class="cov8" title="1">{
                if strings.Index(one, "$") != -1 </span><span class="cov8" title="1">{
                        callstoreRootPath := os.Getenv(strings.Trim(one, "$"))
                        if callstoreRootPath == "" </span><span class="cov0" title="0">{
                                log.Fatal(one  +" is not set!")
                        }</span>
                        <span class="cov8" title="1">strList[n] = callstoreRootPath</span>
                }
        }

        <span class="cov8" title="1">var resultStr string
        for _, one := range strList </span><span class="cov8" title="1">{
                resultStr = resultStr + one + "/"
        }</span>
        // ex) "/root/go/src/github.com/cloud-barista/poc-cicd-spider/meta_db/dat/"
        <span class="cov8" title="1">resultStr = strings.TrimRight(resultStr, "/")
        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        return resultStr</span>
}


func GetConfigString(configInfos *CALLLOGCONFIG) string <span class="cov0" title="0">{
        d, err := yaml.Marshal(configInfos)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: %v", err)
        }</span>
        <span class="cov0" title="0">return string(d)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Call-Log: calling logger of Cloud &amp; VM in CB-Spider
//           Referred to cb-log
//
//      * Cloud-Barista: https://github.com/cloud-barista
//      * CB-Spider: https://github.com/cloud-barista/cb-spider
//      * cb-log: https://github.com/cloud-barista/cb-log
//
// load and set config file
//
// ref) https://github.com/go-yaml/yaml/tree/v3
//      https://godoc.org/gopkg.in/yaml.v3
//
// by CB-Spider Team, 2020.09.

package calllogformatter

import (

        "fmt"

        "strconv"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

const (
        // Default log format will output [INFO]: 2006-01-02T15:04:05Z07:00 - Log message
        defaultLogFormat       = " %time% (%weekday%) %func% - %msg%\n"
        defaultTimestampFormat = time.RFC3339
)

// Formatter implements logrus.Formatter interface.
type Formatter struct {
        TimestampFormat string
        LogFormat string
}

// Format building log message.
func (f *Formatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov0" title="0">{
        output := f.LogFormat
        if output == "" </span><span class="cov0" title="0">{
                output = defaultLogFormat
        }</span>

        <span class="cov0" title="0">timestampFormat := f.TimestampFormat
        if timestampFormat == "" </span><span class="cov0" title="0">{
                timestampFormat = defaultTimestampFormat
        }</span>

        <span class="cov0" title="0">output = strings.Replace(output, "%time%", entry.Time.Format(timestampFormat), 1)
        output = strings.Replace(output, "%weekday%", entry.Time.Weekday().String(), 1)


        if entry.HasCaller() </span><span class="cov0" title="0">{
                funcVal := fmt.Sprintf("%s():%d", entry.Caller.Function, entry.Caller.Line)
                
                output = strings.Replace(output, "%func%", funcVal, 1)
        }</span> else<span class="cov0" title="0"> {
                output = strings.Replace(output, "%func%", "", 1)
        }</span>

        <span class="cov0" title="0">output = strings.Replace(output, "%msg%", entry.Message, 1)


        for k, val := range entry.Data </span><span class="cov0" title="0">{
                switch v := val.(type) </span>{
                case string:<span class="cov0" title="0">
                        output = strings.Replace(output, "%"+k+"%", v, 1)</span>
                case int:<span class="cov0" title="0">
                        s := strconv.Itoa(v)
                        output = strings.Replace(output, "%"+k+"%", s, 1)</span>
                case bool:<span class="cov0" title="0">
                        s := strconv.FormatBool(v)
                        output = strings.Replace(output, "%"+k+"%", s, 1)</span>
                }
        }

        <span class="cov0" title="0">return []byte(output), nil</span>
}

func shortFilePathName(filePath string) string <span class="cov0" title="0">{
        strArray := strings.Split(filePath, "/")

        return strArray[len(strArray)-1]
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by zephy@mz.co.kr, 2019.09.

package alibaba

import (
        "C"
        "fmt"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk/auth/credentials"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
        alicon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
        "github.com/davecgh/go-spew/spew"
)
import (
        "time"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk"
)

type AlibabaDriver struct{}

func (AlibabaDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "ALIBABA-CLOUD DRIVER Version 1.0"
}</span>

func (AlibabaDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = false
        drvCapabilityInfo.VPCHandler = false
        drvCapabilityInfo.SecurityHandler = false
        drvCapabilityInfo.KeyPairHandler = false
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = false
        drvCapabilityInfo.VMSpecHandler = false

        return drvCapabilityInfo
}</span>

func (driver *AlibabaDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        ECSClient, err := getECSClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">VPCClient, err := getVPCClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := alicon.AlibabaCloudConnection{
                Region:        connectionInfo.RegionInfo,
                VMClient:      ECSClient,
                KeyPairClient: ECSClient,
                ImageClient:   ECSClient,
                //PublicIPClient:      VPCClient,
                SecurityGroupClient: ECSClient,
                VpcClient:           VPCClient,
                //VNetClient:          VPCClient,
                //VNicClient:          ECSClient,
                //SubnetClient: VPCClient,
                VmSpecClient: ECSClient,
        }
        return &amp;iConn, nil</span>
}

func getECSClient(connectionInfo idrv.ConnectionInfo) (*ecs.Client, error) <span class="cov0" title="0">{

        // Region Info
        fmt.Println("AlibabaDriver : getECSClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")

        /*
                // Customize config
                config := sdk.NewConfig().
                        WithEnableAsync(true).
                        WithGoRoutinePoolSize(5).
                        WithMaxTaskQueueSize(1000)
                        // 600*time.Second

                //fmt.Println(config)
                spew.Dump(config)
        */

        // Create a credential object
        /* BaseCredential는 deprecated 되었음.
        credential := &amp;credentials.BaseCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }
        */

        credential := &amp;credentials.AccessKeyCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }

        config := sdk.NewConfig()
        config.Timeout = time.Duration(15) * time.Second //time.Millisecond
        config.AutoRetry = true
        config.MaxRetryTime = 2
        //sdk.Timeout(1000)

        //escClient, err := ecs.NewClientWithAccessKey(connectionInfo.RegionInfo.Region, credential.AccessKeyId, credential.AccessKeySecret)

        escClient, err := ecs.NewClientWithOptions(connectionInfo.RegionInfo.Region, config, credential)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create alibaba's ecs service client", err)
                spew.Dump(err)
                return nil, err
        }</span>

        //spew.Dump(escClient)

        /*
                escClient, err := sdk.NewClientWithAccessKey("REGION_ID", "ACCESS_KEY_ID", "ACCESS_KEY_SECRET")
                if err != nil {
                        // Handle exceptions
                        panic(err)
                }
        */

        <span class="cov0" title="0">return escClient, nil</span>
}

func getVPCClient(connectionInfo idrv.ConnectionInfo) (*vpc.Client, error) <span class="cov0" title="0">{

        // Region Info
        fmt.Println("AlibabaDriver : getVPCClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")

        /*
                // Customize config
                config := sdk.NewConfig().
                        WithEnableAsync(true).
                        WithGoRoutinePoolSize(5).
                        WithMaxTaskQueueSize(1000)
                // 600*time.Second
                //fmt.Println(config)
        */

        // Create a credential object
        /* BaseCredential는 deprecated 되었음.
        credential := &amp;credentials.BaseCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }
        */

        credential := &amp;credentials.AccessKeyCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }

        config := sdk.NewConfig()
        config.Timeout = time.Duration(15) * time.Second //time.Millisecond
        config.AutoRetry = true
        config.MaxRetryTime = 2
        //sdk.Timeout(1000)

        //vpcClient, err := vpc.NewClientWithAccessKey(connectionInfo.RegionInfo.Region, credential.AccessKeyId, credential.AccessKeySecret)
        vpcClient, err := vpc.NewClientWithOptions(connectionInfo.RegionInfo.Region, config, credential)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create alibaba's vpc service client", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return vpcClient, nil</span>
}

var CloudDriver AlibabaDriver
</pre>
		
		<pre class="file" id="file42" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by zephy@mz.co.kr, 2019.09.

package connect

import (
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"

        cblog "github.com/cloud-barista/cb-log"
        alirs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type AlibabaCloudConnection struct {
        Region idrv.RegionInfo

        VMClient      *ecs.Client
        KeyPairClient *ecs.Client
        ImageClient   *ecs.Client
        //PublicIPClient      *vpc.Client
        SecurityGroupClient *ecs.Client
        //VNetClient          *vpc.Client
        VpcClient *vpc.Client
        //VNicClient          *ecs.Client
        SubnetClient *vpc.Client
        VmSpecClient *ecs.Client
}

/*
func (cloudConn *AlibabaCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
        cblogger.Info("Alibaba Cloud Driver: called CreateVNetworkHandler()!")
        vNetHandler := alirs.AlibabaVNetworkHandler{cloudConn.Region, cloudConn.VNetClient}
        return &amp;vNetHandler, nil
}
*/
func (cloudConn *AlibabaCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := alirs.AlibabaVPCHandler{cloudConn.Region, cloudConn.VpcClient}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateImageHandler()!")
        imageHandler := alirs.AlibabaImageHandler{cloudConn.Region, cloudConn.ImageClient}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateSecurityHandler()!")
        sgHandler := alirs.AlibabaSecurityHandler{cloudConn.Region, cloudConn.SecurityGroupClient}
        return &amp;sgHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateKeyPairHandler()!")
        keyPairHandler := alirs.AlibabaKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}
        return &amp;keyPairHandler, nil
}</span>

/*
func (cloudConn *AlibabaCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Alibaba Cloud Driver: called CreateVNicHandler()!")
        //vNicHandler := alirs.AlibabaVNicHandler{cloudConn.Region, cloudConn.VNicClient, cloudConn.SubnetClient}
        vNicHandler := alirs.AlibabaVNicHandler{cloudConn.Region, cloudConn.VNicClient}
        return &amp;vNicHandler, nil
}
*/

/*
func (cloudConn *AlibabaCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Alibaba Cloud Driver: called CreatePublicIPHandler()!")
        publicIPHandler := alirs.AlibabaPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}
        return &amp;publicIPHandler, nil
}
*/

func (cloudConn *AlibabaCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateVMHandler()!")
        vmHandler := alirs.AlibabaVMHandler{cloudConn.Region, cloudConn.VMClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := alirs.AlibabaVmSpecHandler{cloudConn.Region, cloudConn.VmSpecClient}
        return &amp;handler, nil
}</span>

func (AlibabaCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>

func (AlibabaCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Cloud Driver of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr, 2019.09.

package resources

import (
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

const (
        // default Resource GROUP Name
        CBResourceGroupName = "CB-GROUP"
        // default VPC Name
        CBVirutalNetworkName = "CB-VNet"
        // default CIDR Block
        CBVnetDefaultCidr = "130.0.0.0/16"
        // default VM User Name
        CBDefaultVmUserName = "cb-user"

        // default Subnet Name
        CBSubnetName = "CB-VNet-Sub"

        // default Bandwidth is 5 Mbit/s
        CBBandwidth = "5"
        // default InstanceChargeType
        CBInstanceChargeType = "PostPaid"
        // default InternetChargeType
        CBInternetChargeType = "PayByTraffic"

        // default Tag Name
        CBMetaDefaultTagName = "cbCate"
        // default Tag Value
        CBMetaDefaultTagValue = "cbAlibaba"

        CBPageOn = true
        // page number for control pages
        CBPageNumber = 1

        // page size for control pages
        CBPageSize = 100

        CBKeyPairPath       = "/cloud-driver-libs/.ssh-aliyun/"
        CBCloudInitFilePath = "/cloud-driver-libs/.cloud-init-aliyun/cloud-init"
)

type AlibabaCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

func GetCBResourceGroupName() string <span class="cov0" title="0">{
        return CBResourceGroupName
}</span>

//VPC
func GetCBVirutalNetworkName() string <span class="cov0" title="0">{
        return CBVirutalNetworkName
}</span>

//Subnet
func GetCBSubnetName() string <span class="cov0" title="0">{
        return CBSubnetName
}</span>

func GetCBVnetDefaultCidr() string <span class="cov0" title="0">{
        return CBVnetDefaultCidr
}</span>

func SetNameTag(Client *ecs.Client, resourceId string, resourceType string, value string) bool <span class="cov0" title="0">{
        // Tag에 Name 설정
        cblogger.Infof("Name Tage 설정 - ResourceId : [%s]  Value : [%s] ", resourceId, value)

        request := ecs.CreateAddTagsRequest()
        request.Scheme = "https"

        request.ResourceType = resourceType // "disk", "instance", "image", "securitygroup", "snapshot"
        request.ResourceId = resourceId     // "i-t4n4qtfwa4w5aavx588v"
        request.Tag = &amp;[]ecs.AddTagsTag{
                {
                        Key:   "Name",
                        Value: value, // "cbVal",
                },
                {
                        Key:   "cbCate",
                        Value: "cbAlibaba",
                },
                {
                        Key:   "cbName",
                        Value: value, // "cbVal",
                },
                // Resources: []*string{&amp;Id},
        }
        _, errtag := Client.AddTags(request)
        if errtag != nil </span><span class="cov0" title="0">{
                cblogger.Error("Name Tag 설정 실패 : ")
                cblogger.Error(errtag)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

//Cloud Object를 JSON String 타입으로 변환
func ConvertJsonString(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON 변환 실패")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

//CB-KeyValue 등을 위해 String 타입으로 변환
func ConvertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                cblogger.Error("Nil Value")
                return "", errors.New("NIL Value")
        }</span>

        <span class="cov0" title="0">var result string
        t := reflect.ValueOf(value)
        cblogger.Debug("==&gt;ValueOf : ", t)

        switch value.(type) </span>{
        case float32:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 32)</span> // f, fmt, prec, bitSize
        case float64:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 64)</span> // f, fmt, prec, bitSize
                //strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)

        default:<span class="cov0" title="0">
                cblogger.Debug("--&gt; default type:", reflect.ValueOf(value).Type())
                result = fmt.Sprint(value)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

//Cloud Object를 CB-KeyValue 형식으로 변환이 필요할 경우 이용
func ConvertKeyValueList(v interface{}) ([]irs.KeyValue, error) <span class="cov0" title="0">{
        spew.Dump(v)

        var keyValueList []irs.KeyValue
        var i map[string]interface{}

        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("KeyValue 변환 실패")
                cblogger.Error(errJson)
                return nil, errJson
        }</span>

        <span class="cov0" title="0">json.Unmarshal(jsonBytes, &amp;i)

        for k, v := range i </span><span class="cov0" title="0">{
                cblogger.Debugf("K:[%s]====&gt;", k)
                /*
                        cblogger.Infof("v:[%s]====&gt;", reflect.ValueOf(v))

                        vv := reflect.ValueOf(v)
                        cblogger.Infof("value ====&gt;[%s]", vv.String())
                        s := fmt.Sprint(v)
                        cblogger.Infof("value2 ====&gt;[%s]", s)
                */
                //value := fmt.Sprint(v)
                value, errString := ConvertToString(v)
                if errString != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("Key[%s]의 값은 변환 불가 - [%s]", k, errString)
                        continue</span>
                }
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, value})</span>
        }
        <span class="cov0" title="0">cblogger.Debug("getKeyValueList : ", keyValueList)
        //keyValueList = append(keyValueList, irs.KeyValue{"test", typeToString([]float32{3.14, 1.53, 2.0000000000000})})

        return keyValueList, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by zephy@mz.co.kr, 2019.09.

package resources

import (
        "errors"
        "strconv"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk/requests"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AlibabaImageHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

func (imageHandler *AlibabaImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateImage : ", imageReqInfo)
        //imageIdArr := strings.Split(imageReqInfo.Id, ":")

        request := ecs.CreateCreateImageRequest()
        request.Scheme = "https"

        // 필수 Req Name
        request.ImageName = imageReqInfo.IId.NameId // ImageName
        request.Tag = &amp;[]ecs.CreateImageTag{        // Default Hidden Tags Info
                {
                        Key:   CBMetaDefaultTagName,  // "cbCat",
                        Value: CBMetaDefaultTagValue, // "cbAlibaba",
                },
        }

        // 요청 매개 변수의 우선 순위는 InstanceId, DiskDeviceMapping, SnapshotId 순서

        // Case1 - 인스턴스 ID (InstanceId)를 지정하여 사용자 지정 이미지를 생성
        // 향후 추가를 고려, for create Case 1 (InstanceId)
        // request.InstanceId = imageReqInfo.InstanceId // "i-t4n98732cvvbbhhbsd4r"

        // &gt;&gt;&gt;&gt; Case2 - 시스템 디스크 또는 스냅 샷 (SnapshotId) 중 하나를 지정하여 사용자 정의 이미지를 생성
        // for create Case 2 (SnapshotId)
        //request.SnapshotId = imageReqInfo.Id // SnapshotId

        // Case3 - 여러 디스크의 스냅 샷을 이미지 템플릿으로 결합하려는 경우 DiskDeviceMapping을 지정하여 사용자 지정 이미지를 만들 수 있습니다.
        // 향후 추가를 고려, for create Case 3 (DiskDeviceMapping)
        // request.DiskDeviceMapping = &amp;[]ecs.CreateImageDiskDeviceMapping{
        //         {
        //           Size: imageReqInfo.DiskDevice[0].Size, // "20",
        //           SnapshotId: imageReqInfo.DiskDevice[0].Id, // "s-t4nhjof9caedzwd4929k",
        //           Device: imageReqInfo.DiskDevice[0].Device, // "/dev/xvda",
        //           DiskType: imageReqInfo.DiskDevice[0].DiskType, // "system",
        //         },
        //         {
        //           Size: imageReqInfo.DiskDevice[1].Size, // "20",
        //           SnapshotId: imageReqInfo.DiskDevice[1].Id, // "s-t4nhjof9caedzwd4929l",
        //           Device: imageReqInfo.DiskDevice[1].Device, // "/dev/xvdb",
        //           DiskType: imageReqInfo.DiskDevice[1].DiskType, // "data",
        //         },
        //   }

        // 추가 옵션 Req
        // request.Description = imageReqInfo.Description // "cb custom img01"
        // request.Platform = imageReqInfo.Platform // "Ubuntu"
        // request.Architecture = imageReqInfo.Architecture // "x86_64"
        // request.OSType = imageReqInfo.OSType // OSType "linux"

        // Check Image Exists

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageReqInfo.IId.SystemId,
                CloudOSAPI:   "CreateImage()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        // Creates a new custom Image with the given name
        result, err := imageHandler.Client.CreateImage(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to create Image: %s, %v.", imageReqInfo.IId.NameId, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created Image %q %s\n %s\n", result.ImageId, imageReqInfo.IId.NameId, result.RequestId)
        spew.Dump(result)

        /*
                ImageInfo := irs.ImageInfo{
                        Id:          result.ImageId,
                        Name:        *imageReqInfo.ImageName,
                }
        */

        // 생성된 Image 정보 획득 후, Image 정보 리턴
        imageInfo, err := imageHandler.GetImage(imageReqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>

        <span class="cov0" title="0">return imageInfo, nil</span>
}

func (imageHandler *AlibabaImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        var imageInfoList []*irs.ImageInfo

        request := ecs.CreateDescribeImagesRequest()
        request.Scheme = "https"

        request.Status = "Available"
        request.ActionType = "*"
        if CBPageOn </span><span class="cov0" title="0">{
                request.PageNumber = requests.NewInteger(CBPageNumber)
                request.PageSize = requests.NewInteger(CBPageSize)
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "ListImage()",
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        //spew.Dump(result) //출력 정보가 너무 많아서 생략
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get Images, %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cnt := 0
        for _, cur := range result.Images.Image </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Image 정보 처리", cur.ImageId)
                imageInfo := ExtractImageDescribeInfo(&amp;cur)
                imageInfoList = append(imageInfoList, &amp;imageInfo)
        }</span>

        //spew.Dump(imageInfoList)
        <span class="cov0" title="0">return imageInfoList, nil</span>
}

//https://pkg.go.dev/github.com/aliyun/alibaba-cloud-sdk-go/services/ecs?tab=doc#Image
//package ecs v1.61.170 Latest Published: Apr 30, 2020
//Image 정보를 추출함
func ExtractImageDescribeInfo(image *ecs.Image) irs.ImageInfo <span class="cov0" title="0">{
        //@TODO : 2020-03-26 Ali클라우드 API 구조가 바뀐 것 같아서 임시로 변경해 놓음.
        //func ExtractImageDescribeInfo(image *ecs.ImageInDescribeImages) irs.ImageInfo {
        //@TODO : 2020-04-20 ecs.ImageInDescribeImages를 인식 못해서 다시 ecs.Image로 변경해 놓음.
        //func ExtractImageDescribeInfo(image *ecs.Image) irs.ImageInfo {
        //*ecs.DescribeImagesResponse
        cblogger.Infof("=====&gt; ")
        spew.Dump(image)
        imageInfo := irs.ImageInfo{
                IId: irs.IID{NameId: image.ImageId, SystemId: image.ImageId},
                //Name:    image.ImageName,
                Status:  image.Status,
                GuestOS: image.OSNameEn,
        }

        keyValueList := []irs.KeyValue{
                {Key: "CreationTime", Value: image.CreationTime},
                {Key: "Architecture", Value: image.Architecture},

                {Key: "OSNameEn", Value: image.OSNameEn},
                {Key: "ProductCode", Value: image.ProductCode},
                {Key: "OSType", Value: image.OSType},
                {Key: "OSName", Value: image.OSName},
                {Key: "Progress", Value: image.Progress},
                {Key: "IsSupportCloudinit", Value: strconv.FormatBool(image.IsSupportCloudinit)},
                {Key: "Usage", Value: image.Usage},
                {Key: "ImageVersion", Value: image.ImageVersion},
                {Key: "IsSupportIoOptimized", Value: strconv.FormatBool(image.IsSupportIoOptimized)},
                {Key: "IsSelfShared", Value: image.IsSelfShared},
                {Key: "IsCopied", Value: strconv.FormatBool(image.IsCopied)},
                {Key: "IsSubscribed", Value: strconv.FormatBool(image.IsSubscribed)},
                {Key: "Platform", Value: image.Platform},
                {Key: "Size", Value: strconv.Itoa(image.Size)},
        }

        keyValueList = append(keyValueList, irs.KeyValue{Key: "Description", Value: image.Description})
        imageInfo.KeyValueList = keyValueList

        return imageInfo
}</span>

func (imageHandler *AlibabaImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("imageID : ", imageIID.SystemId)

        request := ecs.CreateDescribeImagesRequest()
        request.Scheme = "https"

        // request.Status = "Available"
        // request.ActionType = "*"

        request.ImageId = imageIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //ecs.DescribeImagesResponse.Images.Image
        //spew.Dump(result)
        cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get Images, %v", err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, errors.New("Notfound: '" + imageIID.SystemId + "' Images Not found")
        }</span>

        <span class="cov0" title="0">imageInfo := ExtractImageDescribeInfo(&amp;result.Images.Image[0])

        return imageInfo, nil</span>
}

func (imageHandler *AlibabaImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("DeleteImage : [%s]", imageIID.SystemId)
        // Delete the Image by Id

        request := ecs.CreateDeleteImageRequest()
        request.Scheme = "https"

        //request.ImageId = to.StringPtr(imageID)
        request.ImageId = imageIID.SystemId
        // 추가 옵션 Req
        // request.Force = requests.NewBoolean(true)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DeleteImage()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := imageHandler.Client.DeleteImage(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to delete Image: %s, %v.", imageIID.SystemId, err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Successfully deleted %q Image\n", imageIID.SystemId)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr, 2019.09.

package resources

import (
        "bytes"
        "crypto/rsa"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AlibabaKeyPairHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

/*
// @TODO: KeyPairInfo 리소스 프로퍼티 정의 필요
type KeyPairInfo struct {
        Name        string
        Fingerprint string
        KeyMaterial string //RSA PRIVATE KEY
}
*/

func (keyPairHandler *AlibabaKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start ListKey()")
        var keyPairList []*irs.KeyPairInfo
        //spew.Dump(keyPairHandler)
        cblogger.Info(keyPairHandler)

        request := ecs.CreateDescribeKeyPairsRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: "ListKey()",
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        //  Returns a list of key pairs
        result, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get key pairs, %v", err)
                return keyPairList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)

        //cblogger.Debugf("Key Pairs:")
        for _, pair := range result.KeyPairs.KeyPair </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(&amp;pair)

                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s] KeyPair는 Local에서 관리하는 대상이 아니기 때문에 Skip합니다.", *&amp;pair.KeyPairName)
                        cblogger.Info(errKeyPair.Error())
                }</span> else<span class="cov0" title="0"> {
                        keyPairList = append(keyPairList, &amp;keyPairInfo)
                }</span>
        }

        <span class="cov0" title="0">cblogger.Info(keyPairList)
        //spew.Dump(keyPairList)
        return keyPairList, nil</span>
}

func (keyPairHandler *AlibabaKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateKey() : ", keyPairReqInfo)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">request := ecs.CreateCreateKeyPairRequest()
        request.Scheme = "https"

        request.KeyPairName = keyPairReqInfo.IId.NameId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        // Creates a new  key pair with the given name
        result, err := keyPairHandler.Client.CreateKeyPair(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to create key pair: %s, %v.", keyPairReqInfo.IId.NameId, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created key pair %q %s\n%s\n", result.KeyPairName, result.KeyPairFingerPrint, result.PrivateKeyBody)
        spew.Dump(result)

        cblogger.Info("공개키 생성")
        publicKey, errPub := makePublicKeyFromPrivateKey(result.PrivateKeyBody)
        if errPub != nil </span><span class="cov0" title="0">{
                cblogger.Error(errPub)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">cblogger.Infof("Public Key")
        spew.Dump(publicKey)

        keyPairInfo := irs.KeyPairInfo{
                IId:         irs.IID{NameId: result.KeyPairName, SystemId: result.KeyPairName},
                Fingerprint: result.KeyPairFingerPrint,
                PrivateKey:  result.PrivateKeyBody,
                PublicKey:   publicKey,
                KeyValueList: []irs.KeyValue{
                        {Key: "KeyMaterial", Value: result.PrivateKeyBody},
                },
        }

        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        savePrivateFileTo := keyPairPath + hashString + ".pem"
        savePublicFileTo := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Infof("savePrivateFileTo : [%s]", savePrivateFileTo)
        cblogger.Infof("savePublicFileTo : [%s]", savePublicFileTo)

        // 파일에 private Key를 쓴다
        err = writeKeyToFile([]byte(keyPairInfo.PrivateKey), savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 public Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile([]byte(keyPairInfo.PublicKey), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

// 혼선을 피하기 위해 keyPairID 대신 keyPairName으로 변경 함.
func (keyPairHandler *AlibabaKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        //keyPairID := keyPairName
        cblogger.Infof("GetKey(keyPairName) : [%s]", keyIID.SystemId)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">request := ecs.CreateDescribeKeyPairsRequest()
        request.Scheme = "https"
        request.KeyPairName = keyIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                // if aerr, ok := err.(errors.Error); ok {
                cblogger.Errorf("Unable to get key pair: %s, %v.", keyIID.SystemId, err)
                return irs.KeyPairInfo{}, nil
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("result : ", result)
        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, errors.New("Notfound: '" + keyIID.SystemId + "' KeyPair Not found")
        }</span>

        <span class="cov0" title="0">keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(&amp;result.KeyPairs.KeyPair[0])
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair.Error())
                return irs.KeyPairInfo{}, errKeyPair
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

// KeyPair 정보를 추출함
func ExtractKeyPairDescribeInfo(keyPair *ecs.KeyPair) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        spew.Dump(keyPair)

        keyPairInfo := irs.KeyPairInfo{
                IId:         irs.IID{NameId: keyPair.KeyPairName, SystemId: keyPair.KeyPairName},
                Fingerprint: keyPair.KeyPairFingerPrint,
        }

        // Local Keyfile 처리
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, privateKeyPath)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, publicKeyPath)

        // Private Key, Public Key 파일 정보 가져오기
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair의 Local Private 파일 조회 실패", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair의 Local Public 파일 조회 실패", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo.PublicKey = string(publicKeyBytes)
        keyPairInfo.PrivateKey = string(privateKeyBytes)

        keyValueList := []irs.KeyValue{
                //{Key: "ResourceGroupId", Value: keyPair.ResourceGroupId},
                {Key: "CreationTime", Value: keyPair.CreationTime},
        }

        keyPairInfo.KeyValueList = keyValueList

        return keyPairInfo, nil</span>
}

func (keyPairHandler *AlibabaKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("DeleteKey(KeyPairName) : [%s]", keyIID.SystemId)
        // Delete the key pair by name

        //없는 키도 무조건 성공하기 때문에 미리 조회함.
        keyPairInfo, errKey := keyPairHandler.GetKey(keyIID)
        if errKey != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Delete fail", keyIID.SystemId)
                cblogger.Error(errKey)
                return false, errKey
        }</span>

        <span class="cov0" title="0">request := ecs.CreateDeleteKeyPairsRequest()
        request.Scheme = "https"
        request.KeyPairNames = "[" + "\"" + keyIID.SystemId + "\"]"

        spew.Dump(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DeleteKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := keyPairHandler.Client.DeleteKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to delete key pair: %s, %v.", keyIID.SystemId, err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        cblogger.Infof("Successfully deleted %q Alibaba Cloud key pair\n", keyIID.SystemId)

        //====================
        // Local Keyfile 처리
        //====================
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"

        // Private Key, Public Key 삭제
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

//=================================
// 공개 키 변환 및 키 정보 로컬 보관 로직 추가
//=================================
func (keyPairHandler *AlibabaKeyPairHandler) CheckKeyPairFolder(keyPairPath string) error <span class="cov0" title="0">{
        //키페어 생성 시 폴더가 존재하지 않으면 생성 함.
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Path가 존재하지 않아서 생성합니다.", keyPairPath)

                //errDir := os.MkdirAll(keyPairPath, 0755)
                errDir := os.MkdirAll(keyPairPath, 0700)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path가 생성 실패", keyPairPath)
                        cblogger.Error(errDir)
                        return errDir
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ParseKey reads the given RSA private key and create a public one for it.
func makePublicKeyFromPrivateKey(pem string) (string, error) <span class="cov0" title="0">{
        key, err := ssh.ParseRawPrivateKey([]byte(pem))
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">rsaKey, ok := key.(*rsa.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q is not a RSA key", pem)
        }</span>
        <span class="cov0" title="0">pub, err := ssh.NewPublicKey(&amp;rsaKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(bytes.TrimRight(ssh.MarshalAuthorizedKey(pub), "\n")), nil</span>
}

// 파일에 Key를 쓴다
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key 저장위치: %s", saveFileTo)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by zephy@mz.co.kr, 2019.09.

package resources

import (
        "errors"
        "strings"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AlibabaSecurityHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

func (securityHandler *AlibabaSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityReqInfo : ", securityReqInfo)
        //spew.Dump(securityReqInfo)

        //=======================================
        // 보안 그룹 생성
        //=======================================
        request := ecs.CreateCreateSecurityGroupRequest()
        request.Scheme = "https"

        request.Description = securityReqInfo.IId.NameId
        request.SecurityGroupName = securityReqInfo.IId.NameId
        request.VpcId = securityReqInfo.VpcIID.SystemId
        cblogger.Debugf("보안 그룹 생성 요청 정보", request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "CreateSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        // Create the security group with the VPC, name and description.
        createRes, err := securityHandler.Client.CreateSecurityGroup(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to create security group %q, %v", securityReqInfo.IId.NameId, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Infof("[%s] 보안 그룹 생성완료: SecurityGroupId:[%s]", securityReqInfo.IId.NameId, createRes.SecurityGroupId)
        //spew.Dump(createRes)

        //=======================================
        // 보안 정책 추가
        //=======================================
        cblogger.Infof("보안 그룹[%s]에 인바운드/아웃바운드 보안 정책 처리", createRes.SecurityGroupId)
        createRuleRes, errRule := securityHandler.AuthorizeSecurityRules(createRes.SecurityGroupId, securityReqInfo.VpcIID.SystemId, securityReqInfo.SecurityRules)
        if errRule != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("Unable to create security group rule %q, %v", securityReqInfo.IId.NameId, err)
                return irs.SecurityInfo{}, errRule
        }</span> else<span class="cov0" title="0"> {
                cblogger.Info("Successfully set security group AuthorizeSecurityRules")
        }</span>

        <span class="cov0" title="0">cblogger.Debug("AuthorizeSecurityRules Result")
        // spew.Dump(createRuleRes)
        cblogger.Debug(createRuleRes)

        securityInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: createRes.SecurityGroupId})
        //securityInfo.IId.NameId = securityReqInfo.IId.NameId
        return securityInfo, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) AuthorizeSecurityRules(securityGroupId string, vpcId string, securityRuleInfos *[]irs.SecurityRuleInfo) (*[]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityGroupId : [%s] / vpcId : [%s] / securityRuleInfos : [%v]", securityGroupId, vpcId, securityRuleInfos)
        //cblogger.Info("AuthorizeSecurityRules ", securityRuleInfos)
        spew.Dump(securityRuleInfos)

        /*
                if strings.EqualFold(curRule.Direction, "inbound") {
                } else if strings.EqualFold(curRule.Direction, "outbound") {
                }
        */

        for _, curRule := range *securityRuleInfos </span><span class="cov0" title="0">{
                //if curRule.Direction == "inbound" {
                if strings.EqualFold(curRule.Direction, "inbound") </span><span class="cov0" title="0">{
                        request := ecs.CreateAuthorizeSecurityGroupRequest()
                        request.Scheme = "https"
                        request.IpProtocol = curRule.IPProtocol
                        request.PortRange = curRule.FromPort + "/" + curRule.ToPort
                        request.SecurityGroupId = securityGroupId
                        //request.SourceCidrIp = "0.0.0.0/0"
                        request.SourceCidrIp = curRule.CIDR

                        cblogger.Infof("[%s] [%s] inbound rule Request", request.IpProtocol, request.PortRange)
                        spew.Dump(request)
                        response, err := securityHandler.Client.AuthorizeSecurityGroup(request)
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("Unable to create security group[%s] inbound rule - [%s] [%s] AuthorizeSecurityGroup Request", securityGroupId, request.IpProtocol, request.PortRange)
                                cblogger.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">cblogger.Infof("[%s] [%s] AuthorizeSecurityGroup Request success - RequestId:[%s]", request.IpProtocol, request.PortRange, response)</span>
                        //} else if curRule.Direction == "outbound" {
                } else<span class="cov0" title="0"> if strings.EqualFold(curRule.Direction, "outbound") </span><span class="cov0" title="0">{
                        request := ecs.CreateAuthorizeSecurityGroupEgressRequest()
                        request.Scheme = "https"
                        request.IpProtocol = curRule.IPProtocol
                        request.PortRange = curRule.FromPort + "/" + curRule.ToPort
                        request.SecurityGroupId = securityGroupId
                        //request.DestCidrIp = "0.0.0.0/0"
                        request.DestCidrIp = curRule.CIDR

                        cblogger.Infof("[%s] [%s] outbound rule Request", request.IpProtocol, request.PortRange)
                        spew.Dump(request)
                        response, err := securityHandler.Client.AuthorizeSecurityGroupEgress(request)
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("Unable to create security group[%s] outbound rule - [%s] [%s] AuthorizeSecurityGroup Request", securityGroupId, request.IpProtocol, request.PortRange)
                                cblogger.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">cblogger.Infof("[%s] [%s] AuthorizeSecurityGroup Request success - RequestId:[%s]", request.IpProtocol, request.PortRange, response)</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        //        return nil, nil

        // get SecurityGroup &amp; SecurityGroupAttribute for Alibaba
        request := ecs.CreateDescribeSecurityGroupsRequest()
        request.Scheme = "https"
        spew.Dump(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "ListSecurity()",
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        //spew.Dump(result)
        //ecs.DescribeSecurityGroupsResponse

        var securityInfoList []*irs.SecurityInfo
        for _, curSecurityGroup := range result.SecurityGroups.SecurityGroup </span><span class="cov0" title="0">{
                curSecurityInfo, errSecurityInfo := securityHandler.ExtractSecurityInfo(&amp;curSecurityGroup)
                if errSecurityInfo != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errSecurityInfo)
                        return nil, errSecurityInfo
                }</span>

                <span class="cov0" title="0">securityInfoList = append(securityInfoList, &amp;curSecurityInfo)</span>
        }

        <span class="cov0" title="0">return securityInfoList, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("SecurityGroupId : [%s]", securityIID.SystemId)

        request := ecs.CreateDescribeSecurityGroupsRequest()
        request.Scheme = "https"
        request.SecurityGroupId = securityIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Debug(result)
        //spew.Dump(result)
        //ecs.DescribeSecurityGroupsResponse

        //ecs.DescribeSecurityGroupsResponse.SecurityGroups
        //ecs.SecurityGroups
        //spew.Dump(result)
        
        //ecs.DescribeSecurityGroupsResponse
        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("Notfound: '" + securityIID.SystemId + "' SecurityGroup Not found")
        }</span>

        <span class="cov0" title="0">securityInfo, errSecurityInfo := securityHandler.ExtractSecurityInfo(&amp;result.SecurityGroups.SecurityGroup[0])
        if errSecurityInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSecurityInfo)
                return irs.SecurityInfo{}, errSecurityInfo
        }</span>

        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) ExtractSecurityInfo(securityGroupResult *ecs.SecurityGroup) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        //securityRules := ExtractIpPermissions(securityGroupResult.SecurityGroups.SecurityGroup)
        var securityRuleInfos []irs.SecurityRuleInfo

        securityRuleInfos, errRuleInfos := securityHandler.ExtractSecurityRuleInfo(securityGroupResult.SecurityGroupId)
        if errRuleInfos != nil </span><span class="cov0" title="0">{
                cblogger.Error(errRuleInfos)
                return irs.SecurityInfo{}, errRuleInfos
        }</span>

        <span class="cov0" title="0">securityInfo := irs.SecurityInfo{
                IId: irs.IID{NameId: securityGroupResult.SecurityGroupName, SystemId: securityGroupResult.SecurityGroupId},
                //SecurityRules: &amp;[]irs.SecurityRuleInfo{},
                //SecurityRules: &amp;securityRules,
                VpcIID:        irs.IID{SystemId: securityGroupResult.VpcId},
                SecurityRules: &amp;securityRuleInfos,

                KeyValueList: []irs.KeyValue{
                        {Key: "SecurityGroupName", Value: securityGroupResult.SecurityGroupName},
                        {Key: "CreationTime", Value: securityGroupResult.CreationTime},
                },
        }

        return securityInfo, nil</span>
}

// 보안 그룹의 InBound / OutBound 정보를 조회함.
func (securityHandler *AlibabaSecurityHandler) ExtractSecurityRuleInfo(securityGroupId string) ([]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        var securityRuleInfos []irs.SecurityRuleInfo

        request := ecs.CreateDescribeSecurityGroupAttributeRequest()
        request.Scheme = "https"
        request.SecurityGroupId = securityGroupId

        response, err := securityHandler.Client.DescribeSecurityGroupAttribute(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">cblogger.Info(response)

        /*
           FromPort    string
           ToPort        string
        */
        var curSecurityRuleInfo irs.SecurityRuleInfo
        for _, curPermission := range response.Permissions.Permission </span><span class="cov0" title="0">{
                curSecurityRuleInfo.Direction = curPermission.Direction

                if strings.EqualFold(curPermission.Direction, "ingress") </span><span class="cov0" title="0">{
                        // curSecurityRuleInfo.Direction = "inbound"
                        curSecurityRuleInfo.CIDR = curPermission.SourceCidrIp
                }</span> else<span class="cov0" title="0"> if strings.EqualFold(curPermission.Direction, "egress") </span><span class="cov0" title="0">{
                        // curSecurityRuleInfo.Direction = "outbound"
                        curSecurityRuleInfo.CIDR = curPermission.DestCidrIp
                }</span>

                <span class="cov0" title="0">curSecurityRuleInfo.IPProtocol = curPermission.IpProtocol

                portRange := strings.Split(curPermission.PortRange, "/")

                curSecurityRuleInfo.FromPort = portRange[0]
                if len(portRange) &gt; 1 </span><span class="cov0" title="0">{
                        curSecurityRuleInfo.ToPort = portRange[1]
                }</span>
                <span class="cov0" title="0">securityRuleInfos = append(securityRuleInfos, curSecurityRuleInfo)</span>
        }

        <span class="cov0" title="0">return securityRuleInfos, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("securityID : [%s]", securityIID.SystemId)

        request := ecs.CreateDeleteSecurityGroupRequest()
        request.Scheme = "https"
        request.SecurityGroupId = securityIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DeleteSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := securityHandler.Client.DeleteSecurityGroup(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get descriptions for security groups, %v.", err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(response)
        cblogger.Infof("Successfully delete security group %q.", securityIID.SystemId)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Proof of Concepts for the Cloud-Barista Multi-Cloud Project.
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by zephy@mz.co.kr, 2019.09.

package resources

import (
        "encoding/base64"
        "errors"
        "io/ioutil"
        "os"
        "strings"
        "time"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk/requests"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"
        /*
                "github.com/davecgh/go-spew/spew"
        */)

type AlibabaVMHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

// 참고 : VM 생성 시 인증 방식은 KeyPair 또는 ID&amp;PWD 방식이 가능하지만 계정은 모두 root  - 비번 조회 기능은 없음
//        비밀번호는 8-30자로서 대문자, 소문자, 숫자 및/또는 특수 문자가 포함되어야 합니다.
// @TODO : root 계정의 비번만 설정 가능한 데 다른 계정이 요청되었을 경우 예외 처리할 것인지.. 아니면 비번을 설정할 것인지 확인 필요.
// @TODO : PublicIp 요금제 방식과 대역폭 설정 방법 논의 필요
func (vmHandler *AlibabaVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        //cblogger.Info(vmReqInfo)
        spew.Dump(vmReqInfo)

        // 2021-04-28 cbuser 추가에 따른 Local KeyPair만 VM 생성 가능하도록 강제
        //=============================
        // KeyPair의 PublicKey 정보 처리
        //=============================
        cblogger.Infof("[%s] KeyPair 조회 시작", vmReqInfo.KeyPairIID.SystemId)
        keypairHandler := AlibabaKeyPairHandler{
                //CredentialInfo:
                Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(keypairHandler)

        keyPairInfo, errKeyPair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair)
                return irs.VMInfo{}, errKeyPair
        }</span>

        //=============================
        // UserData생성 처리
        //=============================
        /*
                package_update: true
                packages:
                 - sudo
                users:
                  - default
                  - name: cb-user
                        groups: sudo
                        shell: /bin/bash
                        sudo: ['ALL=(ALL) NOPASSWD:ALL']
                        ssh-authorized-keys:
                          - ssh-rsa AAAAB3NzaC1y
        */
        /*
                //sudo 패키지 설치
                //userData := "#cloud-config\npackage_update: true\npackages:\n  - sudo\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    groups: sudo\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                //sudo 그룹 사용
                //userData := "#cloud-config\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    groups: sudo\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                //그룹 제거
                userData := "#cloud-config\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                userData = userData + keyPairInfo.PublicKey
                userDataBase64 := base64.StdEncoding.EncodeToString([]byte(userData))
                cblogger.Infof("===== userData ===")
                spew.Dump(userDataBase64)
        */

        //=============================
        // UserData생성 처리(File기반)
        //=============================
        // 향후 공통 파일이나 외부에서 수정 가능하도록 cloud-init 스크립트 파일로 설정
        <span class="cov0" title="0">rootPath := os.Getenv("CBSPIDER_ROOT")
        fileDataCloudInit, err := ioutil.ReadFile(rootPath + CBCloudInitFilePath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">userData := string(fileDataCloudInit)
        userData = strings.ReplaceAll(userData, "{{username}}", CBDefaultVmUserName)
        userData = strings.ReplaceAll(userData, "{{public_key}}", keyPairInfo.PublicKey)
        userDataBase64 := base64.StdEncoding.EncodeToString([]byte(userData))
        cblogger.Debugf("cloud-init data : [%s]", userDataBase64)

        //=============================
        // 보안그룹 처리 - SystemId 기반
        //=============================
        cblogger.Info("SystemId 기반으로 처리하기 위해 IID 기반의 보안그룹 배열을 SystemId 기반 보안그룹 배열로 조회및 변환함.")
        var newSecurityGroupIds []string
        //var firstSecurityGroupId string

        for _, sgId := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                cblogger.Infof("보안그룹 변환 : [%s]", sgId)
                newSecurityGroupIds = append(newSecurityGroupIds, sgId.SystemId)
                //firstSecurityGroupId = sgId.SystemId
                //break
        }</span>

        <span class="cov0" title="0">cblogger.Info("보안그룹 변환 완료")
        cblogger.Info(newSecurityGroupIds)

        //request := ecs.CreateCreateInstanceRequest()        // CreateInstance는 PublicIp가 자동으로 할당되지 않음.
        request := ecs.CreateRunInstancesRequest() // RunInstances는 PublicIp가 자동으로 할당됨.
        request.Scheme = "https"

        request.InstanceChargeType = "PostPaid" //저렴한 실시간 요금으로 설정 //PrePaid: subscription.  / PostPaid: pay-as-you-go. Default value: PostPaid.
        request.ImageId = vmReqInfo.ImageIID.SystemId
        //request.SecurityGroupIds *[]string
        request.SecurityGroupIds = &amp;newSecurityGroupIds
        //request.SecurityGroupId = firstSecurityGroupId // string 타입이라 첫번째 보안 그룹만 적용
        //request.SecurityGroupId =  "[\"" + newSecurityGroupIds + "\"]" // string 타입이라 첫번째 보안 그룹만 적용

        request.InstanceName = vmReqInfo.IId.NameId
        //request.HostName = vmReqInfo.IId.NameId        // OS 호스트 명
        request.InstanceType = vmReqInfo.VMSpecName
        request.KeyPairName = vmReqInfo.KeyPairIID.SystemId
        request.VSwitchId = vmReqInfo.SubnetIID.SystemId

        request.Password = vmReqInfo.VMUserPasswd //값에는 8-30자가 포함되고 대문자, 소문자, 숫자 및/또는 특수 문자가 포함되어야 합니다.

        request.UserData = userDataBase64 // cbuser 추가

        //==============
        //PublicIp 설정
        //==============
        //Public Ip를 생성하기 위해서는 과금형태와 대역폭(1 Mbit/s이상)을 지정해야 함.
        //PayByTraffic(기본값) : 트래픽 기준 결제(GB 단위) - 트래픽 기준 결제(GB 단위)를 사용하면 대역폭 사용료가 시간별로 청구
        //PayByBandwidth : 대역폭 사용료는 구독 기반이고 ECS 인스턴스 사용료에 포함 됨.
        request.InternetChargeType = "PayByBandwidth"           //Public Ip요금 방식을 1시간 단위(PayByBandwidth) 요금으로 설정 / PayByTraffic(기본값) : 1GB단위 시간당 트래픽 요금 청구
        request.InternetMaxBandwidthOut = requests.Integer("5") // 0보다 크면 Public IP가 할당 됨 - 최대 아웃 바운드 공용 대역폭 단위 : Mbit / s 유효한 값 : 0 ~ 100
        spew.Dump(request)

        //=============================
        // VM생성 처리
        //=============================
        cblogger.Info("Create EC2 Instance")
        cblogger.Info(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmReqInfo.IId.NameId,
                CloudOSAPI:   "RunInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        response, err := vmHandler.Client.RunInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        //spew.Dump(response)

        if len(response.InstanceIdSets.InstanceIdSet) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("No errors have occurred, but no VMs have been created.")
        }</span>

        //=========================================
        // VM 정보를 조회할 수 있을 때까지 대기
        //=========================================
        <span class="cov0" title="0">newVmIID := irs.IID{SystemId: response.InstanceIdSets.InstanceIdSet[0]}

        //VM 생성 요청 후에는 곧바로 VM 정보를 조회할 수 없기 때문에 VM 상태를 조회할 수 있는 NotExist 상태가 아닐 때까지만 대기 함.
        //2021-05-11 WaitForRun을 호출하지 않아도 GetVM() 호출 시 에러가 발생하지 않는 것은 확인했음. (우선은 정책이 최종 확정이 아니라서 WaitForRun을 사용하도록 원복함.)
        //curStatus, errStatus := vmHandler.WaitForExist(newVmIID) // 20210511 - NotExist 상태가 아닐 때 까지만 대기
        curStatus, errStatus := vmHandler.WaitForRun(newVmIID) // 20210511 아직 정책이 최종 확정이 아니라서 WaitForRun을 사용하도록 원복함
        if errStatus != nil </span><span class="cov0" title="0">{
                cblogger.Error(errStatus.Error())
                return irs.VMInfo{}, nil
        }</span>
        <span class="cov0" title="0">cblogger.Info("==&gt;생성된 VM[%s]의 현재 상태[%s]", newVmIID, curStatus)

        //vmInfo, errVmInfo := vmHandler.GetVM(irs.IID{SystemId: response.InstanceId})
        vmInfo, errVmInfo := vmHandler.GetVM(newVmIID)
        if errVmInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVmInfo.Error())
                return irs.VMInfo{}, errVmInfo
        }</span>
        <span class="cov0" title="0">vmInfo.IId.NameId = vmReqInfo.IId.NameId

        //VM 생성 시 요청한 계정 정보가 있을 경우 사용된 계정 정보를 함께 전달 함.
        if vmReqInfo.VMUserPasswd != "" </span><span class="cov0" title="0">{
                vmInfo.VMUserPasswd = vmReqInfo.VMUserPasswd
                vmInfo.VMUserId = "root"
        }</span>
        <span class="cov0" title="0">return vmInfo, nil</span>
}

// VM 상태가 정보를 조회할 수 있는 상태가 될때까지 기다림(최대 30초간 대기)
func (vmHandler *AlibabaVMHandler) WaitForExist(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt; VM 생성 직후에는 VM 정보를 조회할 수 없기 때문에 NotExist 상태가 아닐 때까지만 대기함.")

        waitStatus := "NotExist" //VM정보 조회가 안됨.
        //waitStatus := "Running"
        //waitStatus := "Creating" //너무 일찍 종료 시 리턴할 VM의 세부 항목의 정보 조회가 안됨.

        //===================================
        // Suspending 되도록 3초 정도 대기 함.
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 30
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)

                if curStatus != irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM 상태[%s]는 [%s]가 아니라서 대기를 중단합니다.", curStatus, waitStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM 상태가 [%s]라서 1초 대기후 조회합니다.", curStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("장시간(%d 초) 대기해도 VM의 Status 값이 [%s]를 유지해서 강제로 중단합니다.", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("장시간 기다렸으나 생성된 VM의 상태가 [" + waitStatus + "]외의 상태로 바뀌지 않아서 중단 합니다.")
                }</span>
                //} else {
                //break
                //}
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}

// VM 정보를 조회할 수 있을 때까지 최대 30초간 대기
func (vmHandler *AlibabaVMHandler) WaitForRun(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt; VM 생성 직후에는 정보 조회가 안되기 때문에 Running 될 때까지 대기함.")

        //waitStatus := "NotExist"        //VM정보 조회가 안됨.
        waitStatus := "Running"
        //waitStatus := "Creating" //너무 일찍 종료 시 리턴할 VM의 세부 항목의 정보 조회가 안됨.

        //===================================
        // Suspending 되도록 3초 정도 대기 함.
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)

                if curStatus == irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM 상태가 [%s]라서 대기를 중단합니다.", curStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM 상태가 [%s]이 아니라서 1초 대기후 조회합니다.", waitStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("장시간(%d 초) 대기해도 VM의 Status 값이 [%s]으로 변경되지 않아서 강제로 중단합니다.", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("장시간 기다렸으나 생성된 VM의 상태가 [" + waitStatus + "]으로 바뀌지 않아서 중단 합니다.")
                }</span>
                //} else {
                //break
                //}
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}

func (vmHandler *AlibabaVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateStartInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StartInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.StartInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(response)
        return irs.VMStatus("Resuming"), nil</span>

}

// @TODO - 이슈 : 인스턴스 일시정지 시에 과금 정책을 결정해야 함 - StopCharging / KeepCharging
func (vmHandler *AlibabaVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateStopInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId
        request.StoppedMode = "StopCharging"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StopInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.StopInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)
        return irs.VMStatus("Suspending"), nil</span>
}

func (vmHandler *AlibabaVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateRebootInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "RebootInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.RebootInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)
        return irs.VMStatus("Rebooting"), nil</span>
}

func (vmHandler *AlibabaVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        cblogger.Infof("VM을 종료하기 위해 Suspend 모드로 실행합니다.")
        //Terminate하려면 VM이 Running 상태면 안됨.
        sus, errSus := vmHandler.SuspendVM(vmIID)
        if errSus != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSus.Error())
                return irs.VMStatus("Failed"), errSus
        }</span>

        <span class="cov0" title="0">if sus != "Suspending" </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VM의 Suspend 모드 실행 결과[%s]가 Suspending이 아닙니다.", vmIID.SystemId, sus)
                return irs.VMStatus("Failed"), errors.New(vmIID.SystemId + " VM의 Suspend 모드 실행 결과 가 Suspending이 아닙니다.")
        }</span>

        //===================================
        // Suspending 되도록 3초 정도 대기 함.
        //===================================
        <span class="cov0" title="0">curRetryCnt := 0
        maxRetryCnt := 60
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)
                if curStatus != irs.VMStatus("Suspended") </span><span class="cov0" title="0">{
                        curRetryCnt++
                        cblogger.Error("VM 상태가 Suspended가 아니라서 1초간 대기후 조회합니다.")
                        time.Sleep(time.Second * 1)
                        if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                                cblogger.Error("장시간 대기해도 VM의 Status 값이 Suspended로 변경되지 않아서 강제로 중단합니다.")
                        }</span>
                } else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">request := ecs.CreateDeleteInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DeleteInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DeleteInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)
        return irs.VMStatus("Terminating"), nil</span>
}

func (vmHandler *AlibabaVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateDescribeInstancesRequest()
        request.Scheme = "https"
        request.InstanceIds = "[\"" + vmIID.SystemId + "\"]"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)

        if response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("Notfound: '" + vmIID.SystemId + "' VM Not found")
        }</span>

        //        vmInfo := vmHandler.ExtractDescribeInstances(response.Instances.Instance[0])
        <span class="cov0" title="0">vmInfo := vmHandler.ExtractDescribeInstances(&amp;response.Instances.Instance[0])
        cblogger.Info("vmInfo", vmInfo)
        return vmInfo, nil</span>
}

//@TODO : 2020-03-26 Ali클라우드 API 구조가 바뀐 것 같아서 임시로 변경해 놓음.
//func (vmHandler *AlibabaVMHandler) ExtractDescribeInstances() irs.VMInfo {
func (vmHandler *AlibabaVMHandler) ExtractDescribeInstances(instancInfo *ecs.Instance) irs.VMInfo <span class="cov0" title="0">{
        cblogger.Info(instancInfo)

        //time.Parse(layout, str)
        vmInfo := irs.VMInfo{
                IId:        irs.IID{NameId: instancInfo.InstanceName, SystemId: instancInfo.InstanceId},
                ImageIId:   irs.IID{SystemId: instancInfo.ImageId},
                VMSpecName: instancInfo.InstanceType,
                KeyPairIId: irs.IID{SystemId: instancInfo.KeyPairName},
                //StartTime:  instancInfo.StartTime,

                Region:    irs.RegionInfo{Region: instancInfo.RegionId, Zone: instancInfo.ZoneId}, //  ex) {us-east1, us-east1-c} or {ap-northeast-2}
                VpcIID:    irs.IID{SystemId: instancInfo.VpcAttributes.VpcId},
                SubnetIID: irs.IID{SystemId: instancInfo.VpcAttributes.VSwitchId},
                //SecurityGroupIIds []IID // AWS, ex) sg-0b7452563e1121bb6
                //NetworkInterface string // ex) eth0
                //PublicDNS
                //PrivateIP
                //PrivateIP: instancInfo.VpcAttributes.PrivateIpAddress.IpAddress[0],
                //PrivateDNS

                //VMBootDisk  string // ex) /dev/sda1
                //VMBlockDisk string // ex)

                KeyValueList: []irs.KeyValue{{Key: "", Value: ""}},
        }

        if len(instancInfo.NetworkInterfaces.NetworkInterface) &gt; 0 </span><span class="cov0" title="0">{
                vmInfo.NetworkInterface = instancInfo.NetworkInterfaces.NetworkInterface[0].NetworkInterfaceId
        }</span>

        //vmInfo.VMUserId = "root"
        <span class="cov0" title="0">vmInfo.VMUserId = CBDefaultVmUserName //2021-05-11 VMUserId 정보를 cb-user로 리턴.

        //2021-05-11 VM생성 후 WaitForRun()을 사용하지 않기 위해 추가
        //VM을 생성하자 마자 조회하면 PrivateIpAddress 정보가 없음.
        if len(instancInfo.VpcAttributes.PrivateIpAddress.IpAddress) &gt; 0 </span><span class="cov0" title="0">{
                vmInfo.PrivateIP = instancInfo.VpcAttributes.PrivateIpAddress.IpAddress[0]
        }</span>

        /*
                if !reflect.ValueOf(reservation.Instances[0].PublicDnsName).IsNil() {
                        vmInfo.PublicDNS = *reservation.Instances[0].PublicDnsName
                }
        */

        //VMUserId
        //VMUserPasswd
        //NetworkInterfaceId

        <span class="cov0" title="0">if len(instancInfo.PublicIpAddress.IpAddress) &gt; 0 </span><span class="cov0" title="0">{
                vmInfo.PublicIP = instancInfo.PublicIpAddress.IpAddress[0]
        }</span>

        <span class="cov0" title="0">for _, security := range instancInfo.SecurityGroupIds.SecurityGroupId </span><span class="cov0" title="0">{
                //vmInfo.SecurityGroupIds = append(vmInfo.SecurityGroupIds, *security.GroupId)
                vmInfo.SecurityGroupIIds = append(vmInfo.SecurityGroupIIds, irs.IID{SystemId: security})
        }</span>

        <span class="cov0" title="0">timeLen := len(instancInfo.CreationTime)
        cblogger.Infof("서버 구동 시간 포멧 변환 처리")
        cblogger.Infof("======&gt; 생성시간 길이 [%s]", timeLen)
        if timeLen &gt; 7 </span><span class="cov0" title="0">{
                cblogger.Infof("======&gt; 생성시간 마지막 문자열 [%s]", instancInfo.CreationTime[timeLen-1:])
                var NewStartTime string
                if instancInfo.CreationTime[timeLen-1:] == "Z" &amp;&amp; timeLen == 17 </span><span class="cov0" title="0">{
                        //cblogger.Infof("======&gt; 문자열 변환 : [%s]", StartTime[:timeLen-1])
                        NewStartTime = instancInfo.CreationTime[:timeLen-1] + ":00Z"
                        cblogger.Infof("======&gt; 최종 문자열 변환 : [%s]", NewStartTime)
                }</span> else<span class="cov0" title="0"> {
                        NewStartTime = instancInfo.CreationTime
                }</span>

                <span class="cov0" title="0">cblogger.Infof("Convert StartTime string [%s] to time.time", NewStartTime)

                //layout := "2020-05-07T01:36Z"
                t, err := time.Parse(time.RFC3339, NewStartTime)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Infof("======&gt; [%v]", t)
                        vmInfo.StartTime = t
                }</span>
        }

        <span class="cov0" title="0">return vmInfo</span>
}

func (vmHandler *AlibabaVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")

        request := ecs.CreateDescribeInstancesRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVM()",
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)

        var vmInfoList []*irs.VMInfo
        for _, curInstance := range response.Instances.Instance </span><span class="cov0" title="0">{

                cblogger.Info("[%s] ECS 정보 조회", curInstance.InstanceId)
                vmInfo, errVmInfo := vmHandler.GetVM(irs.IID{SystemId: curInstance.InstanceId})
                if errVmInfo != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errVmInfo.Error())
                        return nil, errVmInfo
                }</span>
                //cblogger.Info("=======&gt;VM 조회 결과")
                <span class="cov0" title="0">spew.Dump(vmInfo)

                vmInfoList = append(vmInfoList, &amp;vmInfo)</span>
        }

        //cblogger.Info("=======&gt;VM 최종 목록결과")
        <span class="cov0" title="0">spew.Dump(vmInfoList)
        //cblogger.Info("=======&gt;VM 목록 완료")
        return vmInfoList, nil</span>
}

//SHUTTING-DOWN / TERMINATED
func (vmHandler *AlibabaVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        request := ecs.CreateDescribeInstanceStatusRequest()
        request.Scheme = "https"
        request.InstanceId = &amp;[]string{vmIID.SystemId}
        cblogger.Infof("request : [%v]", request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstanceStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstanceStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success", response)
        if response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                //return irs.VMStatus("Failed"), errors.New("Notfound: '" + vmIID.SystemId + "' VM Not found")
                return irs.VMStatus("NotExist"), nil
        }</span>

        <span class="cov0" title="0">for _, vm := range response.InstanceStatuses.InstanceStatus </span><span class="cov0" title="0">{
                //vmStatus := strings.ToUpper(vm.Status)
                cblogger.Infof("Req VM:[%s] / Cur VM:[%s] / ECS Status : [%s]", vmID, vm.InstanceId, vm.Status)
                vmStatus, errStatus := vmHandler.ConvertVMStatusString(vm.Status)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                        return irs.VMStatus("Failed"), errStatus
                }</span>
                <span class="cov0" title="0">return vmStatus, errStatus</span>
        }

        <span class="cov0" title="0">return irs.VMStatus("Failed"), errors.New("No status information found.")</span>
}

//알리 클라우드 라이프 사이클 : https://www.alibabacloud.com/help/doc-detail/25380.htm
/*
const (
        Creating VMStatus = “Creating" // from launch to running
        Running VMStatus = “Running"

        Suspending VMStatus = “Suspending" // from running to suspended
        Suspended  VMStatus = “Suspended"
        Resuming VMStatus = “Resuming" // from suspended to running

        Rebooting VMStatus = “Rebooting" // from running to running

        Terminating VMStatus = “Terminating" // from running, suspended to terminated
        Terminated  VMStatus = “Terminated“
        NotExist  VMStatus = “NotExist“  // VM does not exist

        Failed  VMStatus = “Failed“
)

&lt;최종 상태&gt;
Running(동작 상태): MCIS가 동작 상태
Suspended(중지 상태): MCIS가 중지된 상태
Failed(실패 상태): MCIS가 오류로 인해 중단된 상태
Terminated(종료 상태): MCIS가 종료된 상태

&lt;전이 상태&gt;
Creating(생성 진행 상태): MCIS가 생성되는 중간 상태
Suspending(중지 진행 상태): MCIS를 일시 중지하기 위한 중간 상태
Resuming(재개 진행 상태): MCIS를 다시 실행하기 위한 중간 상태
Rebooting(재시작 진행 상태): MCIS를 재부팅하는 상태
Terminating(종료 진행 상태): MCIS의 종료를 실행하고 있는 중간 상태

*/
func (vmHandler *AlibabaVMHandler) ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "Pending") </span><span class="cov0" title="0">{
                resultStatus = "Creating"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Running") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Stopping") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Stopped") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]와 일치하는 맵핑 정보를 찾지 못 함.", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "와 일치하는 CB VM 상태정보를 찾을 수 없습니다.")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM 상태 치환 : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

func (vmHandler *AlibabaVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")

        request := ecs.CreateDescribeInstanceStatusRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVMStatus()",
                CloudOSAPI:   "DescribeInstanceStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstanceStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success", response)
        if response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var vmInfoList []*irs.VMStatusInfo
        for _, vm := range response.InstanceStatuses.InstanceStatus </span><span class="cov0" title="0">{
                cblogger.Infof("Cur VM:[%s] / ECS Status : [%s]", vm.InstanceId, vm.Status)
                vmStatus, errStatus := vmHandler.ConvertVMStatusString(vm.Status)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                        return nil, errStatus
                }</span>
                <span class="cov0" title="0">curVmStatusInfo := irs.VMStatusInfo{IId: irs.IID{SystemId: vm.InstanceId}, VmStatus: vmStatus}
                vmInfoList = append(vmInfoList, &amp;curVmStatusInfo)</span>
        }

        <span class="cov0" title="0">return vmInfoList, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package resources

import (
        "errors"
        "reflect"
        "strconv"
        "strings"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

//https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.DescribeInstanceTypes
type AlibabaVmSpecHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

//인스턴스 스펙 정보를 추출함
func ExtractVMSpecInfo(Region string, instanceTypeInfo ecs.InstanceType) irs.VMSpecInfo <span class="cov0" title="0">{
        //@TODO : 2020-03-26 Ali클라우드 API 구조가 바뀐 것 같아서 임시로 변경해 놓음.
        //윈도우즈에서는 ecs.InstanceType를 인식하지만 Mac과 신규 API에서는 ecs.InstanceType를 못찾고 ecs.InstanceTypeInDescribeInstanceTypes를 이용함.
        //func ExtractVMSpecInfo(Region string, instanceTypeInfo ecs.InstanceTypeInDescribeInstanceTypes) irs.VMSpecInfo {
        //@todo : 2020-04-20 ecs.InstanceTypeInDescribeInstanceTypes을 인식 못해서 다시 ecs.InstanceType을 사용함.
        //func ExtractVMSpecInfo(Region string, instanceTypeInfo ecs.InstanceType) irs.VMSpecInfo {
        //ecs.InstanceType
        cblogger.Infof("ExtractVMSpecInfo : Region:[%s] / SpecName:[%s]", Region, instanceTypeInfo.InstanceTypeFamily)
        //spew.Dump(instanceTypeInfo)

        vCpuInfo := irs.VCpuInfo{
                Clock: "N/A",
        }
        gpuInfoList := []irs.GpuInfo{
                {
                        Count: strconv.Itoa(instanceTypeInfo.GPUAmount),
                        Model: instanceTypeInfo.GPUSpec,
                },
        }

        if !reflect.ValueOf(&amp;instanceTypeInfo.GPUSpec).IsNil() </span><span class="cov0" title="0">{
                gpu := strings.Split(instanceTypeInfo.GPUSpec, " ") //"Nvidia Tesla P4"
                cblogger.Infof("제조사 정보 추출 : 원문[%s] / 추출[%s]", instanceTypeInfo.GPUSpec, gpu[0])
                gpuInfoList[0].Mfr = gpu[0]
        }</span>

        //결과에 리전 정보는 없기 때문에 조회한 리전 정보를 전달 받아서 처리함.
        <span class="cov0" title="0">vmSpecInfo := irs.VMSpecInfo{
                Region: Region,
        }

        //VCPU 정보 처리 - Count
        //if !reflect.ValueOf(&amp;instanceTypeInfo.CpuCoreCount).IsNil() {
        vCpuInfo.Count = strconv.Itoa(instanceTypeInfo.CpuCoreCount)
        //}

        vmSpecInfo.VCpu = vCpuInfo

        vmSpecInfo.Gpu = gpuInfoList

        //if !reflect.ValueOf(&amp;instanceTypeInfo.InstanceTypeId).IsNil() {
        vmSpecInfo.Name = instanceTypeInfo.InstanceTypeId
        //}

        //if !reflect.ValueOf(&amp;instanceTypeInfo.MemorySize).IsNil() {
        //vmSpecInfo.Mem = strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)
        vmSpecInfo.Mem = strconv.FormatFloat(instanceTypeInfo.MemorySize*1024, 'f', 0, 64) // GB-&gt;MB로 변환
        //}

        //KeyValue 목록 처리
        keyValueList, errKeyValue := ConvertKeyValueList(instanceTypeInfo)
        cblogger.Errorf("[%]의 KeyValue 추출 실패", instanceTypeInfo.InstanceTypeId)
        cblogger.Error(errKeyValue)
        vmSpecInfo.KeyValueList = keyValueList

        return vmSpecInfo</span>
}

func (vmSpecHandler *AlibabaVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListVMSpec(Region:[%s])", Region)
        var vMSpecInfoList []*irs.VMSpecInfo

        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get ListVMSpec - %v", err)
                return vMSpecInfoList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //spew.Dump(resp)
        cblogger.Info("조회된 인스턴스 타입 수 : ", len(resp.InstanceTypes.InstanceType))
        for _, curInstance := range resp.InstanceTypes.InstanceType </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VM 스펙 정보 조회", curInstance.InstanceTypeFamily)
                vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)
        }</span>
        //spew.Dump(vMSpecInfoList)
        <span class="cov0" title="0">return vMSpecInfoList, nil</span>
}

func (vmSpecHandler *AlibabaVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetVMSpec(Region:[%s], Name:[%s])", Region, Name)

        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region
        //request.InstanceTypeFamily = Name

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "Region:" + Region + "/ Name:" + Name,
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("조회된 인스턴스 타입 수 : ", len(resp.InstanceTypes.InstanceType))
        //        spew.Dump(resp)

        if len(resp.InstanceTypes.InstanceType) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMSpecInfo{}, errors.New("Notfound: '" + Name + "'에 해당하는 Spec 정보를 찾을 수 없습니다.")
        }</span>

        <span class="cov0" title="0">var vMSpecInfo irs.VMSpecInfo
        //인스턴스 타입으로 필터가 안되기 때문에 직접 처리함.
        //속도를 고려하면 조회 대상을 전체로 설정하지 말고 InstanceTypeFamily을 이용해서 패밀리 그룹을 제한할 수는 있음.
        for _, curInstance := range resp.InstanceTypes.InstanceType </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s]", curInstance.InstanceTypeId)
                if Name == curInstance.InstanceTypeId </span><span class="cov0" title="0">{
                        cblogger.Debugf("===&gt; [%s]", curInstance.InstanceTypeId)
                        cblogger.Infof("[%s] VM 스펙 정보 조회", curInstance.InstanceTypeId)
                        vMSpecInfo = ExtractVMSpecInfo(Region, curInstance)
                        break</span>
                }
        }

        <span class="cov0" title="0">return vMSpecInfo, nil</span>
}

// Alibaba Cloud의 정보 그대로를 가공 없이 JSON으로 리턴 함.
func (vmSpecHandler *AlibabaVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListOrgVMSpec(Region:[%s])", Region)

        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListOrgVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get ListOrgVMSpec - %v", err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //jsonString, errJson := ConvertJsonString(resp.InstanceTypes.InstanceType)
        jsonString, errJson := ConvertJsonString(resp.InstanceTypes)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}

// AWS의 정보 그대로를 가공 없이 JSON으로 리턴 함.
func (vmSpecHandler *AlibabaVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetOrgVMSpec(Region:[%s], Name:[%s])", Region, Name)
        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "Region:" + Region + "/ Name:" + Name,
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("조회된 인스턴스 타입 수 : ", len(resp.InstanceTypes.InstanceType))
        //        spew.Dump(resp)

        if len(resp.InstanceTypes.InstanceType) &lt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(Name + "에 해당하는 Spec 정보를 찾을 수 없습니다.")
        }</span>

        <span class="cov0" title="0">var jsonString string
        var errJson error
        //인스턴스 타입으로 필터가 안되기 때문에 직접 처리함.
        //속도를 고려하면 조회 대상을 전체로 설정하지 말고 InstanceTypeFamily을 이용해서 패밀리 그룹을 제한할 수는 있음.
        for _, curInstance := range resp.InstanceTypes.InstanceType </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s]", curInstance.InstanceTypeId)
                if Name == curInstance.InstanceTypeId </span><span class="cov0" title="0">{
                        cblogger.Debugf("===&gt; [%s]", curInstance.InstanceTypeId)
                        cblogger.Infof("[%s] VM 스펙 정보 조회", curInstance.InstanceTypeId)

                        jsonString, errJson = ConvertJsonString(curInstance)
                        if errJson != nil </span><span class="cov0" title="0">{
                                cblogger.Error(errJson)
                                return "", errJson
                        }</span>

                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">return jsonString, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by zephy@mz.co.kr, 2019.09.
// by devunet@mz.co.kr, 2020.04.

//VPC &amp; Subnet 처리 (AlibabaCloud's Subnet --&gt; VSwitch 임)
package resources

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
        "github.com/davecgh/go-spew/spew"

        //"github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        /*
                "github.com/aliyun/alibaba-cloud-sdk-go/sdk/errors"
                "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
                idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
                irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
                "github.com/davecgh/go-spew/spew"
        */)

type AlibabaVPCHandler struct {
        Region idrv.RegionInfo
        Client *vpc.Client
}

func (VPCHandler *AlibabaVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        request := vpc.CreateCreateVpcRequest()
        request.Scheme = "https"
        request.VpcName = vpcReqInfo.IId.NameId
        request.CidrBlock = vpcReqInfo.IPv4_CIDR

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        response, err := VPCHandler.Client.CreateVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //VPC를 생성하면 Pending 상태라서 Subnet을 추가할 수 없기 때문에 Available로 바뀔 때까지 대기함.
        err = VPCHandler.WaitForRun(response.VpcId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>

        //==========================
        // Subnet 생성
        //==========================
        <span class="cov0" title="0">cblogger.Info("Subnet 생성 시작")
        //var resSubnetList []irs.SubnetInfo
        for _, curSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet 생성", curSubnet.IId.NameId)
                resSubnet, errSubnet := VPCHandler.CreateSubnet(response.VpcId, curSubnet)

                cblogger.Info(resSubnet)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        return irs.VPCInfo{}, errSubnet
                }</span>
        }

        //생성된 Subnet을 포함한 VPC의 최신 정보를 조회함.
        <span class="cov0" title="0">retVpcInfo, errVpc := VPCHandler.GetVPC(irs.IID{SystemId: response.VpcId})
        if errVpc != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpc)
                return irs.VPCInfo{}, errVpc
        }</span>
        <span class="cov0" title="0">retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId // NameId는 요청 받은 값으로 리턴해야 함.

        return retVpcInfo, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Info(reqSubnetInfo)

        /*
                vpcInfo, errVpcInfo := VPCHandler.GetSubnet(reqSubnetInfo.IId.SystemId)
                if errVpcInfo == nil {
                        cblogger.Errorf("이미 [%S] Subnet이 존재하기 때문에 생성하지 않고 기존 정보와 함께 에러를 리턴함.", reqSubnetInfo.IId.SystemId)
                        cblogger.Info(vpcInfo)
                        return vpcInfo, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + reqSubnetInfo.IId.SystemId + "' already exists.")
                }
        */

        //서브넷 생성
        request := vpc.CreateCreateVSwitchRequest()
        request.Scheme = "https"
        request.VpcId = vpcId
        request.CidrBlock = reqSubnetInfo.IPv4_CIDR
        request.VSwitchName = reqSubnetInfo.IId.NameId
        fmt.Printf("\n\n======= %#v\n\n", VPCHandler.Region.Zone) // by powerkim.
        request.ZoneId = VPCHandler.Region.Zone                   //"ap-northeast-1a" // @TOTO : ZoneId 전달 받아야 함.
        cblogger.Info(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateVSwitch()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        response, err := VPCHandler.Client.CreateVSwitch(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        spew.Dump(response)

        subnetInfo, errSunetInfo := VPCHandler.GetSubnet(response.VSwitchId)
        if errSunetInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(subnetInfo)
                return irs.SubnetInfo{}, errSunetInfo
        }</span>

        <span class="cov0" title="0">return subnetInfo, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start")

        request := vpc.CreateDescribeVpcsRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "List()",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(result)
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vpcInfoList []*irs.VPCInfo
        for _, curVpc := range result.Vpcs.Vpc </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VPC 정보 조회", curVpc.VpcId)
                //vpcInfo := ExtractVpcDescribeInfo(&amp;curVpc)
                vpcInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: curVpc.VpcId})
                if vpcErr != nil </span><span class="cov0" title="0">{
                        return nil, vpcErr
                }</span>
                <span class="cov0" title="0">vpcInfoList = append(vpcInfoList, &amp;vpcInfo)</span>
        }

        <span class="cov0" title="0">cblogger.Debug(result)
        //spew.Dump(vpcInfoList)
        return vpcInfoList, nil</span>
}

//VPC 정보를 추출함
func ExtractVpcDescribeInfo(vpcInfo *vpc.Vpc) irs.VPCInfo <span class="cov0" title="0">{
        aliVpcInfo := irs.VPCInfo{
                IId:       irs.IID{NameId: vpcInfo.VpcName, SystemId: vpcInfo.VpcId},
                IPv4_CIDR: vpcInfo.CidrBlock,
        }

        keyValueList := []irs.KeyValue{
                {Key: "IsDefault", Value: strconv.FormatBool(vpcInfo.IsDefault)},
                {Key: "Status", Value: vpcInfo.Status},
                {Key: "VRouterId", Value: vpcInfo.VRouterId},
                {Key: "RegionId", Value: vpcInfo.RegionId},
        }
        aliVpcInfo.KeyValueList = keyValueList

        return aliVpcInfo
}</span>

//Pending , Available
func (VPCHandler *AlibabaVPCHandler) WaitForRun(vpcId string) error <span class="cov0" title="0">{
        cblogger.Info("======&gt; VPC가 Running 될 때까지 대기함.")

        maxRetryCnt := 20
        curRetryCnt := 0
        status := ""
        request := vpc.CreateDescribeVpcsRequest()
        request.Scheme = "https"
        request.VpcId = vpcId

        for </span><span class="cov0" title="0">{
                result, err := VPCHandler.Client.DescribeVpcs(request)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if len(result.Vpcs.Vpc) &lt; 1 </span><span class="cov0" title="0">{
                        return errors.New("Not found")
                }</span>

                <span class="cov0" title="0">status = result.Vpcs.Vpc[0].Status
                cblogger.Info("===&gt;VPC Status : ", status)
                if strings.EqualFold(status, "Pending") </span><span class="cov0" title="0">{
                        curRetryCnt++
                        cblogger.Error("VPC 상태가 Available이 아니라서 1초가 대기후 조회합니다.")
                        time.Sleep(time.Second * 1)
                        if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                                cblogger.Error("장시간 VPC의 Status 값이 Available로 변경되지 않아서 강제로 중단합니다.")
                        }</span>
                } else<span class="cov0" title="0"> {
                        if strings.EqualFold(status, "Available") </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> {
                                return errors.New("Unknown VPC Status value.")
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (VPCHandler *AlibabaVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        request := vpc.CreateDescribeVpcsRequest()
        request.Scheme = "https"
        request.VpcId = vpcIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("VPC 개수 : ", len(result.Vpcs.Vpc))
        //if result.TotalCount &lt; 1 {
        if len(result.Vpcs.Vpc) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New("Notfound: '" + vpcIID.SystemId + "' VPC Not found")
        }</span>

        <span class="cov0" title="0">vpcInfo := ExtractVpcDescribeInfo(&amp;result.Vpcs.Vpc[0])
        spew.Dump(vpcInfo)

        //==========================
        // VPC의 서브넷들 처리
        //==========================
        var subnetInfoList []irs.SubnetInfo
        for _, curSubnet := range result.Vpcs.Vpc[0].VSwitchIds.VSwitchId </span><span class="cov0" title="0">{
                //cblogger.Infof("\n\n\n\n")
                //cblogger.Infof("---------------------------------------------------------------------")
                cblogger.Infof("[%s] VSwitch 정보 조회", curSubnet)
                subnetInfo, errSubnet := VPCHandler.GetSubnet(curSubnet)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] VSwitch 정보 조회 실패", curSubnet)
                        cblogger.Error(errSubnet)
                        return irs.VPCInfo{}, errSubnet
                }</span>
                //cblogger.Infof("    =====&gt; [%s] 조회 결과", curSubnet)
                //spew.Dump(subnetInfo)
                <span class="cov0" title="0">subnetInfoList = append(subnetInfoList, subnetInfo)</span>
        }
        //cblogger.Info("===========&gt; 서브넷 목록")
        //spew.Dump(subnetInfoList)

        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetInfoList
        return vpcInfo, nil</span>
}

//@TODO : 라우트 삭제 로직이 없어서 VPC가 삭제 안되는 현상이 있어서 라우트 정보를 조회해서 삭제하려다 서브넷 삭제 후 특정 시간 이후에 Route가 자동으로 삭제되기 때문에 임시로 4초 대기 후 VPC를 삭제하도록 로직을 변경함.
//@TODO : VPCHandler로 생성하지 않은 VPC의 경우 다른 서비스가 있을 수 있기 때문에 관련 서비스들을 조회후 삭제하는 로직이 필요할 수 있음.
/*
  - 삭제 오류
        자동 할당된 Route가 남아있어서 삭제가 안되는 듯.
        ErrorCode: Forbbiden
        Recommend:
        RequestId: 8871BF19-330B-4F00-93ED-D886F2CE066F
        Message: Active custom route in vpc.)
*/
func (VPCHandler *AlibabaVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        //Subnet 등으 연계된 인프라 제거를 위해 VPC 정보를 조회함.
        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                return false, errVpcInfo
        }</span>

        //=================
        // Subnet삭제
        //=================
        <span class="cov0" title="0">for _, curSubnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VSwitch 삭제 처리", curSubnet.IId.SystemId)
                _, errSubnet := VPCHandler.DeleteSubnet(curSubnet.IId)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        return false, errSubnet
                }</span>
        }

        //=====================
        // 라우트를 제거해야 삭제 가능 함.
        //=================
        //특정 시간 이후 자동 삭제되니 라우트 삭제 대신 3초 대기후 시도해 봄.
        <span class="cov0" title="0">time.Sleep(time.Second * 3)

        cblogger.Infof("[%s] VPC를 삭제 함.", vpcInfo.IId.SystemId)
        //cblogger.Info("VPC 제거를 위해 생성된 IGW / Route들 제거 시작")

        request := vpc.CreateDeleteVpcRequest()
        request.Scheme = "https"
        request.VpcId = vpcIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        response, err := VPCHandler.Client.DeleteVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Infof("[%s] VPC Delete fail", vpcIID.SystemId)
                cblogger.Error(err.Error())
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return true, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) DeleteSubnet(subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VSwitch : [%s]", subnetIID.SystemId)

        request := vpc.CreateDeleteVSwitchRequest()
        request.Scheme = "https"
        request.VSwitchId = subnetIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "DeleteVSwitch()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        response, err := VPCHandler.Client.DeleteVSwitch(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Infof("[%s] VSwitch Delete fail", subnetIID.SystemId)
                cblogger.Error(err.Error())
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return true, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) GetSubnet(reqSubnetId string) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("SubnetId : [%s]", reqSubnetId)

        request := vpc.CreateDescribeVSwitchesRequest()
        request.Scheme = "https"
        request.VSwitchId = reqSubnetId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetId,
                CloudOSAPI:   "DescribeVSwitches()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVSwitches(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        //cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.SubnetInfo{}, errors.New("Notfound: '" + reqSubnetId + "' Subnet Not found")
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(result.VSwitches.VSwitch).IsNil() </span><span class="cov0" title="0">{
                retSubnetInfo := ExtractSubnetDescribeInfo(result.VSwitches.VSwitch[0])
                return retSubnetInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.SubnetInfo{}, errors.New("InvalidVSwitch.NotFound: The '" + reqSubnetId + "' does not exist")
        }</span>
}

//Subnet(VSwitch) 정보를 추출함
func ExtractSubnetDescribeInfo(subnetInfo vpc.VSwitch) irs.SubnetInfo <span class="cov0" title="0">{
        vNetworkInfo := irs.SubnetInfo{
                IId:       irs.IID{NameId: subnetInfo.VSwitchName, SystemId: subnetInfo.VSwitchId},
                IPv4_CIDR: subnetInfo.CidrBlock,
        }

        keyValueList := []irs.KeyValue{
                {Key: "Status", Value: subnetInfo.Status},
                {Key: "IsDefault", Value: strconv.FormatBool(subnetInfo.IsDefault)},
                {Key: "ZoneId", Value: subnetInfo.ZoneId},
        }
        vNetworkInfo.KeyValueList = keyValueList

        return vNetworkInfo
}</span>

func (VPCHandler *AlibabaVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet 추가 - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if errSubnet != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = errSubnet.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(resSubnet)

        //#330이슈 처리
        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, errVpcInfo
        }</span>

        <span class="cov0" title="0">findSubnet := false
        cblogger.Debug("============== 체크할 값 =========")
        for posSubnet, curSubnetInfo := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Debugf("%d - [%s] Subnet 처리 시작", posSubnet, curSubnetInfo.IId.SystemId)
                if resSubnet.IId.SystemId == curSubnetInfo.IId.SystemId </span><span class="cov0" title="0">{
                        cblogger.Infof("추가 요청 받은 [%s] Subnet을 발견 했습니다. - SystemID:[%s]", subnetInfo.IId.NameId, curSubnetInfo.IId.SystemId)
                        //for ~ range는 포인터가 아니라서 값 수정이 안됨. for loop으로 직접 서브넷을 체크하거나 vpcInfo의 배열의 값을 수정해야 함.
                        cblogger.Infof("인덱스 위치 : %d", posSubnet)
                        //vpcInfo.SubnetInfoList[posSubnet].IId.NameId = "테스트~"
                        vpcInfo.SubnetInfoList[posSubnet].IId.NameId = subnetInfo.IId.NameId
                        findSubnet = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !findSubnet </span><span class="cov0" title="0">{
                cblogger.Errorf("서브넷 생성은 성공했으나 VPC의 서브넷 목록에서 추가 요청한 [%s]서브넷의 정보[%s]를 찾지 못했습니다.", subnetInfo.IId.NameId, resSubnet.IId.SystemId)
                return irs.VPCInfo{}, errors.New("MismatchSubnet.NotFound: No SysmteId[" + resSubnet.IId.SystemId + "] found for newly created Subnet[" + subnetInfo.IId.NameId + "].")
        }</span>

        <span class="cov0" title="0">return vpcInfo, nil</span>

        //return irs.VPCInfo{}, nil
}

func (VPCHandler *AlibabaVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC의 [%s] Subnet 삭제", vpcIID.SystemId, subnetIID.SystemId)

        return VPCHandler.DeleteSubnet(subnetIID)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by CB-Spider Team, 2019.06.

//package main

package aws

import (
        "C"

        acon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
        //icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect/AwsNewIfCloudConnect"
        //icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect/connect"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/ec2"
)
import (
        "fmt"

        "github.com/aws/aws-sdk-go/aws/credentials"
)

type AwsDriver struct {
}

func (AwsDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "TEST AWS DRIVER Version 1.0"
}</span>

func (AwsDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

//func getVMClient(regionInfo idrv.RegionInfo) (*ec2.EC2, error) {
func getVMClient(connectionInfo idrv.ConnectionInfo) (*ec2.EC2, error) <span class="cov0" title="0">{

        // setup Region
        fmt.Println("AwsDriver : getVMClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")
        fmt.Println("AwsDriver : getVMClient() - Zone : [" + connectionInfo.RegionInfo.Zone + "]")
        //fmt.Println("전달 받은 커넥션 정보")
        //spew.Dump(connectionInfo)

        sess, err := session.NewSession(&amp;aws.Config{
                Region: aws.String(connectionInfo.RegionInfo.Region),
                //Region:      aws.String("ap-northeast-2"),
                Credentials: credentials.NewStaticCredentials(connectionInfo.CredentialInfo.ClientId, connectionInfo.CredentialInfo.ClientSecret, "")},
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create aws New Session", err)
                return nil, err
        }</span>

        // Create EC2 service client
        <span class="cov0" title="0">svc := ec2.New(sess)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create EC2 service client", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return svc, nil</span>
}

func (driver *AwsDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        //fmt.Println("ConnectCloud의 전달 받은 idrv.ConnectionInfo 정보")
        //spew.Dump(connectionInfo)

        // sample code, do not user like this^^
        //var iConn icon.CloudConnection
        vmClient, err := getVMClient(connectionInfo)
        //vmClient, err := getVMClient(connectionInfo.RegionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        //iConn = acon.AwsCloudConnection{}
        <span class="cov0" title="0">iConn := acon.AwsCloudConnection{
                CredentialInfo: connectionInfo.CredentialInfo,
                Region:         connectionInfo.RegionInfo,
                VMClient:       vmClient,
                KeyPairClient:  vmClient,

                VNetworkClient: vmClient,
                //VNicClient:     vmClient,
                ImageClient: vmClient,
                //PublicIPClient: vmClient,
                SecurityClient: vmClient,
                VmSpecClient:   vmClient,
        }

        return &amp;iConn, nil</span> // return type: (icon.CloudConnection, error)
}

/*
func (AwsDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) {
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.
        // sample code, do not user like this^^
        var iConn icon.CloudConnection
        iConn = acon.AwsCloudConnection{}
        return iConn, nil // return type: (icon.CloudConnection, error)
}
*/
var CloudDriver AwsDriver
</pre>
		
		<pre class="file" id="file51" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by powerkim@etri.re.kr, 2019.06.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        //irs2 "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/new-resources"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"

        ars "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources"

        //ec2drv "github.com/aws/aws-sdk-go/service/ec2"
        "github.com/aws/aws-sdk-go/service/ec2"
)

//type AwsCloudConnection struct{}
type AwsCloudConnection struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
        KeyPairClient  *ec2.EC2
        VMClient       *ec2.EC2

        VNetworkClient *ec2.EC2
        //VNicClient     *ec2.EC2
        ImageClient *ec2.EC2
        //PublicIPClient *ec2.EC2
        SecurityClient *ec2.EC2
        VmSpecClient   *ec2.EC2
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

func (cloudConn *AwsCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateKeyPairHandler()")

        keyPairHandler := ars.AwsKeyPairHandler{cloudConn.CredentialInfo, cloudConn.Region, cloudConn.KeyPairClient}
        //keyPairHandler := ars.AwsKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}

        return &amp;keyPairHandler, nil
}</span>

func (cloudConn *AwsCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateVMHandler()")

        vmHandler := ars.AwsVMHandler{cloudConn.Region, cloudConn.VMClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *AwsCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (cloudConn *AwsCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (cloudConn *AwsCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsVPCHandler{cloudConn.Region, cloudConn.VNetworkClient}

        return &amp;handler, nil
}</span>

//func (cloudConn *AwsCloudConnection) CreateImageHandler() (irs2.ImageHandler, error) {
func (cloudConn *AwsCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsImageHandler{cloudConn.Region, cloudConn.ImageClient}

        return &amp;handler, nil
}</span>

func (cloudConn *AwsCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsSecurityHandler{cloudConn.Region, cloudConn.SecurityClient}

        return &amp;handler, nil
}</span>

/*
func (cloudConn *AwsCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Start")
        handler := ars.AwsVNicHandler{cloudConn.Region, cloudConn.VNicClient}

        return &amp;handler, nil
}

func (cloudConn *AwsCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Start")
        handler := ars.AwsPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}

        return &amp;handler, nil
}
*/

func (cloudConn *AwsCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsVmSpecHandler{cloudConn.Region, cloudConn.VmSpecClient}
        return &amp;handler, nil
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/ec2"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const CBDefaultVNetName string = "CB-VNet"          // CB Default Virtual Network Name
const CBDefaultSubnetName string = "CB-VNet-Subnet" // CB Default Subnet Name
const CBDefaultCidrBlock string = "192.168.0.0/16"  // CB Default CidrBlock
const CBKeyPairPath string = "/cloud-driver-libs/.ssh-aws/"
const CBCloudInitFilePath string = "/cloud-driver-libs/.cloud-init-aws/cloud-init"

const CBDefaultVmUserName string = "cb-user" // default VM User Name

const CUSTOM_ERR_CODE_TOOMANY string = "600"  //awserr.New("600", "n개 이상의 xxxx 정보가 존재합니다.", nil)
const CUSTOM_ERR_CODE_NOTFOUND string = "404" //awserr.New("404", "XXX 정보가 존재하지 않습니다.", nil)

type AwsCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

//VPC
func GetCBDefaultVNetName() string <span class="cov0" title="0">{
        return CBDefaultVNetName
}</span>

//Subnet
func GetCBDefaultSubnetName() string <span class="cov0" title="0">{
        return CBDefaultSubnetName
}</span>

func GetCBDefaultCidrBlock() string <span class="cov0" title="0">{
        return CBDefaultCidrBlock
}</span>

/*
//이 함수는 VPC &amp; Subnet이 존재하는 곳에서만 사용됨.
//VPC &amp; Subnet이 존재하는 경우 정보를 리턴하고 없는 경우 Default VPC &amp; Subnet을 생성 후 정보를 리턴 함.
func (VPCHandler *AwsVPCHandler) GetAutoCBNetworkInfo() (AwsCBNetworkInfo, error) {
        return AwsCBNetworkInfo{}, errors.New("인터페이스 변경해야 함!!!!")
                var awsCBNetworkInfo AwsCBNetworkInfo

                subNetId := VPCHandler.GetMcloudBaristaDefaultSubnetId()
                if subNetId == "" {
                        //내부에서 VPC를 자동으로 생성후 Subnet을 생성함.
                        _, err := VPCHandler.CreateVNetwork(irs.VNetworkReqInfo{})
                        if err != nil {
                                cblogger.Error("Default VNetwork(VPC &amp; Subnet) 자동 생성 실패")
                                cblogger.Error(err)
                                return AwsCBNetworkInfo{}, err
                        }
                }

                //VPC &amp; Subnet을 생성했으므로 예외처리 없이 조회만 처리함.
                awsVpcInfo, _ := VPCHandler.GetVpc(GetCBDefaultVNetName())
                spew.Dump(awsVpcInfo)
                awsCBNetworkInfo.VpcId = awsVpcInfo.Id
                awsCBNetworkInfo.VpcName = awsVpcInfo.Name

                awsSubnetInfo, _ := VPCHandler.GetVNetwork(irs.IID{})
                spew.Dump(awsSubnetInfo)
                //awsCBNetworkInfo.SubnetId = awsSubnetInfo.Id
                //awsCBNetworkInfo.SubnetName = awsSubnetInfo.Name
                awsCBNetworkInfo.SubnetId = awsSubnetInfo.IId.SystemId
                awsCBNetworkInfo.SubnetName = awsSubnetInfo.IId.NameId

                spew.Dump(awsCBNetworkInfo)

                return awsCBNetworkInfo, nil
}
*/

/*

func (VPCHandler *AwsVPCHandler) GetMcloudBaristaDefaultVpcId() string {
        return ""
                awsVpcInfo, err := VPCHandler.GetVpc(GetCBDefaultVNetName())
                if err != nil {
                        if aerr, ok := err.(awserr.Error); ok {
                                switch aerr.Code() {
                                default:
                                        cblogger.Error(aerr.Error())
                                }
                        } else {
                                cblogger.Error(err.Error())
                        }
                        return ""
                }

                //기존 정보가 존재하면...
                if awsVpcInfo.Id != "" {
                        return awsVpcInfo.Id
                } else {
                        return ""
                }
}
*/

/*

//@TODO : awsSubnetInfo.IId.SystemId를 리턴해야 하는지 NameId를 리턴해야 하는지 체크해야 함. -&gt; 생성된 정보가 있는지만 체크 하므로 상관 없음.
func (VPCHandler *AwsVPCHandler) GetMcloudBaristaDefaultSubnetId() string {
        awsSubnetInfo, err := VPCHandler.GetVNetwork(irs.IID{})
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        cblogger.Error(err.Error())
                }
                return ""
        }

        //기존 정보가 존재하면...
        //if awsSubnetInfo.Id != "" {
        //        return awsSubnetInfo.Id
        if awsSubnetInfo.IId.SystemId != "" {
                return awsSubnetInfo.IId.SystemId
        } else {
                return ""
        }
}

//@TODO : ListVNetwork()에서 호출되는 경우도 있기 때문에 필요하면 VPC조회와 생성을 별도의 Func으로 분리해야함.(일단은 큰 문제는 없어서 놔둠)
//CB Default Virtual Network가 존재하지 않으면 생성하며, 존재하는 경우 Vpc ID를 리턴 함.
func (VPCHandler *AwsVPCHandler) FindOrCreateMcloudBaristaDefaultVPC(vNetworkReqInfo irs.VNetworkReqInfo) (string, error) {
        cblogger.Info(vNetworkReqInfo)

        awsVpcInfo, err := VPCHandler.GetVpc(GetCBDefaultVNetName())
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return "", err
        }

        //기존 정보가 존재하면...
        if awsVpcInfo.Id != "" {
                return awsVpcInfo.Id, nil
        } else {
                //@TODO : Subnet과 VPC모두 CSP별 고정된 값으로 드라이버가 내부적으로 자동으로 생성하도록 CB규약이 바뀌어서 서브넷 정보 기반의 로직은 모두 잠시 죽여 놓음 - 리스트 요청시에도 내부적으로 자동 생성하도록 변경 중
                / *
                        cblogger.Infof("기본 VPC[%s]가 없어서 Subnet 요청 정보를 기반으로 /16 범위의 VPC를 생성합니다.", GetCBDefaultVNetName())
                        cblogger.Info("Subnet CIDR 요청 정보 : ", vNetworkReqInfo.CidrBlock)
                        if vNetworkReqInfo.CidrBlock == "" {
                                //VPC가 없는 최초 상태에서 List()에서 호출되었을 수 있기 때문에 에러 처리는 하지 않고 nil을 전달함.
                                cblogger.Infof("요청 정보에 CIDR 정보가 없어서 Default VPC[%s]를 생성하지 않음", GetCBDefaultVNetName())
                                return "", nil
                        }

                        reqCidr := strings.Split(vNetworkReqInfo.CidrBlock, ".")
                        //cblogger.Info("CIDR 추출 정보 : ", reqCidr[0])
                        VpcCidrBlock := reqCidr[0] + "." + reqCidr[1] + ".0.0/16"
                        cblogger.Info("신규 VPC에 사용할 CIDR 정보 : ", VpcCidrBlock)
                * /

                cblogger.Infof("기본 VPC[%s]가 없어서 CIDR[%s] 범위의 VPC를 자동으로 생성합니다.", GetCBDefaultVNetName(), GetCBDefaultCidrBlock())
                awsVpcReqInfo := AwsVpcReqInfo{
                        Name: GetCBDefaultVNetName(),
                        //CidrBlock: VpcCidrBlock,
                        CidrBlock: GetCBDefaultCidrBlock(),
                }

                result, errVpc := VPCHandler.CreateVpc(awsVpcReqInfo)
                if errVpc != nil {
                        cblogger.Error(errVpc)
                        return "", errVpc
                }
                cblogger.Infof("CB Default VPC[%s] 생성 완료 - CIDR : [%s]", GetCBDefaultVNetName(), result.CidrBlock)
                cblogger.Info(result)
                spew.Dump(result)

                return result.Id, nil
        }
}

//자동으로 생성된 VPC &amp; Subnet을 삭제해도 되는가?
//명시적으로 Subnet 삭제의 호출이 없기 때문에 시큐리티 그룹이나 vNic이 삭제되는 시점에 호출됨.
func (VPCHandler *AwsVPCHandler) IsAvailableAutoCBNet() bool {
        return false
}
*/

//Name Tag 설정
func SetNameTag(Client *ec2.EC2, Id string, value string) bool <span class="cov0" title="0">{
        // Tag에 Name 설정
        cblogger.Infof("Name Tage 설정 - ResourceId : [%s]  Value : [%s] ", Id, value)
        _, errtag := Client.CreateTags(&amp;ec2.CreateTagsInput{
                Resources: []*string{&amp;Id},
                Tags: []*ec2.Tag{
                        {
                                Key:   aws.String("Name"),
                                Value: aws.String(value),
                        },
                },
        })
        if errtag != nil </span><span class="cov0" title="0">{
                cblogger.Error("Name Tag 설정 실패 : ")
                cblogger.Error(errtag)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func JSONMarshal(t interface{}) ([]byte, error) <span class="cov0" title="0">{
        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err := encoder.Encode(t)
        return buffer.Bytes(), err
}</span>

//Cloud Object를 JSON String 타입으로 변환
func ConvertJsonStringNoEscape(v interface{}) (string, error) <span class="cov0" title="0">{
        //jsonBytes, errJson := json.Marshal(v)

        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        errJson := encoder.Encode(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON 변환 실패")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        //fmt.Println("After marshal", string(buffer.Bytes()))
        //spew.Dump(string(buffer.Bytes()))
        //spew.Dump("\"TEST")

        <span class="cov0" title="0">jsonString := string(buffer.Bytes())
        //jsonString = strings.Replace(jsonString, "\n", "", -1)
        jsonString = strings.Replace(jsonString, "\"", "", -1)

        return jsonString, nil</span>
}

//Cloud Object를 JSON String 타입으로 변환
func ConvertJsonString(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonBytes, errJson := json.Marshal(v)

        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON 변환 실패")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

//CB-KeyValue 등을 위해 String 타입으로 변환
func ConvertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                cblogger.Debugf("Nil Value")
                return "", errors.New("Nil. Value")
        }</span>

        <span class="cov0" title="0">var result string
        t := reflect.ValueOf(value)
        cblogger.Debug("==&gt;ValueOf : ", t)

        switch value.(type) </span>{
        case float32:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 32)</span> // f, fmt, prec, bitSize
        case float64:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 64)</span> // f, fmt, prec, bitSize
                //strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)

        default:<span class="cov0" title="0">
                cblogger.Debug("--&gt; default type:", reflect.ValueOf(value).Type())
                result = fmt.Sprint(value)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

//Cloud Object를 CB-KeyValue 형식으로 변환이 필요할 경우 이용
func ConvertKeyValueList(v interface{}) ([]irs.KeyValue, error) <span class="cov0" title="0">{
        //spew.Dump(v)
        var keyValueList []irs.KeyValue
        var i map[string]interface{}

        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("KeyValue 변환 실패")
                cblogger.Error(errJson)
                return nil, errJson
        }</span>

        <span class="cov0" title="0">json.Unmarshal(jsonBytes, &amp;i)

        for k, v := range i </span><span class="cov0" title="0">{
                cblogger.Debugf("K:[%s]====&gt;", k)
                /*
                        cblogger.Infof("v:[%s]====&gt;", reflect.ValueOf(v))

                        vv := reflect.ValueOf(v)
                        cblogger.Infof("value ====&gt;[%s]", vv.String())
                        s := fmt.Sprint(v)
                        cblogger.Infof("value2 ====&gt;[%s]", s)
                */
                //value := fmt.Sprint(v)
                value, errString := ConvertToString(v)
                if errString != nil </span><span class="cov0" title="0">{
                        //cblogger.Errorf("Key[%s]의 값은 변환 불가 - [%s]", k, errString)
                        cblogger.Debugf("Key[%s]의 값은 변환 불가 - [%s]", k, errString) //요구에 의해서 Error에서 Warn으로 낮춤
                        continue</span>
                }
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, value})</span>

                /*
                        _, ok := v.(string)
                        if !ok {
                                cblogger.Errorf("Key[%s]의 값은 변환 불가", k)
                                continue
                        }
                        keyValueList = append(keyValueList, irs.KeyValue{k, v.(string)})
                */
        }
        <span class="cov0" title="0">cblogger.Debug("getKeyValueList : ", keyValueList)
        //keyValueList = append(keyValueList, irs.KeyValue{"test", typeToString([]float32{3.14, 1.53, 2.0000000000000})})

        return keyValueList, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Cloud Driver Interface of CB-Spider.  // The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "reflect"
        "strconv"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        //irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/new-resources"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
)

type AwsImageHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

//@TODO : 작업해야 함.
func (imageHandler *AwsImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageReqInfo.IId.NameId,
                CloudOSAPI:   "-",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        imageReqInfo.IId.SystemId = imageReqInfo.IId.NameId

        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        return irs.ImageInfo{imageReqInfo.IId, "", "", nil}, nil
}</span>

//@TODO : 목록이 너무 많기 때문에 amazon 계정으로 공유된 퍼블릭 이미지중 AMI만 조회 함.
//20210607 - Tumblebug에서 필터할 수 있도록 state는 모든 이미지를 대상으로 하며, 이미지가 너무 많기 때문에 AWS 소유의 이미지만 제공 함.
func (imageHandler *AwsImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        var imageInfoList []*irs.ImageInfo
        input := &amp;ec2.DescribeImagesInput{
                //ImageIds: []*string{aws.String("ami-0d097db2fb6e0f05e")},
                Owners: []*string{
                        aws.String("amazon"), //사용자 계정 번호를 넣으면 사용자의 이미지를 대상으로 조회 함.
                },
                Filters: []*ec2.Filter{
                        {
                                Name:   aws.String("image-type"),
                                Values: aws.StringSlice([]string{"machine"}),
                        },
                        {
                                Name:   aws.String("is-public"),
                                Values: aws.StringSlice([]string{"true"}),
                        },
                        /*
                                {
                                        Name:   aws.String("state"),
                                        Values: aws.StringSlice([]string{"available"}),
                                },
                        */
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "ListImage()",
                CloudOSAPI:   "DescribeImages",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := imageHandler.Client.DescribeImages(input)
        //spew.Dump(result)        //출력 정보가 너무 많아서 생략

        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cnt := 0
        for _, cur := range result.Images </span><span class="cov0" title="0">{
                //spew.Dump(cur)
                if reflect.ValueOf(cur.State).IsNil() </span><span class="cov0" title="0">{
                        cblogger.Errorf("===&gt;[%s] AMI는 State 정보가 없어서 Skip함.", *cur.ImageId)
                        continue</span>
                }

                <span class="cov0" title="0">if reflect.ValueOf(cur.Name).IsNil() </span><span class="cov0" title="0">{
                        cblogger.Infof("===&gt;[%s] AMI는 Name 정보가 없어서 Skip함.", *cur.ImageId)
                        continue</span>
                }

                <span class="cov0" title="0">cblogger.Debugf("[%s] - [%s] - [%s] AMI 정보 처리", *cur.ImageId, *cur.State, *cur.Name)
                //cblogger.Infof("[%s] - [%s] - [%s] - [%s] AMI 정보 처리", *cur.ImageId, *cur.State, *cur.Name, *cur.UsageOperation)

                imageInfo := ExtractImageDescribeInfo(cur)
                imageInfoList = append(imageInfoList, &amp;imageInfo)
                cnt++</span>
                /*
                        if cnt &gt; 20 {
                                break
                        }
                */
        }

        <span class="cov0" title="0">cblogger.Info("%d개의 이미지가 조회됨.", cnt)
        //spew.Dump(imageInfoList)

        return imageInfoList, nil</span>
}

//Image 정보를 추출함
//@TODO : GuestOS 쳌크할 것
func ExtractImageDescribeInfo(image *ec2.Image) irs.ImageInfo <span class="cov0" title="0">{
        //spew.Dump(image)
        imageInfo := irs.ImageInfo{
                //IId: irs.IID{*image.Name, *image.ImageId},
                IId: irs.IID{*image.ImageId, *image.ImageId},
                //Id:     *image.ImageId,
                //Name:   *image.Name,
                Status: *image.State,
        }

        keyValueList := []irs.KeyValue{
                //{Key: "Name", Value: *image.Name}, //20200723-Name이 없는 이미지 존재 - 예)ami-0008a301
                {Key: "CreationDate", Value: *image.CreationDate},
                {Key: "Architecture", Value: *image.Architecture}, //x86_64
                {Key: "OwnerId", Value: *image.OwnerId},
                {Key: "ImageType", Value: *image.ImageType},
                {Key: "ImageLocation", Value: *image.ImageLocation},
                {Key: "VirtualizationType", Value: *image.VirtualizationType},
                {Key: "Public", Value: strconv.FormatBool(*image.Public)},
        }

        //주로 윈도우즈는 Platform 정보가 존재하며 리눅스 계열은 PlatformDetails만 존재하는 듯. - "Linux/UNIX"
        //윈도우즈 계열은 PlatformDetails에는 "Windows with SQL Server Standard"처럼 SQL정보도 포함되어있음.
        if !reflect.ValueOf(image.Platform).IsNil() </span><span class="cov0" title="0">{
                imageInfo.GuestOS = *image.Platform //Linux/UNIX
                keyValueList = append(keyValueList, irs.KeyValue{Key: "Platform", Value: *image.Platform})
        }</span> else<span class="cov0" title="0"> {
                // Platform 정보가 없는 경우 PlatformDetails 정보가 존재하면 PlatformDetails 값을 이용함.
                if !reflect.ValueOf(image.PlatformDetails).IsNil() </span><span class="cov0" title="0">{
                        imageInfo.GuestOS = *image.PlatformDetails //Linux/UNIX
                }</span>
        }

        // 일부 이미지들은 아래 정보가 없어서 예외 처리 함.
        <span class="cov0" title="0">if !reflect.ValueOf(image.PlatformDetails).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "PlatformDetails", Value: *image.PlatformDetails})
        }</span>

        // 일부 이미지들은 아래 정보가 없어서 예외 처리 함.
        <span class="cov0" title="0">if !reflect.ValueOf(image.Name).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "Name", Value: *image.Name})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.Description).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "Description", Value: *image.Description})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.ImageOwnerAlias).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "ImageOwnerAlias", Value: *image.ImageOwnerAlias})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.RootDeviceName).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "RootDeviceName", Value: *image.RootDeviceName})
                keyValueList = append(keyValueList, irs.KeyValue{Key: "RootDeviceType", Value: *image.RootDeviceType})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.EnaSupport).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "EnaSupport", Value: strconv.FormatBool(*image.EnaSupport)})
        }</span>

        <span class="cov0" title="0">imageInfo.KeyValueList = keyValueList

        return imageInfo</span>
}

//func (imageHandler *AwsImageHandler) GetImage(imageID string) (irs.ImageInfo, error) {
func (imageHandler *AwsImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{

        cblogger.Infof("imageID : [%s]", imageIID.SystemId)

        input := &amp;ec2.DescribeImagesInput{
                ImageIds: []*string{
                        aws.String(imageIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DescribeImages",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := imageHandler.Client.DescribeImages(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        //spew.Dump(result)
        cblogger.Info(result)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return irs.ImageInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(result.Images) &gt; 0 </span><span class="cov0" title="0">{
                imageInfo := ExtractImageDescribeInfo(result.Images[0])
                return imageInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.ImageInfo{}, errors.New("조회된 Image 정보가 없습니다.")
        }</span>

}

//@TODO : 삭제 API 찾아야 함.
func (imageHandler *AwsImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "-",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        return false, nil
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package resources

import (
        "bytes"
        "crypto/md5"
        "crypto/rsa"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        _ "github.com/davecgh/go-spew/spew"
        "golang.org/x/crypto/ssh"
)

type AwsKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
        Client         *ec2.EC2
}

/*
// @TODO: KeyPairInfo 리소스 프로퍼티 정의 필요
type KeyPairInfo struct {
        Name        string
        Fingerprint string
        KeyMaterial string //RSA PRIVATE KEY
}
*/

func (keyPairHandler *AwsKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start ListKey()")
        var keyPairList []*irs.KeyPairInfo
        //spew.Dump(keyPairHandler)
        cblogger.Debug(keyPairHandler)

        input := &amp;ec2.DescribeKeyPairsInput{
                KeyNames: []*string{
                        nil,
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "ListKey()",
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //  Returns a list of key pairs
        result, err := keyPairHandler.Client.DescribeKeyPairs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Errorf("Unable to get key pairs, %v", err)
                return keyPairList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Debugf("Key Pairs:")
        for _, pair := range result.KeyPairs </span><span class="cov0" title="0">{
                /*
                        cblogger.Debugf("%s: %s\n", *pair.KeyName, *pair.KeyFingerprint)
                        keyPairInfo := new(irs.KeyPairInfo)
                        keyPairInfo.Name = *pair.KeyName
                        keyPairInfo.Fingerprint = *pair.KeyFingerprint
                */
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(pair)
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s] KeyPair는 Local에서 관리하는 대상이 아니기 때문에 Skip합니다.", *pair.KeyName)
                        cblogger.Info(errKeyPair.Error())
                        //return nil, errKeyPair
                }</span> else<span class="cov0" title="0"> {
                        keyPairList = append(keyPairList, &amp;keyPairInfo)
                }</span>
        }

        <span class="cov0" title="0">cblogger.Debug(keyPairList)
        //spew.Dump(keyPairList)
        return keyPairList, nil</span>
}

func (keyPairHandler *AwsKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Info(keyPairReqInfo)
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        // Creates a new  key pair with the given name
        result, err := keyPairHandler.Client.CreateKeyPair(&amp;ec2.CreateKeyPairInput{
                //KeyName: aws.String(keyPairReqInfo.Name),
                KeyName: aws.String(keyPairReqInfo.IId.NameId),
        })
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "InvalidKeyPair.Duplicate" </span><span class="cov0" title="0">{
                        cblogger.Errorf("Keypair %q already exists.", keyPairReqInfo.IId.NameId)
                        return irs.KeyPairInfo{}, err
                }</span>
                <span class="cov0" title="0">cblogger.Errorf("Unable to create key pair: %s, %v.", keyPairReqInfo.IId.NameId, err)
                return irs.KeyPairInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created key pair %q %s\n%s\n", *result.KeyName, *result.KeyFingerprint, *result.KeyMaterial)

        cblogger.Info("공개키 생성")
        publicKey, errPub := makePublicKeyFromPrivateKey(*result.KeyMaterial)
        if errPub != nil </span><span class="cov0" title="0">{
                cblogger.Error(errPub)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">cblogger.Infof("Public Key")
        //spew.Dump(publicKey)
        keyPairInfo := irs.KeyPairInfo{
                //Name:        *result.KeyName,
                IId:         irs.IID{keyPairReqInfo.IId.NameId, *result.KeyName},
                Fingerprint: *result.KeyFingerprint,
                PrivateKey:  *result.KeyMaterial, // AWS(PEM파일-RSA PRIVATE KEY)
                PublicKey:   publicKey,
                //KeyMaterial: *result.KeyMaterial,
                KeyValueList: []irs.KeyValue{
                        {Key: "KeyMaterial", Value: *result.KeyMaterial},
                },
        }

        //spew.Dump(keyPairInfo)

        //        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        //@TODO : File에 저장할 키 파일 이름의 PK 특징 때문에 제약이 걸릴 수 있음. (인증정보로 해쉬를 하면 부모 하위의 IAM 계정에서 해당 키를 못 찾을 수 있으며 사용자 정보를 사용하지 않으면 Uniqueue하지 않아서 충돌 날 수 있음.) 현재는 핑거프린트와 리전을 키로 사용함.
        /*
                hashString, err := CreateHashString(keyPairHandler.CredentialInfo, keyPairHandler.Region)
                if err != nil {
                        cblogger.Error(err)
                        return irs.KeyPairInfo{}, err
                }
                savePrivateFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pem"
                savePublicFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pub"
        */
        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        savePrivateFileTo := keyPairPath + hashString + ".pem"
        savePublicFileTo := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Infof("savePrivateFileTo : [%s]", savePrivateFileTo)
        cblogger.Infof("savePublicFileTo : [%s]", savePublicFileTo)

        // 파일에 private Key를 쓴다
        err = writeKeyToFile([]byte(keyPairInfo.PrivateKey), savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 public Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile([]byte(keyPairInfo.PublicKey), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

//혼선을 피하기 위해 keyPairID 대신 keyName으로 변경 함.
func (keyPairHandler *AwsKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        //keyPairID := keyName
        <span class="cov0" title="0">cblogger.Infof("keyName : [%s]", keyIID.SystemId)
        input := &amp;ec2.DescribeKeyPairsInput{
                KeyNames: []*string{
                        aws.String(keyIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: keyIID.SystemId,
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := keyPairHandler.Client.DescribeKeyPairs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result : ", result)
        cblogger.Info("err : ", err)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        cblogger.Info("aerr : ", aerr)
                        cblogger.Info("aerr.Code()  : ", aerr.Code())
                        cblogger.Info("ok : ", ok)
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                //fmt.Println(aerr.Error())
                                cblogger.Error(aerr.Error())
                                return irs.KeyPairInfo{}, aerr</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        return irs.KeyPairInfo{}, err
                }</span>
                <span class="cov0" title="0">return irs.KeyPairInfo{}, nil</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(result.KeyPairs) &gt; 0 </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(result.KeyPairs[0])
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errKeyPair.Error())
                        return irs.KeyPairInfo{}, errKeyPair
                }</span>

                <span class="cov0" title="0">spew.Dump(keyPairInfo)
                return keyPairInfo, nil</span>
        } else<span class="cov0" title="0"> {
                return irs.KeyPairInfo{}, errors.New("정보를 찾을 수 없습니다.")
        }</span>
}

//KeyPair 정보를 추출함
func ExtractKeyPairDescribeInfo(keyPair *ec2.KeyPairInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        //spew.Dump(keyPair)
        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{*keyPair.KeyName, *keyPair.KeyName},
                //Name:        *keyPair.KeyName,
                Fingerprint: *keyPair.KeyFingerprint,
        }

        // Local Keyfile 처리
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, privateKeyPath)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, publicKeyPath)

        // Private Key, Public Key 파일 정보 가져오기
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair의 Local Private 파일 조회 실패", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair의 Local Public 파일 조회 실패", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo.PublicKey = string(publicKeyBytes)
        keyPairInfo.PrivateKey = string(privateKeyBytes)

        keyValueList := []irs.KeyValue{
                //{Key: "KeyMaterial", Value: *keyPair.KeyMaterial},
        }

        keyPairInfo.KeyValueList = keyValueList

        return keyPairInfo, nil</span>
}

func (keyPairHandler *AwsKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("삭제 요청된 키페어 : [%s]", keyIID.SystemId)

        keyPairInfo, errGet := keyPairHandler.GetKey(keyIID)
        if errGet != nil </span><span class="cov0" title="0">{
                return false, errGet
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: keyIID.SystemId,
                CloudOSAPI:   "DeleteKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Delete the key pair by name
        //by powerkim, result, err := keyPairHandler.Client.DeleteKeyPair(&amp;ec2.DeleteKeyPairInput{
        _, err := keyPairHandler.Client.DeleteKeyPair(&amp;ec2.DeleteKeyPairInput{
                KeyName: aws.String(keyIID.SystemId),
        })
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "InvalidKeyPair.Duplicate" </span><span class="cov0" title="0">{
                        cblogger.Error("Key pair %q does not exist.", keyIID.SystemId)
                        return false, err
                }</span>
                <span class="cov0" title="0">cblogger.Errorf("Unable to delete key pair: %s, %v.", keyIID.SystemId, err)
                return false, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Infof("Successfully deleted %q AWS key pair\n", keyIID.SystemId)

        //====================
        // Local Keyfile 처리
        //====================
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"

        // Private Key, Public Key 삭제
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

//=================================
// 공개 키 변환 및 키 정보 로컬 보관 로직 추가
//=================================
func (keyPairHandler *AwsKeyPairHandler) CheckKeyPairFolder(keyPairPath string) error <span class="cov0" title="0">{
        //키페어 생성 시 폴더가 존재하지 않으면 생성 함.
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Path가 존재하지 않아서 생성합니다.", keyPairPath)

                //errDir := os.MkdirAll(keyPairPath, 0755)
                errDir := os.MkdirAll(keyPairPath, 0700)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path가 생성 실패", keyPairPath)
                        cblogger.Error(errDir)
                        return errDir
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ParseKey reads the given RSA private key and create a public one for it.
func makePublicKeyFromPrivateKey(pem string) (string, error) <span class="cov0" title="0">{
        key, err := ssh.ParseRawPrivateKey([]byte(pem))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">rsaKey, ok := key.(*rsa.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q is not a RSA key", pem)
        }</span>
        <span class="cov0" title="0">pub, err := ssh.NewPublicKey(&amp;rsaKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(bytes.TrimRight(ssh.MarshalAuthorizedKey(pub), "\n")), nil</span>
}

// 파일에 Key를 쓴다
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key 저장위치: %s", saveFileTo)
        return nil</span>
}

// @TODO - PK 이슈 처리해야 함. (A User / B User / User 하위의 IAM 계정간의 호환성에 이슈가 없어야 하는데 현재는 안 됨.)
//       - 따라서 AWS는 대안으로 KeyPair의 FingerPrint를 이용하도록 변경 - 필요시 리전및 키 이름과 혼용해서 만들어야할 듯.
// KeyPair 해시 생성 함수 (PK 이슈로 현재는 사용하지 않음)
func CreateHashString(credentialInfo idrv.CredentialInfo, Region idrv.RegionInfo) (string, error) <span class="cov0" title="0">{
        log.Println("credentialInfo.ClientId : " + credentialInfo.ClientId)
        log.Println("Region.Region : " + Region.Region)
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + Region.Region
        //keyString := credentialInfo
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "reflect"
        "strconv"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

type AwsSecurityHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

//2019-11-16부로 CB-Driver 전체 로직이 NameId 기반으로 변경됨. (보안 그룹은 그룹명으로 처리 가능하기 때문에 Name 태깅시 에러는 무시함)
//@TODO : 존재하는 보안 그룹에 정책 추가하는 기능 필요
//VPC 생략 시 활성화된 세션의 기본 VPC를 이용 함.
func (securityHandler *AwsSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityReqInfo : ", securityReqInfo)
        //spew.Dump(securityReqInfo)

        /*
                //VPC &amp; Subnet을 자동으로 찾아서 처리
                VPCHandler := AwsVPCHandler{Client: securityHandler.Client}
                awsCBNetworkInfo, errAutoCBNetInfo := VPCHandler.GetAutoCBNetworkInfo()
                if errAutoCBNetInfo != nil || awsCBNetworkInfo.VpcId == "" {
                        cblogger.Error("VPC 정보 획득 실패")
                        return irs.SecurityInfo{}, errors.New("mcloud-barista의 기본 네트워크 정보를 찾을 수 없습니다.")
                }

                cblogger.Infof("==&gt; [%s] CB Default VPC 정보 찾음", awsCBNetworkInfo.VpcId)
                vpcId := awsCBNetworkInfo.VpcId
        */
        vpcId := securityReqInfo.VpcIID.SystemId

        // Create the security group with the VPC, name and description.
        //createRes, err := securityHandler.Client.CreateSecurityGroup(&amp;ec2.CreateSecurityGroupInput{
        input := ec2.CreateSecurityGroupInput{
                //GroupName:   aws.String(securityReqInfo.Name),
                GroupName: aws.String(securityReqInfo.IId.NameId),
                //Description: aws.String(securityReqInfo.Name),
                Description: aws.String(securityReqInfo.IId.NameId),
                //                VpcId:       aws.String(securityReqInfo.VpcId),awsCBNetworkInfo
                VpcId: aws.String(vpcId),
        }
        cblogger.Debugf("보안 그룹 생성 요청 정보", input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "CreateSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        createRes, err := securityHandler.Client.CreateSecurityGroup(&amp;input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        case "InvalidVpcID.NotFound":<span class="cov0" title="0">
                                cblogger.Errorf("Unable to find VPC with ID %q.", vpcId)
                                return irs.SecurityInfo{}, err</span>
                        case "InvalidGroup.Duplicate":<span class="cov0" title="0">
                                cblogger.Errorf("Security group %q already exists.", securityReqInfo.IId.NameId)
                                return irs.SecurityInfo{}, err</span>
                        }
                }
                <span class="cov0" title="0">cblogger.Errorf("Unable to create security group %q, %v", securityReqInfo.IId.NameId, err)
                return irs.SecurityInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Infof("[%s] 보안 그룹 생성완료", aws.StringValue(createRes.GroupId))
        cblogger.Debug(createRes)
        //spew.Dump(createRes)

        //newGroupId = *createRes.GroupId

        cblogger.Debug("인바운드 보안 정책 처리")
        //Ingress 처리
        var ipPermissions []*ec2.IpPermission
        for _, ip := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                //for _, ip := range securityReqInfo.IPPermissions {
                if ip.Direction != "inbound" </span><span class="cov0" title="0">{
                        cblogger.Debug("==&gt; inbound가 아닌 보안 그룹 Skip : ", ip.Direction)
                        continue</span>
                }

                // cblogger.Debug("===&gt;변환중")
                // spew.Dump(ip)
                <span class="cov0" title="0">ipPermission := new(ec2.IpPermission)
                ipPermission.SetIpProtocol(ip.IPProtocol)

                if ip.FromPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.FromPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetFromPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.FromPort, "은 숫자가 아님!!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetFromPort(0)
                }</span>

                <span class="cov0" title="0">if ip.ToPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.ToPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetToPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.ToPort, "은 숫자가 아님!!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetToPort(0)
                }</span>

                <span class="cov0" title="0">ipPermission.SetIpRanges([]*ec2.IpRange{
                        (&amp;ec2.IpRange{}).
                                SetCidrIp(ip.CIDR),
                        //SetCidrIp("0.0.0.0/0"),
                })
                // cblogger.Debug("===&gt;변환완료")
                // spew.Dump(ipPermission)

                ipPermissions = append(ipPermissions, ipPermission)</span>
        }

        //인바운드 정책이 있는 경우에만 처리
        <span class="cov0" title="0">if len(ipPermissions) &gt; 0 </span><span class="cov0" title="0">{
                cblogger.Debug("===&gt;적용할 최종 인바운드 정책")
                cblogger.Debug(ipPermissions)
                // spew.Dump(ipPermissions)

                // Add permissions to the security group
                _, err = securityHandler.Client.AuthorizeSecurityGroupIngress(&amp;ec2.AuthorizeSecurityGroupIngressInput{
                        //GroupName:     aws.String(securityReqInfo.Name),
                        GroupId:       createRes.GroupId,
                        IpPermissions: ipPermissions,
                })
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("Unable to set security group %q ingress, %v", securityReqInfo.IId.NameId, err)
                        return irs.SecurityInfo{}, err
                }</span>

                <span class="cov0" title="0">cblogger.Info("Successfully set security group ingress")</span>
        }

        <span class="cov0" title="0">cblogger.Debug("아웃바운드 보안 정책 처리")
        //Egress 처리
        var ipPermissionsEgress []*ec2.IpPermission
        //for _, ip := range securityReqInfo.IPPermissionsEgress {
        for _, ip := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                if ip.Direction != "outbound" </span><span class="cov0" title="0">{
                        cblogger.Debug("==&gt; outbound가 아닌 보안 그룹 Skip : ", ip.Direction)
                        continue</span>
                }

                <span class="cov0" title="0">ipPermission := new(ec2.IpPermission)
                ipPermission.SetIpProtocol(ip.IPProtocol)
                //ipPermission.SetFromPort(ip.FromPort)
                //ipPermission.SetToPort(ip.ToPort)
                if ip.FromPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.FromPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetFromPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.FromPort, "은 숫자가 아님!!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetFromPort(0)
                }</span>

                <span class="cov0" title="0">if ip.ToPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.ToPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetToPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.ToPort, "은 숫자가 아님!!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetToPort(0)
                }</span>

                <span class="cov0" title="0">ipPermission.SetIpRanges([]*ec2.IpRange{
                        (&amp;ec2.IpRange{}).
                                SetCidrIp(ip.CIDR),
                        //SetCidrIp("0.0.0.0/0"),
                })
                //ipPermissions = append(ipPermissions, ipPermission)
                ipPermissionsEgress = append(ipPermissionsEgress, ipPermission)</span>
        }

        //아웃바운드 정책이 있는 경우에만 처리
        <span class="cov0" title="0">if len(ipPermissionsEgress) &gt; 0 </span><span class="cov0" title="0">{
                cblogger.Debug("===&gt;적용할 최종 아웃바운드 정책")
                cblogger.Debug(ipPermissionsEgress)

                // Add permissions to the security group
                _, err = securityHandler.Client.AuthorizeSecurityGroupEgress(&amp;ec2.AuthorizeSecurityGroupEgressInput{
                        GroupId:       createRes.GroupId,
                        IpPermissions: ipPermissionsEgress,
                })
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("Unable to set security group %q egress, %v", securityReqInfo.IId.NameId, err)
                        return irs.SecurityInfo{}, err
                }</span>

                <span class="cov0" title="0">cblogger.Info("Successfully set security group egress")</span>
        }

        <span class="cov0" title="0">cblogger.Debug("Name Tag 처리")
        //======================
        // Name 태그 처리
        //======================
        //VPC Name 태깅
        tagInput := &amp;ec2.CreateTagsInput{
                Resources: []*string{
                        aws.String(*createRes.GroupId),
                },
                Tags: []*ec2.Tag{
                        {
                                Key:   aws.String("Name"),
                                Value: aws.String(securityReqInfo.IId.NameId),
                        },
                },
        }
        //spew.Dump(tagInput)

        _, errTag := securityHandler.Client.CreateTags(tagInput)
        //Tag 실패 시 별도의 처리 없이 에러 로그만 남겨 놓음.
        if errTag != nil </span><span class="cov0" title="0">{
                cblogger.Error(errTag)
        }</span>

        //securityInfo, _ := securityHandler.GetSecurity(*createRes.GroupId)
        //securityInfo, _ := securityHandler.GetSecurity(securityReqInfo.IId) //2019-11-16 NameId 기반으로 변경됨
        <span class="cov0" title="0">securityInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: *createRes.GroupId}) //2020-04-09 SystemId기반으로 변경
        securityInfo.IId.NameId = securityReqInfo.IId.NameId                                  // Name이 필수가 아니므로 혹시 모르니 사용자가 요청한 NameId로 재설정 함.
        securityInfo.VpcIID.NameId = securityReqInfo.VpcIID.NameId                            // Name이 필수가 아니므로 객체에 저장되지 않기 때문에 시스템에서 활용 가능하도록 사용자가 요청한 NameId 값을 그대로 돌려 줌.
        return securityInfo, nil</span>
}

func (securityHandler *AwsSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        //VPC ID 조회
        /* 2020-04-13 : 전체 영역에서 조회하도록 변경
        VPCHandler := AwsVPCHandler{Client: securityHandler.Client}
        vpcId := VPCHandler.GetMcloudBaristaDefaultVpcId()
        if vpcId == "" {
                return nil, nil
        }
        */

        input := &amp;ec2.DescribeSecurityGroupsInput{
                GroupIds: []*string{
                        nil,
                },
                /*
                        Filters: []*ec2.Filter{
                                {
                                        Name:   aws.String("vpc-id"),
                                        Values: aws.StringSlice([]string{vpcId}),
                                },
                        },
                */
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "List()",
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := securityHandler.Client.DescribeSecurityGroups(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result : ", result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                cblogger.Info("err : ", err)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var results []*irs.SecurityInfo
        for _, securityGroup := range result.SecurityGroups </span><span class="cov0" title="0">{
                securityInfo := ExtractSecurityInfo(securityGroup)
                results = append(results, &amp;securityInfo)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

//2019-11-16부로 CB-Driver 전체 로직이 NameId 기반으로 변경됨.
//func (securityHandler *AwsSecurityHandler) GetSecurity(securityNameId string) (irs.SecurityInfo, error) {
func (securityHandler *AwsSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityNameId : [%s]", securityIID.SystemId)

        //2020-04-09 Filter 대신 SystemId 기반으로 변경
        input := &amp;ec2.DescribeSecurityGroupsInput{
                GroupIds: []*string{
                        aws.String(securityIID.SystemId),
                },
        }
        /* 2020-04-09 Name 기반으로 조회 하지 않기때문에 미사용
        input.Filters = ([]*ec2.Filter{
                &amp;ec2.Filter{
                        //Name: aws.String("tag:Name"), // subnet-id
                        Name: aws.String("group-name"), // subnet-id
                        Values: []*string{
                                aws.String(securityIID.SystemId),
                        },
                },
        })
        */
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := securityHandler.Client.DescribeSecurityGroups(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result : ", result)
        cblogger.Info("err : ", err)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return irs.SecurityInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(result.SecurityGroups) &gt; 0 </span><span class="cov0" title="0">{
                securityInfo := ExtractSecurityInfo(result.SecurityGroups[0])
                return securityInfo, nil
        }</span> else<span class="cov0" title="0"> {
                //return irs.SecurityInfo{}, errors.New("[" + securityNameId + "] 정보를 찾을 수 없습니다.")
                return irs.SecurityInfo{}, errors.New("InvalidSecurityGroup.NotFound: The security group '" + securityIID.SystemId + "' does not exist")
        }</span>
}

func ExtractSecurityInfo(securityGroupResult *ec2.SecurityGroup) irs.SecurityInfo <span class="cov0" title="0">{
        var ipPermissions []irs.SecurityRuleInfo
        var ipPermissionsEgress []irs.SecurityRuleInfo
        var securityRules []irs.SecurityRuleInfo

        cblogger.Debugf("===[그룹아이디:%s]===", *securityGroupResult.GroupId)
        ipPermissions = ExtractIpPermissions(securityGroupResult.IpPermissions, "inbound")
        cblogger.Debug("InBouds : ", ipPermissions)
        ipPermissionsEgress = ExtractIpPermissions(securityGroupResult.IpPermissionsEgress, "outbound")
        cblogger.Debug("OutBounds : ", ipPermissionsEgress)
        //spew.Dump(ipPermissionsEgress)
        securityRules = append(ipPermissions, ipPermissionsEgress...)

        securityInfo := irs.SecurityInfo{
                //Id: *securityGroupResult.GroupId,
                IId: irs.IID{"", *securityGroupResult.GroupId},
                //SecurityRules: &amp;[]irs.SecurityRuleInfo{},
                SecurityRules: &amp;securityRules,
                VpcIID:        irs.IID{"", *securityGroupResult.VpcId},

                KeyValueList: []irs.KeyValue{
                        {Key: "GroupName", Value: *securityGroupResult.GroupName},
                        {Key: "VpcID", Value: *securityGroupResult.VpcId},
                        {Key: "OwnerID", Value: *securityGroupResult.OwnerId},
                        {Key: "Description", Value: *securityGroupResult.Description},
                },
        }

        //Name은 Tag의 "Name" 속성에만 저장됨
        cblogger.Debug("Name Tag 찾기")
        for _, t := range securityGroupResult.Tags </span><span class="cov0" title="0">{
                if *t.Key == "Name" </span><span class="cov0" title="0">{
                        //securityInfo.Name = *t.Value
                        securityInfo.IId.NameId = *t.Value
                        cblogger.Debug("Name : ", securityInfo.IId.NameId)
                        break</span>
                }
        }

        <span class="cov0" title="0">return securityInfo</span>
}

// IpPermission에서 공통정보 추출
func ExtractIpPermissionCommon(ip *ec2.IpPermission, securityRuleInfo *irs.SecurityRuleInfo) <span class="cov0" title="0">{
        //공통 정보
        if !reflect.ValueOf(ip.FromPort).IsNil() </span><span class="cov0" title="0">{
                //securityRuleInfo.FromPort = *ip.FromPort
                securityRuleInfo.FromPort = strconv.FormatInt(*ip.FromPort, 10)
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(ip.ToPort).IsNil() </span><span class="cov0" title="0">{
                //securityRuleInfo.ToPort = *ip.ToPort
                securityRuleInfo.ToPort = strconv.FormatInt(*ip.ToPort, 10)
        }</span>

        <span class="cov0" title="0">securityRuleInfo.IPProtocol = *ip.IpProtocol</span>
}

func ExtractIpPermissions(ipPermissions []*ec2.IpPermission, direction string) []irs.SecurityRuleInfo <span class="cov0" title="0">{
        var results []irs.SecurityRuleInfo

        for _, ip := range ipPermissions </span><span class="cov0" title="0">{

                //ipv4 처리
                for _, ipv4 := range ip.IpRanges </span><span class="cov0" title="0">{
                        cblogger.Debug("Inbound/Outbound 정보 조회 : ", *ip.IpProtocol)
                        securityRuleInfo := irs.SecurityRuleInfo{
                                Direction: direction, // "inbound | outbound"
                                CIDR:      *ipv4.CidrIp,
                        }
                        cblogger.Debug(*ipv4.CidrIp)

                        ExtractIpPermissionCommon(ip, &amp;securityRuleInfo) //IP &amp; Port &amp; Protocol 추출
                        results = append(results, securityRuleInfo)
                }</span>

                //ipv6 처리
                <span class="cov0" title="0">for _, ipv6 := range ip.Ipv6Ranges </span><span class="cov0" title="0">{
                        securityRuleInfo := irs.SecurityRuleInfo{
                                Direction: direction, // "inbound | outbound"
                                CIDR:      *ipv6.CidrIpv6,
                        }
                        cblogger.Debug(*ipv6.CidrIpv6)

                        ExtractIpPermissionCommon(ip, &amp;securityRuleInfo) //IP &amp; Port &amp; Protocol 추출
                        results = append(results, securityRuleInfo)
                }</span>

                //ELB나 보안그룹 참조 방식 처리
                <span class="cov0" title="0">for _, userIdGroup := range ip.UserIdGroupPairs </span><span class="cov0" title="0">{
                        securityRuleInfo := irs.SecurityRuleInfo{
                                Direction: direction, // "inbound | outbound"
                                CIDR:      *userIdGroup.GroupId,
                        }
                        cblogger.Debug(*userIdGroup.UserId)

                        ExtractIpPermissionCommon(ip, &amp;securityRuleInfo) //IP &amp; Port &amp; Protocol 추출
                        results = append(results, securityRuleInfo)
                }</span>

                /*  @TODO : 미지원 방식 체크 로직 추가 여부 결정해야 함.
                if !reflect.ValueOf(ip.IpRanges).IsNil() {
                        securityRuleInfo.Cidr = *ip.IpRanges[0].CidrIp
                } else {
                        //ELB나 다른 보안그룹 참조처럼 IpRanges가 없고 UserIdGroupPairs가 있는 경우 처리
                        //https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/classic/elb-security-groups.html
                        if !reflect.ValueOf(ip.UserIdGroupPairs).IsNil() {
                                securityRuleInfo.Cidr = *ip.UserIdGroupPairs[0].GroupId
                        } else {
                                cblogger.Error("미지원 보안 그룹 형태 발견 - 구조 파악 필요 ", ip)
                        }
                }
                */
        }

        <span class="cov0" title="0">return results</span>
}

//2019-11-16부로 CB-Driver 전체 로직이 NameId 기반으로 변경됨.
//func (securityHandler *AwsSecurityHandler) DeleteSecurity(securityNameId string) (bool, error) {
func (securityHandler *AwsSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("securityNameId : [%s]", securityIID.SystemId)

        /* //2020-04-09 SystemId 기반으로 변경되어서 필요 없음.
        securityInfo, errsecurityInfo := securityHandler.GetSecurity(securityIID)
        if errsecurityInfo != nil {
                return false, errsecurityInfo
        }
        cblogger.Info(securityInfo)
        */

        //securityID := securityInfo.Id
        //securityID := securityInfo.IId.SystemId
        securityID := securityIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DeleteSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Delete the security group.
        _, err := securityHandler.Client.DeleteSecurityGroup(&amp;ec2.DeleteSecurityGroupInput{
                GroupId: aws.String(securityID),
        })
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        case "InvalidGroupId.Malformed":<span class="cov0" title="0">
                                fallthrough</span>
                        case "InvalidGroup.NotFound":<span class="cov0" title="0">
                                cblogger.Errorf("%s.", aerr.Message())
                                return false, err</span>
                        }
                }
                <span class="cov0" title="0">cblogger.Errorf("Unable to get descriptions for security groups, %v.", err)
                return false, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Successfully delete security group %q.", securityID)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Proof of Concepts for the Cloud-Barista Multi-Cloud Project.
//      * Cloud-Barista: https://github.com/cloud-barista
//
// EC2 Hander (AWS SDK GO Version 1.16.26, Thanks AWS.)
//
// by CB-Spider Team, 2019.03.
package resources

import (
        "encoding/base64"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "reflect"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/ec2"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"

        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

type AwsVMHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

func Connect(region string) *ec2.EC2 <span class="cov0" title="0">{
        // setup Region
        sess, err := session.NewSession(&amp;aws.Config{
                Region: aws.String(region)},
        )

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create instance", err)
                return nil
        }</span>

        // Create EC2 service client
        <span class="cov0" title="0">svc := ec2.New(sess)

        return svc</span>
}

// 1개의 VM만 생성되도록 수정 (MinCount / MaxCount 이용 안 함)
//키페어 이름(예:mcloud-barista)은 아래 URL에 나오는 목록 중 "키페어 이름"의 값을 적으면 됨.
//https://ap-northeast-2.console.aws.amazon.com/ec2/v2/home?region=ap-northeast-2#KeyPairs:sort=keyName
func (vmHandler *AwsVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vmReqInfo)
        spew.Dump(vmReqInfo)

        imageID := vmReqInfo.ImageIID.SystemId
        instanceType := vmReqInfo.VMSpecName // "t2.micro"
        minCount := aws.Int64(1)
        maxCount := aws.Int64(1)
        keyName := vmReqInfo.KeyPairIID.SystemId
        baseName := vmReqInfo.IId.NameId //"mcloud-barista-VMHandlerTest"
        subnetID := vmReqInfo.SubnetIID.SystemId

        // 2021-04-28 cbuser 추가에 따른 Local KeyPair만 VM 생성 가능하도록 강제
        //=============================
        // KeyPair의 PublicKey 정보 처리
        //=============================
        cblogger.Infof("[%s] KeyPair 조회 시작", keyName)
        keypairHandler := AwsKeyPairHandler{
                //CredentialInfo:
                Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(keypairHandler)

        keyPairInfo, errKeyPair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair)
                return irs.VMInfo{}, errKeyPair
        }</span>

        //=============================
        // 보안그룹 처리 - SystemId 기반
        //=============================
        <span class="cov0" title="0">cblogger.Info("SystemId 기반으로 처리하기 위해 IID 기반의 보안그룹 배열을 SystemId 기반 보안그룹 배열로 조회및 변환함.")
        var newSecurityGroupIds []string

        for _, sgName := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                cblogger.Infof("보안그룹 변환 : [%s]", sgName)
                newSecurityGroupIds = append(newSecurityGroupIds, sgName.SystemId)
        }</span>

        <span class="cov0" title="0">cblogger.Info("보안그룹 변환 완료")
        cblogger.Info(newSecurityGroupIds)

        /* 2020-04-08 EIP 로직 제거
        //=============================
        // PublicIp 처리 - NameId 기반
        //=============================
        cblogger.Info("NameId 기반으로 처리하기 위해 PublicIp 정보를 조회함.")
        publicIPHandler := AwsPublicIPHandler{
                //Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(publicIPHandler)

        publicIPInfo, errPublicIPInfo := publicIPHandler.GetPublicIP(vmReqInfo.PublicIPId)
        cblogger.Info(publicIPInfo)
        if errPublicIPInfo != nil {
                cblogger.Error(errPublicIPInfo)
                return irs.VMInfo{}, errPublicIPInfo
        }
        publicIpId := publicIPInfo.Id
        cblogger.Infof("PublicIP ID를 [%s]대신 [%s]로 사용합니다.", publicIPInfo.Id, publicIpId)
        */

        /*
                //=============================
                // UserData생성 처리
                //=============================
                userData := "#cloud-config\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    groups: sudo\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                //userData = userData + "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0wqohybvHvljVsUW7vmyicVNVDcPdzh6ZRkm1H9SyMuUEK0zOB3Kj+1MxMQPnRXgL9fI518ymUxavrkrHr0LwZtG8pfMOwZkZ7WD4WnT6Ho14N14U1JIM/+005cBBYyF+OWYyxD/q5p/y8R19NXLpEbnpTNL0mKjQ1q8a6/LVCsaKxy9OJ9o/ChN2FDXhCdVLPHL/jrUPqzjSLkm/GIt+v9RWJ0BFAk+rZY7abMNfGSorTqWZEYYd8gqofeTPh2mhYr21NVLBiAyzQqs6fgL+FgsnJFBnuIZ2peuCGxcOxZ7h8iEzJG2r+tGn+ivfMpla12oHxwihJhiodN1KxeZ7"
                userData = userData + keyPairInfo.PublicKey
                userDataBase64 := aws.String(base64.StdEncoding.EncodeToString([]byte(userData)))
                cblogger.Infof("===== userData ===")
                spew.Dump(userDataBase64)
        */

        //=============================
        // UserData생성 처리(File기반)
        //=============================
        // 향후 공통 파일이나 외부에서 수정 가능하도록 cloud-init 스크립트 파일로 설정
        rootPath := os.Getenv("CBSPIDER_ROOT")
        fileDataCloudInit, err := ioutil.ReadFile(rootPath + CBCloudInitFilePath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">userData := string(fileDataCloudInit)
        userData = strings.ReplaceAll(userData, "{{username}}", CBDefaultVmUserName)
        userData = strings.ReplaceAll(userData, "{{public_key}}", keyPairInfo.PublicKey)
        userDataBase64 := aws.String(base64.StdEncoding.EncodeToString([]byte(userData)))
        cblogger.Debugf("cloud-init data : [%s]", userDataBase64)

        //=============================
        // VM생성 처리
        //=============================
        cblogger.Info("Create EC2 Instance")
        input := &amp;ec2.RunInstancesInput{
                ImageId:      aws.String(imageID),
                InstanceType: aws.String(instanceType),
                MinCount:     minCount,
                MaxCount:     maxCount,
                KeyName:      aws.String(keyName),

                /*SecurityGroupIds: []*string{
                        aws.String(securityGroupID), // "sg-0df1c209ea1915e4b" - 미지정시 보안 그룹명이 "default"인 보안 그룹이 사용 됨.
                },*/

                /* PrivateSubnet에도 PublicIp를 할당하려면 AssociatePublicIpAddress 옵션을 사용하거나 Subnet의 PublicIp 할당 옵션을 True로 생성해야 함.
                // 현재는 PublicIp 자동할딩 옵션이 False인 서브넷을 위해 NetworkInterfaces 필드에서 보안그룹과 서브넷을 정의 함. - 2020-04-19
                SecurityGroupIds: aws.StringSlice(newSecurityGroupIds),
                SubnetId:         aws.String(subnetID), // "subnet-cf9ccf83" - 미지정시 기본 VPC의 기본 서브넷이 임의로 이용되며 PublicIP가 할당 됨.
                */

                //AdditionalInfo: aws.String("--associate-public-ip-address"),
                //AdditionalInfo: aws.String("AssociatePublicIpAddress=true"),
                //NetworkInterfaces: []*ec2.InstanceNetworkInterfaceSpecification{{AssociatePublicIpAddress: aws.Bool(true)}},

                NetworkInterfaces: []*ec2.InstanceNetworkInterfaceSpecification{ // PublicIp 할당을 위해 SubnetId와 보안 그룹을 이 곳에서 정의해야 함.
                        {AssociatePublicIpAddress: aws.Bool(true),
                                DeviceIndex: aws.Int64(0),
                                Groups:      aws.StringSlice(newSecurityGroupIds),
                                SubnetId:    aws.String(subnetID),
                        },
                },

                //ec2.InstanceNetworkInterfaceSpecification
                UserData: userDataBase64,
        }
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmReqInfo.IId.NameId,
                CloudOSAPI:   "RunInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        // Specify the details of the instance that you want to create.
        runResult, err := vmHandler.Client.RunInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(runResult)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Errorf("EC2 인스턴스 생성 실패 : ", err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(runResult.Instances) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("AWS로부터 전달 받은 VM 정보가 없습니다.")
        }</span>

        //=============================
        // Name Tag 처리 - NameId 기반
        //=============================
        <span class="cov0" title="0">newVmId := *runResult.Instances[0].InstanceId
        cblogger.Infof("[%s] VM이 생성되었습니다.", newVmId)

        if baseName != "" </span><span class="cov0" title="0">{
                // Tag에 VM Name 설정
                _, errtag := vmHandler.Client.CreateTags(&amp;ec2.CreateTagsInput{
                        Resources: []*string{runResult.Instances[0].InstanceId},
                        Tags: []*ec2.Tag{
                                {
                                        Key:   aws.String("Name"),
                                        Value: aws.String(baseName),
                                },
                        },
                })
                if errtag != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] VM에 Name Tag 설정 실패", newVmId)
                        cblogger.Error(errtag)
                        //return irs.VMInfo{}, errtag
                }</span>
        } else<span class="cov0" title="0"> {
                cblogger.Error("vmReqInfo.IId.NameId가 전달되지 않아서 Name Tag를 설정하지않습니다.")
        }</span>
        //Public IP및 최신 정보 전달을 위해 부팅이 완료될 때까지 대기했다가 전달하는 것으로 변경 함.
        //cblogger.Info("Public IP 할당 및 VM의 최신 정보 획득을 위해 EC2가 Running 상태가 될때까지 대기")

        //2021-05-11 EIP 할당 로직이 제거되었으며 빠른 생성을 위해 Running 상태가 될때까지 대기하지 않음.
        //2021-05-11 WaitForRun을 호출하지 않아도 GetVM() 호출 시 에러가 발생하지 않는 것은 확인했음. (우선은 정책이 최종 확정이 아니라서 WaitForRun을 사용하도록 원복함.)
        <span class="cov0" title="0">cblogger.Info("VM의 최신 정보 획득을 위해 EC2가 Running 상태가 될때까지 대기")
        WaitForRun(vmHandler.Client, newVmId)
        cblogger.Info("EC2 Running 상태 완료 : ", runResult.Instances[0].State.Name)

        /* 2020-04-08 EIP 로직 제거
        //EC2에 EIP 할당 (펜딩 상태에서는 EIP 할당 불가)
        cblogger.Infof("[%s] EC2에 [%s] IP 할당 시작", newVmId, publicIpId)
        assocRes, errIp := vmHandler.AssociatePublicIP(publicIpId, newVmId)
        if errIp != nil {
                cblogger.Errorf("EC2[%s]에 Public IP Id[%s]를 할당 할 수 없습니다 - %v", newVmId, publicIpId, err)
                return irs.VMInfo{}, errIp
        }

        cblogger.Infof("[%s] EC2에 Public IP 할당 결과 : ", newVmId, assocRes)
        */

        /* 2020-04-08 vNic 로직 제거
        //
        //vNic 추가 요청이 있는 경우 전달 받은 vNic을 VM에 추가 함.
        //
        if vmReqInfo.NetworkInterfaceId != "" {
                _, errvNic := vmHandler.AttachNetworkInterface(vmReqInfo.NetworkInterfaceId, newVmId)
                if errvNic != nil {
                        cblogger.Errorf("vNic [%s] 추가 실패!", vmReqInfo.NetworkInterfaceId)
                        cblogger.Error(errvNic)
                        return irs.VMInfo{}, errvNic
                } else {
                        cblogger.Infof("vNic [%s] 추가 완료", vmReqInfo.NetworkInterfaceId)
                }
        }
        */

        //최신 정보 조회
        //newVmInfo, _ := vmHandler.GetVM(newVmId)
        newVmInfo, _ := vmHandler.GetVM(irs.IID{SystemId: newVmId})
        newVmInfo.IId.NameId = vmReqInfo.IId.NameId // Tag 정보가 없을 수 있기 때문에 요청 받은 NameId를 전달 함.

        /*
                //빠른 생성을 위해 Running 상태를 대기하지 않고 최소한의 정보만 리턴 함.
                //Running 상태를 대기 후 Public Ip 등의 정보를 추출하려면 GetVM()을 호출해서 최신 정보를 다시 받아와야 함.
                //vmInfo :=GetVM(runResult.Instances[0].InstanceId)

                //cblogger.Info("EC2 Running 상태 대기")
                //WaitForRun(vmHandler.Client, *runResult.Instances[0].InstanceId)
                //cblogger.Info("EC2 Running 상태 완료 : ", runResult.Instances[0].State.Name)

                vmInfo := ExtractDescribeInstances(runResult)
                //속도상 VM 정보를 다시 조회하지 않았기 때문에 Tag 정보가 누락되어서 Name 정보가 설정되어 있지 않음.
                if vmInfo.Name == "" {
                        vmInfo.Name = baseName
                }
        */

        return newVmInfo, nil</span>
}

//VM이 Running 상태일때까지 대기 함.
func WaitForRun(svc *ec2.EC2, instanceID string) <span class="cov0" title="0">{
        cblogger.Infof("EC2 ID : [%s]", instanceID)

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        aws.String(instanceID),
                },
        }
        err := svc.WaitUntilInstanceRunning(input)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("failed to wait until instances exist: %v", err)
        }</span>
        <span class="cov0" title="0">cblogger.Info("=========WaitForRun() 종료")</span>
}

//func (vmHandler *AwsVMHandler) ResumeVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
                vmID := vmInfo.IId.SystemId
        */
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.StartInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
                DryRun: aws.Bool(true),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StartInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.StartInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        awsErr, ok := err.(awserr.Error)

        if ok &amp;&amp; awsErr.Code() == "DryRunOperation" </span><span class="cov0" title="0">{
                // Let's now set dry run to be false. This will allow us to start the instances
                input.DryRun = aws.Bool(false)
                result, err = vmHandler.Client.StartInstances(input)
                spew.Dump(result)
                if err != nil </span><span class="cov0" title="0">{
                        //fmt.Println("Error", err)
                        cblogger.Error(err)
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        return irs.VMStatus("Failed"), err
                }</span> else<span class="cov0" title="0"> {
                        //fmt.Println("Success", result.StartingInstances)
                        cblogger.Info("Success", result.StartingInstances)
                }</span>
        } else<span class="cov0" title="0"> { // This could be due to a lack of permissions
                //fmt.Println("Error", err)
                cblogger.Error(err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return irs.VMStatus("Resuming"), nil</span>
}

//func (vmHandler *AwsVMHandler) SuspendVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
        */
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.StopInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
                DryRun: aws.Bool(true),
        }
        cblogger.Info(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StopInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := vmHandler.Client.StopInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        awsErr, ok := err.(awserr.Error)
        if ok &amp;&amp; awsErr.Code() == "DryRunOperation" </span><span class="cov0" title="0">{
                input.DryRun = aws.Bool(false)
                result, err = vmHandler.Client.StopInstances(input)
                spew.Dump(result)
                if err != nil </span><span class="cov0" title="0">{
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        cblogger.Error(err)
                        return irs.VMStatus("Failed"), err
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Info("Success", result.StoppingInstances)
                }</span>
        } else<span class="cov0" title="0"> {
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error("Error", err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return irs.VMStatus("Suspending"), nil</span>
}

//func (vmHandler *AwsVMHandler) RebootVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
                vmID := vmInfo.IId.SystemId
        */
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.RebootInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
                DryRun: aws.Bool(true),
        }
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "RebootInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := vmHandler.Client.RebootInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result 값 : ", result)
        cblogger.Info("err 값 : ", err)

        awsErr, ok := err.(awserr.Error)
        cblogger.Info("ok 값 : ", ok)
        cblogger.Info("awsErr 값 : ", awsErr)
        if ok &amp;&amp; awsErr.Code() == "DryRunOperation" </span><span class="cov0" title="0">{
                cblogger.Info("Reboot 권한 있음 - awsErr.Code() : ", awsErr.Code())

                //DryRun 권한 해제 후 리부팅을 요청 함.
                cblogger.Info("DryRun 권한 해제 후 리부팅을 요청 함.")
                input.DryRun = aws.Bool(false)
                result, err = vmHandler.Client.RebootInstances(input)
                spew.Dump(result)
                cblogger.Info("result 값 : ", result)
                cblogger.Info("err 값 : ", err)
                if err != nil </span><span class="cov0" title="0">{
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        cblogger.Error("Error", err)
                        return irs.VMStatus("Failed"), err
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Info("Success", result)
                }</span>
        } else<span class="cov0" title="0"> { // This could be due to a lack of permissions
                cblogger.Info("리부팅 권한이 없는 것같음.")
                cblogger.Error("Error", err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return irs.VMStatus("Rebooting"), nil</span>
}

//func (vmHandler *AwsVMHandler) TerminateVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.TerminateInstancesInput{
                //InstanceIds: instanceIds,
                InstanceIds: []*string{
                        aws.String(vmID),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "TerminateInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.TerminateInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error("Could not termiate instances", err)
                return irs.VMStatus("Failed"), err
        }</span> else<span class="cov0" title="0"> {
                cblogger.Info("Success")
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return irs.VMStatus("Terminating"), nil</span>
}

//2019-11-16부로 CB-Driver 전체 로직이 NameId 기반으로 변경됨.
//func (vmHandler *AwsVMHandler) GetVM(vmNameId string) (irs.VMInfo, error) {
func (vmHandler *AwsVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)
        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmIID.SystemId),
                },
        }
        /*
                input.Filters = ([]*ec2.Filter{
                        &amp;ec2.Filter{
                                Name: aws.String("tag:Name"),
                                Values: []*string{
                                        aws.String(vmIID.NameId),
                                },
                        },
                })
        */
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Info(result)
        cblogger.Infof("조회된 VM 정보 수 : [%d]", len(result.Reservations))
        if len(result.Reservations) &gt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, awserr.New("600", "1개 이상의 VM ["+vmIID.NameId+"] 정보가 존재합니다.", nil)
        }</span> else<span class="cov0" title="0"> if len(result.Reservations) == 0 </span><span class="cov0" title="0">{
                cblogger.Errorf("VM [%s] 정보가 존재하지 않습니다.", vmIID.NameId)
                return irs.VMInfo{}, awserr.New("404", "VM ["+vmIID.NameId+"] 정보가 존재하지 않습니다.", nil)
        }</span>

        <span class="cov0" title="0">vmInfo := irs.VMInfo{}
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                //vmInfo := ExtractDescribeInstances(result.Reservations[0])
                vmInfo = vmHandler.ExtractDescribeInstances(i)
        }</span>

        //if len(vmInfo.Region.Zone) &gt; 0 {
        //vmInfo.Region.Region = vmHandler.Region.Region
        //}

        <span class="cov0" title="0">cblogger.Info("vmInfo", vmInfo)
        return vmInfo, nil</span>
}

// DescribeInstances결과에서 EC2 세부 정보 추출
// VM 생성 시에는 Running 이전 상태의 정보가 넘어오기 때문에
// 최종 정보 기반으로 리턴 받고 싶으면 GetVM에 통합해야 할 듯.
func (vmHandler *AwsVMHandler) ExtractDescribeInstances(reservation *ec2.Reservation) irs.VMInfo <span class="cov0" title="0">{
        //cblogger.Info("ExtractDescribeInstances", reservation)
        cblogger.Info("Instances[0]", reservation.Instances[0])
        //spew.Dump(reservation.Instances[0])

        //"stopped" / "terminated" / "running" ...
        var state string
        state = *reservation.Instances[0].State.Name
        cblogger.Infof("EC2 상태 : [%s]", state)

        //VM상태와 무관하게 항상 값이 존재하는 항목들만 초기화
        vmInfo := irs.VMInfo{
                IId:        irs.IID{"", *reservation.Instances[0].InstanceId},
                ImageIId:   irs.IID{*reservation.Instances[0].ImageId, *reservation.Instances[0].ImageId},
                VMSpecName: *reservation.Instances[0].InstanceType,
                KeyPairIId: irs.IID{*reservation.Instances[0].KeyName, *reservation.Instances[0].KeyName},
                //GuestUserID:    "",
                //AdditionalInfo: "State:" + *reservation.Instances[0].State.Name,
        }

        keyValueList := []irs.KeyValue{
                {Key: "State", Value: *reservation.Instances[0].State.Name},
                {Key: "Architecture", Value: *reservation.Instances[0].Architecture},
        }

        //if *reservation.Instances[0].LaunchTime != "" {
        vmInfo.StartTime = *reservation.Instances[0].LaunchTime
        //}

        //cblogger.Info("=======&gt;타입 : ", reflect.TypeOf(*reservation.Instances[0]))
        //cblogger.Info("===&gt; PublicIpAddress TypeOf : ", reflect.TypeOf(reservation.Instances[0].PublicIpAddress))
        //cblogger.Info("===&gt; PublicIpAddress ValueOf : ", reflect.ValueOf(reservation.Instances[0].PublicIpAddress))

        //vmInfo.PublicIP = *reservation.Instances[0].NetworkInterfaces[0].Association.PublicIp
        //vmInfo.PublicDNS = *reservation.Instances[0].NetworkInterfaces[0].Association.PublicDnsName

        // 특정 항목(예:EIP)은 VM 상태와 무관하게 동작하므로 VM 상태와 무관하게 Nil처리로 모든 필드를 처리 함.
        if !reflect.ValueOf(reservation.Instances[0].PublicIpAddress).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PublicIP = *reservation.Instances[0].PublicIpAddress
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].PublicDnsName).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PublicDNS = *reservation.Instances[0].PublicDnsName
        }</span>

        <span class="cov0" title="0">cblogger.Info("===&gt; BlockDeviceMappings ValueOf : ", reflect.ValueOf(reservation.Instances[0].BlockDeviceMappings))
        if !reflect.ValueOf(reservation.Instances[0].BlockDeviceMappings).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(reservation.Instances[0].BlockDeviceMappings[0].DeviceName).IsNil() </span><span class="cov0" title="0">{
                        vmInfo.VMBlockDisk = *reservation.Instances[0].BlockDeviceMappings[0].DeviceName
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].Placement.AvailabilityZone).IsNil() </span><span class="cov0" title="0">{
                vmInfo.Region = irs.RegionInfo{
                        Region: vmHandler.Region.Region, //리전 정보 추가
                        Zone:   *reservation.Instances[0].Placement.AvailabilityZone,
                }
        }</span>

        //NetworkInterfaces 배열 값들
        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].VpcId).IsNil() </span><span class="cov0" title="0">{
                        //vmInfo.VirtualNetworkId = *reservation.Instances[0].NetworkInterfaces[0].VpcId
                        vmInfo.VpcIID = irs.IID{"", *reservation.Instances[0].NetworkInterfaces[0].VpcId}
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "VpcId", Value: *reservation.Instances[0].NetworkInterfaces[0].VpcId})
                }</span>

                <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].SubnetId).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SubnetId", Value: *reservation.Instances[0].NetworkInterfaces[0].SubnetId})
                        vmInfo.SubnetIID = irs.IID{SystemId: *reservation.Instances[0].NetworkInterfaces[0].SubnetId}
                }</span>

                <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].Attachment).IsNil() </span><span class="cov0" title="0">{
                        vmInfo.NetworkInterface = *reservation.Instances[0].NetworkInterfaces[0].Attachment.AttachmentId
                }</span>

                <span class="cov0" title="0">for _, security := range reservation.Instances[0].NetworkInterfaces[0].Groups </span><span class="cov0" title="0">{
                        //vmInfo.SecurityGroupIds = append(vmInfo.SecurityGroupIds, *security.GroupId)
                        vmInfo.SecurityGroupIIds = append(vmInfo.SecurityGroupIIds, irs.IID{*security.GroupName, *security.GroupId})
                }</span>

                /*
                        if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].Groups).IsNil() {
                                vmInfo.SecurityGroupIds = *reservation.Instances[0].NetworkInterfaces[0].Groups[0]
                                if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].Groups[0].GroupId).IsNil() {
                                        vmInfo.SecurityID = *reservation.Instances[0].NetworkInterfaces[0].Groups[0].GroupId
                                }
                        }
                */
        }

        //SecurityName: *reservation.Instances[0].NetworkInterfaces[0].Groups[0].GroupName,
        //vmInfo.VNIC = "eth0 - 값 위치 확인 필요"

        //vmInfo.PrivateIP = *reservation.Instances[0].NetworkInterfaces[0].PrivateIpAddress        //없는 경우 존재해서 Instances[0].PrivateIpAddress로 대체 - i-0b75cac73c4575386
        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].PrivateIpAddress).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PrivateIP = *reservation.Instances[0].PrivateIpAddress
        }</span>

        //vmInfo.PrivateDNS = *reservation.Instances[0].NetworkInterfaces[0].PrivateDnsName                //없는 경우 존재해서 Instances[0].PrivateDnsName로 대체 - i-0b75cac73c4575386
        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].PrivateDnsName).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PrivateDNS = *reservation.Instances[0].PrivateDnsName
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].RootDeviceName).IsNil() </span><span class="cov0" title="0">{
                vmInfo.VMBootDisk = *reservation.Instances[0].RootDeviceName
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].KeyName).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "KeyName", Value: *reservation.Instances[0].KeyName})
        }</span>

        //Name은 Tag의 "Name" 속성에만 저장됨
        <span class="cov0" title="0">cblogger.Debug("Name Tag 찾기")
        for _, t := range reservation.Instances[0].Tags </span><span class="cov0" title="0">{
                if *t.Key == "Name" </span><span class="cov0" title="0">{
                        vmInfo.IId.NameId = *t.Value
                        cblogger.Debug("EC2 명칭 : ", vmInfo.IId.NameId)
                        break</span>
                }
        }

        <span class="cov0" title="0">vmInfo.KeyValueList = keyValueList
        return vmInfo</span>
}

func ExtractVmName(Tags []*ec2.Tag) string <span class="cov0" title="0">{
        for _, t := range Tags </span><span class="cov0" title="0">{
                if *t.Key == "Name" </span><span class="cov0" title="0">{
                        cblogger.Info("  --&gt; EC2 명칭 : ", *t.Key)
                        return *t.Value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (vmHandler *AwsVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")
        var vmInfoList []*irs.VMInfo

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        nil,
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "",
                CloudOSAPI:   "ListVM()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success")

        //tmpVmName := ""
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                for _, vm := range i.Instances </span><span class="cov0" title="0">{
                        cblogger.Info("[%s] EC2 정보 조회", *vm.InstanceId)
                        /*
                                tmpVmName = ExtractVmName(vm.Tags)
                                if tmpVmName == "" {
                                        cblogger.Errorf("VM Id[%s]에 해당하는 VM 이름을 찾을 수 없습니다!!!", *vm.InstanceId)
                                        continue
                                }
                        */
                        //vmInfo, _ := vmHandler.GetVM(irs.IID{NameId: tmpVmName})
                        vmInfo, _ := vmHandler.GetVM(irs.IID{SystemId: *vm.InstanceId})
                        vmInfoList = append(vmInfoList, &amp;vmInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmInfoList, nil</span>
}

func ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "pending") </span><span class="cov0" title="0">{
                //resultStatus = "Creating"        // VM 생성 시점의 Pending은 CB에서는 조회가 안되기 때문에 일단 처리하지 않음.
                resultStatus = "Resuming" // Resume 요청을 받아서 재기동되는 단계에도 Pending이 있기 때문에 Pending은 Resuming으로 맵핑함.
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "running") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopping") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopped") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
                //} else if strings.EqualFold(vmStatus, "pending") {
                //        resultStatus = "Resuming"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Rebooting") </span><span class="cov0" title="0">{
                resultStatus = "Rebooting"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "shutting-down") </span><span class="cov0" title="0">{
                resultStatus = "Terminating"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Terminated") </span><span class="cov0" title="0">{
                resultStatus = "Terminated"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]와 일치하는 맵핑 정보를 찾지 못 함.", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "와 일치하는 CB VM 상태정보를 찾을 수 없습니다.")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM 상태 치환 : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

//SHUTTING-DOWN / TERMINATED
//func (vmHandler *AwsVMHandler) GetVMStatus(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
                vmID := vmInfo.IId.SystemId
        */

        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        //vmStatus := "pending"
        //return irs.VMStatus(vmStatus)

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success", result)
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                for _, vm := range i.Instances </span><span class="cov0" title="0">{
                        //vmStatus := strings.ToUpper(*vm.State.Name)
                        cblogger.Info(vmID, " EC2 Status : ", *vm.State.Name)
                        vmStatus, errStatus := ConvertVMStatusString(*vm.State.Name)
                        return vmStatus, errStatus
                        //return irs.VMStatus(vmStatus), nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VMStatus("Failed"), errors.New("상태 정보를 찾을 수 없습니다.")</span>
}

func (vmHandler *AwsVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")
        var vmStatusList []*irs.VMStatusInfo

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        nil,
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVMStatus()",
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success")

        tmpVmName := ""
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                for _, vm := range i.Instances </span><span class="cov0" title="0">{
                        //*vm.State.Name
                        //*vm.InstanceId

                        vmStatus, _ := ConvertVMStatusString(*vm.State.Name)
                        tmpVmName = ExtractVmName(vm.Tags)
                        /*
                                if tmpVmName == "" {
                                        cblogger.Errorf("VM Id[%s]에 해당하는 VM 이름을 찾을 수 없습니다!!!", *vm.InstanceId)
                                        //continue //2020-04-10 Name이 필수는 아니기 때문에 예외에서 제외 함.
                                }
                        */

                        vmStatusInfo := irs.VMStatusInfo{
                                //VmId:   *vm.InstanceId,
                                //VmName: tmpVmName,
                                IId: irs.IID{tmpVmName, *vm.InstanceId},
                                //VmStatus: vmHandler.GetVMStatus(*vm.InstanceId),
                                //VmStatus: irs.VMStatus(strings.ToUpper(*vm.State.Name)),
                                VmStatus: vmStatus,
                        }
                        cblogger.Info(vmStatusInfo.IId.SystemId, " EC2 Status : ", vmStatusInfo.VmStatus)
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

// AssociationId 대신 PublicIP로도 가능 함.
func (vmHandler *AwsVMHandler) AssociatePublicIP(allocationId string, instanceId string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("EC2에 퍼블릭 IP할당 - AllocationId : [%s], InstanceId : [%s]", allocationId, instanceId)

        // EC2에 할당.
        // Associate the new Elastic IP address with an existing EC2 instance.
        assocRes, err := vmHandler.Client.AssociateAddress(&amp;ec2.AssociateAddressInput{
                AllocationId: aws.String(allocationId),
                InstanceId:   aws.String(instanceId),
        })

        spew.Dump(assocRes)
        //cblogger.Infof("[%s] EC2에 EIP(AllocationId : [%s]) 할당 완료 - AssociationId Id : [%s]", instanceId, allocationId, *assocRes.AssociationId)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("Unable to associate IP address with %s, %v", instanceId, err)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Errorf(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Errorf(err.Error())
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">cblogger.Info(assocRes)
        return true, nil</span>
}

// 전달 받은 vNic을 VM에 추가함.
func (vmHandler *AwsVMHandler) AttachNetworkInterface(vNicId string, instanceId string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("EC2[%s] VM에 vNic[%s] 추가 시작", vNicId, instanceId)

        input := &amp;ec2.AttachNetworkInterfaceInput{
                DeviceIndex:        aws.Int64(1),
                InstanceId:         aws.String(instanceId),
                NetworkInterfaceId: aws.String(vNicId),
        }

        result, err := vmHandler.Client.AttachNetworkInterface(input)
        cblogger.Info(result)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("EC2[%s] VM에 vNic[%s] 추가 실패", vNicId, instanceId)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Errorf(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Errorf(err.Error())
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package resources

import (
        "errors"
        "reflect"
        "strconv"

        //sdk2 "github.com/aws/aws-sdk-go-v2"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

//https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.DescribeInstanceTypes
type AwsVmSpecHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

func ExtractGpuInfo(gpuDeviceInfo *ec2.GpuDeviceInfo) irs.GpuInfo <span class="cov0" title="0">{
        cblogger.Debug(gpuDeviceInfo)
        //cblogger.Info("================")
        //spew.Dump(gpuDeviceInfo)

        gpuInfo := irs.GpuInfo{
                Count: strconv.FormatInt(*gpuDeviceInfo.Count, 10),
                Mfr:   *gpuDeviceInfo.Manufacturer,
                Model: *gpuDeviceInfo.Name,
                Mem:   strconv.FormatInt(*gpuDeviceInfo.MemoryInfo.SizeInMiB, 10),
        }

        return gpuInfo
}</span>

//인스턴스 스펙 정보를 추출함
func ExtractVMSpecInfo(Region string, instanceTypeInfo *ec2.InstanceTypeInfo) irs.VMSpecInfo <span class="cov0" title="0">{
        cblogger.Debugf("ExtractVMSpecInfo : Region:[%s] / SpecName:[%s]", Region, *instanceTypeInfo.InstanceType)
        //spew.Dump(instanceTypeInfo)

        vCpuInfo := irs.VCpuInfo{}
        gpuInfoList := []irs.GpuInfo{}

        //리전 정보는 없기 때문에 조회한 리전 정보를 전달 받아서 처리함.
        vmSpecInfo := irs.VMSpecInfo{
                Region: Region,
        }

        //VCPU 정보 처리 - Count
        if !reflect.ValueOf(instanceTypeInfo.VCpuInfo.DefaultVCpus).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Count = strconv.FormatInt(*instanceTypeInfo.VCpuInfo.DefaultVCpus, 10)
        }</span>

        //VCPU 정보 처리 - Clock
        <span class="cov0" title="0">if !reflect.ValueOf(instanceTypeInfo.ProcessorInfo.SustainedClockSpeedInGhz).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Clock = strconv.FormatFloat(*instanceTypeInfo.ProcessorInfo.SustainedClockSpeedInGhz, 'f', 1, 64)
        }</span>
        <span class="cov0" title="0">vmSpecInfo.VCpu = vCpuInfo

        //GPU 정보가 있는 인스터스는 GPU 처리
        if !reflect.ValueOf(instanceTypeInfo.GpuInfo).IsNil() </span><span class="cov0" title="0">{
                for _, curGpu := range instanceTypeInfo.GpuInfo.Gpus </span><span class="cov0" title="0">{
                        cblogger.Debugf("[%s] Gpu 스펙 정보 조회", *curGpu.Name)
                        gpuInfo := ExtractGpuInfo(curGpu)
                        gpuInfoList = append(gpuInfoList, gpuInfo)
                }</span>
                //spew.Dump(gpuInfoList)
        }
        <span class="cov0" title="0">vmSpecInfo.Gpu = gpuInfoList

        if !reflect.ValueOf(instanceTypeInfo.InstanceType).IsNil() </span><span class="cov0" title="0">{
                vmSpecInfo.Name = *instanceTypeInfo.InstanceType
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(instanceTypeInfo.MemoryInfo.SizeInMiB).IsNil() </span><span class="cov0" title="0">{
                vmSpecInfo.Mem = strconv.FormatInt(*instanceTypeInfo.MemoryInfo.SizeInMiB, 10)
        }</span>

        //KeyValue 목록 처리
        <span class="cov0" title="0">keyValueList, errKeyValue := ConvertKeyValueList(instanceTypeInfo)
        if errKeyValue != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%]의 KeyValue 추출 실패", *instanceTypeInfo.InstanceType)
                cblogger.Error(errKeyValue)
        }</span>
        /*
                if errKeyValue != nil {
                        return irs.VMSpecInfo{}, errKeyValue
                }
        */
        <span class="cov0" title="0">vmSpecInfo.KeyValueList = keyValueList

        return vmSpecInfo</span>
}

//해당 Zone의 스펙 ID 목록을 조회함.
func (vmSpecHandler *AwsVmSpecHandler) ListVMSpecAZ(ZoneName string) (map[string]string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListVMSpecAZ(ZoneName:[%s])", ZoneName)
        if ZoneName == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return nil, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">var mapVmSpecIds map[string]string
        mapVmSpecIds = make(map[string]string)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstanceTypeOfferings.html
        input := &amp;ec2.DescribeInstanceTypeOfferingsInput{
                //[]*string
                LocationType: aws.String("availability-zone"),
                Filters: []*ec2.Filter{
                        {
                                Name:   aws.String("location"),
                                Values: aws.StringSlice([]string{ZoneName}),
                        },
                },
                MaxResults: aws.Int64(1000), //5~1000
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "ListVMSpecAZ()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        pageNum := 0
        totCnt := 0
        err := vmSpecHandler.Client.DescribeInstanceTypeOfferingsPages(input,
                func(page *ec2.DescribeInstanceTypeOfferingsOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        pageNum++
                        //fmt.Println(page)
                        cblogger.Infof("PageNum : [%d] / Count : [%d] / lastPage : [%v]", pageNum, len(page.InstanceTypeOfferings), lastPage)
                        //totCnt = totCnt + len(page.InstanceTypeOfferings)

                        for _, specInfo := range page.InstanceTypeOfferings </span><span class="cov0" title="0">{
                                totCnt++
                                //cblogger.Infof("===&gt; [%s]", *specInfo.InstanceType)
                                mapVmSpecIds[*specInfo.InstanceType] = ""
                        }</span>
                        <span class="cov0" title="0">return !lastPage</span>
                })
        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("===&gt; Total Check AZ Spec Count : [%d]", totCnt)
        //spew.Dump(mapVmSpecIds)

        return mapVmSpecIds, nil</span>
}

func (vmSpecHandler *AwsVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListVMSpec(Region:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        cblogger.Infof("Request Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return nil, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">mapVmSpecIds, errListVMSpecAZ := vmSpecHandler.ListVMSpecAZ(zoneId)
        if errListVMSpecAZ != nil </span><span class="cov0" title="0">{
                cblogger.Error(errListVMSpecAZ)
                return nil, errListVMSpecAZ
        }</span>

        <span class="cov0" title="0">var vMSpecInfoList []*irs.VMSpecInfo
        input := &amp;ec2.DescribeInstanceTypesInput{
                //MaxResults: aws.Int64(5),
        }

        /*
                req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
                err := req.Send()
                if err != nil { // resp is now filled
                        cblogger.Errorf("Unable to get ListVMSpec - %v", err)
                        return vMSpecInfoList, err
                }
        */

        //cblogger.Info(resp)
        //fmt.Println(resp)

        //ExtractVMSpecInfo(Region, resp.InstanceTypes[0])
        //var vMSpecInfoList []*irs.VMSpecInfo
        /*
                for _, curInstance := range resp.InstanceTypes {
                        cblogger.Infof("[%s] VM 스펙 정보 조회", *curInstance.InstanceType)

                        _, exists := mapVmSpecIds[*curInstance.InstanceType]
                        if !exists {
                                cblogger.Infof("[%s] 스펙은 [%s] Zone에서 사용할 수 없습니다.", *curInstance.InstanceType, zoneId)
                                continue
                        }

                        //vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                        //vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)
                }
        */

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "ListVMSpec()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        pageNum := 0
        totCnt := 0
        err := vmSpecHandler.Client.DescribeInstanceTypesPages(input,
                func(page *ec2.DescribeInstanceTypesOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        pageNum++
                        //fmt.Println(page)
                        cblogger.Infof("PageNum : [%d] / Count : [%d] / isLastPage : [%v]", pageNum, len(page.InstanceTypes), lastPage)
                        //totCnt = totCnt + len(page.InstanceTypes)

                        for _, curInstance := range page.InstanceTypes </span><span class="cov0" title="0">{
                                totCnt++
                                //cblogger.Infof("[%d]번째 [%s] VM 스펙 정보 조회", totCnt, *curInstance.InstanceType)

                                _, exists := mapVmSpecIds[*curInstance.InstanceType]
                                if !exists </span><span class="cov0" title="0">{
                                        cblogger.Debugf("[%s] 스펙은 [%s] Zone에서 지원되지 않습니다.", *curInstance.InstanceType, zoneId)
                                        continue</span>
                                }

                                <span class="cov0" title="0">vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                                vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)</span>
                        }

                        <span class="cov0" title="0">return !lastPage</span>
                })

        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return vMSpecInfoList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        //spew.Dump(vMSpecInfoList)

        //cblogger.Infof("===&gt; Total Check Spec Count : [%d]", totCnt)
        cblogger.Infof("==&gt;[%s] AZ에서는 [%s]리전의 [%d] 스펙 중 [%d]개의 스펙을 사용할 수 있음.", zoneId, Region, totCnt, len(vMSpecInfoList))

        return vMSpecInfoList, nil</span>
}

func (vmSpecHandler *AwsVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetVMSpec(Region:[%s], Name:[%s])", Region, Name)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstanceTypes.html
        input := &amp;ec2.DescribeInstanceTypesInput{
                //[]*string
                InstanceTypes: []*string{
                        aws.String(Name),
                },
        }

        //svc := ec2.New(&amp;sess)
        //svc := ec2.New(&amp;vmSpecHandler.Client, aws.NewConfig().WithRegion("us-west-2"))
        //req, resp := svc.DescribeInstanceTypesRequest(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypesRequest()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Example sending a request using the DescribeInstanceTypesRequest method.
        req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
        err := req.Send()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Info(resp)
        //fmt.Println(resp)
        if len(resp.InstanceTypes) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMSpecInfo{}, errors.New(Name + "에 해당하는 Spec 정보를 찾을 수 없습니다.")
        }</span>

        <span class="cov0" title="0">vMSpecInfo := ExtractVMSpecInfo(Region, resp.InstanceTypes[0])

        /*
                //KeyValue 목록 처리
                keyValueList, errKeyValue := ConvertKeyValueList(resp.InstanceTypes[0])
                if errKeyValue != nil {
                        return irs.VMSpecInfo{}, errKeyValue
                }
                vMSpecInfo.KeyValueList = keyValueList
        */

        return vMSpecInfo, nil</span>
}

// AWS의 정보 그대로를 가공 없이 JSON으로 리턴 함.
func (vmSpecHandler *AwsVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListOrgVMSpec(Region:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return "", errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">mapVmSpecIds, errListVMSpecAZ := vmSpecHandler.ListVMSpecAZ(zoneId)
        if errListVMSpecAZ != nil </span><span class="cov0" title="0">{
                cblogger.Error(errListVMSpecAZ)
                return "", errListVMSpecAZ
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.DescribeInstanceTypesInput{
                //MaxResults: aws.Int64(5),
        }

        /*
                req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
                err := req.Send()
                if err != nil { // resp is now filled
                        cblogger.Errorf("Unable to get ListOrgVMSpec - %v", err)
                        return "", err
                }
        */

        //cblogger.Info(resp)
        //fmt.Println(resp)

        //var resp *ec2.DescribeInstanceTypesOutput

        /*
                resp := *ec2.DescribeInstanceTypesOutput{
                        InstanceTypes: &amp;[]ec2.InstanceTypeInfo{{}},
                }
        */

        resp := new(ec2.DescribeInstanceTypesOutput)

        pageNum := 0
        totCnt := 0
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "ListOrgVMSpec()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        err := vmSpecHandler.Client.DescribeInstanceTypesPages(input,
                func(page *ec2.DescribeInstanceTypesOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        pageNum++
                        //fmt.Println(page)
                        cblogger.Infof("PageNum : [%d] / Count : [%d] / isLastPage : [%v]", pageNum, len(page.InstanceTypes), lastPage)
                        //totCnt = totCnt + len(page.InstanceTypes)

                        for _, curInstance := range page.InstanceTypes </span><span class="cov0" title="0">{
                                totCnt++
                                //cblogger.Infof("[%d]번째 [%s] VM 스펙 정보 조회", totCnt, *curInstance.InstanceType)

                                _, exists := mapVmSpecIds[*curInstance.InstanceType]
                                if !exists </span><span class="cov0" title="0">{
                                        cblogger.Debugf("[%s] 스펙은 [%s] Zone에서 지원되지 않습니다.", *curInstance.InstanceType, zoneId)
                                        continue</span>
                                }

                                //vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                                //vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)
                                <span class="cov0" title="0">resp.InstanceTypes = append(resp.InstanceTypes, curInstance)</span>
                        }

                        <span class="cov0" title="0">return !lastPage</span>
                })

        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        //spew.Dump(vMSpecInfoList)

        cblogger.Infof("==&gt;[%s] AZ에서는 [%s]리전의 [%d] 스펙 중 [%d]개의 스펙을 사용할 수 있음.", zoneId, Region, totCnt, len(resp.InstanceTypes))

        //jsonString, errJson := ConvertJsonString(resp.InstanceTypes[0])
        jsonString, errJson := ConvertJsonString(resp)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}

// AWS의 정보 그대로를 가공 없이 JSON으로 리턴 함.
func (vmSpecHandler *AwsVmSpecHandler) ListOrgVMSpecOld(Region string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListOrgVMSpec(Region:[%s])", Region)

        input := &amp;ec2.DescribeInstanceTypesInput{
                //MaxResults: aws.Int64(5),
        }

        req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
        err := req.Send()
        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                cblogger.Errorf("Unable to get ListOrgVMSpec - %v", err)
                return "", err
        }</span>

        //cblogger.Info(resp)
        //fmt.Println(resp)

        //00, errJson := ConvertJsonString(resp.InstanceTypes[0])
        <span class="cov0" title="0">jsonString, errJson := ConvertJsonString(resp)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}

// AWS의 정보 그대로를 가공 없이 JSON으로 리턴 함.
func (vmSpecHandler *AwsVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetOrgVMSpec(Region:[%s], Name:[%s])", Region, Name)

        input := &amp;ec2.DescribeInstanceTypesInput{
                InstanceTypes: []*string{
                        aws.String(Name),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypesRequest()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
        err := req.Send()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Info(resp)
        //fmt.Println(resp)
        if len(resp.InstanceTypes) &lt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(Name + "에 해당하는 Spec 정보를 찾을 수 없습니다.")
        }</span>

        <span class="cov0" title="0">jsonString, errJson := ConvertJsonString(resp.InstanceTypes[0])
        //jsonString, errJson := ConvertJsonStringNoEscape(resp.InstanceTypes[0])

        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr

package resources

import (
        "errors"
        "reflect"
        "strconv"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AwsVPCHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

func (VPCHandler *AwsVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.VPCInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.CreateVpcInput{
                CidrBlock: aws.String(vpcReqInfo.IPv4_CIDR),
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        retVpcInfo := ExtractVpcDescribeInfo(result.Vpc)
        retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId // NameId는 요청 받은 값으로 리턴해야 함.

        //IGW Name Tag 설정
        if SetNameTag(VPCHandler.Client, *result.Vpc.VpcId, vpcReqInfo.IId.NameId) </span><span class="cov0" title="0">{
                cblogger.Infof("VPC에 %s Name 설정 성공", vpcReqInfo.IId.NameId)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Errorf("VPC에 %s Name 설정 실패", vpcReqInfo.IId.NameId)
        }</span>

        //====================================
        // PublicIP 할당을 위해 IGW 생성및 연결
        //====================================
        //IGW 생성
        <span class="cov0" title="0">resultIGW, errIGW := VPCHandler.Client.CreateInternetGateway(&amp;ec2.CreateInternetGatewayInput{})
        if errIGW != nil </span><span class="cov0" title="0">{
                if aerr, ok := errIGW.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGW.Error())
                }</span>
                <span class="cov0" title="0">return retVpcInfo, errIGW</span>
        }

        <span class="cov0" title="0">cblogger.Info(resultIGW)

        //IGW Name Tag 설정
        if SetNameTag(VPCHandler.Client, *resultIGW.InternetGateway.InternetGatewayId, vpcReqInfo.IId.NameId) </span><span class="cov0" title="0">{
                cblogger.Infof("IGW에 %s Name 설정 성공", vpcReqInfo.IId.NameId)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Errorf("IGW에 %s Name 설정 실패", vpcReqInfo.IId.NameId)
        }</span>

        // VPC에 IGW연결
        <span class="cov0" title="0">inputIGW := &amp;ec2.AttachInternetGatewayInput{
                InternetGatewayId: aws.String(*resultIGW.InternetGateway.InternetGatewayId),
                VpcId:             aws.String(retVpcInfo.IId.SystemId),
        }

        resultIGWAttach, errIGWAttach := VPCHandler.Client.AttachInternetGateway(inputIGW)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := errIGWAttach.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGWAttach.Error())
                }</span>
                <span class="cov0" title="0">return retVpcInfo, errIGWAttach</span>
        }

        <span class="cov0" title="0">cblogger.Info(resultIGWAttach)

        // 생성된 VPC의 기본 라우팅 테이블에 IGW 라우팅 정보 추가
        errRoute := VPCHandler.CreateRouteIGW(retVpcInfo.IId.SystemId, *resultIGW.InternetGateway.InternetGatewayId)
        if errRoute != nil </span><span class="cov0" title="0">{
                return retVpcInfo, errRoute
        }</span>

        //==========================
        // Subnet 생성
        //==========================
        //VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, vpcReqInfo.SubnetInfoList[0])
        <span class="cov0" title="0">var resSubnetList []irs.SubnetInfo
        for _, curSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet 생성", curSubnet.IId.NameId)
                cblogger.Infof("Reqt Subnet Info [%v]", curSubnet)
                resSubnet, errSubnet := VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, curSubnet)

                if errSubnet != nil </span><span class="cov0" title="0">{
                        return retVpcInfo, errSubnet
                }</span>
                <span class="cov0" title="0">resSubnetList = append(resSubnetList, resSubnet)</span>
        }
        <span class="cov0" title="0">retVpcInfo.SubnetInfoList = resSubnetList
        return retVpcInfo, nil</span>
}

// 생성된 VPC의 라우팅 테이블에 IGW(Internet Gateway) 라우팅 정보를 생성함 (AWS 콘솔의 라우팅 테이블의 [라우팅] Tab 처리)
func (VPCHandler *AwsVPCHandler) CreateRouteIGW(vpcId string, igwId string) error <span class="cov0" title="0">{
        cblogger.Infof("VPC ID : [%s] / IGW ID : [%s]", vpcId, igwId)
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil </span><span class="cov0" title="0">{
                return errRoute
        }</span>

        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s]에 IGW[%s]에 대한 라우팅(0.0.0.0/0) 정보를 추가 합니다.", routeTableId, igwId)
        input := &amp;ec2.CreateRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                GatewayId:            aws.String(igwId),
                RouteTableId:         aws.String(routeTableId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: igwId,
                CloudOSAPI:   "CreateRoute()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateRoute(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("RouteTable[%s]에 IGW[%s]에 대한 라우팅(0.0.0.0/0) 정보 추가 실패", routeTableId, igwId)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return err</span>
        }
        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s]에 IGW[%s]에 대한 라우팅(0.0.0.0/0) 정보를 추가 완료", routeTableId, igwId)
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return nil</span>
}

//https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Route_Tables.html
//https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html
// 자동 생성된 VPC의 기본 라우팅 테이블 정보를 찾음
func (VPCHandler *AwsVPCHandler) GetDefaultRouteTable(vpcId string) (string, error) <span class="cov0" title="0">{
        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &gt; 0 </span><span class="cov0" title="0">{
                routeTableId := *result.RouteTables[0].RouteTableId
                cblogger.Infof("라우팅 테이블 ID 찾음 : [%s]", routeTableId)
                return routeTableId, nil
        }</span> else<span class="cov0" title="0"> {
                return "", errors.New("VPC에 할당된 라우팅 테이블 ID를 찾을 수 없습니다.")
        }</span>
}

func (VPCHandler *AwsVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Info(reqSubnetInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.SubnetInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">if reqSubnetInfo.IId.SystemId != "" </span><span class="cov0" title="0">{
                vpcInfo, errVpcInfo := VPCHandler.GetSubnet(reqSubnetInfo.IId.SystemId)
                if errVpcInfo == nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("이미 [%S] Subnet이 존재하기 때문에 생성하지 않고 기존 정보와 함께 에러를 리턴함.", reqSubnetInfo.IId.SystemId)
                        cblogger.Info(vpcInfo)
                        return vpcInfo, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + reqSubnetInfo.IId.SystemId + "' already exists.")
                }</span>
        }

        //서브넷 생성
        <span class="cov0" title="0">input := &amp;ec2.CreateSubnetInput{
                CidrBlock: aws.String(reqSubnetInfo.IPv4_CIDR),
                VpcId:     aws.String(vpcId),
                //AvailabilityZoneId: aws.String(zoneId),        //use1-az1, use1-az2, use1-az3, use1-az4, use1-az5, use1-az6
                AvailabilityZone: aws.String(zoneId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        cblogger.Info(input)
        result, err := VPCHandler.Client.CreateSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)

        //vNetworkInfo := irs.VNetworkInfo{}
        vNetworkInfo := ExtractSubnetDescribeInfo(result.Subnet)

        //Subnet Name 태깅
        if SetNameTag(VPCHandler.Client, *result.Subnet.SubnetId, reqSubnetInfo.IId.NameId) </span><span class="cov0" title="0">{
                cblogger.Infof("Subnet에 %s Name 설정 성공", reqSubnetInfo.IId.NameId)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Errorf("Subnet에 %s Name 설정 실패", reqSubnetInfo.IId.NameId)
        }</span>

        <span class="cov0" title="0">vNetworkInfo.IId.NameId = reqSubnetInfo.IId.NameId

        // VPC의 라우팅 테이블에 생성된 Subnet 정보를 추가 함.
        errSubnetRoute := VPCHandler.AssociateRouteTable(vpcId, vNetworkInfo.IId.SystemId)
        if errSubnetRoute != nil </span>{<span class="cov0" title="0">
        }</span> else<span class="cov0" title="0"> {
                return vNetworkInfo, errSubnetRoute
        }</span>

        <span class="cov0" title="0">return vNetworkInfo, nil</span>
}

// VPC의 라우팅 테이블에 생성된 Subnet을 연결 함.
func (VPCHandler *AwsVPCHandler) AssociateRouteTable(vpcId string, subnetId string) error <span class="cov0" title="0">{
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil </span><span class="cov0" title="0">{
                return errRoute
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.AssociateRouteTableInput{
                RouteTableId: aws.String(routeTableId),
                SubnetId:     aws.String(subnetId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetId,
                CloudOSAPI:   "AssociateRouteTable()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.AssociateRouteTable(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return err</span>
        }

        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)
        return nil</span>
}

func (VPCHandler *AwsVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(&amp;ec2.DescribeVpcsInput{})
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vNetworkInfoList []*irs.VPCInfo
        for _, curVpc := range result.Vpcs </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VPC 정보 조회", *curVpc.VpcId)
                vNetworkInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: *curVpc.VpcId})
                if vpcErr != nil </span><span class="cov0" title="0">{
                        return nil, vpcErr
                }</span>
                <span class="cov0" title="0">vNetworkInfoList = append(vNetworkInfoList, &amp;vNetworkInfo)</span>
        }

        <span class="cov0" title="0">spew.Dump(vNetworkInfoList)
        return vNetworkInfoList, nil</span>
}

func (VPCHandler *AwsVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        input := &amp;ec2.DescribeVpcsInput{
                VpcIds: []*string{
                        aws.String(vpcIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        //spew.Dump(result)

        if reflect.ValueOf(result.Vpcs).IsNil() </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, nil
        }</span>

        <span class="cov0" title="0">var errSubnet error
        awsVpcInfo := ExtractVpcDescribeInfo(result.Vpcs[0])
        awsVpcInfo.SubnetInfoList, errSubnet = VPCHandler.ListSubnet(vpcIID.SystemId)
        if errSubnet != nil </span><span class="cov0" title="0">{
                return awsVpcInfo, errSubnet
        }</span>

        <span class="cov0" title="0">return awsVpcInfo, nil</span>
}

/*
type VPCInfo struct {
        IId   IID       // {NameId, SystemId}
        IPv4_CIDR string
        SubnetInfoList []SubnetInfo

        KeyValueList []KeyValue
}
*/
//VPC 정보를 추출함
func ExtractVpcDescribeInfo(vpcInfo *ec2.Vpc) irs.VPCInfo <span class="cov0" title="0">{
        awsVpcInfo := irs.VPCInfo{
                IId:       irs.IID{SystemId: *vpcInfo.VpcId},
                IPv4_CIDR: *vpcInfo.CidrBlock,
                //IsDefault: *vpcInfo.IsDefault,
                //State:     *vpcInfo.State,
        }

        //Name은 Tag의 "Name" 속성에만 저장됨
        //NameId는 전달할 필요가 없음.
        /*
                cblogger.Debug("Name Tag 찾기")
                for _, t := range vpcInfo.Tags {
                        if *t.Key == "Name" {
                                awsVpcInfo.IId.NameId = *t.Value
                                cblogger.Debug("VPC Name : ", awsVpcInfo.IId.NameId)
                                break
                        }
                }
        */
        return awsVpcInfo
}</span>

func (VPCHandler *AwsVPCHandler) DeleteSubnet(subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        input := &amp;ec2.DeleteSubnetInput{
                SubnetId: aws.String(subnetIID.SystemId),
        }
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "DeleteSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        _, err := VPCHandler.Client.DeleteSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        cblogger.Info(err)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return false, err</span>
        }

        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return true, nil</span>
}

func (VPCHandler *AwsVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                return false, errVpcInfo
        }</span>

        //=================
        // Subnet삭제
        //=================
        <span class="cov0" title="0">for _, curSubnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet 삭제", curSubnet.IId.SystemId)
                delSubnet, errSubnet := VPCHandler.DeleteSubnet(curSubnet.IId)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        return false, errSubnet
                }</span>

                <span class="cov0" title="0">if delSubnet </span><span class="cov0" title="0">{
                        cblogger.Infof("  ==&gt; [%s] Subnet 삭제완료", curSubnet.IId.SystemId)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Errorf("  ==&gt; [%s] Subnet 삭제실패", curSubnet.IId.SystemId)
                        return false, errors.New("Subnet 삭제 실패로 VPC를 삭제하지 못 했습니다.") //삭제 실패 이유를 모르는 경우
                }</span>
        }

        <span class="cov0" title="0">cblogger.Infof("[%s] VPC를 삭제 함.", vpcInfo.IId.SystemId)
        cblogger.Info("VPC 제거를 위해 생성된 IGW / Route들 제거 시작")

        // 라우팅 테이블에 추가한 IGW 라우터를 먼저 삭제함.
        errRoute := VPCHandler.DeleteRouteIGW(vpcInfo.IId.SystemId)
        if errRoute != nil </span><span class="cov0" title="0">{
                cblogger.Error("라우팅 테이블에 추가한 0.0.0.0/0 IGW 라우터 삭제 실패")
                cblogger.Error(errRoute)
                if "InvalidRoute.NotFound" == errRoute.Error() </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s]예외는 #255예외에 의해 정상으로 간주하고 다음 단계를 진행함.", errRoute)
                }</span> else<span class="cov0" title="0"> {
                        return false, errRoute
                }</span>
                //} else {
                //        cblogger.Info("라우팅 테이블에 추가한 0.0.0.0/0 IGW 라우터 삭제 완료")
        }

        //VPC에 연결된 모든 IGW를 삭제함. (VPC에 할당된 모든 IGW조회후 삭제)
        <span class="cov0" title="0">errIgw := VPCHandler.DeleteAllIGW(vpcInfo.IId.SystemId)
        if errIgw != nil </span><span class="cov0" title="0">{
                cblogger.Error("모든 IGW 삭제 실패 : ", errIgw)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Info("모든 IGW 삭제 완료")
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.DeleteVpcInput{
                VpcId: aws.String(vpcInfo.IId.SystemId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcInfo.IId.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DeleteVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return false, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return true, nil</span>
}

/*
// VPC에 설정된 0.0.0.0/0 라우터를 제거 함.
func (VPCHandler *AwsVPCHandler) DeleteRouteIGWOld(vpcId string) error {
        cblogger.Infof("VPC ID : [%s]", vpcId)
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil {
                return errRoute
        }

        cblogger.Infof("RouteTable[%s]에 할당된 라우팅(0.0.0.0/0) 정보를 삭제합니다.", routeTableId)
        input := &amp;ec2.DeleteRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                RouteTableId:         aws.String(routeTableId),
        }
        cblogger.Info(input)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteRoute.html
        result, err := VPCHandler.Client.DeleteRoute(input)
        if err != nil {
                cblogger.Errorf("RouteTable[%s]에 대한 라우팅(0.0.0.0/0) 정보 삭제 실패", routeTableId)
                if aerr, ok := err.(awserr.Error); ok {
                        //InvalidRoute.NotFound
                        cblogger.Errorf("Error Code : [%s] - Error:[%s] - Message:[%s]", aerr.Code(), aerr.Error(), aerr.Message())
                        switch aerr.Code() {
                        case "InvalidRoute.NotFound": //NotFound에러는 무시하라고 해서 (예외#255)
                                return errors.New(aerr.Code())
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }
        cblogger.Infof("RouteTable[%s]에 대한 라우팅(0.0.0.0/0) 정보 삭제 완료", routeTableId)

        cblogger.Info(result)
        spew.Dump(result)
        cblogger.Info("라우팅 테이블에 추가한 0.0.0.0/0 IGW 라우터 삭제 완료")
        return nil
}
*/

// VPC에 설정된 0.0.0.0/0 라우터를 제거 함.
// #255예외 처리 보완에 따른 라우팅 정보 삭제전 0.0.0.0 조회후 삭제하도록 로직 변경
func (VPCHandler *AwsVPCHandler) DeleteRouteIGW(vpcId string) error <span class="cov0" title="0">{
        cblogger.Infof("VPC ID : [%s]", vpcId)
        routeTableId := ""

        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &lt; 1 </span><span class="cov0" title="0">{
                return errors.New("VPC에 할당된 라우팅 테이블 정보를 찾을 수 없습니다.")
        }</span>

        <span class="cov0" title="0">routeTableId = *result.RouteTables[0].RouteTableId
        cblogger.Infof("라우팅 테이블 ID 찾음 : [%s]", routeTableId)

        cblogger.Infof("RouteTable[%s]에 할당된 라우팅(0.0.0.0/0) 정보를 조회합니다.", routeTableId)

        //ec2.Route
        findIgw := false
        for _, curRoute := range result.RouteTables[0].Routes </span><span class="cov0" title="0">{
                cblogger.Infof("DestinationCidrBlock[%s] Check", *curRoute.DestinationCidrBlock)

                if "0.0.0.0/0" == *curRoute.DestinationCidrBlock </span><span class="cov0" title="0">{
                        cblogger.Infof("===&gt;RouteTable[%s]에 할당된 라우팅(0.0.0.0/0) 정보를 찾았습니다!!", routeTableId)
                        findIgw = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !findIgw </span><span class="cov0" title="0">{
                cblogger.Infof("RouteTable[%s]에 할당된 IGW의 라우팅(0.0.0.0/0) 정보가 없으므로 라우트 삭제처리는 중단합니다. ", routeTableId)
                return nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s]에 할당된 라우팅(0.0.0.0/0) 정보를 삭제합니다.", routeTableId)
        inputDel := &amp;ec2.DeleteRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                RouteTableId:         aws.String(routeTableId),
        }
        cblogger.Info(inputDel)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteRoute.html
        resultDel, err := VPCHandler.Client.DeleteRoute(inputDel)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("RouteTable[%s]에 대한 라우팅(0.0.0.0/0) 정보 삭제 실패", routeTableId)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        //InvalidRoute.NotFound
                        cblogger.Errorf("Error Code : [%s] - Error:[%s] - Message:[%s]", aerr.Code(), aerr.Error(), aerr.Message())
                        switch aerr.Code() </span>{
                        case "InvalidRoute.NotFound":<span class="cov0" title="0"> //NotFound에러는 무시하라고 해서 (예외#255)
                                return errors.New(aerr.Code())</span>
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s]에 대한 라우팅(0.0.0.0/0) 정보 삭제 완료", routeTableId)

        cblogger.Info(resultDel)
        spew.Dump(resultDel)
        cblogger.Info("라우팅 테이블에 추가한 0.0.0.0/0 IGW 라우터 삭제 완료")
        return nil</span>
}

//VPC에 연결된 모든 IGW를 삭제함.
func (VPCHandler *AwsVPCHandler) DeleteAllIGW(vpcId string) error <span class="cov0" title="0">{
        input := &amp;ec2.DescribeInternetGatewaysInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("attachment.vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeInternetGateways(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)

        // VPC 삭제를 위해 연결된 모든 IGW 제거
        // 일단, 에러는 무시함.
        for _, curIgw := range result.InternetGateways </span><span class="cov0" title="0">{
                //IGW 삭제전 연결된 IGW의 연결을 끊어야함.
                VPCHandler.DetachInternetGateway(vpcId, *curIgw.InternetGatewayId)
                //IGW 삭제
                VPCHandler.DeleteIGW(*curIgw.InternetGatewayId)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// VPC에 연결된 IGW의 연결을 해제함.
func (VPCHandler *AwsVPCHandler) DetachInternetGateway(vpcId string, igwId string) error <span class="cov0" title="0">{
        cblogger.Infof("VPC[%s]에 연결된 IGW[%s]의 연결을 해제함.", vpcId, igwId)

        input := &amp;ec2.DetachInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
                VpcId:             aws.String(vpcId),
        }

        result, err := VPCHandler.Client.DetachInternetGateway(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)
        return nil</span>
}

// IGW를 삭제 함.
func (VPCHandler *AwsVPCHandler) DeleteIGW(igwId string) error <span class="cov0" title="0">{
        input := &amp;ec2.DeleteInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
        }

        result, err := VPCHandler.Client.DeleteInternetGateway(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)
        return nil</span>
}

//VPC의 하위 서브넷 목록을 조회함.
func (VPCHandler *AwsVPCHandler) ListSubnet(vpcId string) ([]irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        var arrSubnetInfoList []irs.SubnetInfo

        input := &amp;ec2.DescribeSubnetsInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListSubnet",
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //spew.Dump(input)
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        spew.Dump(result)
        for _, curSubnet := range result.Subnets </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet 정보 조회", *curSubnet.SubnetId)
                arrSubnetInfo := ExtractSubnetDescribeInfo(curSubnet)
                //arrSubnetInfo, errSubnet := VPCHandler.GetSubnet(*curSubnet.SubnetId)
                /*
                        if errSubnet != nil {
                                return nil, errSubnet
                        }
                */
                //arrSubnetInfoList = append(arrSubnetInfoList, arrSubnetInfo)
                arrSubnetInfoList = append(arrSubnetInfoList, arrSubnetInfo)
        }</span>

        <span class="cov0" title="0">spew.Dump(arrSubnetInfoList)
        return arrSubnetInfoList, nil</span>
}

func (VPCHandler *AwsVPCHandler) GetSubnet(reqSubnetId string) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("SubnetId : [%s]", reqSubnetId)

        input := &amp;ec2.DescribeSubnetsInput{
                SubnetIds: []*string{
                        aws.String(reqSubnetId),
                },
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetId,
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if !reflect.ValueOf(result.Subnets).IsNil() </span><span class="cov0" title="0">{
                retSubnetInfo := ExtractSubnetDescribeInfo(result.Subnets[0])
                return retSubnetInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.SubnetInfo{}, errors.New("InvalidSubnet.NotFound: The CBVnetwork '" + reqSubnetId + "' does not exist")
        }</span>
}

/*
    IId        IID
    IPv4_CIDR    string
        KeyValueList    []KeyValue
*/

//Subnet 정보를 추출함
func ExtractSubnetDescribeInfo(subnetInfo *ec2.Subnet) irs.SubnetInfo <span class="cov0" title="0">{
        vNetworkInfo := irs.SubnetInfo{
                IId:       irs.IID{SystemId: *subnetInfo.SubnetId},
                IPv4_CIDR: *subnetInfo.CidrBlock,
                //Status:    *subnetInfo.State,
        }

        /*
                cblogger.Debug("Name Tag 찾기")
                for _, t := range subnetInfo.Tags {
                        if *t.Key == "Name" {
                                vNetworkInfo.IId.NameId = *t.Value
                                cblogger.Debug("Subnet Name : ", vNetworkInfo.IId.NameId)
                                break
                        }
                }
        */

        keyValueList := []irs.KeyValue{
                {Key: "VpcId", Value: *subnetInfo.VpcId},
                {Key: "MapPublicIpOnLaunch", Value: strconv.FormatBool(*subnetInfo.MapPublicIpOnLaunch)},
                {Key: "AvailableIpAddressCount", Value: strconv.FormatInt(*subnetInfo.AvailableIpAddressCount, 10)},
                {Key: "AvailabilityZone", Value: *subnetInfo.AvailabilityZone},
                {Key: "Status", Value: *subnetInfo.State},
        }
        vNetworkInfo.KeyValueList = keyValueList

        return vNetworkInfo
}</span>

func (VPCHandler *AwsVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet 추가 - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>
        <span class="cov0" title="0">cblogger.Info(resSubnet)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, errVpcInfo
        }</span>

        <span class="cov0" title="0">findSubnet := false
        cblogger.Debug("============== 체크할 값 =========")
        for posSubnet, curSubnetInfo := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Debugf("%d - [%s] Subnet 처리 시작", posSubnet, curSubnetInfo.IId.SystemId)
                if resSubnet.IId.SystemId == curSubnetInfo.IId.SystemId </span><span class="cov0" title="0">{
                        cblogger.Infof("추가 요청 받은 [%s] Subnet을 발견 했습니다. - SystemID:[%s]", subnetInfo.IId.NameId, curSubnetInfo.IId.SystemId)
                        //for ~ range는 포인터가 아니라서 값 수정이 안됨. for loop으로 직접 서브넷을 체크하거나 vpcInfo의 배열의 값을 수정해야 함.
                        cblogger.Infof("인덱스 위치 : %d", posSubnet)
                        //vpcInfo.SubnetInfoList[posSubnet].IId.NameId = "테스트~"
                        vpcInfo.SubnetInfoList[posSubnet].IId.NameId = subnetInfo.IId.NameId
                        findSubnet = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !findSubnet </span><span class="cov0" title="0">{
                cblogger.Errorf("서브넷 생성은 성공했으나 VPC의 서브넷 목록에서 추가 요청한 [%s]서브넷의 정보[%s]를 찾지 못했습니다.", subnetInfo.IId.NameId, resSubnet.IId.SystemId)
                return irs.VPCInfo{}, errors.New("MismatchSubnet.NotFound: No SysmteId[" + resSubnet.IId.SystemId + "] found for newly created Subnet[" + subnetInfo.IId.NameId + "].")
        }</span>
        //spew.Dump(vpcInfo)

        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (VPCHandler *AwsVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC의 [%s] Subnet 삭제", vpcIID.SystemId, subnetIID.SystemId)

        return VPCHandler.DeleteSubnet(subnetIID)
        //return false, nil
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package azure

import (
        "context"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2020-10-01/resources"
        "github.com/Azure/go-autorest/autorest/azure/auth"
        "github.com/Azure/go-autorest/autorest/to"

        azcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/connect"
        azrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type AzureDriver struct{}

func (AzureDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "AZURE DRIVER Version 1.0"
}</span>

const (
        cspTimeout time.Duration = 6000
)

func (AzureDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

func (driver *AzureDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        // Initialize Logger
        azrs.InitLog()

        // Credentail에 등록된 ResourceGroup 존재 여부 체크 및 생성
        err := checkResourceGroup(connectionInfo.CredentialInfo, connectionInfo.RegionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">Ctx, VMClient, err := getVMClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, imageClient, err := getImageClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, publicIPClient, err := getPublicIPClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, sgClient, err := getSecurityGroupClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, vNicClient, err := getVNicClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, SubnetClient, err := getSubnetClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, VNetClient, err := getVNetworkClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, IPConfigClient, err := getIPConfigClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, VMImageClient, err := getVMImageClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, DiskClient, err := getDiskClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, VmSpecClient, err := getVmSpecClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := azcon.AzureCloudConnection{
                CredentialInfo:      connectionInfo.CredentialInfo,
                Region:              connectionInfo.RegionInfo,
                Ctx:                 Ctx,
                VMClient:            VMClient,
                ImageClient:         imageClient,
                PublicIPClient:      publicIPClient,
                SecurityGroupClient: sgClient,
                VNetClient:          VNetClient,
                VNicClient:          vNicClient,
                IPConfigClient:      IPConfigClient,
                SubnetClient:        SubnetClient,
                VMImageClient:       VMImageClient,
                DiskClient:          DiskClient,
                VmSpecClient:        VmSpecClient,
        }
        return &amp;iConn, nil</span>
}

func checkResourceGroup(credential idrv.CredentialInfo, region idrv.RegionInfo) error <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">resourceClient := resources.NewGroupsClient(credential.SubscriptionId)
        resourceClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        rg, err := resourceClient.Get(ctx, region.ResourceGroup)

        // 해당 리소스 그룹이 없을 경우 생성
        if rg.ID == nil </span><span class="cov0" title="0">{
                rg, err = resourceClient.CreateOrUpdate(ctx, region.ResourceGroup,
                        resources.Group{
                                Name:     to.StringPtr(region.ResourceGroup),
                                Location: to.StringPtr(region.Region),
                        })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getVMClient(credential idrv.CredentialInfo) (context.Context, *compute.VirtualMachinesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vmClient := compute.NewVirtualMachinesClient(credential.SubscriptionId)
        vmClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vmClient, nil</span>
}

func getImageClient(credential idrv.CredentialInfo) (context.Context, *compute.ImagesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">imageClient := compute.NewImagesClient(credential.SubscriptionId)
        imageClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;imageClient, nil</span>
}

func getPublicIPClient(credential idrv.CredentialInfo) (context.Context, *network.PublicIPAddressesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">publicIPClient := network.NewPublicIPAddressesClient(credential.SubscriptionId)
        publicIPClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;publicIPClient, nil</span>
}

func getSecurityGroupClient(credential idrv.CredentialInfo) (context.Context, *network.SecurityGroupsClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">sgClient := network.NewSecurityGroupsClient(credential.SubscriptionId)
        sgClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;sgClient, nil</span>
}

func getVNetworkClient(credential idrv.CredentialInfo) (context.Context, *network.VirtualNetworksClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vNetClient := network.NewVirtualNetworksClient(credential.SubscriptionId)
        vNetClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vNetClient, nil</span>
}

func getVNicClient(credential idrv.CredentialInfo) (context.Context, *network.InterfacesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vNicClient := network.NewInterfacesClient(credential.SubscriptionId)
        vNicClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vNicClient, nil</span>
}

func getIPConfigClient(credential idrv.CredentialInfo) (context.Context, *network.InterfaceIPConfigurationsClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ipConfigClient := network.NewInterfaceIPConfigurationsClient(credential.SubscriptionId)
        ipConfigClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;ipConfigClient, nil</span>
}

func getSubnetClient(credential idrv.CredentialInfo) (context.Context, *network.SubnetsClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">subnetClient := network.NewSubnetsClient(credential.SubscriptionId)
        subnetClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;subnetClient, nil</span>
}

func getVMImageClient(credential idrv.CredentialInfo) (context.Context, *compute.VirtualMachineImagesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vmImageClient := compute.NewVirtualMachineImagesClient(credential.SubscriptionId)
        vmImageClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vmImageClient, nil</span>
}

func getDiskClient(credential idrv.CredentialInfo) (context.Context, *compute.DisksClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">diskClient := compute.NewDisksClient(credential.SubscriptionId)
        diskClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;diskClient, nil</span>
}

func getVmSpecClient(credential idrv.CredentialInfo) (context.Context, *compute.VirtualMachineSizesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vmSpecClient := compute.NewVirtualMachineSizesClient(credential.SubscriptionId)
        vmSpecClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vmSpecClient, nil</span>
}

var CloudDriver AzureDriver
</pre>
		
		<pre class="file" id="file60" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package connect

import (
        "context"
        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        cblog "github.com/cloud-barista/cb-log"
        azrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type AzureCloudConnection struct {
        CredentialInfo      idrv.CredentialInfo
        Region              idrv.RegionInfo
        Ctx                 context.Context
        VMClient            *compute.VirtualMachinesClient
        ImageClient         *compute.ImagesClient
        VMImageClient       *compute.VirtualMachineImagesClient
        PublicIPClient      *network.PublicIPAddressesClient
        SecurityGroupClient *network.SecurityGroupsClient
        VNetClient          *network.VirtualNetworksClient
        VNicClient          *network.InterfacesClient
        IPConfigClient      *network.InterfaceIPConfigurationsClient
        SubnetClient        *network.SubnetsClient
        DiskClient          *compute.DisksClient
        VmSpecClient        *compute.VirtualMachineSizesClient
}

func (cloudConn *AzureCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateImageHandler()!")
        imageHandler := azrs.AzureImageHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.ImageClient, cloudConn.VMImageClient}
        return &amp;imageHandler, nil
}</span>

/*func (cloudConn *AzureCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
        cblogger.Info("Azure Cloud Driver: called CreateVNetworkHandler()!")
        vNetHandler := azrs.AzureVPCHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNetClient, cloudConn.SubnetClient}
        return &amp;vNetHandler, nil
}*/

func (cloudConn *AzureCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := azrs.AzureVPCHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNetClient, cloudConn.SubnetClient}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateSecurityHandler()!")
        sgHandler := azrs.AzureSecurityHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.SecurityGroupClient}
        return &amp;sgHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := azrs.AzureKeyPairHandler{cloudConn.CredentialInfo, cloudConn.Region}
        return &amp;keypairHandler, nil
}</span>

/*func (cloudConn *AzureCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Azure Cloud Driver: called CreateVNicHandler()!")
        vNicHandler := azrs.AzureVNicHandler{cloudConn.CredentialInfo, cloudConn.Region, cloudConn.Ctx, cloudConn.VNicClient, cloudConn.SubnetClient}
        return &amp;vNicHandler, nil
}*/

/*func (cloudConn *AzureCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Azure Cloud Driver: called CreatePublicIPHandler()!")
        publicIPHandler := azrs.AzurePublicIPHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.PublicIPClient, cloudConn.IPConfigClient}
        return &amp;publicIPHandler, nil
}*/

func (cloudConn *AzureCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateVMHandler()!")
        vmHandler := azrs.AzureVMHandler{
                CredentialInfo: cloudConn.CredentialInfo,
                Region:         cloudConn.Region,
                Ctx:            cloudConn.Ctx,
                Client:         cloudConn.VMClient,
                SubnetClient:   cloudConn.SubnetClient,
                NicClient:      cloudConn.VNicClient,
                PublicIPClient: cloudConn.PublicIPClient,
                DiskClient:     cloudConn.DiskClient,
        }
        return &amp;vmHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := azrs.AzureVmSpecHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VmSpecClient}
        return &amp;vmSpecHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>

func (cloudConn *AzureCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package resources

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "sync"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
)

const (
        CBResourceGroupName  = "CB-GROUP"
        CBVirutalNetworkName = "CB-VNet"
        CBVnetDefaultCidr    = "130.0.0.0/16"
        CBVMUser             = "cb-user"
        // by powerkim, 2019.10.30
        CBKeyPairPath = "/cloud-driver-libs/.ssh-azure/"
)

var once sync.Once
var cblogger *logrus.Logger
var calllogger *logrus.Logger

func InitLog() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                // cblog is a global variable.
                cblogger = cblog.GetLogger("CB-SPIDER")
                calllogger = call.GetLogger("HISCALL")
        }</span>)
}

func LoggingError(hiscallInfo call.CLOUDLOGSCHEMA, err error) <span class="cov0" title="0">{
        cblogger.Error(err.Error())
        hiscallInfo.ErrorMSG = err.Error()
        calllogger.Info(call.String(hiscallInfo))
}</span>

func LoggingInfo(hiscallInfo call.CLOUDLOGSCHEMA, start time.Time) <span class="cov0" title="0">{
        hiscallInfo.ElapsedTime = call.Elapsed(start)
        calllogger.Info(call.String(hiscallInfo))
}</span>

func GetCallLogScheme(region idrv.RegionInfo, resourceType call.RES_TYPE, resourceName string, apiName string) call.CLOUDLOGSCHEMA <span class="cov0" title="0">{
        cblogger.Info(fmt.Sprintf("Call %s %s", call.AZURE, apiName))
        return call.CLOUDLOGSCHEMA{
                CloudOS:      call.AZURE,
                RegionZone:   region.Region,
                ResourceType: resourceType,
                ResourceName: resourceName,
                CloudOSAPI:   apiName,
        }
}</span>

// 서브넷 CIDR 생성 (CIDR C class 기준 생성)
/*func CreateSubnetCIDR(subnetList []*irs.VPCHandler) (*string, error) {

        addressPrefix := "0.0.0.0/24"

        // CIDR C class 최대값 찾기
        maxClassNum := 0
        for _, subnet := range subnetList {
                //addressArr := strings.Split(subnet.AddressPrefix, ".")
                addressArr := strings.Split(addressPrefix, ".")
                if curClassNum, err := strconv.Atoi(addressArr[2]); err != nil {
                        return nil, err
                } else {
                        if curClassNum &gt; maxClassNum {
                                maxClassNum = curClassNum
                        }
                }
        }

        if len(subnetList) == 0 {
                maxClassNum = 0
        } else {
                maxClassNum = maxClassNum + 1
        }

        // 서브넷 CIDR 할당
        vNetIP := strings.Split(CBVnetDefaultCidr, "/")
        vNetIPClass := strings.Split(vNetIP[0], ".")
        subnetCIDR := fmt.Sprintf("%s.%s.%d.0/24", vNetIPClass[0], vNetIPClass[1], maxClassNum)
        return &amp;subnetCIDR, nil
}*/

// KeyPair 해시 생성 함수
func CreateHashString(credentialInfo idrv.CredentialInfo) (string, error) <span class="cov0" title="0">{
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + credentialInfo.TenantId + credentialInfo.SubscriptionId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}

// Public KeyPair 정보 가져오기
func GetPublicKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"
        publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(publicKeyBytes), nil</span>
}

// Private KeyPair 정보 가져오기
/*func GetPrivateKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) {
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil {
                return "", err
        }

        privateKeyPath := keyPairPath + hashString + "--" + keyPairName + ".ppk"
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil {
                return "", err
        }
        return string(privateKeyBytes), nil
}*/

func GetVNicIdByName(credentialInfo idrv.CredentialInfo, regionInfo idrv.RegionInfo, vNicName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/networkInterfaces/%s", credentialInfo.SubscriptionId, regionInfo.ResourceGroup, vNicName)
}</span>

func GetPublicIPIdByName(credentialInfo idrv.CredentialInfo, regionInfo idrv.RegionInfo, publicIPName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/publicIPAddresses/%s", credentialInfo.SubscriptionId, regionInfo.ResourceGroup, publicIPName)
}</span>

func GetSecGroupIdByName(credentialInfo idrv.CredentialInfo, regionInfo idrv.RegionInfo, secGroupName string) string <span class="cov0" title="0">{
        //   "SecurityGroupIds": ["/subscriptions/cb592624-b77b-4a8f-bb13-0e5a48cae40f/resourceGroups/CB-GROUP/providers/Microsoft.Network/networkSecurityGroups/CB-SecGroup"],
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/networkSecurityGroups/%s", credentialInfo.SubscriptionId, regionInfo.ResourceGroup, secGroupName)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package resources

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Image = "IMAGE"
)

type AzureImageHandler struct {
        Region        idrv.RegionInfo
        Ctx           context.Context
        Client        *compute.ImagesClient
        VMImageClient *compute.VirtualMachineImagesClient
}

func (imageHandler *AzureImageHandler) setterImage(image compute.Image) *irs.ImageInfo <span class="cov0" title="0">{
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   *image.Name,
                        SystemId: *image.Name,
                },
                GuestOS:      fmt.Sprint(image.ImageProperties.StorageProfile.OsDisk.OsType),
                Status:       *image.ProvisioningState,
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: imageHandler.Region.ResourceGroup}},
        }

        return imageInfo
}</span>

func (imageHandler *AzureImageHandler) setterVMImage(image compute.VirtualMachineImage) *irs.ImageInfo <span class="cov0" title="0">{
        imageIdArr := strings.Split(*image.ID, "/")
        imageName := fmt.Sprintf("%s:%s:%s:%s", imageIdArr[8], imageIdArr[12], imageIdArr[14], imageIdArr[16])
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   imageName,
                        SystemId: imageName,
                },
                GuestOS:      fmt.Sprint(image.OsDiskImage.OperatingSystem),
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: imageHandler.Region.ResourceGroup}},
        }

        return imageInfo
}</span>

func (imageHandler *AzureImageHandler) setterVMImageforList(image compute.VirtualMachineImageResource) *irs.ImageInfo <span class="cov0" title="0">{
        imageIdArr := strings.Split(*image.ID, "/")
        imageName := fmt.Sprintf("%s:%s:%s:%s", imageIdArr[8], imageIdArr[12], imageIdArr[14], imageIdArr[16])
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   imageName,
                        SystemId: imageName,
                },
                //GuestOS:      fmt.Sprint(image.OsDiskImage.OperatingSystem),
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: imageHandler.Region.ResourceGroup}},
        }

        return imageInfo
}</span>

func (imageHandler *AzureImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{

        // @TODO: PublicIP 생성 요청 파라미터 정의 필요
        type ImageReqInfo struct {
                OSType string
                DiskId string
        }

        reqInfo := ImageReqInfo{
                //BlobUrl: "https://md-ds50xp550wh2.blob.core.windows.net/kt0lhznvgx2h/abcd?sv=2017-04-17&amp;sr=b&amp;si=b9674241-fb8e-4cb2-89c7-614d336dc3a7&amp;sig=uvbqvAZQITSpxas%2BWosG%2FGOf6e%2BIBmWNxlUmvARnxiM%3D",
                OSType: "Linux",
                DiskId: "/subscriptions/cb592624-b77b-4a8f-bb13-0e5a48cae40f/resourceGroups/INNO-PLATFORM1-RSRC-GRUP/providers/Microsoft.Compute/disks/inno-test-vm_OsDisk_1_61bf675b990f4aa381d7ee3d766974aa",
                // edited by powerkim for test, 2019.08.13
                //DiskId: "/subscriptions/f1548292-2be3-4acd-84a4-6df079160846/resourceGroups/CB-RESOURCE-GROUP/providers/Microsoft.Compute/disks/vm_name_OsDisk_1_2d63d9cd754c4094b1b1fb6a98c36b71",
        }

        // Check Image Exists
        image, err := imageHandler.Client.Get(imageHandler.Ctx, imageHandler.Region.ResourceGroup, imageReqInfo.IId.NameId, "")
        if image.ID != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("Image with name %s already exist", imageReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                return irs.ImageInfo{}, createErr
        }</span>

        <span class="cov0" title="0">createOpts := compute.Image{
                ImageProperties: &amp;compute.ImageProperties{
                        StorageProfile: &amp;compute.ImageStorageProfile{
                                OsDisk: &amp;compute.ImageOSDisk{
                                        //BlobURI: to.StringPtr(reqInfo.BlobUrl),
                                        ManagedDisk: &amp;compute.SubResource{
                                                ID: to.StringPtr(reqInfo.DiskId),
                                        },
                                        OsType: compute.OperatingSystemTypes(reqInfo.OSType),
                                },
                        },
                },
                Location: &amp;imageHandler.Region.Region,
        }

        future, err := imageHandler.Client.CreateOrUpdate(imageHandler.Ctx, imageHandler.Region.ResourceGroup, imageReqInfo.IId.NameId, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(imageHandler.Ctx, imageHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>

        // 생성된 Image 정보 리턴
        <span class="cov0" title="0">imageInfo, err := imageHandler.GetImage(imageReqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">return imageInfo, nil</span>
}

func (imageHandler *AzureImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Region, call.VMIMAGE, Image, "ListImage()")

        var imageList []*irs.ImageInfo

        publishers, err := imageHandler.VMImageClient.ListPublishers(context.TODO(), imageHandler.Region.Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">start := call.Start()

        var publisherWg sync.WaitGroup
        publisherWg.Add(len(*publishers.Value))

        for _, p := range *publishers.Value </span><span class="cov0" title="0">{
                go func(publisher compute.VirtualMachineImageResource) </span><span class="cov0" title="0">{
                        defer publisherWg.Done()
                        offers, err := imageHandler.VMImageClient.ListOffers(context.TODO(), imageHandler.Region.Region, *publisher.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">for _, offer := range *offers.Value </span><span class="cov0" title="0">{
                                skus, err := imageHandler.VMImageClient.ListSkus(context.TODO(), imageHandler.Region.Region, *publisher.Name, *offer.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">for _, sku := range *skus.Value </span><span class="cov0" title="0">{
                                        imageVersionList, err := imageHandler.VMImageClient.List(context.TODO(), imageHandler.Region.Region, *publisher.Name, *offer.Name, *sku.Name, "", nil, "")
                                        if err != nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if len(*imageVersionList.Value) == 0 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">for _, version := range *imageVersionList.Value </span><span class="cov0" title="0">{
                                                imageIdArr := strings.Split(*version.ID, "/")
                                                imageVersion := imageIdArr[len(imageIdArr)-1]
                                                vmImage, err := imageHandler.VMImageClient.Get(context.TODO(), imageHandler.Region.Region, *publisher.Name, *offer.Name, *sku.Name, imageVersion)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">vmImageInfo := imageHandler.setterVMImage(vmImage)
                                                imageList = append(imageList, vmImageInfo)</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">return</span>
                }(p)
        }

        <span class="cov0" title="0">publisherWg.Wait()
        LoggingInfo(hiscallInfo, start)
        return imageList, nil</span>
}

func (imageHandler *AzureImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Region, call.VMIMAGE, imageIID.NameId, "GetImage()")

        imageArr := strings.Split(imageIID.NameId, ":")

        // 이미지 URN 형식 검사
        if len(imageArr) != 4 </span><span class="cov0" title="0">{
                formatErr := errors.New("invalid format for image ID, imageId=" + imageIID.NameId)
                LoggingError(hiscallInfo, formatErr)
                return irs.ImageInfo{}, formatErr
        }</span>

        // 해당 이미지 publisher, offer, skus 기준 version 목록 조회 (latest 기준 조회 기능 미활용)
        /*
                imageVersion := imageArr[3]
                if strings.EqualFold(imageVersion, "latest") {
                        vmImageList, err := imageHandler.VMImageClient.List(imageHandler.Ctx, imageHandler.Region.Region, imageArr[0], imageArr[1], imageArr[2], "", to.Int32Ptr(1), "name desc")
                        if err != nil {
                                LoggingError(hiscallInfo, err)
                                return irs.ImageInfo{}, err
                        }
                        if &amp;vmImageList == nil {
                                getErr := errors.New(fmt.Sprintf("could not found image with imageId %s", imageIID.NameId))
                                LoggingError(hiscallInfo, getErr)
                                return irs.ImageInfo{}, getErr
                        }
                        if vmImageList.Value == nil {
                                getErr := errors.New(fmt.Sprintf("could not found image with imageId %s", imageIID.NameId))
                                LoggingError(hiscallInfo, getErr)
                                return irs.ImageInfo{}, getErr
                        }
                        if len(*vmImageList.Value) == 0 {
                                getErr := errors.New(fmt.Sprintf("could not found image with imageId %s", imageIID.NameId))
                                LoggingError(hiscallInfo, getErr)
                                return irs.ImageInfo{}, getErr
                        } else {
                                latestVmImage := (*vmImageList.Value)[0]
                                imageIdArr := strings.Split(*latestVmImage.ID, "/")
                                imageVersion = imageIdArr[len(imageIdArr)-1]
                        }
                }
        */

        // 1개의 버전 정보를 기준으로 이미지 정보 조회
        <span class="cov0" title="0">start := call.Start()
        vmImage, err := imageHandler.VMImageClient.Get(imageHandler.Ctx, imageHandler.Region.Region, imageArr[0], imageArr[1], imageArr[2], imageArr[3])
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageInfo := imageHandler.setterVMImage(vmImage)
        return *imageInfo, nil</span>
}

func (imageHandler *AzureImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Region, call.VMIMAGE, imageIID.NameId, "DeleteImage()")

        start := call.Start()
        future, err := imageHandler.Client.Delete(imageHandler.Ctx, imageHandler.Region.ResourceGroup, imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(imageHandler.Ctx, imageHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package resources

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        KeyPair = "KEYPAIR"
)

type AzureKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
}

func (keyPairHandler *AzureKeyPairHandler) CheckKeyPairFolder(folderPath string) error <span class="cov0" title="0">{
        // Check KeyPair Folder Exists
        if _, err := os.Stat(folderPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.MkdirAll(folderPath, 0700); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, keyPairReqInfo.IId.NameId, "CreateKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">savePrivateFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId
        savePublicFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pub"
        bitSize := 4096

        // Check KeyPair Exists
        if _, err := os.Stat(savePrivateFileTo); err == nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("KeyPair with name %s already exist", keyPairReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                cblogger.Error(createErr.Error())
                hiscallInfo.ErrorMSG = createErr.Error()
                calllogger.Info(call.String(hiscallInfo))
                return irs.KeyPairInfo{}, createErr
        }</span>

        <span class="cov0" title="0">start := call.Start()

        // 지정된 바이트크기의 RSA 형식 개인키(비공개키)를 만듬
        privateKey, err := generatePrivateKey(bitSize)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 개인키를 RSA에서 PEM 형식으로 인코딩
        <span class="cov0" title="0">privateKeyBytes := encodePrivateKeyToPEM(privateKey)

        // rsa.PublicKey를 가져와서 .pub 파일에 쓰기 적합한 바이트로 변환
        // "ssh-rsa ..."형식으로 변환
        publicKeyBytes, err := generatePublicKey(&amp;privateKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 private Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile(privateKeyBytes, savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 public Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile([]byte(publicKeyBytes), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairReqInfo.IId.NameId,
                        SystemId: keyPairReqInfo.IId.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keyPairInfo, nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, KeyPair, "ListKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var keyPairInfoList []*irs.KeyPairInfo

        start := call.Start()

        files, err := ioutil.ReadDir(keyPairPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), ".pub") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.Contains(f.Name(), hashString) </span><span class="cov0" title="0">{
                        fileNameArr := strings.Split(f.Name(), "--")
                        keypairInfo, err := keyPairHandler.GetKey(irs.IID{NameId: fileNameArr[1]})
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keyPairInfoList = append(keyPairInfoList, &amp;keypairInfo)</span>
                }
        }

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return keyPairInfoList, nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, keyIID.NameId, "GetKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)

        privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key 파일 정보 가져오기
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keypairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyIID.NameId,
                        SystemId: keyIID.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keypairInfo, nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, keyIID.NameId, "DeleteKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key 삭제
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

// 지정된 바이트크기의 RSA 형식 개인키(비공개키)를 만듬
func generatePrivateKey(bitSize int) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        // Private Key 생성
        privateKey, err := rsa.GenerateKey(rand.Reader, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Private Key 확인
        <span class="cov0" title="0">err = privateKey.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Private Key generated(생성)")
        //fmt.Println(privateKey)
        return privateKey, nil</span>
}

// 개인키를 RSA에서 PEM 형식으로 인코딩
func encodePrivateKeyToPEM(privateKey *rsa.PrivateKey) []byte <span class="cov0" title="0">{
        // Get ASN.1 DER format
        privDER := x509.MarshalPKCS1PrivateKey(privateKey)

        // pem.Block
        privBlock := pem.Block{
                Type:    "RSA PRIVATE KEY",
                Headers: nil,
                Bytes:   privDER,
        }

        // Private key in PEM format
        privatePEM := pem.EncodeToMemory(&amp;privBlock)
        fmt.Println("privateKey Rsa -&gt; Pem 형식으로 변환")
        //fmt.Println(privatePEM)
        return privatePEM
}</span>

// rsa.PublicKey를 가져와서 .pub 파일에 쓰기 적합한 바이트로 변환
// "ssh-rsa ..."형식으로 변환
func generatePublicKey(privatekey *rsa.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        publicRsaKey, err := ssh.NewPublicKey(privatekey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pubKeyBytes := ssh.MarshalAuthorizedKey(publicRsaKey)

        log.Println("Public key 생성")
        //fmt.Println(pubKeyBytes)
        return pubKeyBytes, nil</span>
}

// 파일에 Key를 쓴다
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key 저장위치: %s", saveFileTo)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package resources

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        ICMP          = "icmp"
        SecurityGroup = "SECURITYGROUP"
)

type AzureSecurityHandler struct {
        Region idrv.RegionInfo
        Ctx    context.Context
        Client *network.SecurityGroupsClient
}

func (securityHandler *AzureSecurityHandler) setterSec(securityGroup network.SecurityGroup) *irs.SecurityInfo <span class="cov0" title="0">{
        security := &amp;irs.SecurityInfo{
                IId: irs.IID{
                        NameId:   *securityGroup.Name,
                        SystemId: *securityGroup.ID,
                },
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: securityHandler.Region.ResourceGroup}},
        }

        var securityRuleArr []irs.SecurityRuleInfo
        for _, sgRule := range *securityGroup.SecurityRules </span><span class="cov0" title="0">{

                var fromPort string
                var toPort string

                if strings.Contains(*sgRule.SourcePortRange, "-") </span><span class="cov0" title="0">{
                        sourcePortArr := strings.Split(*sgRule.SourcePortRange, "-")
                        fromPort = sourcePortArr[0]
                        toPort = sourcePortArr[1]
                }</span> else<span class="cov0" title="0"> {
                        fromPort = *sgRule.SourcePortRange
                        toPort = *sgRule.DestinationPortRange
                }</span>

                <span class="cov0" title="0">ruleInfo := irs.SecurityRuleInfo{
                        IPProtocol: strings.ToLower(fmt.Sprint(sgRule.Protocol)),
                        Direction:  fmt.Sprint(sgRule.Direction),
                        CIDR:       *sgRule.SourceAddressPrefix,
                }

                if strings.ToLower(fmt.Sprint(sgRule.Protocol)) == ICMP </span><span class="cov0" title="0">{
                        ruleInfo.FromPort = "-1"
                        ruleInfo.ToPort = "-1"
                }</span> else<span class="cov0" title="0"> {
                        ruleInfo.FromPort = fromPort
                        ruleInfo.ToPort = toPort
                }</span>

                <span class="cov0" title="0">securityRuleArr = append(securityRuleArr, ruleInfo)</span>
        }
        <span class="cov0" title="0">security.SecurityRules = &amp;securityRuleArr

        return security</span>
}

func (securityHandler *AzureSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, securityReqInfo.IId.NameId, "CreateSecurity()")

        // Check SecurityGroup Exists
        security, _ := securityHandler.Client.Get(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityReqInfo.IId.NameId, "")
        if security.ID != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Security Group with name %s already exist", securityReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.SecurityInfo{}, createErr
        }</span>

        <span class="cov0" title="0">var sgRuleList []network.SecurityRule
        var priorityNum int32
        for idx, rule := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                priorityNum = int32(300 + idx*100)
                sgRuleInfo := network.SecurityRule{
                        Name: to.StringPtr(fmt.Sprintf("%s-rules-%d", securityReqInfo.IId.NameId, idx+1)),
                        SecurityRulePropertiesFormat: &amp;network.SecurityRulePropertiesFormat{
                                SourceAddressPrefix:      &amp;rule.CIDR,
                                DestinationAddressPrefix: to.StringPtr("*"),
                                DestinationPortRange:     to.StringPtr("*"),
                                Protocol:                 network.SecurityRuleProtocol(strings.ToUpper(rule.IPProtocol)),
                                Access:                   network.SecurityRuleAccess("Allow"),
                                Priority:                 to.Int32Ptr(priorityNum),
                                Direction:                network.SecurityRuleDirection(rule.Direction),
                        },
                }

                if strings.ToLower(rule.IPProtocol) == ICMP || (rule.FromPort == "*" &amp;&amp; rule.ToPort == "*") </span><span class="cov0" title="0">{
                        sgRuleInfo.SourcePortRange = to.StringPtr("*")
                }</span> else<span class="cov0" title="0"> if rule.FromPort == rule.ToPort </span><span class="cov0" title="0">{
                        sgRuleInfo.SourcePortRange = to.StringPtr(rule.FromPort)
                }</span> else<span class="cov0" title="0"> {
                        sgRuleInfo.SourcePortRange = to.StringPtr(rule.FromPort + "-" + rule.ToPort)
                }</span>

                <span class="cov0" title="0">sgRuleList = append(sgRuleList, sgRuleInfo)</span>
        }

        <span class="cov0" title="0">createOpts := network.SecurityGroup{
                SecurityGroupPropertiesFormat: &amp;network.SecurityGroupPropertiesFormat{
                        SecurityRules: &amp;sgRuleList,
                },
                Location: &amp;securityHandler.Region.Region,
        }

        start := call.Start()
        future, err := securityHandler.Client.CreateOrUpdate(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityReqInfo.IId.NameId, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(securityHandler.Ctx, securityHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>

        // 생성된 SecurityGroup 정보 리턴
        <span class="cov0" title="0">securityInfo, err := securityHandler.GetSecurity(securityReqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>

        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *AzureSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, SecurityGroup, "ListSecurity()")

        start := call.Start()
        result, err := securityHandler.Client.List(securityHandler.Ctx, securityHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var securityList []*irs.SecurityInfo
        for _, security := range result.Values() </span><span class="cov0" title="0">{
                securityInfo := securityHandler.setterSec(security)
                securityList = append(securityList, securityInfo)
        }</span>
        <span class="cov0" title="0">return securityList, nil</span>
}

func (securityHandler *AzureSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, securityIID.NameId, "GetSecurity()")

        start := call.Start()
        security, err := securityHandler.Client.Get(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityIID.NameId, "")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        securityInfo := securityHandler.setterSec(security)
        return *securityInfo, nil</span>
}

func (securityHandler *AzureSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, securityIID.NameId, "DeleteSecurity()")

        start := call.Start()
        future, err := securityHandler.Client.Delete(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(securityHandler.Ctx, securityHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package resources

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        ProvisioningStateCode string = "ProvisioningState/succeeded"
        VM                           = "VM"
)

type AzureVMHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
        Ctx            context.Context
        Client         *compute.VirtualMachinesClient
        SubnetClient   *network.SubnetsClient
        NicClient      *network.InterfacesClient
        PublicIPClient *network.PublicIPAddressesClient
        DiskClient     *compute.DisksClient
}

func (vmHandler *AzureVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmReqInfo.IId.NameId, "StartVM()")

        // Check VM Exists
        vm, err := vmHandler.Client.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.IId.NameId, compute.InstanceViewTypesInstanceView)
        if vm.ID != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("virtualMachine with name %s already exist", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // Check login method (keypair, password)
        <span class="cov0" title="0">if vmReqInfo.VMUserPasswd != "" &amp;&amp; vmReqInfo.KeyPairIID.NameId != "" </span><span class="cov0" title="0">{
                createErr := errors.New("specify one login method, Password or Keypair")
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // TODO: nested flow 개선
        // PublicIP 생성
        <span class="cov0" title="0">publicIPIId, err := CreatePublicIP(vmHandler, vmReqInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        // TODO: nested flow 개선
        // VNic 생성
        <span class="cov0" title="0">vNicIId, err := CreateVNic(vmHandler, vmReqInfo, publicIPIId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">vmOpts := compute.VirtualMachine{
                Location: &amp;vmHandler.Region.Region,
                VirtualMachineProperties: &amp;compute.VirtualMachineProperties{
                        HardwareProfile: &amp;compute.HardwareProfile{
                                VMSize: compute.VirtualMachineSizeTypes(vmReqInfo.VMSpecName),
                        },
                        OsProfile: &amp;compute.OSProfile{
                                ComputerName:  &amp;vmReqInfo.IId.NameId,
                                AdminUsername: to.StringPtr(CBVMUser),
                        },
                        NetworkProfile: &amp;compute.NetworkProfile{
                                NetworkInterfaces: &amp;[]compute.NetworkInterfaceReference{
                                        {
                                                //ID: &amp;vmReqInfo.NetworkInterfaceId,
                                                ID: &amp;vNicIId.SystemId,
                                                NetworkInterfaceReferenceProperties: &amp;compute.NetworkInterfaceReferenceProperties{
                                                        Primary: to.BoolPtr(true),
                                                },
                                        },
                                },
                        },
                },
        }

        // Image 설정
        if strings.Contains(vmReqInfo.ImageIID.SystemId, ":") </span><span class="cov0" title="0">{
                imageArr := strings.Split(vmReqInfo.ImageIID.SystemId, ":")
                // URN 기반 퍼블릭 이미지 설정
                vmOpts.StorageProfile = &amp;compute.StorageProfile{
                        ImageReference: &amp;compute.ImageReference{
                                Publisher: &amp;imageArr[0],
                                Offer:     &amp;imageArr[1],
                                Sku:       &amp;imageArr[2],
                                Version:   &amp;imageArr[3],
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                // 사용자 프라이빗 이미지 설정
                vmOpts.StorageProfile = &amp;compute.StorageProfile{
                        ImageReference: &amp;compute.ImageReference{
                                ID: &amp;vmReqInfo.ImageIID.NameId,
                        },
                }
        }</span>

        // KeyPair 설정
        <span class="cov0" title="0">if vmReqInfo.KeyPairIID.NameId != "" </span><span class="cov0" title="0">{
                publicKey, err := GetPublicKey(vmHandler.CredentialInfo, vmReqInfo.KeyPairIID.NameId)
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VMInfo{}, err
                }</span>
                <span class="cov0" title="0">vmOpts.OsProfile.LinuxConfiguration = &amp;compute.LinuxConfiguration{
                        SSH: &amp;compute.SSHConfiguration{
                                PublicKeys: &amp;[]compute.SSHPublicKey{
                                        {
                                                Path:    to.StringPtr(fmt.Sprintf("/home/%s/.ssh/authorized_keys", CBVMUser)),
                                                KeyData: to.StringPtr(publicKey),
                                        },
                                },
                        },
                }</span>
        } else<span class="cov0" title="0"> {
                vmOpts.OsProfile.AdminPassword = to.StringPtr(vmReqInfo.VMUserPasswd)
        }</span>

        // VM 정보 태깅 설정
        <span class="cov0" title="0">if vmReqInfo.KeyPairIID.NameId != "" </span><span class="cov0" title="0">{
                vmOpts.Tags = map[string]*string{
                        "keypair":  to.StringPtr(vmReqInfo.KeyPairIID.NameId),
                        "publicip": to.StringPtr(publicIPIId.NameId),
                }
        }</span>

        <span class="cov0" title="0">start := call.Start()
        future, err := vmHandler.Client.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.IId.NameId, vmOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">vm, err = vmHandler.Client.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.IId.NameId, compute.InstanceViewTypesInstanceView)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
        }</span>

        <span class="cov0" title="0">vmInfo := vmHandler.mappingServerInfo(vm)
        return vmInfo, nil</span>
}

func (vmHandler *AzureVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "SuspendVM()")

        start := call.Start()
        future, err := vmHandler.Client.PowerOff(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId, to.BoolPtr(false))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // Get VM Status
        <span class="cov0" title="0">vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return vmStatus, nil</span>
}

func (vmHandler *AzureVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "ResumeVM()")

        start := call.Start()
        future, err := vmHandler.Client.Start(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // 자체생성상태 반환
        return irs.Resuming, nil</span>
}

func (vmHandler *AzureVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "RebootVM()")

        start := call.Start()
        future, err := vmHandler.Client.Restart(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // 자체생성상태 반환
        return irs.Rebooting, nil</span>
}

func (vmHandler *AzureVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "TerminateVM()")

        // VM 삭제 시 OS Disk도 함께 삭제 처리
        // VM OSDisk 이름 가져오기
        vmInfo, err := vmHandler.GetVM(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">osDiskName := vmInfo.VMBootDisk
        /* Detach may not be required for dynamic public IP mode. by powerkim. 2021.04.30.
        // TODO: nested flow 개선
        // VNic에서 PublicIP 연결해제
        vNicDetachStatus, err := DetachVNic(vmHandler, vmInfo)
        if err != nil {
                LoggingError(hiscallInfo, err)
                return vNicDetachStatus, err
        }
        */

        // VM 삭제
        start := call.Start()
        future, err := vmHandler.Client.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId, to.BoolPtr(false))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // TODO: nested flow 개선
        // VNic 삭제
        <span class="cov0" title="0">vNicStatus, err := DeleteVNic(vmHandler, vmInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return vNicStatus, err
        }</span>

        // TODO: nested flow 개선
        // PublicIP 삭제
        <span class="cov0" title="0">publicIPStatus, err := DeletePublicIP(vmHandler, vmInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return publicIPStatus, err
        }</span>

        // TODO: nested flow 개선
        // OS Disk 삭제
        <span class="cov0" title="0">diskStatus, err := DeleteVMDisk(vmHandler, osDiskName)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return diskStatus, err
        }</span>

        // 자체생성상태 반환
        <span class="cov0" title="0">return irs.NotExist, nil</span>
}

func (vmHandler *AzureVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, VM, "ListVMStatus()")

        start := call.Start()
        serverList, err := vmHandler.Client.List(vmHandler.Ctx, vmHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMStatusInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var vmStatusList []*irs.VMStatusInfo
        for _, s := range serverList.Values() </span><span class="cov0" title="0">{
                if s.InstanceView != nil </span><span class="cov0" title="0">{
                        statusStr := getVmStatus(*s.InstanceView)
                        status := irs.VMStatus(statusStr)
                        vmStatusInfo := irs.VMStatusInfo{
                                IId: irs.IID{
                                        NameId:   *s.Name,
                                        SystemId: *s.ID,
                                },
                                VmStatus: status,
                        }
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span> else<span class="cov0" title="0"> {
                        vmIdArr := strings.Split(*s.ID, "/")
                        vmName := vmIdArr[8]
                        status, _ := vmHandler.GetVMStatus(irs.IID{NameId: vmName, SystemId: *s.ID})
                        vmStatusInfo := irs.VMStatusInfo{
                                IId: irs.IID{
                                        NameId:   *s.Name,
                                        SystemId: *s.ID,
                                },
                                VmStatus: status,
                        }
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func (vmHandler *AzureVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "GetVMStatus()")

        start := call.Start()
        instanceView, err := vmHandler.Client.InstanceView(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Get powerState, provisioningState
        vmStatus := getVmStatus(instanceView)
        return irs.VMStatus(vmStatus), nil</span>
}

func (vmHandler *AzureVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, VM, "ListVM()")

        start := call.Start()
        serverList, err := vmHandler.Client.List(vmHandler.Ctx, vmHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var vmList []*irs.VMInfo
        for _, server := range serverList.Values() </span><span class="cov0" title="0">{
                vmInfo := vmHandler.mappingServerInfo(server)
                vmList = append(vmList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmList, nil</span>
}

func (vmHandler *AzureVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "GetVM()")

        start := call.Start()
        vm, err := vmHandler.Client.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId, compute.InstanceViewTypesInstanceView)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfo := vmHandler.mappingServerInfo(vm)
        return vmInfo, nil</span>
}

func getVmStatus(instanceView compute.VirtualMachineInstanceView) irs.VMStatus <span class="cov0" title="0">{
        var powerState, provisioningState string

        for _, stat := range *instanceView.Statuses </span><span class="cov0" title="0">{
                statArr := strings.Split(*stat.Code, "/")

                if statArr[0] == "PowerState" </span><span class="cov0" title="0">{
                        powerState = strings.ToLower(statArr[1])
                }</span> else<span class="cov0" title="0"> if statArr[0] == "ProvisioningState" </span><span class="cov0" title="0">{
                        provisioningState = strings.ToLower(statArr[1])
                }</span>
        }

        <span class="cov0" title="0">if strings.EqualFold(provisioningState, "failed") </span><span class="cov0" title="0">{
                return irs.Failed
        }</span>

        // Set VM Status Info
        <span class="cov0" title="0">var resultStatus string
        switch powerState </span>{
        case "starting":<span class="cov0" title="0">
                resultStatus = "Creating"</span>
        case "running":<span class="cov0" title="0">
                resultStatus = "Running"</span>
        case "stopping":<span class="cov0" title="0">
                resultStatus = "Suspending"</span>
        case "stopped":<span class="cov0" title="0">
                resultStatus = "Suspended"</span>
        case "deleting":<span class="cov0" title="0">
                resultStatus = "Terminating"</span>
        default:<span class="cov0" title="0">
                resultStatus = "Failed"</span>
        }
        <span class="cov0" title="0">return irs.VMStatus(resultStatus)</span>
}

func (vmHandler *AzureVMHandler) mappingServerInfo(server compute.VirtualMachine) irs.VMInfo <span class="cov0" title="0">{

        // Get Default VM Info
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId:   *server.Name,
                        SystemId: *server.ID,
                },
                Region: irs.RegionInfo{
                        Region: *server.Location,
                },
                VMSpecName: string(server.VirtualMachineProperties.HardwareProfile.VMSize),
        }

        // Set VM Zone
        if server.Zones != nil </span><span class="cov0" title="0">{
                vmInfo.Region.Zone = (*server.Zones)[0]
        }</span>

        // Set VM Image Info
        <span class="cov0" title="0">if reflect.ValueOf(server.StorageProfile.ImageReference.ID).IsNil() </span><span class="cov0" title="0">{
                imageRef := server.VirtualMachineProperties.StorageProfile.ImageReference
                vmInfo.ImageIId.SystemId = *imageRef.Publisher + ":" + *imageRef.Offer + ":" + *imageRef.Sku + ":" + *imageRef.Version
                //vmInfo.ImageIId.SystemId = vmInfo.ImageIId.NameId
        }</span> else<span class="cov0" title="0"> {
                vmInfo.ImageIId.SystemId = *server.VirtualMachineProperties.StorageProfile.ImageReference.ID
                //vmInfo.ImageIId.SystemId = vmInfo.ImageIId.NameId
        }</span>

        // Get VNic ID
        <span class="cov0" title="0">niList := *server.NetworkProfile.NetworkInterfaces
        var VNicId string
        for _, ni := range niList </span><span class="cov0" title="0">{
                if ni.ID != nil </span><span class="cov0" title="0">{
                        VNicId = *ni.ID
                }</span>
        }

        // Get VNic
        <span class="cov0" title="0">nicIdArr := strings.Split(VNicId, "/")
        nicName := nicIdArr[len(nicIdArr)-1]
        vNic, _ := vmHandler.NicClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, nicName, "")
        vmInfo.NetworkInterface = nicName

        // Get SecurityGroup
        sgGroupIdArr := strings.Split(*vNic.NetworkSecurityGroup.ID, "/")
        sgGroupName := sgGroupIdArr[len(sgGroupIdArr)-1]
        vmInfo.SecurityGroupIIds = []irs.IID{
                {
                        NameId:   sgGroupName,
                        SystemId: *vNic.NetworkSecurityGroup.ID,
                },
        }

        // Get PrivateIP, PublicIpId
        for _, ip := range *vNic.IPConfigurations </span><span class="cov0" title="0">{
                if *ip.Primary </span><span class="cov0" title="0">{
                        // PrivateIP 정보 설정
                        vmInfo.PrivateIP = *ip.PrivateIPAddress

                        // PublicIP 정보 조회 및 설정
                        if ip.PublicIPAddress != nil </span><span class="cov0" title="0">{
                                publicIPId := *ip.PublicIPAddress.ID
                                publicIPIdArr := strings.Split(publicIPId, "/")
                                publicIPName := publicIPIdArr[len(publicIPIdArr)-1]

                                publicIP, _ := vmHandler.PublicIPClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPName, "")
                                vmInfo.PublicIP = *publicIP.IPAddress
                        }</span>

                        // Get Subnet
                        <span class="cov0" title="0">subnetIdArr := strings.Split(*ip.InterfaceIPConfigurationPropertiesFormat.Subnet.ID, "/")
                        subnetName := subnetIdArr[len(subnetIdArr)-1]
                        vmInfo.SubnetIID = irs.IID{NameId: subnetName, SystemId: *ip.InterfaceIPConfigurationPropertiesFormat.Subnet.ID}

                        // Get VPC
                        vpcIdArr := subnetIdArr[:len(subnetIdArr)-2]
                        vpcName := vpcIdArr[len(vpcIdArr)-1]
                        vmInfo.VpcIID = irs.IID{NameId: vpcName, SystemId: strings.Join(vpcIdArr, "/")}</span>
                }
        }

        // Set GuestUser Id/Pwd
        <span class="cov0" title="0">if server.VirtualMachineProperties.OsProfile.AdminUsername != nil </span><span class="cov0" title="0">{
                vmInfo.VMUserId = *server.VirtualMachineProperties.OsProfile.AdminUsername
        }</span>
        <span class="cov0" title="0">if server.VirtualMachineProperties.OsProfile.AdminPassword != nil </span><span class="cov0" title="0">{
                vmInfo.VMUserPasswd = *server.VirtualMachineProperties.OsProfile.AdminPassword
        }</span>

        // Set BootDisk
        <span class="cov0" title="0">if server.VirtualMachineProperties.StorageProfile.OsDisk.Name != nil </span><span class="cov0" title="0">{
                vmInfo.VMBootDisk = *server.VirtualMachineProperties.StorageProfile.OsDisk.Name
        }</span>

        // Get StartTime
        <span class="cov0" title="0">if server.VirtualMachineProperties.InstanceView != nil </span><span class="cov0" title="0">{
                for _, status := range *server.VirtualMachineProperties.InstanceView.Statuses </span><span class="cov0" title="0">{
                        if strings.EqualFold(*status.Code, ProvisioningStateCode) </span><span class="cov0" title="0">{
                                vmInfo.StartTime = status.Time.Local()
                                break</span>
                        }
                }
        }

        // Get Keypair
        <span class="cov0" title="0">tagList := server.Tags
        for key, val := range tagList </span><span class="cov0" title="0">{
                if key == "keypair" </span><span class="cov0" title="0">{
                        vmInfo.KeyPairIId = irs.IID{NameId: *val, SystemId: *val}
                }</span>
                <span class="cov0" title="0">if key == "publicip" </span><span class="cov0" title="0">{
                        vmInfo.KeyValueList = []irs.KeyValue{
                                {Key: "publicip", Value: *val},
                        }
                }</span>
        }

        <span class="cov0" title="0">return vmInfo</span>
}

// VM 생성 시 Public IP 자동 생성 (nested flow 적용)
func CreatePublicIP(vmHandler *AzureVMHandler, vmReqInfo irs.VMReqInfo) (irs.IID, error) <span class="cov0" title="0">{

        // PublicIP 이름 생성
        /*var publicIPName string
        uuid, err := uuid.NewUUID()
        if err != nil {
                createErr := errors.New(fmt.Sprintf("Failed to generate UUID, error=%s", err))
                return irs.IID{}, createErr
        }*/
        //publicIPName = fmt.Sprintf("%s-%s-PublicIP", vmReqInfo.IId.NameId, uuid)
        publicIPName := fmt.Sprintf("%s-PublicIP", vmReqInfo.IId.NameId)

        createOpts := network.PublicIPAddress{
                Name: to.StringPtr(publicIPName),
                Sku: &amp;network.PublicIPAddressSku{
                        Name: network.PublicIPAddressSkuName("Basic"),
                },
                PublicIPAddressPropertiesFormat: &amp;network.PublicIPAddressPropertiesFormat{
                        PublicIPAddressVersion: network.IPVersion("IPv4"),
                        //PublicIPAllocationMethod: network.IPAllocationMethod("Static"),
                        PublicIPAllocationMethod: network.IPAllocationMethod("Dynamic"),
                        IdleTimeoutInMinutes:     to.Int32Ptr(4),
                },
                Location: &amp;vmHandler.Region.Region,
        }

        future, err := vmHandler.PublicIPClient.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPName, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to create PublicIP, error=%s", err))
                return irs.IID{}, createErr
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.PublicIPClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to create PublicIP, error=%s", err))
                return irs.IID{}, createErr
        }</span>

        // 생성된 PublicIP 정보 리턴
        <span class="cov0" title="0">publicIPInfo, err := vmHandler.PublicIPClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPName, "")
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get PublicIP, error=%s", err))
                return irs.IID{}, getErr
        }</span>
        <span class="cov0" title="0">publicIPIId := irs.IID{NameId: *publicIPInfo.Name, SystemId: *publicIPInfo.ID}
        return publicIPIId, nil</span>
}

// VM 삭제 시 Public IP 자동 삭제 (nested flow 적용)
func DeletePublicIP(vmHandler *AzureVMHandler, vmInfo irs.VMInfo) (irs.VMStatus, error) <span class="cov0" title="0">{
        var publicIPId string
        for _, keyInfo := range vmInfo.KeyValueList </span><span class="cov0" title="0">{
                if keyInfo.Key == "publicip" </span><span class="cov0" title="0">{
                        publicIPId = keyInfo.Value
                        break</span>
                }
        }

        <span class="cov0" title="0">publicIPFuture, err := vmHandler.PublicIPClient.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = publicIPFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.PublicIPClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">return irs.Terminating, nil</span>
}

// VM 생성 시 VNic 자동 생성 (nested flow 적용)
func CreateVNic(vmHandler *AzureVMHandler, vmReqInfo irs.VMReqInfo, publicIPIId irs.IID) (irs.IID, error) <span class="cov0" title="0">{

        // VNic 이름 생성
        /*var VNicName string
        uuid, err := uuid.NewUUID()
        if err != nil {
                createErr := errors.New(fmt.Sprintf("Failed to generate UUID, error=%s", err))
                return irs.IID{}, createErr
        }*/
        //VNicName = fmt.Sprintf("%s-%s-VNic", vmReqInfo.IId.NameId, uuid)
        VNicName := fmt.Sprintf("%s-VNic", vmReqInfo.IId.NameId)

        // 리소스 Id 정보 매핑
        // Azure의 경우 VNic에 1개의 보안그룹만 할당 가능
        secGroupId := GetSecGroupIdByName(vmHandler.CredentialInfo, vmHandler.Region, vmReqInfo.SecurityGroupIIDs[0].NameId)
        subnet, err := vmHandler.SubnetClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.VpcIID.NameId, vmReqInfo.SubnetIID.NameId, "")

        var ipConfigArr []network.InterfaceIPConfiguration
        ipConfig := network.InterfaceIPConfiguration{
                Name: to.StringPtr("ipConfig1"),
                InterfaceIPConfigurationPropertiesFormat: &amp;network.InterfaceIPConfigurationPropertiesFormat{
                        Subnet:                    &amp;subnet,
                        PrivateIPAllocationMethod: "Dynamic",
                        PublicIPAddress: &amp;network.PublicIPAddress{
                                ID: to.StringPtr(publicIPIId.SystemId),
                        },
                },
        }
        ipConfigArr = append(ipConfigArr, ipConfig)

        /*
         test VM is interfacingProperties
        */

        createOpts := network.Interface{
                InterfacePropertiesFormat: &amp;network.InterfacePropertiesFormat{
                        IPConfigurations: &amp;ipConfigArr,
                        NetworkSecurityGroup: &amp;network.SecurityGroup{
                                ID: to.StringPtr(secGroupId),
                        },
                },
                Location: &amp;vmHandler.Region.Region,
        }

        future, err := vmHandler.NicClient.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, VNicName, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                return irs.IID{}, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.NicClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                return irs.IID{}, err
        }</span>

        // 생성된 VNic 정보 리턴
        <span class="cov0" title="0">VNic, err := vmHandler.NicClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, VNicName, "")
        if err != nil </span><span class="cov0" title="0">{
                return irs.IID{}, err
        }</span>
        <span class="cov0" title="0">VNicIId := irs.IID{NameId: *VNic.Name, SystemId: *VNic.ID}
        return VNicIId, nil</span>
}

// VNic 삭제 전 PublicIP 연결 해제
func DetachVNic(vmHandler *AzureVMHandler, vmInfo irs.VMInfo) (irs.VMStatus, error) <span class="cov0" title="0">{
        var ipConfigArr []network.InterfaceIPConfiguration
        ipConfig := network.InterfaceIPConfiguration{
                Name: to.StringPtr("ipConfig1"),
                InterfaceIPConfigurationPropertiesFormat: &amp;network.InterfaceIPConfigurationPropertiesFormat{
                        Subnet: &amp;network.Subnet{
                                Name: to.StringPtr(vmInfo.SubnetIID.NameId),
                                ID:   to.StringPtr(vmInfo.SubnetIID.SystemId),
                        },
                        PrivateIPAllocationMethod: "Dynamic",
                        PublicIPAddress:           nil,
                },
        }
        ipConfigArr = append(ipConfigArr, ipConfig)

        detachOpts := network.Interface{
                InterfacePropertiesFormat: &amp;network.InterfacePropertiesFormat{
                        IPConfigurations: &amp;ipConfigArr,
                },
                Location: &amp;vmHandler.Region.Region,
        }

        nicDetachFuture, err := vmHandler.NicClient.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmInfo.NetworkInterface, detachOpts)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = nicDetachFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.NicClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return irs.Terminating, nil</span>
}

// VM 삭제 시 VNic 자동 삭제 (nested flow 적용)
func DeleteVNic(vmHandler *AzureVMHandler, vmInfo irs.VMInfo) (irs.VMStatus, error) <span class="cov0" title="0">{
        nicDeleteFuture, err := vmHandler.NicClient.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmInfo.NetworkInterface)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = nicDeleteFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.NicClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">return irs.Terminating, nil</span>
}

// VM 삭제 시 VM Disk 자동 삭제 (nested flow 적용)
func DeleteVMDisk(vmHandler *AzureVMHandler, osDiskName string) (irs.VMStatus, error) <span class="cov0" title="0">{
        diskFuture, err := vmHandler.DiskClient.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, osDiskName)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = diskFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">return irs.Terminating, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package resources

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMSpec = "VMSPEC"
)

type AzureVmSpecHandler struct {
        Region idrv.RegionInfo
        Ctx    context.Context
        Client *compute.VirtualMachineSizesClient
}

func setterVmSpec(region string, vmSpec compute.VirtualMachineSize) *irs.VMSpecInfo <span class="cov0" title="0">{
        vmSpecInfo := &amp;irs.VMSpecInfo{
                Region:       region,
                Name:         *vmSpec.Name,
                VCpu:         irs.VCpuInfo{Count: strconv.FormatInt(int64(*vmSpec.NumberOfCores), 10)},
                Mem:          strconv.FormatInt(int64(*vmSpec.MemoryInMB), 10),
                Gpu:          nil,
                KeyValueList: nil,
        }
        return vmSpecInfo
}</span>

func (vmSpecHandler *AzureVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, VMSpec, "ListVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmSpecList := make([]*irs.VMSpecInfo, len(*result.Value))
        for i, spec := range *result.Value </span><span class="cov0" title="0">{
                vmSpecList[i] = setterVmSpec(Region, spec)
        }</span>
        <span class="cov0" title="0">return vmSpecList, nil</span>
}

func (vmSpecHandler *AzureVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, Name, "GetVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMSpecInfo{}, err
        }</span>

        <span class="cov0" title="0">for _, spec := range *result.Value </span><span class="cov0" title="0">{
                if Name == *spec.Name </span><span class="cov0" title="0">{
                        LoggingInfo(hiscallInfo, start)
                        vmSpecInfo := setterVmSpec(Region, spec)
                        return *vmSpecInfo, nil
                }</span>
        }

        <span class="cov0" title="0">getErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err))
        LoggingError(hiscallInfo, getErr)
        return irs.VMSpecInfo{}, getErr</span>
}

func (vmSpecHandler *AzureVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, VMSpec, "ListOrgVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var jsonResult struct {
                Result []compute.VirtualMachineSize `json:"list"`
        }
        jsonResult.Result = *result.Value
        jsonBytes, err := json.Marshal(jsonResult)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)
        return jsonString, nil</span>
}

func (vmSpecHandler *AzureVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, Name, "GetOrgVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        for _, spec := range *result.Value </span><span class="cov0" title="0">{
                if Name == *spec.Name </span><span class="cov0" title="0">{
                        jsonBytes, err := json.Marshal(spec)
                        if err != nil </span><span class="cov0" title="0">{
                                getErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err))
                                LoggingError(hiscallInfo, getErr)
                                return "", err
                        }</span>

                        <span class="cov0" title="0">jsonString := string(jsonBytes)
                        return jsonString, nil</span>
                }
        }

        <span class="cov0" title="0">notFoundErr := errors.New("failed to get VM spec")
        LoggingError(hiscallInfo, notFoundErr)
        return "", notFoundErr</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package resources

import (
        "context"
        "errors"
        "fmt"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VPC = "VPC"
)

type AzureVPCHandler struct {
        Region       idrv.RegionInfo
        Ctx          context.Context
        Client       *network.VirtualNetworksClient
        SubnetClient *network.SubnetsClient
}

func (vpcHandler *AzureVPCHandler) setterVPC(network network.VirtualNetwork) *irs.VPCInfo <span class="cov0" title="0">{
        vpcInfo := &amp;irs.VPCInfo{
                IId: irs.IID{
                        NameId:   *network.Name,
                        SystemId: *network.ID,
                },
                IPv4_CIDR:    (*network.AddressSpace.AddressPrefixes)[0],
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: vpcHandler.Region.ResourceGroup}},
        }

        subnetArr := make([]irs.SubnetInfo, len(*network.Subnets))
        for i, subnet := range *network.Subnets </span><span class="cov0" title="0">{
                subnetArr[i] = *vpcHandler.setterSubnet(subnet)
        }</span>
        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetArr

        return vpcInfo</span>
}

func (vpcHandler *AzureVPCHandler) setterSubnet(subnet network.Subnet) *irs.SubnetInfo <span class="cov0" title="0">{
        subnetInfo := &amp;irs.SubnetInfo{
                IId: irs.IID{
                        NameId:   *subnet.Name,
                        SystemId: *subnet.ID,
                },
                IPv4_CIDR:    *subnet.AddressPrefix,
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: vpcHandler.Region.ResourceGroup}},
        }
        return subnetInfo
}</span>

func (vpcHandler *AzureVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, VPC, "CreateVPC()")

        // Check VPC Exists
        vpc, _ := vpcHandler.Client.Get(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcReqInfo.IId.NameId, "")
        if vpc.ID != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("vpc with name %s already exist", vpcReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // Create VPC
        <span class="cov0" title="0">createOpts := network.VirtualNetwork{
                Name: to.StringPtr(vpcReqInfo.IId.NameId),
                VirtualNetworkPropertiesFormat: &amp;network.VirtualNetworkPropertiesFormat{
                        AddressSpace: &amp;network.AddressSpace{
                                AddressPrefixes: &amp;[]string{vpcReqInfo.IPv4_CIDR},
                        },
                },
                Location: &amp;vpcHandler.Region.Region,
        }

        start := call.Start()
        future, err := vpcHandler.Client.CreateOrUpdate(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcReqInfo.IId.NameId, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Create Subnet
        var subnetCreateOpts network.Subnet
        for _, subnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                subnetCreateOpts = network.Subnet{
                        Name: to.StringPtr(subnet.IId.NameId),
                        SubnetPropertiesFormat: &amp;network.SubnetPropertiesFormat{
                                AddressPrefix: to.StringPtr(subnet.IPv4_CIDR),
                        },
                }
                future, err := vpcHandler.SubnetClient.CreateOrUpdate(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcReqInfo.IId.NameId, subnet.IId.NameId, subnetCreateOpts)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(fmt.Sprintf("failed to create subnet with name %s", subnet.IId.NameId))
                        continue</span>
                }
                <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(fmt.Sprintf("failed to create subnet with name %s", subnet.IId.NameId))
                        continue</span>
                }
        }

        // 생성된 VNetwork 정보 리턴
        <span class="cov0" title="0">vpcInfo, err := vpcHandler.GetVPC(irs.IID{NameId: vpcReqInfo.IId.NameId})
        if err != nil </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (vpcHandler *AzureVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, VPC, "ListVPC()")

        start := call.Start()
        vpcList, err := vpcHandler.Client.List(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfoList := make([]*irs.VPCInfo, len(vpcList.Values()))
        for i, vpc := range vpcList.Values() </span><span class="cov0" title="0">{
                vpcInfoList[i] = vpcHandler.setterVPC(vpc)
        }</span>
        <span class="cov0" title="0">return vpcInfoList, nil</span>
}

func (vpcHandler *AzureVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, vpcIID.NameId, "GetVPC()")

        start := call.Start()
        vpc, err := vpcHandler.Client.Get(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId, "")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(vpc)
        return *vpcInfo, nil</span>
}

func (vpcHandler *AzureVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, vpcIID.NameId, "DeleteVPC()")

        start := call.Start()
        future, err := vpcHandler.Client.Delete(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (vpcHandler *AzureVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, subnetInfo.IId.NameId, "AddSubnet()")

        vpc, _ := vpcHandler.Client.Get(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId, "")
        if vpc.ID == nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("vpc with name %s not exist", vpcIID.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">subnetCreateOpts := network.Subnet{
                Name: to.StringPtr(subnetInfo.IId.NameId),
                SubnetPropertiesFormat: &amp;network.SubnetPropertiesFormat{
                        AddressPrefix: to.StringPtr(subnetInfo.IPv4_CIDR),
                },
        }
        future, err := vpcHandler.SubnetClient.CreateOrUpdate(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, *vpc.Name, subnetInfo.IId.NameId, subnetCreateOpts)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to create subnet with name %s", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to create subnet with name %s", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">result, err := vpcHandler.GetVPC(irs.IID{NameId: vpcIID.NameId})
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to create subnet with name %s", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (vpcHandler *AzureVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        future, err := vpcHandler.SubnetClient.Delete(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId, subnetIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package cloudit

import (
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        cicon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/connect"
        cirs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type ClouditDriver struct{}

func (ClouditDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "CLOUDIT DRIVER Version 1.0"
}</span>

func (ClouditDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = false
        drvCapabilityInfo.VPCHandler = false
        drvCapabilityInfo.SecurityHandler = false
        drvCapabilityInfo.KeyPairHandler = false
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true

        return drvCapabilityInfo
}</span>

func (driver *ClouditDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        // Initialize Logger
        cirs.InitLog()

        Client, err := getServiceClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := cicon.ClouditCloudConnection{
                CredentialInfo: connectionInfo.CredentialInfo,
                Client:         *Client,
        }

        return &amp;iConn, nil</span>
}

func getServiceClient(connInfo idrv.ConnectionInfo) (*client.RestClient, error) <span class="cov0" title="0">{
        restClient := client.RestClient{
                IdentityBase:   connInfo.CredentialInfo.IdentityEndpoint,
                ClouditVersion: "v4.0",
                TenantID:       connInfo.CredentialInfo.TenantId,
        }
        return &amp;restClient, nil
}</span>

var CloudDriver ClouditDriver
</pre>
		
		<pre class="file" id="file69" style="display: none">package client

import (
        "bytes"
        "encoding/json"
        "fmt"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
        "io"
        "io/ioutil"
        "net/http"
        "strings"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

// DefaultUserAgent is the default User-Agent string set in the request header.
const (
        DefaultUserAgent = "cloudit/1.0.0"
)

// ClouditEngine is type of cloud service in cloudit
type ClouditEngine string

const (
        IAM ClouditEngine = "iam"
        ACE ClouditEngine = "ace"
        DNA ClouditEngine = "dna"
)

// UserAgent represents a User-Agent header.
type UserAgent struct {
        // prepend is the slice of User-Agent strings to prepend to DefaultUserAgent.
        // All the strings to prepend are accumulated and prepended in the Join method.
        prepend []string
}

// Prepend prepends a user-defined string to the default User-Agent string. Users
// may pass in one or more strings to prepend.
func (ua *UserAgent) Prepend(s ...string) <span class="cov0" title="0">{
        ua.prepend = append(s, ua.prepend...)
}</span>

// Join concatenates all the user-defined User-Agend strings with the default
func (ua *UserAgent) Join() string <span class="cov0" title="0">{
        uaSlice := append(ua.prepend, DefaultUserAgent)
        return strings.Join(uaSlice, " ")
}</span>

type RestClient struct {
        // IdentityBase is the base URL used for a particular provider's identity
        // service - it will be used when issuing authenticatation requests. It
        // should point to the root resource of the identity service, not a specific
        // identity version.
        IdentityBase string

        // IdentityEndpoint is the identity endpoint. This may be a specific version
        // of the identity service. If this is the case, this endpoint is used rather
        // than querying versions first.
        IdentityEndpoint string

        // ClouditVersion
        ClouditVersion string

        // TenantId for Cloudit User
        TenantID string

        // TokenID is the ID of the most recently issued valid token.
        TokenID string

        // HTTPClient allows users to interject arbitrary http, https, or other transit behaviors.
        HTTPClient http.Client

        // UserAgent represents the User-Agent header in the HTTP request.
        UserAgent UserAgent

        // ReauthFunc is the function used to re-authenticate the user if the request
        // fails with a 401 HTTP response code. This a needed because there may be multiple
        // authentication functions for different Identity service versions.
        ReauthFunc func() error
}

// AuthenticatedHeaders returns a map of HTTP headers that are common for all
// authenticated service requests.
func (client *RestClient) AuthenticatedHeaders() map[string]string <span class="cov0" title="0">{
        if client.TokenID == "" </span><span class="cov0" title="0">{
                return map[string]string{}
        }</span>
        <span class="cov0" title="0">return map[string]string{"X-Auth-Token": client.TokenID}</span>
}

// RequestOpts customizes the behavior of the provider.Request() method.
type RequestOpts struct {
        // JSONBody, if provided, will be encoded as JSON and used as the body of the HTTP request. The
        // content type of the request will default to "application/json" unless overridden by MoreHeaders.
        // It's an error to specify both a JSONBody and a RawBody.
        JSONBody interface{}
        // RawBody contains an io.ReadSeeker that will be consumed by the request directly. No content-type
        // will be set unless one is provided explicitly by MoreHeaders.
        RawBody io.ReadSeeker

        // JSONResponse, if provided, will be populated with the contents of the response body parsed as
        // JSON.
        JSONResponse interface{}
        // OkCodes contains a list of numeric HTTP status codes that should be interpreted as success. If
        // the response has a different code, an error will be returned.
        OkCodes []int

        // MoreHeaders specifies additional HTTP headers to be provide on the request. If a header is
        // provided with a blank value (""), that header will be *omitted* instead: use this to suppress
        // the default Accept header or an inferred Content-Type, for example.
        MoreHeaders map[string]string
}

type Result struct {
        // Body is the payload of the HTTP response from the server. In most cases,
        // this will be the deserialized JSON structure.
        Body interface{}

        // Header contains the HTTP header structure from the original response.
        Header http.Header

        // Err is an error that occurred during the operation. It's deferred until
        // extraction to make it easier to chain the Extract call.
        Err error
}

func (opts *RequestOpts) setBody(body interface{}) <span class="cov0" title="0">{
        if v, ok := (body).(io.ReadSeeker); ok </span><span class="cov0" title="0">{
                opts.RawBody = v
        }</span> else<span class="cov0" title="0"> if body != nil </span><span class="cov0" title="0">{
                opts.JSONBody = body
        }</span>
}

// UnexpectedResponseCodeError is returned by the Request method when a response code other than
// those listed in OkCodes is encountered.
type UnexpectedResponseCodeError struct {
        URL      string
        Method   string
        Expected []int
        Actual   int
        Body     []byte
}

func (err *UnexpectedResponseCodeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Expected HTTP response code %v when accessing [%s %s], but got %d instead\n%s",
                err.Expected, err.Method, err.URL, err.Actual, err.Body,
        )
}</span>

var applicationJSON = "application/json"

// Request performs an HTTP request using the RestClient's current HTTPClient. An authentication
// header will automatically be provided.
func (client *RestClient) Request(method, url string, options RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        var body io.ReadSeeker
        var contentType *string

        // Derive the content body by either encoding an arbitrary object as JSON, or by taking a provided
        // io.ReadSeeker as-is. Default the content-type to application/json.
        if options.JSONBody != nil </span><span class="cov0" title="0">{
                if options.RawBody != nil </span><span class="cov0" title="0">{
                        cblogger.Error("Please provide only one of JSONBody or RawBody to cloudit.Request().")
                }</span>

                <span class="cov0" title="0">rendered, err := json.Marshal(options.JSONBody)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">body = bytes.NewReader(rendered)
                contentType = &amp;applicationJSON</span>
        }

        <span class="cov0" title="0">if options.RawBody != nil </span><span class="cov0" title="0">{
                body = options.RawBody
        }</span>

        // Construct the http.Request.
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Populate the request headers. Apply options.MoreHeaders last, to give the caller the chance to
        // modify or omit any header.
        <span class="cov0" title="0">if contentType != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", *contentType)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", applicationJSON)

        for k, v := range client.AuthenticatedHeaders() </span><span class="cov0" title="0">{
                req.Header.Add(k, v)
        }</span>

        // Set the User-Agent header
        <span class="cov0" title="0">req.Header.Set("User-Agent", client.UserAgent.Join())

        if options.MoreHeaders != nil </span><span class="cov0" title="0">{
                for k, v := range options.MoreHeaders </span><span class="cov0" title="0">{
                        if v != "" </span><span class="cov0" title="0">{
                                req.Header.Set(k, v)
                        }</span> else<span class="cov0" title="0"> {
                                req.Header.Del(k)
                        }</span>
                }
        }

        // Set connection parameter to close the connection immediately when we've got the response
        <span class="cov0" title="0">req.Close = true

        // Issue the request.
        resp, err := client.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                if client.ReauthFunc != nil </span><span class="cov0" title="0">{
                        err = client.ReauthFunc()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error trying to re-authenticate: %s", err)
                        }</span>
                        <span class="cov0" title="0">if options.RawBody != nil </span><span class="cov0" title="0">{
                                options.RawBody.Seek(0, 0)
                        }</span>
                        <span class="cov0" title="0">resp.Body.Close()
                        resp, err = client.Request(method, url, options)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Successfully re-authenticated, but got error executing request: %s", err)
                        }</span>

                        <span class="cov0" title="0">return resp, nil</span>
                }
        }

        // Allow default OkCodes if none explicitly set
        <span class="cov0" title="0">if options.OkCodes == nil </span><span class="cov0" title="0">{
                options.OkCodes = defaultOkCodes(method)
        }</span>

        // Validate the HTTP response status.
        <span class="cov0" title="0">var ok bool
        for _, code := range options.OkCodes </span><span class="cov0" title="0">{
                if resp.StatusCode == code </span><span class="cov0" title="0">{
                        ok = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                body, _ := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                return resp, &amp;UnexpectedResponseCodeError{
                        URL:      url,
                        Method:   method,
                        Expected: options.OkCodes,
                        Actual:   resp.StatusCode,
                        Body:     body,
                }
        }</span>

        // Parse the response body as JSON, if requested to do so.
        <span class="cov0" title="0">if options.JSONResponse != nil </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                if err := json.NewDecoder(resp.Body).Decode(options.JSONResponse); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

func defaultOkCodes(method string) []int <span class="cov0" title="0">{
        switch </span>{
        case method == "GET":<span class="cov0" title="0">
                return []int{200}</span>
        case method == "POST":<span class="cov0" title="0">
                return []int{201, 202}</span>
        case method == "PUT":<span class="cov0" title="0">
                return []int{201, 202}</span>
        case method == "PATCH":<span class="cov0" title="0">
                return []int{200, 204}</span>
        case method == "DELETE":<span class="cov0" title="0">
                return []int{202, 204}</span>
        }

        <span class="cov0" title="0">return []int{}</span>
}

func (client *RestClient) Get(url string, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>
        <span class="cov0" title="0">if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>
        <span class="cov0" title="0">return client.Request("GET", url, *opts)</span>
}

func (client *RestClient) Post(url string, body interface{}, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">opts.setBody(body)

        if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>

        <span class="cov0" title="0">return client.Request("POST", url, *opts)</span>
}

func (client *RestClient) Put(url string, body interface{}, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">opts.setBody(body)

        if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>

        <span class="cov0" title="0">return client.Request("PUT", url, *opts)</span>
}

func (client *RestClient) Patch(url string, JSONBody interface{}, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">if v, ok := (JSONBody).(io.ReadSeeker); ok </span><span class="cov0" title="0">{
                opts.RawBody = v
        }</span> else<span class="cov0" title="0"> if JSONBody != nil </span><span class="cov0" title="0">{
                opts.JSONBody = JSONBody
        }</span>

        <span class="cov0" title="0">if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>

        <span class="cov0" title="0">return client.Request("PATCH", url, *opts)</span>
}

func (client *RestClient) Delete(url string, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">return client.Request("DELETE", url, *opts)</span>
}

func (r Result) ExtractInto(to interface{}) error <span class="cov0" title="0">{
        if reader, ok := r.Body.(io.Reader); ok </span><span class="cov0" title="0">{
                if readCloser, ok := reader.(io.Closer); ok </span><span class="cov0" title="0">{
                        defer readCloser.Close()
                }</span>
                <span class="cov0" title="0">return json.NewDecoder(reader).Decode(to)</span>
        }

        <span class="cov0" title="0">b, err := json.Marshal(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(b, to)

        return err</span>
}

func (client *RestClient) CreateRequestBaseURL(engine ClouditEngine, parts ...string) string <span class="cov0" title="0">{
        engineName := fmt.Sprint(engine)
        baseURL := strings.Join([]string{client.IdentityBase, "cloudit", client.ClouditVersion, engineName, "v1.0", client.TenantID}, "/")
        customURI := strings.Join(parts, "/")
        return baseURL + "/" + customURI
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package image

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type ImageReqInfo struct {
        Name         string `json:"name" required:"true"`
        VolumeId     string `json:"volumeId" required:"true"`   // 정지된 서버 볼륨을 기준으로 이미지 템플릿 생성
        SnapshotId   string `json:"snapshotId" required:"true"` // 서버 스냅샷을 기준으로 이미지 템플릿 생성
        Ownership    string `json:"ownership" required:"true"`  // TENANT, PRIVATE
        Format       string `json:"format" required:"true"`     // raw, vdi, vmdk, vpc, qcow2
        SourceType   string `json:"sourceType" required:"true"` // server, snapshot
        TemplateType string `json:"templateType" required:"true"`
        Size         int    `json:"size" required:"false"`
        PoolId       string `json:"poolId" required:"false"`
        Protection   int    `json:"protection" required:"false"`
}

type ImageInfo struct {
        ID            string
        TenantID      string
        ClusterID     string
        ClusterName   string
        Size          int
        RealSize      int
        RefCount      int
        Name          string
        CreatedAt     string
        Ownership     string // 테넌트 소유, 개인 소유
        TemplateType  string
        State         string
        Protection    int
        OS            string
        Arch          string // Architecture
        Format        string
        Enabled       int
        Description   string
        PoolID        string
        PoolName      string
        SnapshotID    string
        Creator       string
        VolumeID      string
        Url           string
        Pause         int
        SourceType    string
        MinKvmVersion int
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]ImageInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var image []ImageInfo
        if err := result.ExtractInto(&amp;image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;image, nil</span>
}

func Get(restClient *client.RestClient, templateId string, requestOpts *client.RequestOpts) (*ImageInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates", templateId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var image ImageInfo
        if err := result.ExtractInto(&amp;image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;image, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*ImageInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var image ImageInfo
        if err := result.ExtractInto(&amp;image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;image, nil</span>
}

func Delete(restClient *client.RestClient, templateId string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates", templateId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package nic

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type VNicReqInfo struct {
        SubnetAddr string                             `json:"subnetAddr" required:"true"`
        VmId       string                             `json:"vmId" required:"true"`
        Type       string                             `json:"type" required:"true"`
        Secgroups  []securitygroup.SecurityGroupRules `json:"secgroups" required:"true"`
        IP         string                             `json:"ip" required:"true"`
}

type VmNicInfo struct {
        TenantId        string
        VmId            string
        Type            string
        Mac             string
        Dev             string
        Ip              string
        SubnetAddr      string
        Creator         string
        CreatedAt       string
        VmName          string
        NetworkName     string
        AdaptiveIp      string
        State           string
        Template        string
        SpecName        string
        CpuNum          string
        MemSize         string
        VolumeSize      string
        Qos             int
        SecGroups       []SecurityGroupInfo `json:"secgroupMapInfo"`
        AdaptiveMapInfo interface{}
}

type SecurityGroupInfo struct {
        Id         string `json:"secgroup_id"`
        Name       string
        TenantId   string `json:"tenant_id"`
        State      string
        Mac        string
        Protection int
}

func List(restClient *client.RestClient, serverId string, requestOpts *client.RequestOpts) (*[]VmNicInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var nic []VmNicInfo
        if err := result.ExtractInto(&amp;nic); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;nic, nil</span>
}

func Get(restClient *client.RestClient, serverId string, macAddr string, requestOpts *client.RequestOpts) (*VmNicInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics", macAddr)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var nic VmNicInfo
        if err := result.ExtractInto(&amp;nic); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;nic, nil</span>
}

func Create(restClient *client.RestClient, serverId string, requestOpts *client.RequestOpts) (*VmNicInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics")

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var nicInfo VmNicInfo
        if err := result.ExtractInto(&amp;nicInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov0" title="0"> {
                return &amp;nicInfo, nil
        }</span>

}
func Delete(restClient *client.RestClient, serverId string, macAddr string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics", macAddr)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// updateNIC
func Put(restClient *client.RestClient, serverId string, requestOpts *client.RequestOpts, nicMac string) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nic", nicMac, "securitygroup")
        cblogger.Info(requestURL)

        var result client.Result
        _, _ = restClient.Put(requestURL, nil, &amp;result.Body, requestOpts)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package server

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type SecGroupInfo struct {
        Id string `json:"id" required:"true"`
}

type VMReqInfo struct {
        TemplateId   string         `json:"templateId" required:"true"`
        SpecId       string         `json:"specId" required:"true"`
        Name         string         `json:"name" required:"true"`
        HostName     string         `json:"hostName" required:"true"`
        RootPassword string         `json:"rootPassword" required:"true"`
        SubnetAddr   string         `json:"subnetAddr" required:"true"`
        Secgroups    []SecGroupInfo `json:"secgroups" required:"true"`
        Description  int            `json:"description" required:"false"`
        Protection   int            `json:"protection" required:"false"`
}

type ServerInfo struct {
        VolumeInfoList interface{}
        VmNicInfoList  interface{}
        NicMapInfo     []struct {
                Name    string
                Count   int
                Address string `json:"addr"`
        }
        PoolMapInfo []struct {
                Name       string
                Count      int
                PoolID     string `json:"pool_id"`
                FileSystem string
        }
        AdaptiveIpMapInfo []struct {
                IP        string
                Count     int
                PrivateIP string `json:"private_ip"`
        }
        ID                string
        TenantID          string
        CpuNum            float32
        MemSize           float32
        VncPort           int
        RepeaterPort      int
        State             string
        NodeIp            string
        NodeHostName      string
        Name              string
        Protection        int
        CreatedAt         string
        IsoId             string
        IsoPath           string
        Iso               string
        Template          string
        TemplateID        string
        OsType            string
        RootPassword      string
        HostName          string
        Creator           string
        VolumeId          string
        VolumeSize        int
        VolumeMode        string
        MacAddr           string
        Spec              string
        SpecId            string
        Pool              string
        PoolId            string
        Cycle             int
        Metric            int
        MigrationPort     int
        MigrationIp       string
        Cloudinit         bool
        DeleteVolume      bool
        ServerCount       int
        PrivateIp         string
        AdaptiveIp        string
        InitCloud         int
        ClusterId         string
        ClusterName       string
        NicType           string
        Secgroups         []securitygroup.SecurityGroupInfo
        Ip                string
        SubnetAddr        string
        DeviceId          string
        Gpu               string
        GpuCount          int
        GpuId             string
        Description       string
        DiskSize          int
        DiskCount         int
        IsoInsertedAt     string
        Puppet            int
        SshKeyName        string
        SshPublicKey      string
        TemplateOwnership string
        TemplateType      string
        VmStatInfo        string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]ServerInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var server []ServerInfo
        if err := result.ExtractInto(&amp;server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;server, nil</span>
}

func Get(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) (*ServerInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id)
        cblogger.Info(requestURL)

        var result client.Result
        _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts)

        var server ServerInfo
        if err := result.ExtractInto(&amp;server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;server, nil</span>
}

// create
func Start(restClient *client.RestClient, requestOpts *client.RequestOpts) (*ServerInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var server ServerInfo
        if err := result.ExtractInto(&amp;server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;server, nil</span>
}

//shutdown
func Suspend(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id, "shutdown")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, nil, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//start
func Resume(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id, "start")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, nil, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//reboot
func Reboot(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id, "reboot")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, nil, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//delete
func Terminate(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package specs

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type VMSpecInfo struct {
        Id      string `json:"id" required:"true"`
        Name    string `json:"name" required:"true"`
        Cpu     int    `json:"cpu" required:"true"`
        Mem     int    `json:"mem" required:"true"`
        Disk    int    `json:"disk" required:"true"`
        GPU     int    `json:"gpu" required:"true"`
        Enabled int    `json:"enabled" required:"true"`
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]VMSpecInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "specs")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var spec []VMSpecInfo
        if err := result.ExtractInto(&amp;spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;spec, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package adaptiveip

import (
        //"fmt"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type PublicIPReqInfo struct {
        IP         string `json:"ip" required:"true"`
        Name       string `json:"name" required:"true"`
        PrivateIP  string `json:"privateIp" required:"true"` // PublicIP가 적용되는 VM의 Private IP
        Protection int    `json:"protection" required:"false"`
}

type IPInfo struct {
        IP      string `json:"addr"`
        gateway string
        prefix  string
        state   string
        netmask string
}

type AdaptiveIPInfo struct {
        ID          string
        IP          string
        Name        string
        Rules       interface{}
        TenantId    string
        Creator     string
        State       string
        CreatedAt   string
        PrivateIp   string
        Protection  int
        RuleCount   int
        VmName      string
        Description string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]AdaptiveIPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var adaptiveIP []AdaptiveIPInfo
        if err := result.ExtractInto(&amp;adaptiveIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;adaptiveIP, nil</span>
}

func ListAvailableIP(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]IPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "ips")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var availableIP []IPInfo
        if err := result.ExtractInto(&amp;availableIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;availableIP, nil</span>
}

func Get(restClient *client.RestClient, adaptiveIPId string, requestOpts *client.RequestOpts) (*AdaptiveIPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips", adaptiveIPId, "detail")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var adaptiveIP AdaptiveIPInfo
        if err := result.ExtractInto(&amp;adaptiveIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;adaptiveIP, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*AdaptiveIPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips")
        cblogger.Info(requestURL)

        var result client.Result

        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var adaptiveIP AdaptiveIPInfo
        if err := result.ExtractInto(&amp;adaptiveIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;adaptiveIP, nil</span>
}

func Delete(restClient *client.RestClient, adaptiveIP string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips", adaptiveIP)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package subnet

import (
        //"fmt"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type VNetworkReqInfo struct {
        Name       string `json:"name" required:"true"`
        Addr       string `json:"addr" required:"true"`
        Prefix     string `json:"prefix" required:"true"`
        Gateway    string `json:"gateway" required:"false"`
        Protection int    `json:"protection" required:"false"`
}

type SubnetInfo struct {
        ID          string
        TenantId    string
        Addr        string
        Prefix      string
        Gateway     string
        Creator     string
        Protection  int
        Name        string
        State       string
        Vlan        int
        CreatedAt   string
        NicCount    int
        Description string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet []SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func ListCreatableSubnet(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets", "creatable")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet []SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func Get(restClient *client.RestClient, subnetId string, requestOpts *client.RequestOpts) (*SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, subnetId, "detail")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets")
        cblogger.Info(requestURL)

        var result client.Result

        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func Delete(restClient *client.RestClient, addr string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets", addr)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package securitygroup

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type SecurityReqInfo struct {
        Name       string               `json:"name" required:"true"`
        Rules      []SecurityGroupRules `json:"rules" required:"false"`
        Protection int                  `json:"protection" required:"false"`
}

type SecurityGroupRules struct {
        ID         string `json:"id"`
        SecGroupID string `json:"secgroupId"`
        Name       string `json:"name"`
        Type       string `json:"type"`
        Port       string `json:"port"`
        Target     string `json:"target"`
        Protocol   string `json:"protocol"`
        Creator    string `json:"creator"`
        CreatedAt  string `json:"createdAt"`
}

type SecurityGroupInfo struct {
        ID          string
        Name        string
        TenantID    string
        Creator     string
        State       string
        CreatedAt   string
        Protection  int
        Rules       []SecurityGroupRules
        RulesCount  int
        Description string
        AsID        string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]SecurityGroupInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup []SecurityGroupInfo
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func ListRule(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) (*[]SecurityGroupRules, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var sgRules []SecurityGroupRules
        if err := result.ExtractInto(&amp;sgRules); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sgRules, nil</span>
}

func Get(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) (*SecurityGroupInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId, "detail")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup SecurityGroupInfo
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*SecurityGroupInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup SecurityGroupInfo
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func Delete(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ListRulesinSG(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) (*[]SecurityGroupRules, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup []SecurityGroupRules
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func AddRule(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts, rule string) (*SecurityGroupRules, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId, rule)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup SecurityGroupRules
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func DeleteRule(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts, ruleID string) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId, ruleID)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.com, 2019.08.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        cirs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type ClouditCloudConnection struct {
        CredentialInfo idrv.CredentialInfo
        Client         client.RestClient
}

func (cloudConn *ClouditCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateImageHandler()!")
        imageHandler := cirs.ClouditImageHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *ClouditCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateVNetworkHandler()!")
        vNetHandler := cirs.ClouditVPCHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;vNetHandler, nil
}</span>

func (cloudConn ClouditCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateSecurityHandler()!")
        securityHandler := cirs.ClouditSecurityHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;securityHandler, nil
}</span>

func (cloudConn *ClouditCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := cirs.ClouditKeyPairHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;keypairHandler, nil
}</span>

/*func (cloudConn ClouditCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Cloudit Cloud Driver: called CreateVNicHandler()!")
        vNicHandler := cirs.ClouditNicHandler{cloudConn.CredentialInfo, &amp;cloudConn.Client}
        return &amp;vNicHandler, nil
}*/

/*func (cloudConn ClouditCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Cloudit Cloud Driver: called CreatePublicIPHandler()!")
        publicIPHandler := cirs.ClouditPublicIPHandler{cloudConn.CredentialInfo, &amp;cloudConn.Client}
        return &amp;publicIPHandler, nil
}*/

func (cloudConn *ClouditCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateVMHandler()!")
        vmHandler := cirs.ClouditVMHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *ClouditCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := cirs.ClouditVMSpecHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;vmSpecHandler, nil
}</span>

func (ClouditCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (ClouditCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package resources

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/bramvdbogaerde/go-scp"
        "github.com/bramvdbogaerde/go-scp/auth"
        cblog "github.com/cloud-barista/cb-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        "github.com/sirupsen/logrus"
        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/nic"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/specs"
)

const (
        CBVMUser      = "cb-user"
        CBKeyPairPath = "/cloud-driver-libs/.ssh-cloudit/"
)

var once sync.Once
var cblogger *logrus.Logger
var calllogger *logrus.Logger

func InitLog() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                // cblog is a global variable.
                cblogger = cblog.GetLogger("CB-SPIDER")
                calllogger = call.GetLogger("HISCALL")
        }</span>)
}

func LoggingError(hiscallInfo call.CLOUDLOGSCHEMA, err error) <span class="cov0" title="0">{
        cblogger.Error(err.Error())
        hiscallInfo.ErrorMSG = err.Error()
        calllogger.Info(call.String(hiscallInfo))
}</span>

func LoggingInfo(hiscallInfo call.CLOUDLOGSCHEMA, start time.Time) <span class="cov0" title="0">{
        hiscallInfo.ElapsedTime = call.Elapsed(start)
        calllogger.Info(call.String(hiscallInfo))
}</span>

func GetCallLogScheme(endpoint string, resourceType call.RES_TYPE, resourceName string, apiName string) call.CLOUDLOGSCHEMA <span class="cov0" title="0">{
        cblogger.Info(fmt.Sprintf("Call %s %s", call.CLOUDIT, apiName))
        return call.CLOUDLOGSCHEMA{
                CloudOS:      call.CLOUDIT,
                RegionZone:   endpoint,
                ResourceType: resourceType,
                ResourceName: resourceName,
                CloudOSAPI:   apiName,
        }
}</span>

// VM Spec 정보 조회
func GetVMSpecByName(authHeader map[string]string, reqClient *client.RestClient, specName string) (*string, error) <span class="cov0" title="0">{
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        specList, err := specs.List(reqClient, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(fmt.Sprintf("failed to get security group list, err : %s", err))
                return nil, err
        }</span>

        <span class="cov0" title="0">specInfo := specs.VMSpecInfo{}
        for _, s := range *specList </span><span class="cov0" title="0">{
                if strings.EqualFold(specName, s.Name) </span><span class="cov0" title="0">{
                        specInfo = s
                        break</span>
                }
        }

        // VM Spec 정보가 없을 경우 에러 리턴
        <span class="cov0" title="0">if specInfo.Id == "" </span><span class="cov0" title="0">{
                cblogger.Error(fmt.Sprintf("failed to get image, err : %s", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;specInfo.Id, nil</span>
}

// VNic 목록 조회
func ListVNic(authHeader map[string]string, reqClient *client.RestClient, vmId string) (*[]nic.VmNicInfo, error) <span class="cov0" title="0">{
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        vNicList, err := nic.List(reqClient, vmId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return vNicList, nil</span>
}

// KeyPair 해시 생성 함수
func CreateHashString(credentialInfo idrv.CredentialInfo) (string, error) <span class="cov0" title="0">{
        keyString := credentialInfo.IdentityEndpoint + credentialInfo.AuthToken + credentialInfo.TenantId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}

// Public KeyPair 정보 가져오기
func GetPublicKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"
        publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(publicKeyBytes), nil</span>
}

func GetSSHClient(serverIp string, serverPort int, username string, password string) (scp.Client, error) <span class="cov0" title="0">{
        clientConfig, err := auth.PasswordKey(username, password, ssh.InsecureIgnoreHostKey())
        if err != nil </span><span class="cov0" title="0">{
                return scp.Client{}, err
        }</span>
        <span class="cov0" title="0">sshClient := scp.NewClient(fmt.Sprintf("%s:%d", serverIp, serverPort), &amp;clientConfig)
        err = sshClient.Connect()
        return sshClient, err</span>
}

func RunCommand(serverIp string, serverPort int, username string, password string, command string) (string, error) <span class="cov0" title="0">{
        clientConfig, err := auth.PasswordKey(username, password, ssh.InsecureIgnoreHostKey())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">sshClient := scp.NewClient(fmt.Sprintf("%s:%d", serverIp, serverPort), &amp;clientConfig)
        err = sshClient.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer sshClient.Close()

        session := sshClient.Session
        sshOut, err := session.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">session.Stderr = os.Stderr

        err = session.Run(command)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return "", err
        }</span>
        <span class="cov0" title="0">defer session.Close()
        return stdoutToString(sshOut), err</span>
}

func stdoutToString(sshOut io.Reader) string <span class="cov0" title="0">{
        buf := make([]byte, 1000)
        num, err := sshOut.Read(buf)
        outStr := ""
        if err == nil </span><span class="cov0" title="0">{
                outStr = string(buf[:num])
        }</span>
        <span class="cov0" title="0">for err == nil </span><span class="cov0" title="0">{
                num, err = sshOut.Read(buf)
                outStr += string(buf[:num])
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span>{<span class="cov0" title="0">
                                //cblog.Error(err)
                        }</span>
                }

        }
        <span class="cov0" title="0">return strings.Trim(outStr, "\n")</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/image"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Image = "IMAGE"
)

type ClouditImageHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func setterImage(image image.ImageInfo) *irs.ImageInfo <span class="cov0" title="0">{
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   image.Name,
                        SystemId: image.ID,
                },
                GuestOS: image.OS,
                Status:  image.State,
        }
        return imageInfo
}</span>

func (imageHandler *ClouditImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageReqInfo.IId.NameId, "CreateImage()")

        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        reqInfo := image.ImageReqInfo{
                Name:         imageReqInfo.IId.NameId,
                VolumeId:     "fa4bb8d7-bf09-4fd7-b123-d08677ac0691",
                SnapshotId:   "dbc61213-b37e-4cc2-94ca-47991337e36f",
                Ownership:    "TENANT",
                Format:       "qcow2",
                SourceType:   "server",
                TemplateType: "DEFAULT",
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        // Create Image
        start := call.Start()
        image, err := image.Create(imageHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageInfo := setterImage(*image)
        return *imageInfo, nil</span>
}

func (imageHandler *ClouditImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, Image, "ListImage()")

        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        imageList, err := image.List(imageHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        resultList := make([]*irs.ImageInfo, len(*imageList))
        for i, vmImage := range *imageList </span><span class="cov0" title="0">{
                imageInfo := setterImage(vmImage)
                resultList[i] = imageInfo
        }</span>
        <span class="cov0" title="0">return resultList, nil</span>
}

func (imageHandler *ClouditImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "GetImage()")

        start := call.Start()
        imageInfo, err := imageHandler.getImageByName(imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return *imageInfo, nil</span>
}

func (imageHandler *ClouditImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "DeleteImage()")

        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := image.Delete(imageHandler.Client, imageIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (imageHandler *ClouditImageHandler) getImageByName(imageName string) (*irs.ImageInfo, error) <span class="cov0" title="0">{
        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        imageList, err := image.List(imageHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var imageInfo *irs.ImageInfo
        for _, image := range *imageList </span><span class="cov0" title="0">{
                if strings.EqualFold(image.Name, imageName) </span><span class="cov0" title="0">{
                        imageInfo = setterImage(image)
                        break</span>
                }
        }

        <span class="cov0" title="0">if imageInfo == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find image with name %s", imageName))
                return nil, err
        }</span>
        <span class="cov0" title="0">return imageInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package resources

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        KeyPair = "KEYPAIR"
)

type ClouditKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func (keyPairHandler *ClouditKeyPairHandler) CheckKeyPairFolder(folderPath string) error <span class="cov0" title="0">{
        // Check KeyPair Folder Exists
        if _, err := os.Stat(folderPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.MkdirAll(folderPath, 0700); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyPairReqInfo.IId.NameId, "CreateKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">savePrivateFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId
        savePublicFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pub"
        bitSize := 4096

        // Check KeyPair Exists
        if _, err := os.Stat(savePrivateFileTo); err == nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("KeyPair with name %s already exist", keyPairReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                cblogger.Error(createErr.Error())
                hiscallInfo.ErrorMSG = createErr.Error()
                calllogger.Info(call.String(hiscallInfo))
                return irs.KeyPairInfo{}, createErr
        }</span>

        <span class="cov0" title="0">start := call.Start()

        // 지정된 바이트크기의 RSA 형식 개인키(비공개키)를 만듬
        privateKey, err := generatePrivateKey(bitSize)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 개인키를 RSA에서 PEM 형식으로 인코딩
        <span class="cov0" title="0">privateKeyBytes := encodePrivateKeyToPEM(privateKey)

        // rsa.PublicKey를 가져와서 .pub 파일에 쓰기 적합한 바이트로 변환
        // "ssh-rsa ..."형식으로 변환
        publicKeyBytes, err := generatePublicKey(&amp;privateKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 private Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile(privateKeyBytes, savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 public Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile([]byte(publicKeyBytes), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairReqInfo.IId.NameId,
                        SystemId: keyPairReqInfo.IId.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keyPairInfo, nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, KeyPair, "ListKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var keyPairInfoList []*irs.KeyPairInfo

        start := call.Start()

        files, err := ioutil.ReadDir(keyPairPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), ".pub") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.Contains(f.Name(), hashString) </span><span class="cov0" title="0">{
                        fileNameArr := strings.Split(f.Name(), "--")
                        keypairInfo, err := keyPairHandler.GetKey(irs.IID{NameId: fileNameArr[1]})
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keyPairInfoList = append(keyPairInfoList, &amp;keypairInfo)</span>
                }
        }

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return keyPairInfoList, nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "GetKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)

        privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key 파일 정보 가져오기
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keypairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyIID.NameId,
                        SystemId: keyIID.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keypairInfo, nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "DeleteKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key 삭제
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

// 지정된 바이트크기의 RSA 형식 개인키(비공개키)를 만듬
func generatePrivateKey(bitSize int) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        // Private Key 생성
        privateKey, err := rsa.GenerateKey(rand.Reader, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Private Key 확인
        <span class="cov0" title="0">err = privateKey.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Private Key generated(생성)")
        //fmt.Println(privateKey)
        return privateKey, nil</span>
}

// 개인키를 RSA에서 PEM 형식으로 인코딩
func encodePrivateKeyToPEM(privateKey *rsa.PrivateKey) []byte <span class="cov0" title="0">{
        // Get ASN.1 DER format
        privDER := x509.MarshalPKCS1PrivateKey(privateKey)

        // pem.Block
        privBlock := pem.Block{
                Type:    "RSA PRIVATE KEY",
                Headers: nil,
                Bytes:   privDER,
        }

        // Private key in PEM format
        privatePEM := pem.EncodeToMemory(&amp;privBlock)
        fmt.Println("privateKey Rsa -&gt; Pem 형식으로 변환")
        //fmt.Println(privatePEM)
        return privatePEM
}</span>

// rsa.PublicKey를 가져와서 .pub 파일에 쓰기 적합한 바이트로 변환
// "ssh-rsa ..."형식으로 변환
func generatePublicKey(privatekey *rsa.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        publicRsaKey, err := ssh.NewPublicKey(privatekey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pubKeyBytes := ssh.MarshalAuthorizedKey(publicRsaKey)

        log.Println("Public key 생성")
        //fmt.Println(pubKeyBytes)
        return pubKeyBytes, nil</span>
}

// 파일에 Key를 쓴다
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key 저장위치: %s", saveFileTo)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        SecurityGroup = "SECURITYGROUP"
        NULL          = ""
        DefaultCIDR   = "0.0.0.0/0"
        DefaultPort   = "0"
)

type ClouditSecurityHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func setterSecGroup(secGroup securitygroup.SecurityGroupInfo) *irs.SecurityInfo <span class="cov0" title="0">{

        secInfo := &amp;irs.SecurityInfo{
                IId: irs.IID{
                        NameId:   secGroup.Name,
                        SystemId: secGroup.ID,
                },
                VpcIID: irs.IID{
                        NameId:   defaultVPCName,
                        SystemId: defaultVPCName,
                },
                SecurityRules: nil,
        }

        secRuleArr := make([]irs.SecurityRuleInfo, len(secGroup.Rules))
        for i, sgRule := range secGroup.Rules </span><span class="cov0" title="0">{
                secRuleInfo := irs.SecurityRuleInfo{
                        IPProtocol: sgRule.Protocol,
                        Direction:  sgRule.Type,
                        CIDR:       sgRule.Target,
                }
                if strings.Contains(sgRule.Port, "-") </span><span class="cov0" title="0">{
                        portArr := strings.Split(sgRule.Port, "-")
                        secRuleInfo.FromPort = portArr[0]
                        secRuleInfo.ToPort = portArr[1]
                }</span> else<span class="cov0" title="0"> {
                        secRuleInfo.FromPort = sgRule.Port
                        secRuleInfo.ToPort = sgRule.Port
                }</span>
                <span class="cov0" title="0">secRuleArr[i] = secRuleInfo</span>
        }
        <span class="cov0" title="0">secInfo.SecurityRules = &amp;secRuleArr

        return secInfo</span>
}

func (securityHandler *ClouditSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityReqInfo.IId.NameId, "CreateSecurity()")

        // 보안그룹 이름 중복 체크
        securityInfo, _ := securityHandler.getSecurityByName(securityReqInfo.IId.NameId)
        if securityInfo != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("SecurityGroup with name %s already exist", securityReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.SecurityInfo{}, createErr
        }</span>

        <span class="cov0" title="0">securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        reqInfo := securitygroup.SecurityReqInfo{
                Name: securityReqInfo.IId.NameId,
        }

        // SecurityGroup Rule 설정
        ruleList := make([]securitygroup.SecurityGroupRules, len(*securityReqInfo.SecurityRules))
        for i, rule := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                var port string
                if rule.CIDR == NULL </span><span class="cov0" title="0">{
                        rule.CIDR = DefaultCIDR
                }</span>
                <span class="cov0" title="0">if rule.FromPort == rule.ToPort </span><span class="cov0" title="0">{
                        port = rule.FromPort
                }</span> else<span class="cov0" title="0"> {
                        port = rule.FromPort + "-" + rule.ToPort
                }</span>
                <span class="cov0" title="0">secRuleInfo := securitygroup.SecurityGroupRules{
                        Name:     fmt.Sprintf("%s-rules-%d", securityReqInfo.IId.NameId, i+1),
                        Type:     rule.Direction,
                        Port:     port,
                        Target:   rule.CIDR,
                        Protocol: strings.ToLower(rule.IPProtocol),
                }
                ruleList[i] = secRuleInfo</span>
        }
        <span class="cov0" title="0">reqInfo.Rules = ruleList

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        start := call.Start()
        securityGroup, err := securitygroup.Create(securityHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        secGroupInfo := setterSecGroup(*securityGroup)
        return *secGroupInfo, nil</span>
}

func (securityHandler *ClouditSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, SecurityGroup, "ListSecurity()")

        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        securityList, err := securitygroup.List(securityHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // SecurityGroup Rule 정보 가져오기
        for i, sg := range *securityList </span><span class="cov0" title="0">{
                sgRules, err := securitygroup.ListRule(securityHandler.Client, sg.ID, &amp;requestOpts)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        continue</span>
                }
                <span class="cov0" title="0">(*securityList)[i].Rules = *sgRules
                (*securityList)[i].RulesCount = len(*sgRules)</span>
        }

        <span class="cov0" title="0">resultList := make([]*irs.SecurityInfo, len(*securityList))
        for i, security := range *securityList </span><span class="cov0" title="0">{
                secInfo := setterSecGroup(security)
                resultList[i] = secInfo
        }</span>
        <span class="cov0" title="0">return resultList, nil</span>
}

func (securityHandler *ClouditSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "GetSecurity()")

        // 이름 기준 보안그룹 조회
        start := call.Start()
        securityInfo, err := securityHandler.getSecurityByName(securityIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        // SecurityGroup Rule 정보 가져오기
        sgRules, err := securitygroup.ListRule(securityHandler.Client, securityInfo.ID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>

        <span class="cov0" title="0">(*securityInfo).Rules = *sgRules
        (*securityInfo).RulesCount = len(*sgRules)
        secGroupInfo := setterSecGroup(*securityInfo)

        return *secGroupInfo, nil</span>
}

func (securityHandler *ClouditSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "DeleteSecurity()")

        // 이름 기준 보안그룹 조회
        securityInfo, err := securityHandler.getSecurityByName(securityIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        // 보안그룹 삭제
        start := call.Start()
        err = securitygroup.Delete(securityHandler.Client, securityInfo.ID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (securityHandler *ClouditSecurityHandler) getSecurityByName(securityName string) (*securitygroup.SecurityGroupInfo, error) <span class="cov0" title="0">{
        var security *securitygroup.SecurityGroupInfo

        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        securityList, err := securitygroup.List(securityHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range *securityList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, securityName) </span><span class="cov0" title="0">{
                        security = &amp;s
                        break</span>
                }
        }

        <span class="cov0" title="0">if security == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find security group with name %s", securityName))
                return nil, err
        }</span>
        <span class="cov0" title="0">return security, nil</span>
}

func (securityHandler *ClouditSecurityHandler) listRulesInSG(securityID string) (*[]securitygroup.SecurityGroupRules, error) <span class="cov0" title="0">{
        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        securityList, err := securitygroup.ListRulesinSG(securityHandler.Client, securityID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return securityList, nil</span>
}

func (securityHandler *ClouditSecurityHandler) addRuleToSG(extraRuleName, securityID, rule string) (*securitygroup.SecurityGroupRules, error) <span class="cov0" title="0">{
        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        reqInfo := securitygroup.SecurityGroupRules{
                Name:     extraRuleName,
                Protocol: strings.ToLower(DefaultSGName),
                Port:     DefaultPort,
                Target:   DefaultCIDR,
                Type:     rule,
        }

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
                JSONBody:    reqInfo,
        }

        createdRule, err := securitygroup.AddRule(securityHandler.Client, securityID, &amp;requestOpts, rule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return createdRule, nil</span>
}

func (securityHandler *ClouditSecurityHandler) deleteRuleInSG(securityGroupID, ruleID string) error <span class="cov0" title="0">{
        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        err := securitygroup.DeleteRule(securityHandler.Client, securityGroupID, &amp;requestOpts, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.08.

package resources

import (
        "errors"
        "fmt"
        "strings"
        "time"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/nic"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/server"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/adaptiveip"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMDefaultUser         = "root"
        VMDefaultPassword     = "qwe1212!Q"
        SSHDefaultUser        = "cb-user"
        SSHDefaultPort        = 22
        VM                    = "VM"
        DefaultSGName         = "ALL"
        ExtraInboundRuleName  = "extra-inbound"
        ExtraOutboundRuleName = "extra-outbound"
        InboundRule           = "inbound"
        OutboundRule          = "outbound"
)

type ClouditVMHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func (vmHandler *ClouditVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "StartVM()")

        // 가상서버 이름 중복 체크
        vmId, _ := vmHandler.getVmIdByName(vmReqInfo.IId.NameId)
        if vmId != "" </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("VirtualMachine with name %s already exist", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // 이미지 정보 조회 (Name)
        <span class="cov0" title="0">imageHandler := ClouditImageHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }
        image, err := imageHandler.GetImage(vmReqInfo.ImageIID)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get image, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        //  네트워크 정보 조회 (Name)
        <span class="cov0" title="0">vpcHandler := ClouditVPCHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }
        vpc, err := vpcHandler.GetSubnet(vmReqInfo.SubnetIID)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get virtual network, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // 보안그룹 정보 조회 (Name)
        <span class="cov0" title="0">sgHandler := ClouditSecurityHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }

        // TODO: VNIC Security Group 수정 API 작업
        //// Default SG 조회
        //defaultSG, err := sgHandler.getSecurityByName(DefaultSGName)
        //if err != nil {
        //        return irs.VMInfo{}, nil
        //}
        //defaultSecGroups := make([]server.SecGroupInfo, len(vmReqInfo.SecurityGroupIIDs))
        //for i, _ := range vmReqInfo.SecurityGroupIIDs {
        //        defaultSecGroups[i] = server.SecGroupInfo{
        //                Id: defaultSG.ID,
        //        }
        //}

        // VM VNIC에 User Security Group 설정
        secGroups := make([]server.SecGroupInfo, len(vmReqInfo.SecurityGroupIIDs))
        for i, s := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                secGroups[i] = server.SecGroupInfo{
                        Id: s.SystemId,
                }
        }</span>

        // 임시 Inbound 규칙 생성
        <span class="cov0" title="0">_, err = sgHandler.addRuleToSG(ExtraInboundRuleName, secGroups[0].Id, InboundRule)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to add extra inbound rule to SG, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>
        // 임시 Outbound 규칙 생성
        <span class="cov0" title="0">_, err = sgHandler.addRuleToSG(ExtraOutboundRuleName, secGroups[0].Id, OutboundRule)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to add extra outbound rule to SG, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // Spec 정보 조회 (Name)
        <span class="cov0" title="0">vmSpecId, err := GetVMSpecByName(vmHandler.Client.AuthenticatedHeaders(), vmHandler.Client, vmReqInfo.VMSpecName)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get vm spec, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        <span class="cov0" title="0">vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        reqInfo := server.VMReqInfo{
                TemplateId:   image.IId.SystemId,
                SpecId:       *vmSpecId,
                Name:         vmReqInfo.IId.NameId,
                HostName:     vmReqInfo.IId.NameId,
                RootPassword: VMDefaultPassword,
                SubnetAddr:   vpc.Addr,
                Secgroups:    secGroups,
        }

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
                JSONBody:    reqInfo,
        }

        // VM 생성
        start := call.Start()
        creatingVm, err := server.Start(vmHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM 생성 완료까지 wait
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                // Check VM Deploy Status
                vmInfo, err := server.Get(vmHandler.Client, creatingVm.ID, &amp;requestOpts)
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VMInfo{}, err
                }</span>

                <span class="cov0" title="0">if vmInfo.PrivateIp != "" &amp;&amp; getVmStatus(vmInfo.State) == irs.Running </span><span class="cov0" title="0">{
                        ok, err := vmHandler.AssociatePublicIP(creatingVm.Name, vmInfo.PrivateIp)
                        if !ok </span><span class="cov0" title="0">{
                                LoggingError(hiscallInfo, err)
                                return irs.VMInfo{}, err
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                curRetryCnt++
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                        return irs.VMInfo{}, errors.New(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                }</span>
        }

        <span class="cov0" title="0">vm, err := server.Get(vmHandler.Client, creatingVm.ID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">vmInfo := vmHandler.mappingServerInfo(*vm)

        // SSH 접속 사용자 및 공개키 등록
        loginUserId := SSHDefaultUser
        createUserErr := errors.New("Error adding cb-User to new VM")

        // SSH 접속까지 시도
        curConnectionCnt := 0
        maxConnectionRetryCnt := 30
        for </span><span class="cov0" title="0">{
                cblogger.Info("Trying to connect via root user ...")
                _, err := RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "echo test")
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                curConnectionCnt++
                if curConnectionCnt &gt; maxConnectionRetryCnt </span><span class="cov0" title="0">{
                        return irs.VMInfo{}, createUserErr
                }</span>
        }

        // 사용자 등록 및 sudoer 권한 추가
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("useradd -s /bin/bash %s -rm", loginUserId))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("echo \"%s ALL=(root) NOPASSWD:ALL\" &gt;&gt; /etc/sudoers", loginUserId))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>

        // 공개키 등록
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("mkdir -p /home/%s/.ssh", loginUserId))
        publicKey, err := GetPublicKey(vmHandler.CredentialInfo, vmReqInfo.KeyPairIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("echo \"%s\" &gt; /home/%s/.ssh/authorized_keys", publicKey, loginUserId))

        // ssh 접속 방법 변경 (sshd_config 파일 변경)
        _, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "sed -i 's/PasswordAuthentication yes/PasswordAuthentication no/g' /etc/ssh/sshd_config")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "sed -i 's/#PubkeyAuthentication yes/PubkeyAuthentication yes/g' /etc/ssh/sshd_config")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "systemctl restart sshd")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>

        // VM VNIC에 User Security Group Attach
        <span class="cov0" title="0">userSecGroups := make([]server.SecGroupInfo, len(vmReqInfo.SecurityGroupIIDs))
        for i, s := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                userSecGroups[i] = server.SecGroupInfo{
                        Id: s.SystemId,
                }
        }</span>

        // SG 임시 규칙 삭제를 위한 Rule ID 조회
        <span class="cov0" title="0">extraSG, _ := sgHandler.listRulesInSG(secGroups[0].Id)
        //deleteTargetRuleID := make([]string, 2)
        var deleteTargetRuleID []string

        for _, v := range *extraSG </span><span class="cov0" title="0">{
                if v.Name == ExtraInboundRuleName || v.Name == ExtraOutboundRuleName </span><span class="cov0" title="0">{
                        deleteTargetRuleID = append(deleteTargetRuleID, v.ID)
                }</span>
        }

        // SG 임시 규칙 삭제
        <span class="cov0" title="0">for _, v := range deleteTargetRuleID </span><span class="cov0" title="0">{
                err = sgHandler.deleteRuleInSG(secGroups[0].Id, v)
                if err != nil </span><span class="cov0" title="0">{
                        deleteErr := errors.New(fmt.Sprintf("failed to delete extra rules, err : %s", err.Error()))
                        LoggingError(hiscallInfo, deleteErr)
                        return irs.VMInfo{}, deleteErr
                }</span>
        }
        // TODO: VNIC의 SG 설정 API 수정
        //err = vmHandler.attachSgToVnic(authHeader, vm.ID, vmHandler.Client, vnicMac, defaultSecGroups, userSecGroups)
        //if err != nil {
        //        return irs.VMInfo{}, err
        //}

        <span class="cov0" title="0">return vmInfo, nil</span>
}

func (vmHandler *ClouditVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "SuspendVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := server.Suspend(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM 상태 정보 반환
        vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return vmStatus, nil</span>
}

func (vmHandler *ClouditVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "ResumeVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := server.Resume(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM 상태 정보 반환
        vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return vmStatus, nil</span>
}

func (vmHandler *ClouditVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "RebootVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := server.Reboot(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM 상태 정보 반환
        vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return vmStatus, nil</span>
}

func (vmHandler *ClouditVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "TerminateVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        // VM 정보 조회
        vmInfo, err := vmHandler.GetVM(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // 연결된 PublicIP 반환
        <span class="cov0" title="0">if vmInfo.PublicIP != "" </span><span class="cov0" title="0">{
                if ok, err := vmHandler.DisassociatePublicIP(vmInfo.PublicIP); !ok </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.Failed, err
                }</span>
                <span class="cov0" title="0">time.Sleep(5 * time.Second)</span>
        }

        <span class="cov0" title="0">start := call.Start()
        if err := server.Terminate(vmHandler.Client, vmInfo.IId.SystemId, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM 상태 정보 반환
        return irs.Terminating, nil</span>
}

func (vmHandler *ClouditVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVMStatus()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        vmList, err := server.List(vmHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMStatusInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmStatusList := make([]*irs.VMStatusInfo, len(*vmList))
        for i, vm := range *vmList </span><span class="cov0" title="0">{
                vmStatusInfo := irs.VMStatusInfo{
                        IId: irs.IID{
                                NameId:   vm.Name,
                                SystemId: vm.ID,
                        },
                        VmStatus: irs.VMStatus(vm.State),
                }
                vmStatusList[i] = &amp;vmStatusInfo
        }</span>
        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func (vmHandler *ClouditVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVMStatus()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        vmSystemID, err := vmHandler.getVmIdByName(vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        vm, err := server.Get(vmHandler.Client, vmSystemID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Set VM Status Info
        status := getVmStatus(vm.State)
        return status, nil</span>
}

func (vmHandler *ClouditVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        vmList, err := server.List(vmHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfoList := make([]*irs.VMInfo, len(*vmList))
        for i, vm := range *vmList </span><span class="cov0" title="0">{
                vmInfo := vmHandler.mappingServerInfo(vm)
                vmInfoList[i] = &amp;vmInfo
        }</span>
        <span class="cov0" title="0">return vmInfoList, nil</span>
}

func (vmHandler *ClouditVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        vm, err := server.Get(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfo := vmHandler.mappingServerInfo(*vm)
        return vmInfo, nil</span>
}

// VM에 PublicIP 연결
func (vmHandler *ClouditVMHandler) AssociatePublicIP(vmName string, vmIp string) (bool, error) <span class="cov0" title="0">{
        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        var availableIP adaptiveip.IPInfo

        // 1. 사용 가능한 PublicIP 목록 가져오기
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        if availableIPList, err := adaptiveip.ListAvailableIP(vmHandler.Client, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span> else<span class="cov0" title="0"> {
                if len(*availableIPList) == 0 </span><span class="cov0" title="0">{
                        allocateErr := errors.New(fmt.Sprintf("There is no PublicIPs to allocate"))
                        return false, allocateErr
                }</span> else<span class="cov0" title="0"> {
                        availableIP = (*availableIPList)[0]
                }</span>
        }

        // 2. PublicIP 생성 및 할당
        <span class="cov0" title="0">reqInfo := adaptiveip.PublicIPReqInfo{
                IP:        availableIP.IP,
                Name:      vmName + "-PublicIP",
                PrivateIP: vmIp,
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }
        _, err := adaptiveip.Create(vmHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// VM에 PublicIP 해제
func (vmHandler *ClouditVMHandler) DisassociatePublicIP(publicIP string) (bool, error) <span class="cov0" title="0">{
        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        if err := adaptiveip.Delete(vmHandler.Client, publicIP, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span> else<span class="cov0" title="0"> {
                return true, nil
        }</span>
}

func (vmHandler *ClouditVMHandler) mappingServerInfo(server server.ServerInfo) irs.VMInfo <span class="cov0" title="0">{

        // Get Default VM Info
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId:   server.Name,
                        SystemId: server.ID,
                },
                Region: irs.RegionInfo{
                        Region: server.TenantID,
                        Zone:   server.TenantID,
                },
                ImageIId: irs.IID{
                        NameId:   server.Template,
                        SystemId: server.TemplateID,
                },
                VMSpecName: server.Spec,
                VpcIID: irs.IID{
                        NameId:   defaultVPCName,
                        SystemId: defaultVPCName,
                },
                VMUserId:  VMDefaultUser,
                PublicIP:  server.AdaptiveIp,
                PrivateIP: server.PrivateIp,
        }

        if server.CreatedAt != "" </span><span class="cov0" title="0">{
                timeArr := strings.Split(server.CreatedAt, " ")
                timeFormatStr := fmt.Sprintf("%sT%sZ", timeArr[0], timeArr[1])
                if createTime, err := time.Parse(time.RFC3339, timeFormatStr); err == nil </span><span class="cov0" title="0">{
                        vmInfo.StartTime = createTime
                }</span>
        }

        // Get Subnet Info
        <span class="cov0" title="0">VPCHandler := ClouditVPCHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }
        subnet, err := VPCHandler.GetSubnet(irs.IID{NameId: server.SubnetAddr})
        if err == nil </span><span class="cov0" title="0">{
                vmInfo.SubnetIID = irs.IID{
                        NameId:   subnet.Name,
                        SystemId: subnet.ID,
                }
        }</span>

        // Get SecurityGroup Info
        <span class="cov0" title="0">vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()
        vnicList, _ := ListVNic(authHeader, vmHandler.Client, server.ID)
        if vnicList != nil </span><span class="cov0" title="0">{
                defaultVnic := (*vnicList)[0]
                segGroupList := make([]irs.IID, len(defaultVnic.SecGroups))
                for i, s := range defaultVnic.SecGroups </span><span class="cov0" title="0">{
                        segGroupList[i] = irs.IID{
                                NameId:   s.Name,
                                SystemId: s.Id,
                        }
                }</span>
                <span class="cov0" title="0">vmInfo.SecurityGroupIIds = segGroupList</span>
        }
        <span class="cov0" title="0">return vmInfo</span>
}

func (vmHandler *ClouditVMHandler) getVmIdByName(vmNameID string) (string, error) <span class="cov0" title="0">{
        var vmId string

        // VM 목록 검색
        vmList, err := vmHandler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // VM 목록에서 Name 기준 검색
        <span class="cov0" title="0">for _, v := range vmList </span><span class="cov0" title="0">{
                if strings.EqualFold(v.IId.NameId, vmNameID) </span><span class="cov0" title="0">{
                        vmId = v.IId.SystemId
                        break</span>
                }
        }

        // 만약 VM이 검색되지 않을 경우 에러 처리
        <span class="cov0" title="0">if vmId == "" </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find vm with name %s", vmNameID))
                return "", err
        }</span>
        <span class="cov0" title="0">return vmId, nil</span>
}

func getVmStatus(vmStatus string) irs.VMStatus <span class="cov0" title="0">{
        var resultStatus string
        switch strings.ToLower(vmStatus) </span>{
        case "creating":<span class="cov0" title="0">
                resultStatus = "Creating"</span>
        case "running":<span class="cov0" title="0">
                resultStatus = "Running"</span>
        case "stopping":<span class="cov0" title="0">
                resultStatus = "Suspending"</span>
        case "stopped":<span class="cov0" title="0">
                resultStatus = "Suspended"</span>
        case "starting":<span class="cov0" title="0">
                resultStatus = "Resuming"</span>
        case "rebooting":<span class="cov0" title="0">
                resultStatus = "Rebooting"</span>
        case "terminating":<span class="cov0" title="0">
                resultStatus = "Terminating"</span>
        case "terminated":<span class="cov0" title="0">
                resultStatus = "Terminated"</span>
        case "failed":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                resultStatus = "Failed"</span>
        }
        <span class="cov0" title="0">return irs.VMStatus(resultStatus)</span>
}

func (vmHandler *ClouditVMHandler) attachSgToVnic(authHeader map[string]string, vmID string, reqClient *client.RestClient, vnicMac string, sgGroup []server.SecGroupInfo) <span class="cov0" title="0">{

        reqInfo := server.VMReqInfo{
                Secgroups: sgGroup,
        }
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
                JSONBody:    reqInfo,
        }
        nic.Put(reqClient, vmID, &amp;requestOpts, vnicMac)
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2020.01.

package resources

import (
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/specs"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMSpec = "VMSPEC"
)

type ClouditVMSpecHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func setterVMSpec(region string, vmSpec specs.VMSpecInfo) *irs.VMSpecInfo <span class="cov0" title="0">{
        vmSpecInfo := &amp;irs.VMSpecInfo{
                Region:       region,
                Name:         vmSpec.Name,
                VCpu:         irs.VCpuInfo{Count: strconv.Itoa(vmSpec.Cpu)},
                Gpu:          []irs.GpuInfo{{Count: strconv.Itoa(vmSpec.GPU)}},
                KeyValueList: nil,
        }
        vmSpecInfo.Mem = strconv.FormatFloat(float64(vmSpec.Mem)*1024, 'f', 0, 64)
        return vmSpecInfo
}</span>

func (vmSpecHandler *ClouditVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListVMSpec()")

        vmSpecHandler.Client.TokenID = vmSpecHandler.CredentialInfo.AuthToken
        authHeader := vmSpecHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        list, err := specs.List(vmSpecHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                getError := errors.New(fmt.Sprintf("failed to get VM spec list, err : %s", err.Error()))
                LoggingError(hiscallInfo, getError)
                return nil, getError
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmSpecList := make([]*irs.VMSpecInfo, len(*list))
        for i, spec := range *list </span><span class="cov0" title="0">{
                vmSpecList[i] = setterVMSpec(Region, spec)
        }</span>
        <span class="cov0" title="0">return vmSpecList, nil</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetVMSpec()")

        start := call.Start()
        specInfo, err := vmSpecHandler.GetVMSpecByName(Region, Name)
        if err != nil </span><span class="cov0" title="0">{
                notFoundErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err.Error()))
                LoggingError(hiscallInfo, notFoundErr)
                return irs.VMSpecInfo{}, notFoundErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return *specInfo, nil</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListOrgVMSpec()")

        vmSpecHandler.Client.TokenID = vmSpecHandler.CredentialInfo.AuthToken
        authHeader := vmSpecHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        list, err := specs.List(vmSpecHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("failed to get VM spec list, err : %s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return "", getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var jsonResult struct {
                Result []specs.VMSpecInfo `json:"list"`
        }
        jsonResult.Result = *list
        jsonBytes, err := json.Marshal(jsonResult)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetOrgVMSpec()")

        start := call.Start()
        specInfo, err := vmSpecHandler.GetVMSpecByName(Region, Name)
        if err != nil </span><span class="cov0" title="0">{
                notFoundErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err.Error()))
                LoggingError(hiscallInfo, notFoundErr)
                return "", notFoundErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        jsonBytes, err := json.Marshal(specInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, err</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) GetVMSpecByName(region string, specName string) (*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        vmSpecHandler.Client.TokenID = vmSpecHandler.CredentialInfo.AuthToken
        authHeader := vmSpecHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        specList, err := specs.List(vmSpecHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var specInfo *irs.VMSpecInfo
        for _, spec := range *specList </span><span class="cov0" title="0">{
                if strings.EqualFold(spec.Name, specName) </span><span class="cov0" title="0">{
                        specInfo = setterVMSpec(region, spec)
                        break</span>
                }
        }

        <span class="cov0" title="0">if specInfo == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find vmSpec with name %s", specName))
                return nil, err
        }</span>

        <span class="cov0" title="0">return specInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/subnet"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        defaultVPCName    = "Default-VPC"
        defaultVPCCIDR    = "10.0.0.0/16"
        defaultSubnetName = "Default Network"
        VPC               = "VPC"
)

type ClouditVPCHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func (vpcHandler *ClouditVPCHandler) setterVPC(subnets []subnet.SubnetInfo) *irs.VPCInfo <span class="cov0" title="0">{
        // VPC 정보 맵핑
        vpcInfo := irs.VPCInfo{
                IId: irs.IID{
                        NameId:   defaultVPCName,
                        SystemId: defaultVPCName,
                },
                IPv4_CIDR: defaultVPCCIDR,
        }
        // 서브넷 정보 조회
        subnetInfoList := make([]irs.SubnetInfo, len(subnets))
        for i, s := range subnets </span><span class="cov0" title="0">{
                subnetInfo := vpcHandler.setterSubnet(s)
                subnetInfoList[i] = *subnetInfo
        }</span>
        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetInfoList

        return &amp;vpcInfo</span>
}

func (vpcHandler *ClouditVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, VPC, "CreateVPC()")

        // Create Subnet
        start := call.Start()
        subnetList := make([]subnet.SubnetInfo, len(vpcReqInfo.SubnetInfoList))
        for i, vpcSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                result, err := vpcHandler.CreateSubnet(vpcSubnet)
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VPCInfo{}, err
                }</span>
                <span class="cov0" title="0">subnetList[i] = result</span>
        }
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(subnetList)
        return *vpcInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, VPC, "ListVPC()")

        start := call.Start()
        subnetList, err := vpcHandler.ListSubnet()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(subnetList)
        vpcInfoList := []*irs.VPCInfo{vpcInfo}
        return vpcInfoList, nil</span>
}

func (vpcHandler *ClouditVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "GetVPC()")

        start := call.Start()
        vpcInfo, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return *vpcInfo[0], err</span>
}

func (vpcHandler *ClouditVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "DeleteVPC()")

        vpcInfo, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        for _, subnetInfo := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                subnetList, err := vpcHandler.ListSubnet()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return false, err
                }</span>
                <span class="cov0" title="0">for _, value := range subnetList </span><span class="cov0" title="0">{
                        if value.ID == subnetInfo.IId.SystemId </span><span class="cov0" title="0">{
                                if value.Protection == 0 </span><span class="cov0" title="0">{
                                        if ok, _ := vpcHandler.DeleteSubnet(subnetInfo.IId); ok </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (vpcHandler *ClouditVPCHandler) setterSubnet(subnet subnet.SubnetInfo) *irs.SubnetInfo <span class="cov0" title="0">{
        subnetInfo := irs.SubnetInfo{
                IId: irs.IID{
                        NameId:   subnet.Name,
                        SystemId: subnet.ID,
                },
                IPv4_CIDR: subnet.Addr + "/" + subnet.Prefix,
        }
        return &amp;subnetInfo
}</span>

func (vpcHandler *ClouditVPCHandler) CreateSubnet(subnetReqInfo irs.SubnetInfo) (subnet.SubnetInfo, error) <span class="cov0" title="0">{
        // 서브넷 이름 중복 체크
        checkSubnet, _ := vpcHandler.getSubnetByName(subnetReqInfo.IId.NameId)
        if checkSubnet != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("virtualNetwork with name %s already exist", subnetReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                return subnet.SubnetInfo{}, createErr
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        var creatableSubnet subnet.SubnetInfo

        // 1. 사용 가능한 Subnet 목록 가져오기
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        if creatableSubnetList, err := subnet.ListCreatableSubnet(vpcHandler.Client, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                return subnet.SubnetInfo{}, err
        }</span> else<span class="cov0" title="0"> {
                if len(*creatableSubnetList) == 0 </span><span class="cov0" title="0">{
                        allocateErr := errors.New("there is no PublicIPs to allocate")
                        return subnet.SubnetInfo{}, allocateErr
                }</span> else<span class="cov0" title="0"> {
                        creatableSubnet = (*creatableSubnetList)[0]
                }</span>
        }

        // 2. Subnet 생성
        <span class="cov0" title="0">reqInfo := subnet.VNetworkReqInfo{
                Name:   subnetReqInfo.IId.NameId,
                Addr:   creatableSubnet.Addr,
                Prefix: creatableSubnet.Prefix,
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        subnetInfo, err := subnet.Create(vpcHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                return subnet.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">return *subnetInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) ListSubnet() ([]subnet.SubnetInfo, error) <span class="cov0" title="0">{
        vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        subnetList, err := subnet.List(vpcHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return *subnetList, err</span>
}

func (vpcHandler *ClouditVPCHandler) GetSubnet(subnetIId irs.IID) (subnet.SubnetInfo, error) <span class="cov0" title="0">{
        // 이름 기준 서브넷 조회
        subnetInfo, err := vpcHandler.getSubnetByName(subnetIId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return subnet.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">return *subnetInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) DeleteSubnet(subnetIId irs.IID) (bool, error) <span class="cov0" title="0">{
        // 이름 기준 서브넷 조회
        subnetInfo, err := vpcHandler.getSubnetByName(subnetIId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        if err := subnet.Delete(vpcHandler.Client, subnetInfo.Addr, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *ClouditVPCHandler) getSubnetByName(subnetName string) (*subnet.SubnetInfo, error) <span class="cov0" title="0">{
        var subnetInfo *subnet.SubnetInfo

        vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        subnetList, err := subnet.List(vpcHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range *subnetList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, subnetName) </span><span class="cov0" title="0">{
                        subnetInfo = &amp;s
                        break</span>
                }
        }

        <span class="cov0" title="0">if subnetInfo == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find subnet with name %s", subnetName))
                return nil, err
        }</span>
        <span class="cov0" title="0">return subnetInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "AddSubnet()")

        checkSubnet, _ := vpcHandler.getSubnetByName(subnetInfo.IId.NameId)
        if checkSubnet != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("virtualNetwork with name %s already exist", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        var creatableSubnet subnet.SubnetInfo

        // 1. 사용 가능한 Subnet 목록 가져오기
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        if creatableSubnetList, err := subnet.ListCreatableSubnet(vpcHandler.Client, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span> else<span class="cov0" title="0"> {
                if len(*creatableSubnetList) == 0 </span><span class="cov0" title="0">{
                        allocateErr := errors.New("there is no PublicIPs to allocate")
                        LoggingError(hiscallInfo, allocateErr)
                        return irs.VPCInfo{}, allocateErr
                }</span> else<span class="cov0" title="0"> {
                        creatableSubnet = (*creatableSubnetList)[0]
                }</span>
        }

        // 2. Subnet 생성
        <span class="cov0" title="0">reqInfo := subnet.VNetworkReqInfo{
                Name:   subnetInfo.IId.NameId,
                Addr:   creatableSubnet.Addr,
                Prefix: creatableSubnet.Prefix,
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        start := call.Start()
        _, err := subnet.Create(vpcHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        result, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (vpcHandler *ClouditVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, subnetIID.NameId, "RemoveSubnet()")

        subnetInfo, err := vpcHandler.getSubnetByName(subnetIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err = subnet.Delete(vpcHandler.Client, subnetInfo.Addr, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package docker

import (
        "C"
        "github.com/sirupsen/logrus"
        cblog "github.com/cloud-barista/cb-log"
        "context"
        "github.com/docker/docker/client"

        dkcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type DockerDriver struct{}
var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>


func (DockerDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "DOCKER DRIVER Version 1.0"
}</span>

func (DockerDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = false
        drvCapabilityInfo.SecurityHandler = false
        drvCapabilityInfo.KeyPairHandler = false
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = false

        return drvCapabilityInfo
}</span>

func (driver *DockerDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of XXX Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/XXX_CloudConnection".
        // 4. return CloudConnection Interface of XXX_CloudConnection.

        //thisContext, _ := context.WithTimeout(context.Background(), 600*time.Second)
        thisContext := context.Background()

        // ex)
        // IdentityEndpoint = "http://18.191.129.154:1004"
        // APIVersion = "v1.36"
        Host:= connectionInfo.CredentialInfo.Host
        APIVersion:= connectionInfo.CredentialInfo.APIVersion
        client, err := client.NewClient(Host, APIVersion, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := dkcon.DockerCloudConnection{
                ConnectionInfo:      connectionInfo,
                Context:             thisContext,
                Client:                     client,
        }
        return &amp;iConn, nil</span>
}

var CloudDriver DockerDriver
</pre>
		
		<pre class="file" id="file86" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package connect

import (
        "context"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/docker/docker/client"
        dkrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type DockerCloudConnection struct {
        ConnectionInfo      idrv.ConnectionInfo
        Context                    context.Context
        Client              *client.Client
}

func (cloudConn *DockerCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called CreateImageHandler()!")
        imageHandler := dkrs.DockerImageHandler{cloudConn.ConnectionInfo.RegionInfo, cloudConn.Context, cloudConn.Client}
        return &amp;imageHandler, nil
}</span>


func (cloudConn *DockerCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called CreateVMHandler()!")
        vmHandler := dkrs.DockerVMHandler{
                Region:         cloudConn.ConnectionInfo.RegionInfo,
                Context:        cloudConn.Context,
                Client:         cloudConn.Client,
        }
        return &amp;vmHandler, nil
}</span>

func (cloudConn *DockerCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateVPCHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn DockerCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateSecurityHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn *DockerCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateKeyPairHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn *DockerCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateVMSpecHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn *DockerCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called IsConnected()!")
        if cloudConn == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if cloudConn.Client == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (cloudConn *DockerCloudConnection) Close() error <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called Close()!")
        return cloudConn.Client.Close()
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package resources

import (
        "github.com/sirupsen/logrus"
        cblog "github.com/cloud-barista/cb-log"
        "context"
        "github.com/docker/docker/client"
        "github.com/docker/docker/api/types"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "bytes"
        "fmt"
        "strings"
)

type DockerImageHandler struct {
        Region        idrv.RegionInfo
        Context       context.Context
        Client        *client.Client
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>


// (1) pull from dockerhub
// (2) get repo digests id from pulling return
// (3) get all image summary from local repos
// (4) get image ID and OS Info from inspection
func (imageHandler *DockerImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called CreateImage()!")

        // (1) pull from dockerhub
        //ref) images, err := cli.ImagePull(context.Background(), "alpine:latest", types.ImagePullOptions{})
        out, err := imageHandler.Client.ImagePull(imageHandler.Context, imageReqInfo.IId.NameId, types.ImagePullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        buf := new(bytes.Buffer)
        buf.ReadFrom(out)
        msg := buf.String()
//        cblogger.Info(msg)

        // (2) get repo digests id from pulling return
        repoDigests, err := getRepoDigests(msg)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        // (3) get all image summary from local repos
        <span class="cov0" title="0">images, err := imageHandler.Client.ImageList(imageHandler.Context, types.ImageListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        // (4) get image ID and OS Info from inspection
        <span class="cov0" title="0">for _, image := range images </span><span class="cov0" title="0">{
                if strings.Contains(image.RepoDigests[0], repoDigests) </span><span class="cov0" title="0">{
                        imageReqInfo.IId.SystemId = image.ID
                        // (3) inspect image info for OS info
                        osName, err := getOSInfo(imageHandler, image.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Error(err)
                                return irs.ImageInfo{}, err
                        }</span>
                        <span class="cov0" title="0">return irs.ImageInfo{imageReqInfo.IId, osName, "", nil}, nil</span>
                }
        }
        
        <span class="cov0" title="0">return irs.ImageInfo{}, fmt.Errorf("[Local Repos:" + imageReqInfo.IId.NameId + "] does not exist!")</span>
}

func getRepoDigests(msg string) (string, error) <span class="cov0" title="0">{

        /*---------- msg example
        {"status":"Pulling from panubo/sshd","id":"latest"}
        {"status":"Digest: sha256:b260ab0136c734d80ef643387af0eeb807deb7e1f0a85cb432c7f310eca3bb83"}
        {"status":"Status: Image is up to date for panubo/sshd:latest"}
        ------------*/
        strList := strings.Split(msg, "\n")        

        for _, str := range strList </span><span class="cov0" title="0">{
                if strings.Contains(str, "sha256") </span><span class="cov0" title="0">{
                        tmpList := strings.Split(str, ":")
                        str1 := strings.Trim(tmpList[2], " ") // sha256
                        runes := []rune(tmpList[3])  // b260ab0136c734d80ef643387af0eeb807deb7e1f0a85cb432c7f310eca3bb83"}
                        str2 := string(runes[0:len(tmpList[3])-3]) // b260ab0136c734d80ef643387af0eeb807deb7e1f0a85cb432c7f310eca3bb83
                        return str1+":"+str2, nil

                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed image pulling-" + msg)</span>
}

func getOSInfo(imageHandler *DockerImageHandler, imageID string) (string, error) <span class="cov0" title="0">{
        inspec, _, err := imageHandler.Client.ImageInspectWithRaw(imageHandler.Context, imageID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">return inspec.Os + ":" + inspec.OsVersion + ":" + inspec.Architecture, nil</span>
}

func (imageHandler *DockerImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ListImage()!")
        
        //ref) images, err := cli.ImageList(context.Background(), types.ImageListOptions{})
        images, err := imageHandler.Client.ImageList(imageHandler.Context, types.ImageListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">listImages := make([]*irs.ImageInfo, len(images))
        for i, image := range images </span><span class="cov0" title="0">{
                osName, err := getOSInfo(imageHandler, image.ID)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return []*irs.ImageInfo{}, err
                }</span>

                <span class="cov0" title="0">listImages[i] = &amp;irs.ImageInfo{irs.IID{"", image.ID}, osName, "", nil }</span> 
        }

        <span class="cov0" title="0">return listImages, nil</span>
}

func (imageHandler *DockerImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called GetImage()!")

        // inspect image info for OS info
        osName, err := getOSInfo(imageHandler, imageIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">return irs.ImageInfo{imageIID, osName, "", nil}, nil</span>
}

func (imageHandler *DockerImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called DeleteImage()!")


        response, err := imageHandler.Client.ImageRemove(imageHandler.Context, imageIID.SystemId, types.ImageRemoveOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n\n=================\n %#v", response)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package resources

import (
        "context"
        "github.com/docker/docker/client"
        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/go-connections/nat"

        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "time"
        "strconv"
)

type DockerVMHandler struct {
        Region        idrv.RegionInfo
        Context       context.Context
        Client        *client.Client
}

func (vmHandler *DockerVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called StartVM()!")

/*
 ref) https://godoc.org/github.com/docker/docker/api/types/container#Config
type Config struct {
    Hostname        string              // Hostname
    Domainname      string              // Domainname
    User            string              // User that will run the command(s) inside the container, also support user:group
    AttachStdin     bool                // Attach the standard input, makes possible user interaction
    AttachStdout    bool                // Attach the standard output
    AttachStderr    bool                // Attach the standard error
    ExposedPorts    nat.PortSet         `json:",omitempty"` // List of exposed ports
    Tty             bool                // Attach standard streams to a tty, including stdin if it is not closed.
    OpenStdin       bool                // Open stdin
    StdinOnce       bool                // If true, close stdin after the 1 attached client disconnects.
    Env             []string            // List of environment variable to set in the container
    Cmd             strslice.StrSlice   // Command to run when starting the container
    Healthcheck     *HealthConfig       `json:",omitempty"` // Healthcheck describes how to check the container is healthy
    ArgsEscaped     bool                `json:",omitempty"` // True if command is already escaped (meaning treat as a command line) (Windows specific).
    Image           string              // Name of the image as it was passed by the operator (e.g. could be symbolic)
    Volumes         map[string]struct{} // List of volumes (mounts) used for the container
    WorkingDir      string              // Current directory (PWD) in the command will be launched
    Entrypoint      strslice.StrSlice   // Entrypoint to run when starting the container
    NetworkDisabled bool                `json:",omitempty"` // Is network disabled
    MacAddress      string              `json:",omitempty"` // Mac Address of the container
    OnBuild         []string            // ONBUILD metadata that were defined on the image Dockerfile
    Labels          map[string]string   // List of labels set to this container
    StopSignal      string              `json:",omitempty"` // Signal to stop a container
    StopTimeout     *int                `json:",omitempty"` // Timeout (in seconds) to stop a container
    Shell           strslice.StrSlice   `json:",omitempty"` // Shell for shell-form of RUN, CMD, ENTRYPOINT
}
*/


        // set Port binding
        config := &amp;container.Config{
                Image: vmReqInfo.ImageIID.NameId,
                //Image: "panubo/sshd",
                //Cmd:   []string{"echo", "hello world"},
                //Tty:   true,
                ExposedPorts: nat.PortSet{
                                //"80/tcp": struct{}{},
                        },
        }
        // @todo now, fixed port binding. by powerkim, 2020.05.19
        hostConfig := &amp;container.HostConfig{
                PortBindings: nat.PortMap{
                        "80/tcp": []nat.PortBinding{
                                {
                                        HostIP: "0.0.0.0",
                                        HostPort: "8080",
                                },
                        },
                },
        }

/*
        hostConfig := &amp;container.HostConfig{
                PortBindings: nat.PortMap{
                        "22/tcp": []nat.PortBinding{
                                {
                                        HostIP: "0.0.0.0",
                                        HostPort: "44",
                                },
                        },
                },
        }
*/
        resp, err := vmHandler.Client.ContainerCreate(vmHandler.Context, config, hostConfig, nil, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">if err := vmHandler.Client.ContainerStart(vmHandler.Context, resp.ID, types.ContainerStartOptions{}); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
/*
        statusCh, errCh := vmHandler.Client.ContainerWait(vmHandler.Context, resp.ID, container.WaitConditionNotRunning)
        select {
        case err := &lt;-errCh:
                if err != nil {
                        cblogger.Error(err)
                        return irs.VMInfo{}, err
                }
        case &lt;-statusCh:
        }

        out, err := vmHandler.Client.ContainerLogs(vmHandler.Context, resp.ID, types.ContainerLogsOptions{ShowStdout: true})
        if err != nil {
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }
        stdcopy.StdCopy(os.Stdout, os.Stderr, out)
*/

        <span class="cov0" title="0">contJson, err := vmHandler.Client.ContainerInspect(vmHandler.Context, resp.ID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">return getVMInfoByContainerJSON(vmHandler.Region, vmReqInfo.IId, contJson), nil</span>
}

func getVMInfoByContainerJSON(regionInfo idrv.RegionInfo, vmReqIID irs.IID, contJson types.ContainerJSON) irs.VMInfo <span class="cov0" title="0">{
/* ref) https://godoc.org/github.com/docker/docker/api/types#ContainerJSON
        type ContainerJSON struct {
            *ContainerJSONBase
            Mounts          []MountPoint
            Config          *container.Config
            NetworkSettings *NetworkSettings
        }
        type ContainerJSONBase struct {
            ID              string `json:"Id"`
            Created         string
            Path            string
            Args            []string
            State           *ContainerState
            Image           string
            ResolvConfPath  string
            HostnamePath    string
            HostsPath       string
            LogPath         string
            Node            *ContainerNode `json:",omitempty"` // Node is only propagated by Docker Swarm standalone API
            Name            string
            RestartCount    int
            Driver          string
            Platform        string
            MountLabel      string
            ProcessLabel    string
            AppArmorProfile string
            ExecIDs         []string
            HostConfig      *container.HostConfig
            GraphDriver     GraphDriverData
            SizeRw          *int64 `json:",omitempty"`
            SizeRootFs      *int64 `json:",omitempty"`
        }
*/
        container := contJson.ContainerJSONBase
        networks := contJson.NetworkSettings.Networks["bridge"] // @todo Now, only bridge.

        iid := vmReqIID
        iid.SystemId = container.ID

        int64Time, _ := strconv.ParseInt(container.Created, 10, 64)

        vmInfo := irs.VMInfo{
                IId:        iid,
                StartTime:       time.Unix(int64Time, 0),
                Region:          irs.RegionInfo {regionInfo.Region, regionInfo.Zone},
                ImageIId:         irs.IID{container.Image, container.Image},
                VMSpecName:      "",
                VpcIID:          irs.IID{},
                SubnetIID:       irs.IID{},
                SecurityGroupIIds: []irs.IID{},

                KeyPairIId:     irs.IID{},

                VMUserId:       "",
                VMUserPasswd:   "",

                NetworkInterface: networks.NetworkID,
                PublicIP:         "",
                PublicDNS:        "",
                PrivateIP:        networks.IPAddress,
                PrivateDNS:       "",

                VMBootDisk:     "", // ex) /dev/sda1
                VMBlockDisk:    "", // ex)

                KeyValueList: []irs.KeyValue{},
        } 
        return vmInfo
}</span>

func (vmHandler *DockerVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called SuspendVM()!")

        err := vmHandler.Client.ContainerPause(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.Suspending, nil</span>
}

func (vmHandler *DockerVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ResumeVM()!")

        err := vmHandler.Client.ContainerUnpause(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.Resuming, nil</span>
}

func (vmHandler *DockerVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called RebootVM()!")

        err := vmHandler.Client.ContainerRestart(vmHandler.Context, vmIID.SystemId, nil)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.Rebooting, nil</span>
}

// (1) docker stop
// (2) docker rm
func (vmHandler *DockerVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called TerminateVM()!")

        err := vmHandler.Client.ContainerStop(vmHandler.Context, vmIID.SystemId, nil)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">statusCh, errCh := vmHandler.Client.ContainerWait(vmHandler.Context, vmIID.SystemId, container.WaitConditionNotRunning)
        select </span>{
        case err := &lt;-errCh:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return "", err
                }</span>
        case &lt;-statusCh:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">err = vmHandler.Client.ContainerRemove(vmHandler.Context, vmIID.SystemId, types.ContainerRemoveOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.NotExist, nil</span>
}

func (vmHandler *DockerVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ListVMStatus()!")

        // []types.Container
        containers, err := vmHandler.Client.ContainerList(vmHandler.Context, types.ContainerListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return []*irs.VMStatusInfo{}, err
        }</span>

        <span class="cov0" title="0">var vmStatusInfoList []*irs.VMStatusInfo
        // Container = CM = VM
        for _, container := range containers </span><span class="cov0" title="0">{
                vmStatusInfo := irs.VMStatusInfo{irs.IID{"",container.ID}, getMappedStatus(container.State)}
                vmStatusInfoList = append(vmStatusInfoList, &amp;vmStatusInfo)
        }</span>

        <span class="cov0" title="0">return vmStatusInfoList, nil</span>
}

func getMappedStatus(containerStatus string) irs.VMStatus <span class="cov0" title="0">{
// Container Status: "created", "running", "paused", "restarting", "removing", "exited", "dead"        
// Spider Status:     Creating,  Running,  Suspended,   Rebooting,  Terminating, 

        // Set VM Status Info
        switch containerStatus </span>{
                case "created":<span class="cov0" title="0">
                        return irs.Creating</span>
                case "running":<span class="cov0" title="0">
                        return irs.Running</span>
                case "paused":<span class="cov0" title="0">
                        return irs.Suspended</span>
                case "restarting":<span class="cov0" title="0">
                        return irs.Rebooting</span>
                case "removing":<span class="cov0" title="0">
                        return irs.Terminating</span>
                default:<span class="cov0" title="0">
                        return irs.Failed</span>
        }
}

func (vmHandler *DockerVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called GetVMStatus()!")

        // types.Container
        container, err := vmHandler.Client.ContainerInspect(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return getMappedStatus(container.State.Status), nil</span>
}

func (vmHandler *DockerVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ListVM()!")

        // []types.Container
        containers, err := vmHandler.Client.ContainerList(vmHandler.Context, types.ContainerListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return []*irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">var vmList []*irs.VMInfo
        // Container = CM = VM
        for _, container := range containers </span><span class="cov0" title="0">{
                vmInfo := getVMInfoByContainer(vmHandler.Region, container)        
                vmList = append(vmList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmList, nil</span>
}

func getVMInfoByContainer(regionInfo idrv.RegionInfo, container types.Container) irs.VMInfo <span class="cov0" title="0">{
/* 
type Container struct {
    ID         string `json:"Id"`
    Names      []string
    Image      string
    ImageID    string
    Command    string
    Created    int64
    Ports      []Port
    SizeRw     int64 `json:",omitempty"`
    SizeRootFs int64 `json:",omitempty"`
    Labels     map[string]string
    State      string
    Status     string
    HostConfig struct {
        NetworkMode string `json:",omitempty"`
    }
    NetworkSettings *SummaryNetworkSettings
    Mounts          []MountPoint
}
*/                

        // @todo NameId
        vmIID := irs.IID{"", container.ID}
        networks := container.NetworkSettings.Networks["bridge"] // @todo Now, only bridge.
 
        vmInfo := irs.VMInfo {
                IId:                 vmIID,
                StartTime:         time.Unix(container.Created, 0),  // @todo refine time display.
                Region:          irs.RegionInfo {regionInfo.Region, regionInfo.Zone},
                ImageIId:  irs.IID{container.Image, container.ImageID},
                VMSpecName:      "",
                VpcIID:          irs.IID{}, 
                SubnetIID:       irs.IID{},
                SecurityGroupIIds: []irs.IID{},

                KeyPairIId:        irs.IID{},

                VMUserId:        "",
                VMUserPasswd:         "",

                NetworkInterface: networks.NetworkID,
                PublicIP:         "",
                PublicDNS:        "",
                PrivateIP:        networks.IPAddress,
                PrivateDNS:       "",

                VMBootDisk:          "", // ex) /dev/sda1
                VMBlockDisk:         "", // ex)

                KeyValueList: []irs.KeyValue{},
        }

        return vmInfo
}</span>


func (vmHandler *DockerVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called GetVM()!")

        // types.Container
        container, err := vmHandler.Client.ContainerInspect(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">return getVMInfoByContainerJSON(vmHandler.Region, vmIID, container), nil</span>
}

</pre>
		
		<pre class="file" id="file89" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by jazmandorf@gmail.com MZC

package gcp

import (
        "C"

        "context"
        "encoding/json"
        "fmt"

        gcpcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"

        o2 "golang.org/x/oauth2"
        goo "golang.org/x/oauth2/google"

        compute "google.golang.org/api/compute/v1"
)

type GCPDriver struct {
}

func (GCPDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "GCP DRIVER Version 1.0"
}</span>

func (GCPDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        //drvCapabilityInfo.VNicHandler = true
        //drvCapabilityInfo.PublicIPHandler = true
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true
        drvCapabilityInfo.VPCHandler = true

        return drvCapabilityInfo
}</span>

func (driver *GCPDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        Ctx, VMClient, err := getVMClient(connectionInfo.CredentialInfo)
        fmt.Println("################## getVMClient ##################")
        fmt.Println("getVMClient")
        fmt.Println("################## getVMClient ##################")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := gcpcon.GCPCloudConnection{
                Region:      connectionInfo.RegionInfo,
                Credential:  connectionInfo.CredentialInfo,
                Ctx:         Ctx,
                VMClient:    VMClient,
                ImageClient: VMClient,
                // PublicIPClient:      VMClient,
                SecurityGroupClient: VMClient,
                // VNetClient:          VMClient,
                // VNicClient:          VMClient,
                SubnetClient:  VMClient,
                VMSpecHandler: VMClient,
                VPCHandler:    VMClient,
        }

        //fmt.Println("################## resource ConnectionInfo ##################")
        //fmt.Println("iConn : ", iConn)
        //fmt.Println("################## resource ConnectionInfo ##################")
        return &amp;iConn, nil</span>
}

func getVMClient(credential idrv.CredentialInfo) (context.Context, *compute.Service, error) <span class="cov0" title="0">{

        // GCP 는  ClientSecret에
        gcpType := "service_account"
        data := make(map[string]string)

        data["type"] = gcpType
        data["private_key"] = credential.PrivateKey
        data["client_email"] = credential.ClientEmail

        fmt.Println("################## data ##################")
        //fmt.Println("data to json : ", data)
        fmt.Println("################## data ##################")

        res, _ := json.Marshal(data)
        // data, err := ioutil.ReadFile(credential.ClientSecret)
        authURL := "https://www.googleapis.com/auth/compute"

        conf, err := goo.JWTConfigFromJSON(res, authURL)

        if err != nil </span><span class="cov0" title="0">{

                return nil, nil, err
        }</span>

        <span class="cov0" title="0">client := conf.Client(o2.NoContext)

        vmClient, err := compute.New(client)

        ctx := context.Background()

        return ctx, vmClient, nil</span>
}

var CloudDriver GCPDriver
</pre>
		
		<pre class="file" id="file90" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by jaz, 2019.07.

package connect

import (
        "context"

        cblog "github.com/cloud-barista/cb-log"
        gcprs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
        compute "google.golang.org/api/compute/v1"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type GCPCloudConnection struct {
        Region              idrv.RegionInfo
        Credential          idrv.CredentialInfo
        Ctx                 context.Context
        VMClient            *compute.Service
        ImageClient         *compute.Service
        PublicIPClient      *compute.Service
        SecurityGroupClient *compute.Service
        VNetClient          *compute.Service
        VNicClient          *compute.Service
        SubnetClient        *compute.Service
        VMSpecHandler       *compute.Service
        VPCHandler          *compute.Service
}

// func (cloudConn *GCPCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
//         cblogger.Info("GCP Cloud Driver: called CreateVNetworkHandler()!")

//         vNetHandler := gcprs.GCPVNetworkHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNetClient, cloudConn.Credential}
//         return &amp;vNetHandler, nil
// }

func (cloudConn *GCPCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateImageHandler()!")
        imageHandler := gcprs.GCPImageHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.ImageClient, cloudConn.Credential}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateSecurityHandler()!")
        sgHandler := gcprs.GCPSecurityHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.SecurityGroupClient, cloudConn.Credential}
        return &amp;sgHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := gcprs.GCPKeyPairHandler{cloudConn.Credential, cloudConn.Region}
        return &amp;keypairHandler, nil
}</span>

// func (cloudConn *GCPCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
//         cblogger.Info("GCP Cloud Driver: called CreateVNicHandler()!")
//         vNicHandler := gcprs.GCPVNicHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNicClient, cloudConn.Credential}
//         return &amp;vNicHandler, nil
// }

// func (cloudConn *GCPCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
//         cblogger.Info("GCP Cloud Driver: called CreatePublicIPHandler()!")
//         publicIPHandler := gcprs.GCPPublicIPHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.PublicIPClient, cloudConn.Credential}
//         return &amp;publicIPHandler, nil
// }

func (cloudConn *GCPCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateVMHandler()!")
        vmHandler := gcprs.GCPVMHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := gcprs.GCPVPCHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := gcprs.GCPVMSpecHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
        return &amp;vmSpecHandler, nil
}</span>

func (GCPCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (GCPCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "os"

        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        CBVMUser = "cscservice"
        //CBKeyPairPath = "/cloud-control-manager/cloud-driver/driver-libs/.ssh-gcp/"
        // by powerkim, 2019.10.30
        CBKeyPairPath = "/cloud-driver-libs/.ssh-gcp/"
)

const CBDefaultVNetName string = "cb-vnet"   // CB Default Virtual Network Name
const CBDefaultSubnetName string = "cb-vnet" // CB Default Subnet Name

type GcpCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

//VPC
func GetCBDefaultVNetName() string <span class="cov0" title="0">{
        return CBDefaultVNetName
}</span>

//Subnet
func GetCBDefaultSubnetName() string <span class="cov0" title="0">{
        return CBDefaultSubnetName
}</span>

func GetKeyValueList(i map[string]interface{}) []irs.KeyValue <span class="cov0" title="0">{
        var keyValueList []irs.KeyValue
        for k, v := range i </span><span class="cov0" title="0">{
                //cblogger.Infof("K:[%s]====&gt;", k)
                _, ok := v.(string)
                if !ok </span><span class="cov0" title="0">{
                        cblogger.Errorf("Key[%s]의 값은 변환 불가", k)
                        continue</span>
                }
                //if strings.EqualFold(k, "users") {
                //        continue
                //}
                //cblogger.Infof("====&gt;", v)
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, v.(string)})
                cblogger.Info("getKeyValueList : ", keyValueList)</span>
        }

        <span class="cov0" title="0">return keyValueList</span>
}

// KeyPair 해시 생성 함수
func CreateHashString(credentialInfo idrv.CredentialInfo) (string, error) <span class="cov0" title="0">{
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + credentialInfo.TenantId + credentialInfo.SubscriptionId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}

// Public KeyPair 정보 가져오기
func GetPublicKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"
        publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(publicKeyBytes), nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"

        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"
        compute "google.golang.org/api/compute/v1"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type GCPImageHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

/*
이미지를 생성할 때 GCP 같은 경우는 내가 생성한 이미지에서만 리스트를 가져 올 수 있다.
퍼블릭 이미지를 가져 올 수 없다.
가져올라면 다르게 해야 함.
Insert할때 필수 값
name, sourceDisk(sourceImage),storageLocations(배열 ex : ["asia"])
이미지를 어떻게 생성하는냐에 따라서 키 값이 변경됨
디스크, 스냅샷,이미지, 가상디스크, Cloud storage
1) Disk일 경우 :
        {"sourceDisk": "projects/mcloud-barista-251102/zones/asia-northeast1-b/disks/my-root-pd",}
2) Image일 경우 :
        {"sourceImage": "projects/mcloud-barista-251102/global/images/image-1",}



*/

func (imageHandler *GCPImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        return irs.ImageInfo{}, errors.New("Feature not implemented.")
}</span>

/*
//리스트의 경우 Name 기반으로 조회해서 처리하기에는 너무 느리기 때문에 직접 컨버팅함.
func (imageHandler *GCPImageHandler) ListImage() ([]*irs.ImageInfo, error) {

        //projectId := imageHandler.Credential.ProjectID
        projectId := "gce-uefi-images"

        // list, err := imageHandler.Client.Images.List(projectId).Do()
        list, err := imageHandler.Client.Images.List(projectId).Do()
        if err != nil {
                cblogger.Error(err)
                return nil, err
        }
        var imageList []*irs.ImageInfo
        for _, item := range list.Items {
                info := mappingImageInfo(item)
                imageList = append(imageList, &amp;info)
        }

        //spew.Dump(imageList)
        return imageList, nil
}
*/

//리스트의 경우 Name 기반으로 조회해서 처리하기에는 너무 느리기 때문에 직접 컨버팅함.
func (imageHandler *GCPImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("전체 이미지 조회")

        //https://cloud.google.com/compute/docs/images?hl=ko
        arrImageProjectList := []string{
                "gce-uefi-images", // 보안 VM을 지원하는 이미지

                //보안 VM을 지원하지 않는 이미지들
                "centos-cloud",
                "cos-cloud",
                "coreos-cloud",
                "debian-cloud",
                "rhel-cloud",
                "rhel-sap-cloud",
                "suse-cloud",
                "suse-sap-cloud",
                "ubuntu-os-cloud",
                "windows-cloud",
                "windows-sql-cloud",
        }

        var imageList []*irs.ImageInfo

        cnt := 0
        nextPageToken := ""
        var req *compute.ImagesListCall
        var res *compute.ImageList
        var err error
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        for _, projectId := range arrImageProjectList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] 프로젝트 소유의 이미지 목록 처리", projectId)

                //첫번째 호출
                req = imageHandler.Client.Images.List(projectId)
                res, err = req.Do()
                if err != nil </span><span class="cov0" title="0">{
                        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        cblogger.Errorf("[%s] 프로젝트 소유의 이미지 목록 조회 실패!", projectId)
                        cblogger.Error(err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">nextPageToken = res.NextPageToken
                cblogger.Debug("NextPageToken : ", nextPageToken)

                //현재 페이지부터 마지막 페이지까지 조회
                for </span><span class="cov0" title="0">{
                        for _, item := range res.Items </span><span class="cov0" title="0">{
                                cnt++
                                spew.Dump(item)
                                info := mappingImageInfo(item)
                                imageList = append(imageList, &amp;info)
                        }</span> // for : 페이지 데이터 추출

                        //다음 페이지가 존재하면 호출
                        <span class="cov0" title="0">if nextPageToken != "" </span><span class="cov0" title="0">{
                                res, err = req.PageToken(nextPageToken).Do()
                                nextPageToken = res.NextPageToken
                                cblogger.Debug("NextPageToken : ", nextPageToken)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                } // for : 멀티 페이지 처리
        }
        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        //spew.Dump(imageList)
        return imageList, nil</span>
}

//Name 기반으로 VM생성에 필요한 URL및 Image API 호출과 CB 리턴 정보 조회용
type GcpImageInfo struct {
        ImageUrl string //for CB(VM Start)
        Name     string //for CB
        GuestOS  string //for CB (Item.Family)
        Status   string //for CB

        ProjectId string //for image api call
        //Id        uint64 //for image api call
        Id string

        SourceType  string //for keyValue
        SourceImage string //for keyValue
        SelfLink    string //for keyValue
        Family      string //for keyValue
}

//GCP 호출을 줄이기 위해 조회된 정보를 CB형태로 직접 변환해서 전달 함.
func (imageHandler *GCPImageHandler) ConvertGcpImageInfoToCbImageInfo(imageInfo GcpImageInfo) irs.ImageInfo <span class="cov0" title="0">{
        cblogger.Info(imageInfo)
        spew.Dump(imageInfo)

        cbImageInfo := irs.ImageInfo{
                IId: irs.IID{
                        NameId:   imageInfo.Name,
                        SystemId: imageInfo.Name,
                },
                GuestOS: imageInfo.GuestOS,
                Status:  imageInfo.Status,

                KeyValueList: []irs.KeyValue{
                        {"Name", imageInfo.Name},
                        //{"Id", strconv.FormatUint(imageInfo.Id, 10)},
                        {"Id", imageInfo.Id},
                        {"ImageUrl", imageInfo.ImageUrl},
                        {"SourceImage", imageInfo.SourceImage}, // VM생성 시에는 SourceImage나 SelfLink 값을 이용해야 함.
                        {"SourceType", imageInfo.SourceType},
                        {"SelfLink", imageInfo.SelfLink},
                        {"Family", imageInfo.Family},
                        {"ProjectId", imageInfo.ProjectId},
                },
        }

        return cbImageInfo
}</span>

//이슈 #239에 의해 Name 기반에서 URL 기반으로 로직 변경
//전달 받은 URL에서 projectId와 Name을 추출해서 조회함.
func (imageHandler *GCPImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info(imageIID)

        //"https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/ubuntu-minimal-1804-bionic-v20200415"
        //projectId := imageHandler.Credential.ProjectID
        projectId := ""
        imageName := ""

        arrLink := strings.Split(imageIID.SystemId, "/")
        if len(arrLink) &gt; 0 </span><span class="cov0" title="0">{
                imageName = arrLink[len(arrLink)-1]
                for pos, item := range arrLink </span><span class="cov0" title="0">{
                        if strings.EqualFold(item, "projects") </span><span class="cov0" title="0">{
                                projectId = arrLink[pos+1]
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">cblogger.Infof("projectId : [%s] / imageName : [%s]", projectId, imageName)
        if projectId == "" </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, errors.New("ProjectId information not found in URL.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "Images.Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        image, err := imageHandler.Client.Images.Get(projectId, imageName).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        imageInfo := mappingImageInfo(image)
        return imageInfo, nil</span>
}

//이슈 #239에 의해 Name 기반에서 URL 기반으로 로직 변경
//전체 목록에서 이미지 정보를 조회 함. - 위의 GetImage()로 검색되지 않는 경우가 발생하면 이 함수를 이용할 것.
func (imageHandler *GCPImageHandler) GetImageByUrl(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info(imageIID)

        //이미지 명을 기반으로 이미지 정보를 조회함.
        gcpImageInfo, err := imageHandler.FindImageInfo(imageIID.SystemId)
        //return irs.ImageInfo{IId: irs.IID{SystemId: gcpImageInfo.Url}}, err
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">cblogger.Info(gcpImageInfo)
        //return irs.ImageInfo{}, nil
        return imageHandler.ConvertGcpImageInfoToCbImageInfo(gcpImageInfo), nil</span>

        /*
                //projectId := imageHandler.Credential.ProjectID
                projectId := "gce-uefi-images"

                image, err := imageHandler.Client.Images.Get(projectId, imageIID.SystemId).Do()
                if err != nil {
                        cblogger.Error(err)
                        return irs.ImageInfo{}, err
                }
                imageInfo := mappingImageInfo(image)
                return imageInfo, nil
        */
}

// public Image 는 지울 수 없는데 어떻게 해야 하는가?
func (imageHandler *GCPImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{

        //이미지 명을 기반으로 이미지 정보를 조회함.
        gcpImageInfo, err := imageHandler.FindImageInfo(imageIID.SystemId)
        //return irs.ImageInfo{IId: irs.IID{SystemId: gcpImageInfo.Url}}, err
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        //projectId := imageHandler.Credential.ProjectID
        <span class="cov0" title="0">projectId := gcpImageInfo.ProjectId
        imageId := gcpImageInfo.Id

        //res, err := imageHandler.Client.Images.Delete(projectId, imageIID.SystemId).Do()
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        res, err := imageHandler.Client.Images.Delete(projectId, imageId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        fmt.Println(res)
        return true, err</span>
}

//이슈 #239에 의해 Name 기반에서 URL 기반으로 로직 변경
//사용의 편의를 위해 이미지 URL을 전달 받아서 이미지 정보를 리턴 함.
//https://cloud.google.com/compute/docs/images?hl=ko
//@TODO : 효율을 위해서 최소한 ProjectId 정보를 입력 받아야 하지만 현재는 이미지 URL만 전달 받기 때문에 하나로 통합해 놓음.
func (imageHandler *GCPImageHandler) FindImageInfo(reqImageName string) (GcpImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] 이미지 정보 찾기 ", reqImageName)

        //https://cloud.google.com/compute/docs/images?hl=ko
        arrImageProjectList := []string{
                //"ubuntu-os-cloud",

                "gce-uefi-images", // 보안 VM을 지원하는 이미지

                //보안 VM을 지원하지 않는 이미지들
                "centos-cloud",
                "cos-cloud",
                "coreos-cloud",
                "debian-cloud",
                "rhel-cloud",
                "rhel-sap-cloud",
                "suse-cloud",
                "suse-sap-cloud",
                "ubuntu-os-cloud",
                "windows-cloud",
                "windows-sql-cloud",
        }

        cnt := 0
        //curImageLink := ""
        imageInfo := GcpImageInfo{}
        nextPageToken := ""
        var req *compute.ImagesListCall
        var res *compute.ImageList
        var err error
        for _, projectId := range arrImageProjectList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] 프로젝트 소유의 이미지 목록 조회 처리", projectId)

                //첫번째 호출
                req = imageHandler.Client.Images.List(projectId)
                //req.Filter("name=" + reqImageName)
                //req.Filter("SelfLink=" + reqImageName)

                res, err = req.Do()
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] 프로젝트 소유의 이미지 목록 조회 실패!", projectId)
                        cblogger.Error(err)
                        return GcpImageInfo{}, err
                }</span>

                <span class="cov0" title="0">nextPageToken = res.NextPageToken
                cblogger.Info("NestPageToken : ", nextPageToken)

                //현재 페이지부터 마지막 페이지까지 조회
                for </span><span class="cov0" title="0">{
                        /*
                                //list, err := imageHandler.Client.Images.List(projectId).Do() // 1000 // 500
                                req := imageHandler.Client.Images.List(projectId)
                                ret, err := req.Do()
                                cblogger.Info("First -------------&gt; ", ret.NextPageToken)
                                list, err := req.PageToken(ret.NextPageToken).Do()
                                cblogger.Info("Second -------------&gt; ", list.NextPageToken)
                        */

                        //데이터 찾기
                        for _, item := range res.Items </span><span class="cov0" title="0">{
                                cnt++

                                //curImageLink = imageInfo.SourceImage //보통은 SelfLink에 정보가 있는데 혹시 몰라서 SourceImage 정보와 함께 비교 함. // SourceImage는 Name과 동일할 때가 있음.
                                //cblogger.Debugf(" SourceImage : [%s]", curImageLink)

                                //SourceImage 정보가 없으면 SelfLink 정보를 이용함.
                                //SelfLink: [Output Only] Server-defined URL for the resource.
                                //if curImageLink == "" {

                                //2020-07-24 Name 기반에서 URL기반으로 바뀌었기 때문에 굳이 Split할 필요는 없음
                                /*
                                        arrLink := strings.Split(item.SelfLink, "/")
                                        if len(arrLink) &gt; 0 {
                                                curImageLink = arrLink[len(arrLink)-1]
                                        }
                                        cblogger.Debugf("  [%d] : [%s] : [%s]", item.Id, item.SelfLink, curImageLink)
                                */
                                //cblogger.Debug("")
                                //}

                                //2020-07-24 Name 기반에서 URL기반으로 바뀌었기 때문에 직접 SelfLink만 체크 함.
                                if strings.EqualFold(reqImageName, item.SelfLink) </span><span class="cov0" title="0">{
                                        //if strings.EqualFold(reqImageName, item.Name) || strings.EqualFold(reqImageName, curImageLink) {
                                        //cblogger.Debug("=====************** 찾았다!!! *********======")
                                        cblogger.Debugf("=====************** [%d]번째에 찾았다!!! *********======", cnt)
                                        if item.SelfLink == "" </span><span class="cov0" title="0">{
                                                cblogger.Errorf("요청 받은 [%s] 이미지의 정보를 찾았지만 Image URL[SelfLink]정보가 없습니다.", reqImageName)
                                                return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information does not contain URL information.")
                                        }</span>
                                        //imageInfo.Id = item.Id
                                        <span class="cov0" title="0">imageInfo.Id = strconv.FormatUint(item.Id, 10)
                                        imageInfo.ImageUrl = item.SelfLink //item.SourceImage에 URL이 아닌 item.Name이 나와서 SelfLink만 이용함.

                                        imageInfo.GuestOS = item.Family
                                        imageInfo.Status = item.Status

                                        //imageInfo.Name = item.Name
                                        imageInfo.Name = item.SelfLink //2020-07-24 Name에서 URL로 변경됨. 이슈 #239
                                        imageInfo.SourceImage = item.SourceImage
                                        imageInfo.SourceType = item.SourceType
                                        imageInfo.SelfLink = item.SelfLink
                                        imageInfo.Family = item.Family
                                        imageInfo.ProjectId = projectId

                                        cblogger.Info("최종 이미지 정보")
                                        //spew.Dump(imageInfo)
                                        return imageInfo, nil</span>
                                }
                        } // for : 조회 결과에서 일치하는 데이터 찾기

                        //다음 페이지가 존재하면 호출
                        <span class="cov0" title="0">if nextPageToken != "" </span><span class="cov0" title="0">{
                                res, err = req.PageToken(nextPageToken).Do()
                                nextPageToken = res.NextPageToken
                                cblogger.Info("NestPageToken : ", nextPageToken)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                } // for : 멀티 페이지 처리
        }

        <span class="cov0" title="0">cblogger.Errorf("요청 받은 [%s] 이미지에 대한 정보를 찾지 못 했습니다. - 총 이미지 체크 갯수 : [%d]", reqImageName, cnt)
        return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information not found")</span>
}

//목록에서 이미지 Name으로 정보를 찾아서 리턴 함. - 2020-07-24 URL기반으로 변경되어서 이 메소드는 사용 안 함.
//@TODO : 효율을 위해서 최소한 ProjectId 정보를 입력 받아야 하지만 현재는 이미지 명만 전달 받기 때문에 하나로 통합해 놓음.
func (imageHandler *GCPImageHandler) FindImageInfoByName(reqImageName string) (GcpImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] 이미지 정보 찾기 ", reqImageName)

        //https://cloud.google.com/compute/docs/images?hl=ko
        arrImageProjectList := []string{
                //"ubuntu-os-cloud",

                "gce-uefi-images", // 보안 VM을 지원하는 이미지

                //보안 VM을 지원하지 않는 이미지들
                "centos-cloud",
                "cos-cloud",
                "coreos-cloud",
                "debian-cloud",
                "rhel-cloud",
                "rhel-sap-cloud",
                "suse-cloud",
                "suse-sap-cloud",
                "ubuntu-os-cloud",
                "windows-cloud",
                "windows-sql-cloud",
        }

        cnt := 0
        curImageLink := ""
        imageInfo := GcpImageInfo{}
        nextPageToken := ""
        var req *compute.ImagesListCall
        var res *compute.ImageList
        var err error
        for _, projectId := range arrImageProjectList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] 프로젝트 소유의 이미지 목록 조회 처리", projectId)

                //첫번째 호출
                req = imageHandler.Client.Images.List(projectId)
                req.Filter("name=" + reqImageName)

                res, err = req.Do()
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] 프로젝트 소유의 이미지 목록 조회 실패!", projectId)
                        cblogger.Error(err)
                        return GcpImageInfo{}, err
                }</span>

                <span class="cov0" title="0">nextPageToken = res.NextPageToken
                cblogger.Info("NestPageToken : ", nextPageToken)

                //현재 페이지부터 마지막 페이지까지 조회
                for </span><span class="cov0" title="0">{
                        /*
                                //list, err := imageHandler.Client.Images.List(projectId).Do() // 1000 // 500
                                req := imageHandler.Client.Images.List(projectId)
                                ret, err := req.Do()
                                cblogger.Info("First -------------&gt; ", ret.NextPageToken)
                                list, err := req.PageToken(ret.NextPageToken).Do()
                                cblogger.Info("Second -------------&gt; ", list.NextPageToken)
                        */

                        //데이터 찾기
                        for _, item := range res.Items </span><span class="cov0" title="0">{
                                cnt++

                                //curImageLink = imageInfo.SourceImage //보통은 SelfLink에 정보가 있는데 혹시 몰라서 SourceImage 정보와 함께 비교 함. // SourceImage는 Name과 동일할 때가 있음.
                                cblogger.Debugf(" SourceImage : [%s]", curImageLink)

                                //SourceImage 정보가 없으면 SelfLink 정보를 이용함.
                                //SelfLink: [Output Only] Server-defined URL for the resource.
                                //if curImageLink == "" {

                                arrLink := strings.Split(item.SelfLink, "/")
                                if len(arrLink) &gt; 0 </span><span class="cov0" title="0">{
                                        curImageLink = arrLink[len(arrLink)-1]
                                }</span>
                                <span class="cov0" title="0">cblogger.Debugf("  [%d] : [%s] : [%s]", item.Id, item.SelfLink, curImageLink)
                                cblogger.Debug("")
                                //}

                                if strings.EqualFold(reqImageName, item.Name) || strings.EqualFold(reqImageName, curImageLink) </span><span class="cov0" title="0">{
                                        //cblogger.Debug("=====************** 찾았다!!! *********======")
                                        cblogger.Infof("=====************** [%d]번째에 찾았다!!! *********======", cnt)
                                        if item.SelfLink == "" </span><span class="cov0" title="0">{
                                                cblogger.Errorf("요청 받은 [%s] 이미지의 정보를 찾았지만 Image URL[SelfLink]정보가 없습니다.", reqImageName)
                                                return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information does not contain URL information.")
                                        }</span>
                                        //imageInfo.Id = item.Id
                                        <span class="cov0" title="0">imageInfo.Id = strconv.FormatUint(item.Id, 10)
                                        imageInfo.ImageUrl = item.SelfLink //item.SourceImage에 URL이 아닌 item.Name이 나와서 SelfLink만 이용함.

                                        imageInfo.GuestOS = item.Family
                                        imageInfo.Status = item.Status

                                        imageInfo.Name = item.Name
                                        imageInfo.SourceImage = item.SourceImage
                                        imageInfo.SourceType = item.SourceType
                                        imageInfo.SelfLink = item.SelfLink
                                        imageInfo.Family = item.Family
                                        imageInfo.ProjectId = projectId

                                        cblogger.Info("최종 이미지 정보")
                                        spew.Dump(imageInfo)
                                        return imageInfo, nil</span>
                                }
                        } // for : 조회 결과에서 일치하는 데이터 찾기

                        //다음 페이지가 존재하면 호출
                        <span class="cov0" title="0">if nextPageToken != "" </span><span class="cov0" title="0">{
                                res, err = req.PageToken(nextPageToken).Do()
                                nextPageToken = res.NextPageToken
                                cblogger.Info("NestPageToken : ", nextPageToken)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                } // for : 멀티 페이지 처리
        }

        <span class="cov0" title="0">cblogger.Errorf("요청 받은 [%s] 이미지에 대한 정보를 찾지 못 했습니다. - 총 이미지 체크 갯수 : [%d]", reqImageName, cnt)
        return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information not found")</span>
}

/*
//향후 필요하면 프로젝트Id를 입력 받도로 구현
//이미지 설명 : https://cloud.google.com/compute/docs/images?hl=ko
func (imageHandler *GCPImageHandler) FindImageInfo(projectId string, reqImageName string) (GcpImageInfo, error) {
        cblogger.Infof("[%s] 프로젝트에서 [%s] 이미지 정보 찾기 ", projectId, reqImageName)

        list, err := imageHandler.Client.Images.List(projectId).Do()
        if err != nil {
                cblogger.Error(err)
                return GcpImageInfo{}, err
        }

        imageInfo := GcpImageInfo{}
        curImageLink := ""
        for _, item := range list.Items {
                curImageLink = ""
                arrLink := strings.Split(item.SelfLink, "/")
                if len(arrLink) &gt; 0 {
                        curImageLink = arrLink[len(arrLink)-1]
                }
                cblogger.Infof("  [%s] : [%s] : [%s]", item.Id, item.SelfLink, curImageLink)

                if strings.EqualFold(reqImageName, item.Name) || strings.EqualFold(reqImageName, curImageLink) {
                        imageInfo.Id = item.Id
                        imageInfo.Url = curImageLink
                        return imageInfo, nil
                }
        }

        cblogger.Errorf("요청 받은 [%s] 이미지에 대한 정보를 찾지 못 했습니다.", reqImageName)
        return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information not found")
        //return GcpImageInfo{},nil
}
*/

//@TODO : 나중에 시스템아이디 값 변경해야 함.(현재 이미지 핸들러는 이름 기반으로 변경되어 있기 때문...)
func mappingImageInfo(imageInfo *compute.Image) irs.ImageInfo <span class="cov0" title="0">{
        //lArr := strings.Split(imageInfo.Licenses[0], "/")
        //os := lArr[len(lArr)-1]

        //cblogger.Info("===================================")
        //spew.Dump(imageInfo)

        imageList := irs.ImageInfo{
                IId: irs.IID{
                        NameId: imageInfo.SelfLink,
                        //NameId: imageInfo.Name, //2020-07-23 이미지 핸들러는 아직 생성 기능을 지원하지 않기 때문에 NameId대신 SystemId로 통일
                        //SystemId: imageInfo.Name, //자체 기능 구현을 위해 Name 기반으로 리턴함. - 2020-05-14 다음 버전에 적용 예정
                        SystemId: imageInfo.SelfLink, //2020-05-14 카푸치노는 VM 생성시 URL 방식을 사용하기 때문에 임의로 맞춤(이미지 핸들러의 다른 함수에는 적용 못함)
                        //SystemId: strconv.FormatUint(imageInfo.Id, 10), //이 값으로는 VM생성 안됨.

                        //SystemId: imageInfo.SourceImage, //imageInfo.SourceImage의 경우 공백("")인 경우가 있음
                },
                //Id:      strconv.FormatUint(imageInfo.Id, 10),
                //Id:      imageInfo.SelfLink,
                //Name:    imageInfo.Name,
                GuestOS: imageInfo.Family,
                Status:  imageInfo.Status,
                KeyValueList: []irs.KeyValue{
                        {"Name", imageInfo.Name},
                        {"SourceImage", imageInfo.SourceImage}, // VM생성 시에는 SourceImage나 SelfLink 값을 이용해야 함.
                        {"SourceType", imageInfo.SourceType},
                        {"SelfLink", imageInfo.SelfLink},
                        //{"GuestOsFeature", imageInfo.GuestOsFeatures[0].Type},        //Data가 없는 경우가 있어서 필요한 경우 체크해야 함.
                        {"Family", imageInfo.Family},
                        {"DiskSizeGb", strconv.FormatInt(imageInfo.DiskSizeGb, 10)},
                },
        }

        return imageList

}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "golang.org/x/crypto/ssh"
)

type GCPKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
}

func (keyPairHandler *GCPKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        keyPairName := strings.ToLower(keyPairReqInfo.IId.NameId)
        cblogger.Infof("keyPairName [%s] --&gt; [%s]", keyPairReqInfo.IId.NameId, keyPairName)

        //projectId := keyPairHandler.CredentialInfo.ProjectID
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        //키페어 생성 시 폴더가 존재하지 않으면 생성 함.
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Path가 존재하지 않아서 생성합니다.", keyPairPath)

                errDir := os.MkdirAll(keyPairPath, 0755)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path가 생성 실패", keyPairPath)
                        cblogger.Error(errDir)
                        return irs.KeyPairInfo{}, errDir
                }</span>
        }

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateHashString()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        savePrivateFileTo := keyPairPath + hashString + "--" + keyPairName
        savePublicFileTo := keyPairPath + hashString + "--" + keyPairName + ".pub"
        bitSize := 4096

        // Check KeyPair Exists
        if _, err := os.Stat(savePrivateFileTo); err == nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("KeyPair with name %s already exist", keyPairName)
                createErr := errors.New(errMsg)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, createErr
        }</span>

        // 지정된 바이트크기의 RSA 형식 개인키(비공개키)를 만듬
        <span class="cov0" title="0">privateKey, err := generatePrivateKey(bitSize)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 개인키를 RSA에서 PEM 형식으로 인코딩
        <span class="cov0" title="0">privateKeyBytes := encodePrivateKeyToPEM(privateKey)

        // rsa.PublicKey를 가져와서 .pub 파일에 쓰기 적합한 바이트로 변환
        // "ssh-rsa ..."형식으로 변환
        publicKeyBytes, err := generatePublicKey(&amp;privateKey.PublicKey)
        publicKeyString := string(publicKeyBytes)
        // projectId 대신에 cb-user 고정
        publicKeyString = strings.TrimSpace(publicKeyString) + " " + "cb-user"
        fmt.Println("publicKeyString : ", publicKeyString)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 private Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile(privateKeyBytes, savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 public Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile([]byte(publicKeyString), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairName,
                        SystemId: keyPairName,
                },
                PublicKey:  publicKeyString,
                PrivateKey: string(privateKeyBytes),
        }
        return keyPairInfo, nil</span>
}

func (keyPairHandler *GCPKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Fail CreateHashString")
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var keyPairInfoList []*irs.KeyPairInfo

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: "List",
                CloudOSAPI:   "ioutil.ReadDir()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        files, err := ioutil.ReadDir(keyPairPath)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                //cblogger.Error("Fail ReadDir(keyPairPath)")
                //cblogger.Error(err)
                //return nil, err

                //키페어 폴더가 없는 경우 생성된 키가 없는 것으로 변경
                return nil, nil
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        for _, f := range files </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), ".pub") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.Contains(f.Name(), hashString) </span><span class="cov0" title="0">{
                        fileNameArr := strings.Split(f.Name(), "--")
                        keypairInfo, err := keyPairHandler.GetKey(irs.IID{SystemId: fileNameArr[1]})
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Error("Fail GetKey")
                                cblogger.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keyPairInfoList = append(keyPairInfoList, &amp;keypairInfo)</span>
                }
        }

        <span class="cov0" title="0">return keyPairInfoList, nil</span>
}

func (keyPairHandler *GCPKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("keyPairName : [%s]", keyIID.SystemId)
        keyPairName := strings.ToLower(keyIID.SystemId)
        cblogger.Infof("keyPairName 소문자로 치환 : [%s]", keyPairName)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Fail CreateHashString")
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyPairName
        publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.SystemId,
                CloudOSAPI:   "os.Stat()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //키 페어 존재 여부 체크
        if _, err := os.Stat(privateKeyPath); err != nil </span><span class="cov0" title="0">{
                callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.KeyPairInfo{}, errors.New("Not Found : [" + keyIID.SystemId + "] KeyPair Not Found.")
        }</span>
        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        // Private Key, Public Key 파일 정보 가져오기
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keypairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairName,
                        SystemId: keyPairName,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keypairInfo, nil</span>
}

func (keyPairHandler *GCPKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("keyPairName : [%s]", keyIID.SystemId)
        keyPairName := strings.ToLower(keyIID.SystemId)
        cblogger.Infof("keyPairName 소문자로 치환 : [%s]", keyPairName)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Fail CreateHashString")
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyPairName
        publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"

        //키 페어 존재 여부 체크
        if _, err := os.Stat(privateKeyPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, errors.New("Not Found : [" + keyIID.SystemId + "] KeyPair Not Found.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairName,
                CloudOSAPI:   "Remove()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Private Key, Public Key 삭제
        err = os.Remove(privateKeyPath)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// 지정된 바이트크기의 RSA 형식 개인키(비공개키)를 만듬
func generatePrivateKey(bitSize int) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        // Private Key 생성
        privateKey, err := rsa.GenerateKey(rand.Reader, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        // Private Key 확인
        <span class="cov0" title="0">err = privateKey.Validate()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Private Key generated(생성)")
        //fmt.Println(privateKey)
        return privateKey, nil</span>
}

// 개인키를 RSA에서 PEM 형식으로 인코딩
func encodePrivateKeyToPEM(privateKey *rsa.PrivateKey) []byte <span class="cov0" title="0">{
        // Get ASN.1 DER format
        privDER := x509.MarshalPKCS1PrivateKey(privateKey)

        // pem.Block
        privBlock := pem.Block{
                Type:    "RSA PRIVATE KEY",
                Headers: nil,
                Bytes:   privDER,
        }

        // Private key in PEM format
        privatePEM := pem.EncodeToMemory(&amp;privBlock)
        fmt.Println("privateKey Rsa -&gt; Pem 형식으로 변환")
        //fmt.Println(privatePEM)
        return privatePEM
}</span>

// rsa.PublicKey를 가져와서 .pub 파일에 쓰기 적합한 바이트로 변환
// "ssh-rsa ..."형식으로 변환
func generatePublicKey(privatekey *rsa.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        publicRsaKey, err := ssh.NewPublicKey(privatekey)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">pubKeyBytes := ssh.MarshalAuthorizedKey(publicRsaKey)

        log.Println("Public key 생성")
        //fmt.Println(pubKeyBytes)
        return pubKeyBytes, nil</span>
}

// 파일에 Key를 쓴다
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key 저장위치: %s", saveFileTo)
        return nil</span>
}

// Credential 기반 hash 생성
/*func createHashString(credentialInfo idrv.CredentialInfo) (string, error) {
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + credentialInfo.TenantId + credentialInfo.SubscriptionId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil {
                return "", err
        }
        return fmt.Sprintf("%x", hasher.Sum(nil)), nil
}*/
</pre>
		
		<pre class="file" id="file94" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        compute "google.golang.org/api/compute/v1"
)

type GCPSecurityHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

//@TODO : 이슈
func (securityHandler *GCPSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Info(securityReqInfo)

        vNetworkHandler := GCPVPCHandler{
                Client:     securityHandler.Client,
                Region:     securityHandler.Region,
                Ctx:        securityHandler.Ctx,
                Credential: securityHandler.Credential,
        }

        vNetInfo, errVnet := vNetworkHandler.GetVPC(securityReqInfo.VpcIID)
        spew.Dump(vNetInfo)
        if errVnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVnet)
                return irs.SecurityInfo{}, errVnet
        }</span>

        <span class="cov0" title="0">if len(*securityReqInfo.SecurityRules) &lt; 1 </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("invalid value - The SecurityRules policy to add is empty")
        }</span>

        //GCP의 경우 1개의 보안그룹에 Inbound나 Outbound를 1개만 지정할 수 있으며 CIDR도 1개의 보안그룹에 1개만 공통으로 지정됨.
        //즉, 1개의 보안 정책에 다중 포트를 선언하는 형태라서  irs.SecurityReqInfo의 정보를 사용할 것인지
        // irs.SecurityReqInfo의 *[]SecurityRuleInfo 배열의 첫 번째 값을 사용할 것인지 미정이라 공통 변수를 만들어서 처리함.
        <span class="cov0" title="0">commonPolicy := *securityReqInfo.SecurityRules
        commonDirection := commonPolicy[0].Direction
        commonCidr := strings.Split(commonPolicy[0].CIDR, ",")

        if len(commonCidr[0]) &lt; 2 </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("invalid value - The CIDR is empty")
        }</span>

        <span class="cov0" title="0">projectID := securityHandler.Credential.ProjectID
        // @TODO: SecurityGroup 생성 요청 파라미터 정의 필요
        ports := *securityReqInfo.SecurityRules
        var firewallAllowed []*compute.FirewallAllowed

        //다른 드라이버와의 통일을 위해 All은 -1로 처리함.
        //GCP는 포트 번호를 적지 않으면 All임.
        //GCP 방화벽 정책
        //https://cloud.google.com/vpc/docs/firewalls?hl=ko&amp;_ga=2.238147008.-1577666838.1589162755#protocols_and_ports
        for _, item := range ports </span><span class="cov0" title="0">{
                var port string
                fp := item.FromPort
                tp := item.ToPort

                //GCP는 1개의 정책에 1가지 Direction만 지정 가능하기 때문에 Inbound와 Outbound 모두 지정되었을 경우 에러 처리함.
                if !strings.EqualFold(item.Direction, commonDirection) </span><span class="cov0" title="0">{
                        return irs.SecurityInfo{}, errors.New("invalid value - GCP can only use one Direction for one security policy")
                }</span>

                // CB Rule에 의해 Port 번호에 -1이 기입된 경우 GCP Rule에 맞게 치환함.
                <span class="cov0" title="0">if fp == "-1" || tp == "-1" </span><span class="cov0" title="0">{
                        if (fp == "-1" &amp;&amp; tp == "-1") || (fp == "-1" &amp;&amp; tp == "") || (fp == "" &amp;&amp; tp == "-1") </span><span class="cov0" title="0">{
                                port = ""
                        }</span> else<span class="cov0" title="0"> if fp == "-1" </span><span class="cov0" title="0">{
                                port = tp
                        }</span> else<span class="cov0" title="0"> {
                                port = fp
                        }</span>
                } else<span class="cov0" title="0"> {
                        //둘 다 있는 경우
                        if tp != "" &amp;&amp; fp != "" </span><span class="cov0" title="0">{
                                port = fp + "-" + tp
                                //From Port가 없는 경우
                        }</span> else<span class="cov0" title="0"> if tp != "" &amp;&amp; fp == "" </span><span class="cov0" title="0">{
                                port = tp
                                //To Port가 없는 경우
                        }</span> else<span class="cov0" title="0"> if tp == "" &amp;&amp; fp != "" </span><span class="cov0" title="0">{
                                port = fp
                        }</span> else<span class="cov0" title="0"> {
                                port = ""
                        }</span>
                }

                <span class="cov0" title="0">if port == "" </span><span class="cov0" title="0">{
                        firewallAllowed = append(firewallAllowed, &amp;compute.FirewallAllowed{
                                IPProtocol: item.IPProtocol,
                        })
                }</span> else<span class="cov0" title="0"> {
                        firewallAllowed = append(firewallAllowed, &amp;compute.FirewallAllowed{
                                IPProtocol: item.IPProtocol,
                                Ports: []string{
                                        port,
                                },
                        })
                }</span>
        }

        <span class="cov0" title="0">if strings.EqualFold(commonDirection, "inbound") || strings.EqualFold(commonDirection, "INGRESS") </span><span class="cov0" title="0">{
                commonDirection = "INGRESS"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(commonDirection, "outbound") || strings.EqualFold(commonDirection, "EGRESS") </span><span class="cov0" title="0">{
                commonDirection = "EGRESS"
        }</span> else<span class="cov0" title="0"> {
                // cblogger.Errorf("!!!!!!!!! SecurityReqInfo.Direction 정보[%s]가 없어서 INGRESS로 처리합니다.", securityReqInfo.Direction)
                return irs.SecurityInfo{}, errors.New("invalid value - The direction[" + securityReqInfo.Direction + "] information is unknown")
        }</span>

        <span class="cov0" title="0">prefix := "https://www.googleapis.com/compute/v1/projects/" + projectID
        //networkURL := prefix + "/global/networks/" + securityReqInfo.VpcIID.NameId
        networkURL := prefix + "/global/networks/" + securityReqInfo.VpcIID.SystemId

        fireWall := &amp;compute.Firewall{
                Allowed:   firewallAllowed,
                Direction: commonDirection, //INGRESS(inbound), EGRESS(outbound)
                // SourceRanges: []string{
                //         // "0.0.0.0/0",
                //         commonCidr,
                // },
                Name: securityReqInfo.IId.NameId,
                TargetTags: []string{
                        securityReqInfo.IId.NameId,
                },
                Network: networkURL,
        }

        //CIDR 처리
        if strings.EqualFold(commonDirection, "INGRESS") </span><span class="cov0" title="0">{
                //fireWall.SourceRanges = []string{commonCidr}
                fireWall.SourceRanges = commonCidr
        }</span> else<span class="cov0" title="0"> {
                //fireWall.DestinationRanges = []string{commonCidr}
                fireWall.DestinationRanges = commonCidr
        }</span>

        <span class="cov0" title="0">cblogger.Info("생성할 방화벽 정책")
        cblogger.Debug(fireWall)
        //spew.Dump(fireWall)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "Firewalls.Insert()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        res, err := securityHandler.Client.Firewalls.Insert(projectID, fireWall).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        fmt.Println("create result : ", res)
        time.Sleep(time.Second * 3)
        //secInfo, _ := securityHandler.GetSecurity(securityReqInfo.IId)
        secInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: securityReqInfo.IId.NameId})
        return secInfo, nil</span>
}

func (securityHandler *GCPSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        //result, err := securityHandler.Client.ListAll(securityHandler.Ctx)
        projectID := securityHandler.Credential.ProjectID
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "",
                CloudOSAPI:   "Firewalls.List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := securityHandler.Client.Firewalls.List(projectID).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var securityInfo []*irs.SecurityInfo
        for _, item := range result.Items </span><span class="cov0" title="0">{
                name := item.Name
                //systemId := strconv.FormatUint(item.Id, 10)
                //secInfo, _ := securityHandler.GetSecurity(irs.IID{NameId: name, SystemId: systemId})
                secInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: name})

                securityInfo = append(securityInfo, &amp;secInfo)
        }</span>

        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *GCPSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        projectID := securityHandler.Credential.ProjectID

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "Firewalls.Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        security, err := securityHandler.Client.Firewalls.Get(projectID, securityIID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var commonCidr string
        if strings.EqualFold(security.Direction, "INGRESS") </span><span class="cov0" title="0">{
                commonCidr = strings.Join(security.SourceRanges, ", ")
        }</span> else<span class="cov0" title="0"> {
                commonCidr = strings.Join(security.DestinationRanges, ", ")
        }</span>

        <span class="cov0" title="0">var securityRules []irs.SecurityRuleInfo
        for _, item := range security.Allowed </span><span class="cov0" title="0">{
                var portArr []string
                var fromPort string
                var toPort string
                if ports := item.Ports; ports != nil </span><span class="cov0" title="0">{
                        portArr = strings.Split(item.Ports[0], "-")
                        fromPort = portArr[0]
                        if len(portArr) &gt; 1 </span><span class="cov0" title="0">{
                                toPort = portArr[len(portArr)-1]
                        }</span> else<span class="cov0" title="0"> {
                                toPort = ""
                        }</span>

                } else<span class="cov0" title="0"> {
                        fromPort = ""
                        toPort = ""
                }</span>

                <span class="cov0" title="0">securityRules = append(securityRules, irs.SecurityRuleInfo{
                        FromPort:   fromPort,
                        ToPort:     toPort,
                        IPProtocol: item.IPProtocol,
                        Direction:  security.Direction,
                        CIDR:       commonCidr,
                })</span>
        }
        <span class="cov0" title="0">vpcArr := strings.Split(security.Network, "/")
        vpcName := vpcArr[len(vpcArr)-1]
        securityInfo := irs.SecurityInfo{
                IId: irs.IID{
                        NameId: security.Name,
                        //SystemId: strconv.FormatUint(security.Id, 10),
                        SystemId: security.Name,
                },
                VpcIID: irs.IID{
                        NameId:   vpcName,
                        SystemId: vpcName,
                },

                // Direction: security.Direction,
                KeyValueList: []irs.KeyValue{
                        {Key: "Priority", Value: strconv.FormatInt(security.Priority, 10)},
                        // {"SourceRanges", security.SourceRanges[0]},
                        {Key: "Allowed", Value: security.Allowed[0].IPProtocol},
                        {Key: "Vpc", Value: vpcName},
                },
                SecurityRules: &amp;securityRules,
        }

        return securityInfo, nil</span>
}

func (securityHandler *GCPSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        projectID := securityHandler.Credential.ProjectID

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        res, err := securityHandler.Client.Firewalls.Delete(projectID, securityIID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        fmt.Println(res)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        _ "errors"
        "fmt"
        "strings"
        "time"

        compute "google.golang.org/api/compute/v1"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type GCPVMHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

func (vmHandler *GCPVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // Set VM Create Information
        // GCP 는 reqinfo에 ProjectID를 받아야 함.
        cblogger.Info(vmReqInfo)

        //ctx := vmHandler.Ctx
        vmName := vmReqInfo.IId.NameId
        projectID := vmHandler.Credential.ProjectID
        prefix := "https://www.googleapis.com/compute/v1/projects/" + projectID
        //imageURL := "projects/ubuntu-os-cloud/global/images/ubuntu-minimal-1804-bionic-v20191024"
        imageURL := vmReqInfo.ImageIID.SystemId
        region := vmHandler.Region.Region

        zone := vmHandler.Region.Zone
        // email을 어디다가 넣지? 이것또한 문제넹
        clientEmail := vmHandler.Credential.ClientEmail

        /* // 2020-05-15 Name 기반 로직을 임의로 막아 놓음 - 다음 버전에 적용 예정. 현재는 URL 방식
        //이미지 URL처리
        cblogger.Infof("[%s] Image Name에 해당하는 Image Url 정보를 조회합니다.", vmReqInfo.ImageIID.SystemId)
        imageHandler := GCPImageHandler{Credential: vmHandler.Credential, Region: vmHandler.Region, Client: vmHandler.Client}

        imageInfo, errImage := imageHandler.FindImageInfo(vmReqInfo.ImageIID.SystemId)
        if errImage != nil {
                return irs.VMInfo{}, nil
        }

        cblogger.Infof("ImageName: [%s] ---&gt; ImageUrl : [%s]", vmReqInfo.ImageIID.SystemId, imageInfo.ImageUrl)
        imageURL = imageInfo.ImageUrl
        */

        //PublicIP처리
        // var publicIPAddress string
        // cblogger.Info("PublicIp 처리 시작")
        // publicIpHandler := GCPPublicIPHandler{
        //         vmHandler.Region, vmHandler.Ctx, vmHandler.Client, vmHandler.Credential}

        //PublicIp를 전달 받았으면 전달 받은 Ip를 할당
        // if vmReqInfo.PublicIPId != "" {
        //         cblogger.Info("PublicIp 정보 조회 시작")
        //         publicIPInfo, err := publicIpHandler.GetPublicIP(vmReqInfo.PublicIPId)
        //         if err != nil {
        //                 cblogger.Error(err)
        //                 return irs.VMInfo{}, err
        //         }
        //         cblogger.Info("PublicIp 조회됨")
        //         cblogger.Info(publicIPInfo)
        //         publicIPAddress = publicIPInfo.PublicIP
        // } else { //PublicIp가 없으면 직접 생성
        //         cblogger.Info("PublicIp 생성 시작")
        //         // PublicIPHandler  불러서 처리 해야 함.
        //         publicIpName := vmReqInfo.VMName
        //         publicIpReqInfo := irs.PublicIPReqInfo{Name: publicIpName}
        //         publicIPInfo, err := publicIpHandler.CreatePublicIP(publicIpReqInfo)

        //         if err != nil {
        //                 cblogger.Error(err)
        //                 return irs.VMInfo{}, err
        //         }
        //         cblogger.Info("PublicIp 생성됨")
        //         cblogger.Info(publicIPInfo)
        //         publicIPAddress = publicIPInfo.PublicIP
        // }

        //KEYPAIR HANDLER
        keypairHandler := GCPKeyPairHandler{
                vmHandler.Credential, vmHandler.Region}
        keypairInfo, errKeypair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        pubKey := "cb-user:" + keypairInfo.PublicKey
        if errKeypair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeypair)
                return irs.VMInfo{}, errKeypair
        }</span>

        <span class="cov0" title="0">cblogger.Info("keypairInfo 정보")
        spew.Dump(keypairInfo)

        /*
                type GCPImageHandler struct {
                        Region     idrv.RegionInfo
                        Ctx        context.Context
                        Client     *compute.Service
                        Credential idrv.CredentialInfo
                }
        */

        // Security Group Tags
        var securityTags []string
        for _, item := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                //securityTags = append(securityTags, item.NameId)
                securityTags = append(securityTags, item.SystemId)
        }</span>
        <span class="cov0" title="0">cblogger.Info("Security Tags 정보 : ", securityTags)
        //networkURL := prefix + "/global/networks/" + vmReqInfo.VpcIID.NameId
        networkURL := prefix + "/global/networks/" + vmReqInfo.VpcIID.SystemId
        //subnetWorkURL := prefix + "/regions/" + region + "/subnetworks/" + vmReqInfo.SubnetIID.NameId
        subnetWorkURL := prefix + "/regions/" + region + "/subnetworks/" + vmReqInfo.SubnetIID.SystemId

        cblogger.Info("networkURL 정보 : ", networkURL)
        cblogger.Info("subnetWorkURL 정보 : ", subnetWorkURL)
        instance := &amp;compute.Instance{
                Name: vmName,
                Metadata: &amp;compute.Metadata{
                        Items: []*compute.MetadataItems{
                                {Key: "ssh-keys",
                                        Value: &amp;pubKey},
                        },
                },
                Labels: map[string]string{
                        //"keypair": strings.ToLower(vmReqInfo.KeyPairIID.NameId),
                        "keypair": strings.ToLower(vmReqInfo.KeyPairIID.SystemId),
                },
                Description: "compute sample instance",
                MachineType: prefix + "/zones/" + zone + "/machineTypes/" + vmReqInfo.VMSpecName,
                Disks: []*compute.AttachedDisk{
                        {
                                AutoDelete: true,
                                Boot:       true,
                                Type:       "PERSISTENT",
                                InitializeParams: &amp;compute.AttachedDiskInitializeParams{
                                        DiskName:    vmName + "-" + zone, //disk name 도 매번 바뀌어야 하는 값
                                        SourceImage: imageURL,
                                },
                        },
                },
                NetworkInterfaces: []*compute.NetworkInterface{
                        {
                                AccessConfigs: []*compute.AccessConfig{
                                        {
                                                Type: "ONE_TO_ONE_NAT",
                                                Name: "External NAT", // default

                                        },
                                },
                                Network:    networkURL,
                                Subnetwork: subnetWorkURL,
                        },
                },
                ServiceAccounts: []*compute.ServiceAccount{
                        {
                                Email: clientEmail,
                                Scopes: []string{
                                        compute.DevstorageFullControlScope,
                                        compute.ComputeScope,
                                },
                        },
                },
                Tags: &amp;compute.Tags{
                        Items: securityTags,
                },
        }

        cblogger.Info("VM 생성 시작")
        cblogger.Info(instance)
        spew.Dump(instance)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmName,
                CloudOSAPI:   "Insert()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        op, err1 := vmHandler.Client.Instances.Insert(projectID, zone, instance).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("VM 생성 요청 호출 완료")
        cblogger.Info(op)
        spew.Dump(op)
        if err1 != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err1.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error("VM 생성 실패")
                cblogger.Error(err1)
                return irs.VMInfo{}, err1
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        /*
                js, err := op.MarshalJSON()
                if err != nil {
                        cblogger.Info("VM 생성 실패")
                        cblogger.Error(err)
                        return irs.VMInfo{}, err
                }

                cblogger.Info("Insert vm to marshal Json : ", string(js))
                cblogger.Infof("Got compute.Operation, err: %#v, %v", op, err)
        */

        // 이게 시작하는  api Start 내부 매개변수로 projectID, zone, InstanceID
        //vm, err := vmHandler.Client.Instances.Start(project string, zone string, instance string)

        //time.Sleep(time.Second * 10)

        //2021-05-11 WaitForRun을 호출하지 않아도 GetVM() 호출 시 에러가 발생하지 않는 것은 확인했음. (우선은 정책이 최종 확정이 아니라서 WaitForRun을 사용하도록 원복함.)
        vmStatus, _ := vmHandler.WaitForRun(irs.IID{NameId: vmName, SystemId: vmName})
        cblogger.Info("VM 상태 : ", vmStatus)

        cblogger.Info("VM 정보 조회 호출 - GetVM()")
        //만약 30초 이내에 VM이 Running 상태가 되지 않더라도 GetVM으로 VM의 정보 조회를 요청해 봄.
        vmInfo, errVmInfo := vmHandler.GetVM(irs.IID{NameId: vmName, SystemId: vmName})
        if errVmInfo != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VM을 생성했지만 정보 조회는 실패 함.", vmName)
                cblogger.Error(errVmInfo)
                return irs.VMInfo{}, errVmInfo
        }</span>

        //ImageIId의 NameId는 사용자가 요청한 값으로 리턴
        <span class="cov0" title="0">vmInfo.ImageIId.NameId = vmReqInfo.ImageIID.NameId
        return vmInfo, nil</span>

        /* 2020-05-13 Start &amp; Get 요청 시의 리턴 정보 통일을 위해 기존 로직 임시 제거
        vm, err2 := vmHandler.Client.Instances.Get(projectID, zone, vmName).Context(ctx).Do()
        if err2 != nil {
                cblogger.Error(err2)
                return irs.VMInfo{}, err2
        }
        //vmInfo := vmHandler.mappingServerInfo(vm)
        var securityTag []irs.IID

        for _, item := range vm.Tags.Items {
                iId := irs.IID{
                        NameId:   item,
                        SystemId: item,
                }

                securityTag = append(securityTag, iId)
        }
        //var vpcHandler *GCPVPCHandler
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId: vm.Name,
                        //SystemId: strconv.FormatUint(vm.Id, 10),
                        SystemId: vm.Name,
                },
                Region: irs.RegionInfo{
                        Region: vmHandler.Region.Region,
                        Zone:   vmHandler.Region.Zone,
                },
                VMUserId:          "cb-user",
                NetworkInterface:  vm.NetworkInterfaces[0].Name,
                SecurityGroupIIds: securityTag,
                VMSpecName:        vm.MachineType,
                KeyPairIId: irs.IID{
                        NameId:   vm.Labels["keypair"],
                        SystemId: vm.Labels["keypair"],
                },
                ImageIId:  vmHandler.getImageInfo(vm.Disks[0].Source),
                PublicIP:  vm.NetworkInterfaces[0].AccessConfigs[0].NatIP,
                PrivateIP: vm.NetworkInterfaces[0].NetworkIP,
                VpcIID:    vmReqInfo.VpcIID,
                SubnetIID: vmReqInfo.SubnetIID,
                KeyValueList: []irs.KeyValue{
                        {"SubNetwork", vm.NetworkInterfaces[0].Subnetwork},
                        {"AccessConfigName", vm.NetworkInterfaces[0].AccessConfigs[0].Name},
                        {"NetworkTier", vm.NetworkInterfaces[0].AccessConfigs[0].NetworkTier},
                        {"DiskDeviceName", vm.Disks[0].DeviceName},
                        {"DiskName", vm.Disks[0].Source},
                },
        }

        return vmInfo, nil
        */
}

// VM 정보를 조회할 수 있을 때까지 최대 30초간 대기
func (vmHandler *GCPVMHandler) WaitForRun(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt; 생성된 VM의 최종 정보 확인을 위해 Running 될 때까지 대기함.")

        waitStatus := "Running"

        //===================================
        // Suspending 되도록 3초 정도 대기 함.
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)
                if curStatus == irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM 상태가 [%s]라서 대기를 중단합니다.", curStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM 상태가 [%s]이 아니라서 1초 대기후 조회합니다.", waitStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("장시간(%d 초) 대기해도 VM의 Status 값이 [%s]으로 변경되지 않아서 강제로 중단합니다.", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("장시간 기다렸으나 생성된 VM의 상태가 [" + waitStatus + "]으로 바뀌지 않아서 중단 합니다.")
                }</span>
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}

// stop이라고 보면 될듯
func (vmHandler *GCPVMHandler) SuspendVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        ctx := vmHandler.Ctx

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "Stop()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        inst, err := vmHandler.Client.Instances.Stop(projectID, zone, vmID.SystemId).Context(ctx).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(inst)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        fmt.Println("instance stop status :", inst.Status)
        return irs.VMStatus("Suspending"), nil</span>
}

func (vmHandler *GCPVMHandler) ResumeVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{

        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        ctx := vmHandler.Ctx

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "Start()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        inst, err := vmHandler.Client.Instances.Start(projectID, zone, vmID.SystemId).Context(ctx).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(inst)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        fmt.Println("instance resume status :", inst.Status)
        return irs.VMStatus("Resuming"), nil</span>
}

func (vmHandler *GCPVMHandler) RebootVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "SuspendVM()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        _, err := vmHandler.SuspendVM(vmID)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        _, err2 := vmHandler.ResumeVM(vmID)
        if err2 != nil </span><span class="cov0" title="0">{
                return irs.VMStatus("Failed"), err2
        }</span>

        <span class="cov0" title="0">return irs.VMStatus("Rebooting"), nil</span>
}

func (vmHandler *GCPVMHandler) TerminateVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        ctx := vmHandler.Ctx

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "Delete()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        inst, err := vmHandler.Client.Instances.Delete(projectID, zone, vmID.SystemId).Context(ctx).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(inst)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        fmt.Println("instance status :", inst.Status)

        return irs.VMStatus("Terminating"), nil</span>
}

func (vmHandler *GCPVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        //serverList, err := vmHandler.Client.ListAll(vmHandler.Ctx)
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        serverList, err := vmHandler.Client.Instances.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vmStatusList []*irs.VMStatusInfo
        for _, s := range serverList.Items </span><span class="cov0" title="0">{
                if s.Name != "" </span><span class="cov0" title="0">{
                        vmId := s.Name
                        status, _ := vmHandler.GetVMStatus(irs.IID{NameId: vmId, SystemId: vmId})
                        vmStatusInfo := irs.VMStatusInfo{
                                IId: irs.IID{
                                        NameId: vmId,
                                        //SystemId: strconv.FormatUint(s.Id, 10),
                                        SystemId: vmId,
                                },

                                VmStatus: status,
                        }
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "PROVISIONING") </span><span class="cov0" title="0">{
                resultStatus = "Creating"
                //resultStatus = "Resuming" // Resume 요청을 받아서 재기동되는 단계에도 Pending이 있기 때문에 Pending은 Resuming으로 맵핑함.
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "RUNNING") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "STOPPING") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Terminated") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "STAGING") </span><span class="cov0" title="0">{
                resultStatus = "Resuming"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]와 일치하는 맵핑 정보를 찾지 못 함.", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "와 일치하는 CB VM 상태정보를 찾을 수 없습니다.")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM 상태 치환 : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

func (vmHandler *GCPVMHandler) GetVMStatus(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{ // GCP의 ID는 uint64 이므로 GCP에서는 Name을 ID값으로 사용한다.
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "GetVMStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        instanceView, err := vmHandler.Client.Instances.Get(projectID, zone, vmID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        // Get powerState, provisioningState
        //vmStatus := instanceView.Status
        vmStatus, errStatus := ConvertVMStatusString(instanceView.Status)
        //return irs.VMStatus(vmStatus), err
        return vmStatus, errStatus</span>
}

func (vmHandler *GCPVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        cblogger.Info("VMLIST zone info :", zone)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        serverList, err := vmHandler.Client.Instances.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                cblogger.Infof("해당존에 만들어진 Vm List 가 없음")
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vmList []*irs.VMInfo
        for _, server := range serverList.Items </span><span class="cov0" title="0">{
                vmInfo := vmHandler.mappingServerInfo(server)
                vmList = append(vmList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmList, nil</span>
}

func (vmHandler *GCPVMHandler) GetVM(vmID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "GetVM()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        vm, err := vmHandler.Client.Instances.Get(projectID, zone, vmID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        spew.Dump(vm)

        vmInfo := vmHandler.mappingServerInfo(vm)
        return vmInfo, nil</span>
}

// func getVmStatus(vl *compute.Service) string {
//         var powerState, provisioningState string

//         for _, stat := range vl {
//                 statArr := strings.Split(*stat.Code, "/")

//                 if statArr[0] == "PowerState" {
//                         powerState = statArr[1]
//                 } else if statArr[0] == "ProvisioningState" {
//                         provisioningState = statArr[1]
//                 }
//         }

//         // Set VM Status Info
//         var vmState string
//         if powerState != "" &amp;&amp; provisioningState != "" {
//                 vmState = powerState + "(" + provisioningState + ")"
//         } else if powerState != "" &amp;&amp; provisioningState == "" {
//                 vmState = powerState
//         } else if powerState == "" &amp;&amp; provisioningState != "" {
//                 vmState = provisioningState
//         } else {
//                 vmState = "-"
//         }
//         return vmState
// }

func (vmHandler *GCPVMHandler) mappingServerInfo(server *compute.Instance) irs.VMInfo <span class="cov0" title="0">{
        cblogger.Info("================맵핑=====================================")
        spew.Dump(server)

        //var gcpHanler *GCPVMHandler
        vpcArr := strings.Split(server.NetworkInterfaces[0].Network, "/")
        subnetArr := strings.Split(server.NetworkInterfaces[0].Subnetwork, "/")
        vpcName := vpcArr[len(vpcArr)-1]
        subnetName := subnetArr[len(subnetArr)-1]

        type IIDBox struct {
                Items []irs.IID
        }

        var iIdBox IIDBox
        for _, item := range server.Tags.Items </span><span class="cov0" title="0">{
                iId := irs.IID{
                        NameId:   item,
                        SystemId: item,
                }
                iIdBox.Items = append(iIdBox.Items, iId)
        }</span>

        <span class="cov0" title="0">vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId: server.Name,
                        //SystemId: strconv.FormatUint(server.Id, 10),
                        SystemId: server.Name,
                },
                //VMSpecName: server.MachineType,

                Region: irs.RegionInfo{
                        Region: vmHandler.Region.Region,
                        Zone:   vmHandler.Region.Zone,
                },
                VMUserId:          "cb-user",
                NetworkInterface:  server.NetworkInterfaces[0].Name,
                SecurityGroupIIds: iIdBox.Items,
                KeyPairIId: irs.IID{
                        NameId:   server.Labels["keypair"],
                        SystemId: server.Labels["keypair"],
                },
                ImageIId:  vmHandler.getImageInfo(server.Disks[0].Source),
                PublicIP:  server.NetworkInterfaces[0].AccessConfigs[0].NatIP,
                PrivateIP: server.NetworkInterfaces[0].NetworkIP,
                VpcIID: irs.IID{
                        NameId:   vpcName,
                        SystemId: vpcName,
                },
                SubnetIID: irs.IID{
                        NameId:   subnetName,
                        SystemId: subnetName,
                },
                KeyValueList: []irs.KeyValue{
                        {"SubNetwork", server.NetworkInterfaces[0].Subnetwork},
                        {"AccessConfigName", server.NetworkInterfaces[0].AccessConfigs[0].Name},
                        {"NetworkTier", server.NetworkInterfaces[0].AccessConfigs[0].NetworkTier},
                        {"DiskDeviceName", server.Disks[0].DeviceName},
                        {"DiskName", server.Disks[0].Source},
                },
        }

        arrVmSpec := strings.Split(server.MachineType, "/")
        cblogger.Info(arrVmSpec)
        if len(arrVmSpec) &gt; 1 </span><span class="cov0" title="0">{
                cblogger.Info(arrVmSpec[len(arrVmSpec)-1])
                vmInfo.VMSpecName = arrVmSpec[len(arrVmSpec)-1]
        }</span>

        //2020-05-13T00:15:37.183-07:00
        <span class="cov0" title="0">if len(server.CreationTimestamp) &gt; 5 </span><span class="cov0" title="0">{
                cblogger.Infof("서버 구동 시간 처리 : [%s]", server.CreationTimestamp)
                t, err := time.Parse(time.RFC3339, server.CreationTimestamp)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Infof("======&gt; [%v]", t)
                        vmInfo.StartTime = t
                }</span>
        }

        <span class="cov0" title="0">return vmInfo</span>
}

//이미지 URL 방식 대신 이름을 사용하도록 변경 중
//@TODO : 2020-05-15 카푸치노 버전에서는 이름 대신 URL을 사용하기로 했음.
func (vmHandler *GCPVMHandler) getImageInfo(diskname string) irs.IID <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        dArr := strings.Split(diskname, "/")
        var result string
        if dArr != nil </span><span class="cov0" title="0">{
                result = dArr[len(dArr)-1]
        }</span>
        <span class="cov0" title="0">cblogger.Infof("result : [%s]", result)

        info, err := vmHandler.Client.Disks.Get(projectID, zone, result).Do()

        cblogger.Infof("********************************** Disk 정보 ****************")
        spew.Dump(info)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.IID{}
        }</span>

        /* 2020-05-14 카푸치노 다음 버전에서 사용 예정
        arrImageUrl := strings.Split(info.SourceImage, "/")
        imageName := ""
        if len(arrImageUrl) &gt; 0 {
                imageName = arrImageUrl[len(arrImageUrl)-1]
        }
        iId := irs.IID{
                NameId:   imageName,
                SystemId: imageName,
        }
        */

        <span class="cov0" title="0">iId := irs.IID{
                NameId:   info.SourceImage, //2020-05-14 NameId는 사용자가 사용한 이름도 있기 때문에 리턴하지 않도록 수정
                SystemId: info.SourceImage,
        }

        /*
                iId := irs.IID{
                        NameId: info.Name,
                        //SystemId: strconv.FormatUint(info.Id, 10),
                        SystemId: info.Name,
                }
        */
        return iId</span>
}

// func (vmHandler *GCPVMHandler) getKeyPairInfo(diskname string) irs.IID {
//         projectID := vmHandler.Credential.ProjectID
//         zone := vmHandler.Region.Zone
//         var gcpKeyPairHandler *GCPKeyPairHandler
//         iId := irs.IID{
//                 NameId:   "cb-user",
//                 SystemId: "cb-user",
//         }
//         result, err := gcpKeyPairHandler.GetKey(iId)

//         spew.Dump(result)
//         if err != nil {
//                 cblogger.Error(err)
//                 return result
//         }

//         return result
// }
</pre>
		
		<pre class="file" id="file96" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2020.01.

package resources

import (
        "context"
        _ "errors"
        "strconv"
        "strings"

        compute "google.golang.org/api/compute/v1"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

type GCPVMSpecHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

func (vmSpecHandler *GCPVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{

        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.MachineTypes.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return []*irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        var vmSpecInfo []*irs.VMSpecInfo
        for _, i := range resp.Items </span><span class="cov0" title="0">{
                info := irs.VMSpecInfo{
                        Region: zone,
                        Name:   i.Name,
                        VCpu: irs.VCpuInfo{
                                Count: strconv.FormatInt(i.GuestCpus, 10),
                        },
                        Mem: strconv.FormatInt(i.MemoryMb, 10),
                }
                vmSpecInfo = append(vmSpecInfo, &amp;info)
        }</span>
        <span class="cov0" title="0">return vmSpecInfo, nil</span>
}

func (vmSpecHandler *GCPVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // default info
        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        info, err := vmSpecHandler.Client.MachineTypes.Get(projectID, zone, Name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        vmSpecInfo := irs.VMSpecInfo{
                Region: Region,
                Name:   Name,
                VCpu: irs.VCpuInfo{
                        Count: strconv.FormatInt(info.GuestCpus, 10),
                        Clock: "",
                },
                Mem: strconv.FormatInt(info.MemoryMb, 10),
                Gpu: []irs.GpuInfo{
                        {
                                Count: "",
                                Mfr:   "",
                                Model: "",
                                Mem:   "",
                        },
                },
        }

        return vmSpecInfo, nil</span>
}

func (vmSpecHandler *GCPVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.MachineTypes.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        j, _ := resp.MarshalJSON()

        return string(j), err</span>
}

func (vmSpecHandler *GCPVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        info, err := vmSpecHandler.Client.MachineTypes.Get(projectID, zone, Name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        j, _ := info.MarshalJSON()

        return string(j), err</span>
}

// gcp 같은경우 n1 타입만 그래픽 카드가 추가 되며
// 1. n1타입인지 확인하는 로직 필요
// 2. 해당 카드에 관련된 정보를 조회하는 로직필요.
// 3. 해당 리스트를 조회하고 해당 GPU를 선택하는 로직

func CheckMachineType(Name string) bool <span class="cov0" title="0">{
        prefix := "n1"

        if ok := strings.HasPrefix(prefix, Name); ok </span><span class="cov0" title="0">{
                return ok
        }</span>

        <span class="cov0" title="0">return false</span>

}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        "strconv"
        "strings"

        compute "google.golang.org/api/compute/v1"

        "time"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type GCPVPCHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

//@TODO : VPC 생성 로직 변경 필요 / 서브넷이 백그라운드로 생성되기 때문에 조회 시 모두 생성될 때까지 대기하는 로직 필요(그렇지 않으면 일부 정보가 누락됨)
func (vVPCHandler *GCPVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        if vpcReqInfo.IId.NameId == "" </span><span class="cov0" title="0">{
                cblogger.Infof("생성할 VPC 이름[%s]이 없습니다.", vpcReqInfo.IId.NameId)
                return irs.VPCInfo{}, errors.New("Invalid Request - VPC NameId is required.")
        }</span>

        <span class="cov0" title="0">if vpcReqInfo.SubnetInfoList == nil </span><span class="cov0" title="0">{
                cblogger.Info("생성할 VPC의 Subnet 정보가 없습니다.")
                return irs.VPCInfo{}, errors.New("Invalid Request - Subnet information is required.")
        }</span>

        <span class="cov0" title="0">cblogger.Infof("생성된 [%s] VPC가 있는지 체크", vpcReqInfo.IId.NameId)
        _, errChkVpc := vVPCHandler.GetVPC(irs.IID{SystemId: vpcReqInfo.IId.NameId})
        if errChkVpc == nil </span><span class="cov0" title="0">{
                cblogger.Infof("이미 [%s] VPCs가 존재함.", vpcReqInfo.IId.NameId)
                return irs.VPCInfo{}, errors.New("Already Exist - " + vpcReqInfo.IId.NameId)
        }</span>

        <span class="cov0" title="0">projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region
        name := vpcReqInfo.IId.NameId

        autoCreateSubnetworks := false // VPC에 서브넷을 자동으로 생성하지 않도록 함.

        network := &amp;compute.Network{
                Name: name,
                //Name:                  GetCBDefaultVNetName(),
                AutoCreateSubnetworks: autoCreateSubnetworks, // subnet 유무에 따라서 달라짐 true, false
                ForceSendFields:       []string{"AutoCreateSubnetworks"},
        }

        cblogger.Infof("[%s] VPC 생성 시작", name)
        cblogger.Info(network)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "Insert()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        req, err := vVPCHandler.Client.Networks.Insert(projectID, network).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VPC 생성 실패", name)
                cblogger.Error(err)
                callLogInfo.ErrorMSG = err.Error()

                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("[%s] VPC가 정상적으로 생성되고 있습니다 - 리소스 ID : [%d]", name, req.Id)
        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(req.Id, 10), true)
        if errWait != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VPC 생성 완료 대기 실패", name)
                cblogger.Error(errWait)
                return irs.VPCInfo{}, errWait
        }</span>

        /*
                //VPC를 생성하면 생성된 정보가 조회되기전까지는 다른 작업을 할 수 없기 때문에 대기함.
                errChkVpcStatus := vVPCHandler.WaitForRunVpc(name, true)
                if errChkVpcStatus != nil {
                        cblogger.Errorf("생성된 VPC[%s] 정보 조회 실패", name)
                        return irs.VPCInfo{}, errChkVpcStatus
                }
        */

        //서브넷 생성
        <span class="cov0" title="0">vpcNetworkUrl := "https://www.googleapis.com/compute/v1/projects/" + projectID + "/global/networks/" + vpcReqInfo.IId.NameId
        for _, item := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                subnetName := item.IId.NameId
                cblogger.Infof("생성할 [%s] Subnet이 존재하는지 체크", subnetName)
                checkInfo, err := vVPCHandler.Client.Subnetworks.Get(projectID, region, subnetName).Do()
                if err == nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("이미 [%s] Subnet이 존재함", subnetName)
                        return irs.VPCInfo{}, errors.New("Already Exist - " + subnetName + " Subnet is exist")
                }</span>
                <span class="cov0" title="0">cblogger.Info(" Subnet info : ", checkInfo)

                //서브네 생성
                subnetWork := &amp;compute.Subnetwork{
                        Name:        subnetName,
                        IpCidrRange: item.IPv4_CIDR,
                        Network:     vpcNetworkUrl,
                }
                cblogger.Infof("[%s] Subnet 생성시작", subnetName)
                cblogger.Info(subnetWork)

                infoSubnet, errSubnet := vVPCHandler.Client.Subnetworks.Insert(projectID, region, subnetWork).Do()
                if errSubnet != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errSubnet)
                        return irs.VPCInfo{}, errors.New("Making Subnet Error - " + subnetName)
                }</span>

                <span class="cov0" title="0">spew.Dump(infoSubnet)
                //생성된 서브넷이 조회되는데 시간이 필요하기 때문에 홀딩 함.
                /*
                        errChkSubnetStatus := vVPCHandler.WaitForRunSubnet(subnetName, true)
                        if errChkSubnetStatus != nil {
                                cblogger.Errorf("생성된 Subnet[%s] 정보 조회 실패", subnetName)
                                return irs.VPCInfo{}, errChkSubnetStatus
                        }
                */
                cblogger.Infof("[%s] Subnet 생성 성공 - 리소스 ID : [%d]", subnetName, infoSubnet.Id)
                errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
                if errWait != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] Subnet 생성 완료 대기 실패", subnetName)
                        cblogger.Error(errWait)
                        return irs.VPCInfo{}, errWait
                }</span>

                <span class="cov0" title="0">cblogger.Infof("[%s] Subnet 생성완료", subnetName)
                cblogger.Info(infoSubnet)</span>
        }

        //최신 정보로 리턴 함.
        <span class="cov0" title="0">vpcInfo, errVPC := vVPCHandler.GetVPC(irs.IID{SystemId: vpcReqInfo.IId.NameId})
        if errVPC != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("최종 생성된 [%s] VPC 정보 조회 실패", vpcReqInfo.IId.NameId)
                cblogger.Error(errVPC)
                return vpcInfo, errVPC
        }</span>
        <span class="cov0" title="0">vpcInfo.IId.NameId = vpcReqInfo.IId.NameId

        return vpcInfo, nil</span>
}

//VPC 정보가 조회될때까지 대기
//waitFound : true - 정보가 조회될때까지 대기(생성 시) / false - 정보가 조회되지 않을때까지 대기(삭제 시)
func (vVPCHandler *GCPVPCHandler) WaitForRunVpc(name string, waitFound bool) error <span class="cov0" title="0">{
        cblogger.Info("======&gt; VPC 정보가 조회될때까지 대기함.")

        before_time := time.Now()
        max_time := 300 //최대 300초간 체크

        cblogger.Infof("VPC 정보 조회가 %v될 때까지 1초 텀으로 체크 시작", waitFound)
        for </span><span class="cov0" title="0">{
                cblogger.Infof("==&gt; [%s] VPC 정보 조회", name)
                vpcInfo, errVnet := vVPCHandler.Client.Networks.Get(vVPCHandler.Credential.ProjectID, name).Do()
                //spew.Dump(vpcInfo)

                //============================
                //정보가 조회될때까지 대기
                //============================
                if waitFound </span><span class="cov0" title="0">{
                        if errVnet != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] VPC 정보 조회 실패", name)
                                cblogger.Error(errVnet)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]초 동안 [%s] VPC 정보가 조회되지 않아서 강제로 종료함.", max_time, name)
                                        return errVnet
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cblogger.Infof("==&gt; [%s] VPC 정보 조회 완료", name)
                                spew.Dump(vpcInfo)
                                //cblogger.Info(vpcInfo)
                                return nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        //============================
                        //정보가 조회되지 않을때까지 대기
                        //============================
                        if errVnet == nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] VPC 정보 조회 성공", name)
                                //cblogger.Info(vpcInfo)
                                spew.Dump(vpcInfo)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]초를 기다려도 [%s] VPC 정보가 조회되고 있어서 Wait을 강제로 종료함.", max_time, name)
                                        return errors.New("300초를 기다려도 생성된 " + name + " VPC 정보가 조회되고 있어서 Wait을 강제로 종료함.")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cblogger.Infof("==&gt; [%s] VPC 정보가 사라졌음", name)
                                return nil
                        }</span>
                } //end of if waitFound : 조회 옵션
        }

        <span class="cov0" title="0">return nil</span>
}

//Subnet 정보가 조회될때까지 대기
//waitFound : true - 정보가 조회될때까지 대기(생성 시) / false - 정보가 조회되지 않을때까지 대기(삭제 시)
func (vVPCHandler *GCPVPCHandler) WaitForRunSubnet(subnetName string, waitFound bool) error <span class="cov0" title="0">{
        cblogger.Info("======&gt; Subnet 정보가 조회될때까지 대기함.")

        before_time := time.Now()
        max_time := 300 //최대 300초간 체크

        cblogger.Infof("Subnet 정보 조회가 %v될 때까지 1초 텀으로 체크 시작", waitFound)
        for </span><span class="cov0" title="0">{
                cblogger.Infof("--&gt; 생성된 [%s] Subnet이 존재하는지 체크", subnetName)
                chkInfo, err := vVPCHandler.Client.Subnetworks.Get(vVPCHandler.Credential.ProjectID, vVPCHandler.Region.Region, subnetName).Do()
                //spew.Dump(chkInfo)
                //============================
                //정보가 조회될때까지 대기
                //============================
                if waitFound </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] Subnet 정보 조회 실패", subnetName)
                                spew.Dump(err)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]초 동안 [%s] Subnet 정보가 조회되지 않아서 강제로 종료함.", max_time, subnetName)
                                        return errors.New("생성된 Subnet 정보가 장시간 조회되지 않아서 강제로 종료함.)")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cblogger.Infof("==&gt; [%s] Subnet 정보 조회 완료", subnetName)
                                //cblogger.Info(chkInfo)
                                spew.Dump(chkInfo)
                                return nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        //============================
                        //정보가 조회되지 않을때까지 대기
                        //============================
                        if err == nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] Subnet 정보 조회 성공", subnetName)
                                //cblogger.Info(chkInfo)
                                spew.Dump(chkInfo)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]초를 기다려도 [%s] Subnet 정보가 조회되고 있어서 Wait을 강제로 종료함.", max_time, subnetName)
                                        return errors.New("300초를 기다려도 생성된 " + subnetName + " Subnet 정보가 조회되고 있어서 Wait을 강제로 종료함.")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                spew.Dump(err)
                                cblogger.Infof("==&gt; [%s] Subnet 정보가 사라졌음", subnetName)
                                return nil
                        }</span>
                } // end of if : 정보 조회 옵션
        }

        <span class="cov0" title="0">return nil</span>
}

//https://cloud.google.com/compute/docs/reference/rest/v1/globalOperations/list
//GET https://compute.googleapis.com/compute/v1/projects/{project}/global/operations
//https://godoc.org/google.golang.org/api/compute/v1#GlobalOperationsGetCall.Do
//https://cloud.google.com/compute/docs/reference/rest/v1/globalOperations/list

//https://cloud.google.com/compute/docs/reference/rest/v1/globalOperations/get
//
// resourceId : API 호출후 받은 리소스 값
//VPC : 글로벌
//https://www.googleapis.com/compute/v1/projects/mcloud-barista2020/global/networks/cb-vpc-load-test
//Subnet : Regions
//https://www.googleapis.com/compute/v1/projects/mcloud-barista2020/regions/asia-northeast3/operations/operation-1590139586815-5a6393937274c-71aebdca-1574e4d7
// 404 에러 체크해서 global과 region 자동으로 처리 가능하니 필요하면 나중에 공통 유틸로 변경할 것
func (vVPCHandler *GCPVPCHandler) WaitUntilComplete(resourceId string, isGlobalAction bool) error <span class="cov0" title="0">{
        //compute.ZoneOperationsGetCall
        //chkInfo, err := vVPCHandler.Client.Subnetworks.Get(vVPCHandler.Credential.ProjectID, vVPCHandler.Region.Region, subnetName).Do()

        //project string, operation string
        project := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region
        //resourceId := ""

        before_time := time.Now()
        max_time := 300 //최대 300초간 체크

        var opSatus *compute.Operation
        var err error

        for </span><span class="cov0" title="0">{
                //opSatus, err := vVPCHandler.Client.GlobalOperations.Get(project, resourceId).Do()
                if isGlobalAction </span><span class="cov0" title="0">{
                        opSatus, err = vVPCHandler.Client.GlobalOperations.Get(project, resourceId).Do()
                }</span> else<span class="cov0" title="0"> {
                        opSatus, err = vVPCHandler.Client.RegionOperations.Get(project, region, resourceId).Do()
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cblogger.Infof("==&gt; 상태 : 진행율 : [%d] / [%s]", opSatus.Progress, opSatus.Status)

                //PENDING, RUNNING, or DONE.
                //if (opSatus.Status == "RUNNING" || opSatus.Status == "DONE") &amp;&amp; opSatus.Progress &gt;= 100 {
                if opSatus.Status == "DONE" </span><span class="cov0" title="0">{
                        cblogger.Info("요청 작업이 정상적으로 처리되어서 Wait을 종료합니다.")
                        return nil
                }</span>

                <span class="cov0" title="0">time.Sleep(time.Second * 1)
                after_time := time.Now()
                diff := after_time.Sub(before_time)
                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%d]초 동안 리소스[%s]의 상태가 완료되지 않아서 Wait을 강제로 종료함.", max_time, resourceId)
                        return errors.New("장시간 요청 작업이 완료되지 않아서 Wait을 강제로 종료함.)")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (vVPCHandler *GCPVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        projectID := vVPCHandler.Credential.ProjectID
        //region := vVPCHandler.Region.Region
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        vpcList, err := vVPCHandler.Client.Networks.List(projectID).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()

                callogger.Info(call.String(callLogInfo))

                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vpcInfo []*irs.VPCInfo

        for _, item := range vpcList.Items </span><span class="cov0" title="0">{
                iId := irs.IID{
                        NameId: item.Name,
                        //SystemId: strconv.FormatUint(item.Id, 10),
                        SystemId: item.Name,
                }
                subnetInfo, err := vVPCHandler.GetVPC(iId)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return vpcInfo, err
                }</span>

                <span class="cov0" title="0">vpcInfo = append(vpcInfo, &amp;subnetInfo)</span>

        }

        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (vVPCHandler *GCPVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{

        projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region
        //name := VPCID
        systemId := vpcIID.SystemId
        //name := vpcIID.NameId

        //cblogger.Infof("NameID : [%s] / SystemID : [%s]", name, systemId)
        cblogger.Infof("SystemID : [%s]", systemId)
        subnetInfoList := []irs.SubnetInfo{}

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        infoVPC, err := vVPCHandler.Client.Networks.Get(projectID, systemId).Do()
        //infoVPC, err := vVPCHandler.Client.Networks.Get(projectID, name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()

                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        spew.Dump(infoVPC)
        if infoVPC.Subnetworks != nil </span><span class="cov0" title="0">{
                for _, item := range infoVPC.Subnetworks </span><span class="cov0" title="0">{
                        str := strings.Split(item, "/")
                        region = str[len(str)-3]
                        subnet := str[len(str)-1]
                        infoSubnet, err := vVPCHandler.Client.Subnetworks.Get(projectID, region, subnet).Do()
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Error(err)
                                return irs.VPCInfo{}, err
                        }</span>
                        <span class="cov0" title="0">subnetInfoList = append(subnetInfoList, mappingSubnet(infoSubnet))</span>
                }

        }

        <span class="cov0" title="0">networkInfo := irs.VPCInfo{
                IId: irs.IID{
                        NameId: infoVPC.Name,
                        //SystemId: strconv.FormatUint(infoVPC.Id, 10),
                        SystemId: infoVPC.Name,
                },
                IPv4_CIDR:      "Not support IPv4_CIDR at GCP VPC",
                SubnetInfoList: subnetInfoList,
                KeyValueList: []irs.KeyValue{
                        {"RoutingMode", infoVPC.RoutingConfig.RoutingMode},
                        {"Description", infoVPC.Description},
                        {"SelfLink", infoVPC.SelfLink},
                },
        }

        return networkInfo, nil</span>
}

func mappingSubnet(subnet *compute.Subnetwork) irs.SubnetInfo <span class="cov0" title="0">{
        //str := subnet.SelfLink
        str := strings.Split(subnet.SelfLink, "/")
        subnetName := str[len(str)-1]
        regionStr := strings.Split(subnet.Region, "/")
        region := regionStr[len(regionStr)-1]
        subnetInfo := irs.SubnetInfo{
                IId: irs.IID{
                        NameId: subnet.Name,
                        //SystemId: strconv.FormatUint(subnet.Id, 10),
                        SystemId: subnet.Name,
                },
                IPv4_CIDR: subnet.IpCidrRange,
                KeyValueList: []irs.KeyValue{
                        {"region", region},
                        {"subnet", subnetName},
                },
        }
        return subnetInfo
}</span>

func (vVPCHandler *GCPVPCHandler) DeleteVPC(vpcID irs.IID) (bool, error) <span class="cov0" title="0">{
        projectID := vVPCHandler.Credential.ProjectID
        //region := vVPCHandler.Region.Region
        //name := VPCID
        //name := vpcID.NameId
        name := vpcID.SystemId
        cblogger.Infof("Name : [%s]", name)
        subnetInfo, subErr := vVPCHandler.GetVPC(vpcID)
        if subErr != nil </span><span class="cov0" title="0">{
                cblogger.Error(subErr)
                return false, subErr
        }</span>
        <span class="cov0" title="0">if subnetInfo.SubnetInfoList != nil </span><span class="cov0" title="0">{
                for _, item := range subnetInfo.SubnetInfoList </span><span class="cov0" title="0">{
                        for _, si := range item.KeyValueList </span><span class="cov0" title="0">{
                                if si.Key == "region" </span><span class="cov0" title="0">{
                                        region := si.Value
                                        infoSubnet, infoSubErr := vVPCHandler.Client.Subnetworks.Delete(projectID, region, item.IId.NameId).Do()
                                        if infoSubErr != nil </span><span class="cov0" title="0">{
                                                //cblogger.Error(infoSubErr)
                                                return false, infoSubErr
                                        }</span>
                                        <span class="cov0" title="0">cblogger.Info("Delete subnet result :", infoSubnet)
                                        //cblogger.Info("Subnet Deleting....wait 10seconds")
                                        //time.Sleep(time.Second * 10)

                                        //서브넷이 완전히 삭제될때까지 대기
                                        /*
                                                errChkSubnetStatus := vVPCHandler.WaitForRunSubnet(item.IId.NameId, false)
                                                if errChkSubnetStatus != nil {
                                                        return false, errChkSubnetStatus
                                                }
                                        */

                                        cblogger.Infof("[%s] Subnet 삭제 성공 - 리소스 ID : [%d]", item.IId.NameId, infoSubnet.Id)
                                        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
                                        if errWait != nil </span><span class="cov0" title="0">{
                                                cblogger.Errorf("[%s] Subnet 삭제 완료 대기 실패", item.IId.NameId)
                                                cblogger.Error(errWait)
                                                return false, errWait
                                        }</span>

                                }
                        }
                }
        }
        //cblogger.Info("VPC Deleting....wait 15seconds")
        //time.Sleep(time.Second * 15)
        <span class="cov0" title="0">cblogger.Info("[NOW Delete VPC]")
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcID.SystemId,
                CloudOSAPI:   "Delete()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        info, err := vVPCHandler.Client.Networks.Delete(projectID, name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //time.Sleep(time.Second * 15)
        cblogger.Info(info)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return false, err
        }</span>

        //삭제될때까지 대기
        /*
                errChkVpcStatus := vVPCHandler.WaitForRunVpc(name, false)
                if errChkVpcStatus != nil {
                        return false, errChkVpcStatus
                }
        */

        <span class="cov0" title="0">cblogger.Infof("[%s] VPC가 최종 삭제될까지 대기 - 리소스 ID : [%d]", name)
        errChkVpcStatus := vVPCHandler.WaitUntilComplete(strconv.FormatUint(info.Id, 10), true)
        callogger.Info(call.String(callLogInfo))
        if errChkVpcStatus != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = errChkVpcStatus.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Errorf("[%s] Subnet 삭제 완료 대기 실패", name)
                cblogger.Error(errChkVpcStatus)
                return false, errChkVpcStatus
        }</span>

        //fmt.Println(info)
        <span class="cov0" title="0">return true, nil</span>
}

func (VPCHandler *GCPVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet 추가 - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        //resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        _, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>
        //cblogger.Debug(resSubnet)

        <span class="cov0" title="0">return VPCHandler.GetVPC(vpcIID)</span>
        //return irs.VPCInfo{}, nil
}

//리턴 값은 구현하지 않고 nil을 리턴함. - 현재 사용되는 곳이 없어서 시간상 누락 시킴.
func (vVPCHandler *GCPVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Info(reqSubnetInfo)

        projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region

        //서브넷 생성
        vpcNetworkUrl := "https://www.googleapis.com/compute/v1/projects/" + projectID + "/global/networks/" + vpcId
        subnetName := reqSubnetInfo.IId.NameId
        cblogger.Infof("생성할 [%s] Subnet이 존재하는지 체크", subnetName)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        checkInfo, err := vVPCHandler.Client.Subnetworks.Get(projectID, region, subnetName).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err == nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                cblogger.Errorf("이미 [%s] Subnet이 존재함", subnetName)
                callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, errors.New("Already Exist - " + subnetName + " Subnet is exist")
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info("Subnet info : ", checkInfo)

        //서브넷 생성
        subnetWork := &amp;compute.Subnetwork{
                Name:        subnetName,
                IpCidrRange: reqSubnetInfo.IPv4_CIDR,
                Network:     vpcNetworkUrl,
        }
        cblogger.Infof("[%s] Subnet 생성시작", subnetName)
        cblogger.Info(subnetWork)

        infoSubnet, errSubnet := vVPCHandler.Client.Subnetworks.Insert(projectID, region, subnetWork).Do()
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.SubnetInfo{}, errors.New("Making Subnet Error - " + subnetName)
        }</span>

        <span class="cov0" title="0">spew.Dump(infoSubnet)
        //생성된 서브넷이 조회되는데 시간이 필요하기 때문에 홀딩 함.
        cblogger.Infof("[%s] Subnet 생성 성공 - 리소스 ID : [%d]", subnetName, infoSubnet.Id)
        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
        if errWait != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Subnet 생성 완료 대기 실패", subnetName)
                cblogger.Error(errWait)
                return irs.SubnetInfo{}, errWait
        }</span>

        <span class="cov0" title="0">cblogger.Infof("[%s] Subnet 생성완료", subnetName)
        cblogger.Info(infoSubnet)

        //생성된 정보 조회
        //mappingSubnet() 이용하면 되지만 수정해야 함.

        return irs.SubnetInfo{}, nil</span>
}

func (vVPCHandler *GCPVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC의 [%s] Subnet 삭제", vpcIID.SystemId, subnetIID.SystemId)

        projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        infoSubnet, infoSubErr := vVPCHandler.Client.Subnetworks.Delete(projectID, region, subnetIID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if infoSubErr != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = infoSubErr.Error()

                callogger.Info(call.String(callLogInfo))
                cblogger.Error(infoSubErr)
                return false, infoSubErr
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info("Delete subnet result :", infoSubnet)

        //서브넷이 완전히 삭제될때까지 대기
        cblogger.Infof("[%s] Subnet 삭제 성공 - 리소스 ID : [%d]", subnetIID.SystemId, infoSubnet.Id)
        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
        if errWait != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Subnet 삭제 완료 대기 실패", subnetIID.SystemId)
                cblogger.Error(errWait)
                return false, errWait
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Mock Driver of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package mock

import (
        "C"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"

        mkcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/connect"
        mkrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type MockDriver struct{}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

func (MockDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "MOCK DRIVER Version 1.0"
}</span>

func (MockDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

func (driver *MockDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov8" title="1">{
        // &lt;standard flow&gt;
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of XXX Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/XXX_CloudConnection".
        // 4. return CloudConnection Interface of XXX_CloudConnection.

        // ex)
        // MockName = "mock01"
        iConn := mkcon.MockConnection{
                Region:   connectionInfo.RegionInfo,
                MockName: connectionInfo.CredentialInfo.MockName,
        }
        
        // Please, do not delete this line.
        mkrs.PrepareVMImage(iConn.MockName)
        mkrs.PrepareVMSpec(iConn.MockName)

        return &amp;iConn, nil
}</span>

var CloudDriver MockDriver
</pre>
		
		<pre class="file" id="file99" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.05.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        mkrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type MockConnection struct {
        Region   idrv.RegionInfo
        MockName string
}

func (cloudConn *MockConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateImageHandler()!")
        handler := mkrs.MockImageHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateVMHandler()!")
        handler := mkrs.MockVMHandler{cloudConn.Region, cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateVPCHandler()!")
        handler := mkrs.MockVPCHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn MockConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateSecurityHandler()!")
        handler := mkrs.MockSecurityHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateKeyPairHandler()!")
        handler := mkrs.MockKeyPairHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateVMSpecHandler()!")
        handler := mkrs.MockVMSpecHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        cblogger.Info("Mock Driver: called IsConnected()!")
        if cloudConn == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (cloudConn *MockConnection) Close() error <span class="cov0" title="0">{
        cblogger.Info("Mock Driver: called Close()!")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var imgInfoMap map[string][]*irs.ImageInfo

type MockImageHandler struct {
        MockName string
}

var PrepareImageInfoList []*irs.ImageInfo

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        imgInfoMap = make(map[string][]*irs.ImageInfo)
}</span>

// Be called before using the User function.
// Called in MockDriver
func PrepareVMImage(mockName string) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called PrepareVMImage()!")

        if imgInfoMap[mockName] != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">PrepareImageInfoList = []*irs.ImageInfo{
                {irs.IID{"mock-vmimage-01", "mock-vmimage-01"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-02", "mock-vmimage-02"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-03", "mock-vmimage-03"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-04", "mock-vmimage-04"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-05", "mock-vmimage-05"}, "TestGuestOS", "TestStatus", nil},
        }
        imgInfoMap[mockName] = PrepareImageInfoList</span>
}

// (1) create imageInfo object
// (2) insert ImageInfo into global Map
func (imageHandler *MockImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateImage()!")

        mockName := imageHandler.MockName
        imageReqInfo.IId.SystemId = imageReqInfo.IId.NameId

        // (1) create imageInfo object
        imageInfo := irs.ImageInfo{irs.IID{imageReqInfo.IId.NameId, imageReqInfo.IId.SystemId}, "TestGuestOS", "TestStatus", nil}

        // (2) insert ImageInfo into global Map
        imgInfoList, _ := imgInfoMap[mockName]
        imgInfoList = append(imgInfoList, &amp;imageInfo)
        imgInfoMap[mockName] = imgInfoList

        return imageInfo, nil
}</span>

func (imageHandler *MockImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListImage()!")

        mockName := imageHandler.MockName
        imgInfoList, ok := imgInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.ImageInfo{}, nil
        }</span>
        // cloning list of Image
        <span class="cov8" title="1">resultList := make([]*irs.ImageInfo, len(imgInfoList))
        copy(resultList, imgInfoList)
        return resultList, nil</span>
}

func (imageHandler *MockImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetImage()!")

        imgInfoList, err := imageHandler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range imgInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == imageIID.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.ImageInfo{}, fmt.Errorf("%s image does not exist!!", imageIID.NameId)</span>
}

func (imageHandler *MockImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteImage()!")

        imgInfoList, err := imageHandler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := imageHandler.MockName
        for idx, info := range imgInfoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == imageIID.SystemId </span><span class="cov8" title="1">{
                        imgInfoList = append(imgInfoList[:idx], imgInfoList[idx+1:]...)
                        imgInfoMap[mockName] = imgInfoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        _ "github.com/sirupsen/logrus"
)

var keyPairInfoMap map[string][]*irs.KeyPairInfo

type MockKeyPairHandler struct {
        MockName string
}

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        keyPairInfoMap = make(map[string][]*irs.KeyPairInfo)
}</span>

// (1) create keyPairInfo object
// (2) insert keyPairInfo into global Map
func (keyPairHandler *MockKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateKey()!")

        mockName := keyPairHandler.MockName
        keyPairReqInfo.IId.SystemId = keyPairReqInfo.IId.NameId

        // (1) create keyPairInfo object
        keyPairInfo := irs.KeyPairInfo{keyPairReqInfo.IId,
                "XXXXFingerprint", "XXXXPublicKey", "XXXXPrivateKey", "cb-user", nil}

        // (2) insert KeyPairInfo into global Map
        infoList, _ := keyPairInfoMap[mockName]
        infoList = append(infoList, &amp;keyPairInfo)
        keyPairInfoMap[mockName] = infoList

        return keyPairInfo, nil
}</span>

func (keyPairHandler *MockKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListKey()!")

        mockName := keyPairHandler.MockName
        infoList, ok := keyPairInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.KeyPairInfo{}, nil
        }</span>
        // cloning list of KeyPair
        <span class="cov8" title="1">resultList := make([]*irs.KeyPairInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (keyPairHandler *MockKeyPairHandler) GetKey(iid irs.IID) (irs.KeyPairInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetKey()!")

        infoList, err := keyPairHandler.ListKey()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.KeyPairInfo{}, fmt.Errorf("%s keypair does not exist!!", iid.NameId)</span>
}

func (keyPairHandler *MockKeyPairHandler) DeleteKey(iid irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteKey()!")

        infoList, err := keyPairHandler.ListKey()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := keyPairHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                        keyPairInfoMap[mockName] = infoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.10.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var securityInfoMap map[string][]*irs.SecurityInfo

type MockSecurityHandler struct {
        MockName string
}

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        securityInfoMap = make(map[string][]*irs.SecurityInfo)
}</span>

// (1) create securityInfo object
// (2) insert securityInfo into global Map
func (securityHandler *MockSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateSecurity()!")

        mockName := securityHandler.MockName
        securityReqInfo.IId.SystemId = securityReqInfo.IId.NameId
        securityReqInfo.VpcIID.SystemId = securityReqInfo.VpcIID.NameId
        // (1) create securityInfo object
        securityInfo := irs.SecurityInfo{securityReqInfo.IId,
                securityReqInfo.VpcIID,
                securityReqInfo.Direction,
                securityReqInfo.SecurityRules,
                nil}

        // (2) insert SecurityInfo into global Map
        infoList, _ := securityInfoMap[mockName]
        infoList = append(infoList, &amp;securityInfo)
        securityInfoMap[mockName] = infoList

        return CloneSecurityInfo(securityInfo), nil
}</span>

func CloneSecurityInfoList(srcInfoList []*irs.SecurityInfo) []*irs.SecurityInfo <span class="cov8" title="1">{
        clonedInfoList := []*irs.SecurityInfo{}
        for _, srcInfo := range srcInfoList </span><span class="cov8" title="1">{
                clonedInfo := CloneSecurityInfo(*srcInfo)
                clonedInfoList = append(clonedInfoList, &amp;clonedInfo)
        }</span>
        <span class="cov8" title="1">return clonedInfoList</span>
}

func CloneSecurityInfo(srcInfo irs.SecurityInfo) irs.SecurityInfo <span class="cov8" title="1">{
        /*
                type SecurityInfo struct {
                        IId IID // {NameId, SystemId}
                        VpcIID        IID    // {NameId, SystemId}
                        Direction     string // @todo userd??
                        SecurityRules *[]SecurityRuleInfo
                        KeyValueList []KeyValue
                }
        */

        // clone SecurityInfo
        clonedInfo := irs.SecurityInfo{
                IId:       irs.IID{srcInfo.IId.NameId, srcInfo.IId.SystemId},
                VpcIID:    irs.IID{srcInfo.VpcIID.NameId, srcInfo.VpcIID.SystemId},
                Direction: srcInfo.Direction,

                // Need not clone
                SecurityRules: srcInfo.SecurityRules,
                KeyValueList:  srcInfo.KeyValueList,
        }

        return clonedInfo
}</span>

func (securityHandler *MockSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListSecurity()!")

        mockName := securityHandler.MockName
        infoList, ok := securityInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.SecurityInfo{}, nil
        }</span>

        <span class="cov8" title="1">return CloneSecurityInfoList(infoList), nil</span>
}

func (securityHandler *MockSecurityHandler) GetSecurity(iid irs.IID) (irs.SecurityInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetSecurity()!")

        infoList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>

        // infoList is already cloned in ListSecurity()
        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.SecurityInfo{}, fmt.Errorf("%s SecurityGroup does not exist!!", iid.NameId)</span>
}

func (securityHandler *MockSecurityHandler) DeleteSecurity(iid irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteSecurity()!")

        infoList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := securityHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                        securityInfoMap[mockName] = infoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.10.

package resources

import (
        "fmt"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var vmInfoMap map[string][]*irs.VMInfo
var vmStatusInfoMap map[string][]*irs.VMStatusInfo

type MockVMHandler struct {
        Region   idrv.RegionInfo
        MockName string
}

func init() <span class="cov8" title="1">{
        vmInfoMap = make(map[string][]*irs.VMInfo)
        vmStatusInfoMap = make(map[string][]*irs.VMStatusInfo)
}</span>

func (vmHandler *MockVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called StartVM()!")

        mockName := vmHandler.MockName
        vmReqInfo.IId.SystemId = vmReqInfo.IId.NameId

        // image validation
        imageHandler := MockImageHandler{mockName}
        validatedImgInfo, err := imageHandler.GetImage(vmReqInfo.ImageIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // spec validation
        <span class="cov8" title="1">vmSpecHandler := MockVMSpecHandler{mockName}
        validatedSpecInfo, err := vmSpecHandler.GetVMSpec(vmHandler.Region.Region, vmReqInfo.VMSpecName)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // vpc validation
        <span class="cov8" title="1">vpcHandler := MockVPCHandler{mockName}
        validatedVPCInfo, err := vpcHandler.GetVPC(vmReqInfo.VpcIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // subnet validation
        <span class="cov8" title="1">var validatedSubnetInfo *irs.SubnetInfo = nil
        for _, info := range validatedVPCInfo.SubnetInfoList </span><span class="cov8" title="1">{
                if info.IId.NameId == vmReqInfo.SubnetIID.NameId </span><span class="cov8" title="1">{
                        validatedSubnetInfo = &amp;info
                }</span>
        }
        <span class="cov8" title="1">if validatedSubnetInfo == nil </span><span class="cov0" title="0">{
                errMSG := vmReqInfo.SubnetIID.NameId + " subnet iid does not exist!!"
                cblogger.Error(errMSG)
                return irs.VMInfo{}, fmt.Errorf(errMSG)
        }</span>

        // sg validation
        <span class="cov8" title="1">securityHandler := MockSecurityHandler{mockName}
        sgInfoList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov8" title="1">validatedSgIIDs := []irs.IID{}
        for _, info1 := range vmReqInfo.SecurityGroupIIDs </span><span class="cov8" title="1">{
                flg := false
                for _, info2 := range sgInfoList </span><span class="cov8" title="1">{
                        if (*info2).IId.NameId == info1.NameId </span><span class="cov8" title="1">{
                                validatedSgIIDs = append(validatedSgIIDs, info2.IId)
                                flg = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !flg </span><span class="cov0" title="0">{
                        errMSG := info1.NameId + " security group iid does not exist!!"
                        cblogger.Error(errMSG)
                        return irs.VMInfo{}, fmt.Errorf(errMSG)
                }</span>
        }

        // keypair validation
        <span class="cov8" title="1">keyPairHandler := MockKeyPairHandler{mockName}
        validatedKeyPairInfo, err := keyPairHandler.GetKey(vmReqInfo.KeyPairIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // vm creation
        <span class="cov8" title="1">vmInfo := irs.VMInfo{
                IId:       vmReqInfo.IId,
                StartTime: time.Now(),

                Region:            irs.RegionInfo{vmHandler.Region.Region, vmHandler.Region.Zone},
                ImageIId:          validatedImgInfo.IId,
                VMSpecName:        validatedSpecInfo.Name,
                VpcIID:            validatedVPCInfo.IId,
                SubnetIID:         validatedSubnetInfo.IId,
                SecurityGroupIIds: validatedSgIIDs,

                KeyPairIId: validatedKeyPairInfo.IId,

                VMUserId:     vmReqInfo.VMUserId,
                VMUserPasswd: vmReqInfo.VMUserPasswd,

                NetworkInterface: vmReqInfo.IId.NameId + "_" + mockName + "mockni",
                PublicIP:         "4.3.2.1",
                PublicDNS:        vmReqInfo.IId.NameId + "." + mockName + ".spider.barista.com",
                PrivateIP:        "1.2.3.4",
                PrivateDNS:       vmReqInfo.IId.NameId + "." + mockName + ".spider.barista.com",

                VMBootDisk:  "/dev/sda1",
                VMBlockDisk: "/dev/sda1",

                KeyValueList: nil,
        }

        infoList, _ := vmInfoMap[mockName]
        infoList = append(infoList, &amp;vmInfo)
        vmInfoMap[mockName] = infoList

        // vm status creation
        vmStatusInfo := irs.VMStatusInfo{vmReqInfo.IId, irs.Running}

        statusInfoList, _ := vmStatusInfoMap[mockName]
        statusInfoList = append(statusInfoList, &amp;vmStatusInfo)
        vmStatusInfoMap[mockName] = statusInfoList

        return vmInfo, nil</span>
}

func (vmHandler *MockVMHandler) SuspendVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called SuspendVM()!")

        mockName := vmHandler.MockName

        statusInfoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                errMSG := mockName + " vm status does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">var validatedStatusInfo *irs.VMStatusInfo = nil
        for _, info := range statusInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        validatedStatusInfo = info
                }</span>
        }
        <span class="cov8" title="1">if validatedStatusInfo == nil </span><span class="cov0" title="0">{
                errMSG := iid.NameId + " status iid does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">validatedStatusInfo.VmStatus = irs.Suspended
        return irs.Suspending, nil</span>
}

func (vmHandler *MockVMHandler) ResumeVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ResumeVM()!")

        mockName := vmHandler.MockName

        statusInfoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{

                errMSG := mockName + " vm status does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">var validatedStatusInfo *irs.VMStatusInfo = nil
        for _, info := range statusInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        validatedStatusInfo = info
                }</span>
        }
        <span class="cov8" title="1">if validatedStatusInfo == nil </span><span class="cov0" title="0">{
                errMSG := iid.NameId + " vm status iid does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">validatedStatusInfo.VmStatus = irs.Running
        return irs.Resuming, nil</span>
}

func (vmHandler *MockVMHandler) RebootVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called RebootVM()!")

        mockName := vmHandler.MockName

        statusInfoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                errMSG := mockName + " vm status does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">var validatedStatusInfo *irs.VMStatusInfo = nil
        for _, info := range statusInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        validatedStatusInfo = info
                }</span>
        }
        <span class="cov8" title="1">if validatedStatusInfo == nil </span><span class="cov0" title="0">{
                errMSG := iid.NameId + " vm status iid does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">if validatedStatusInfo.VmStatus == irs.Suspended </span><span class="cov0" title="0">{
                errMSG := "reboot not supported in SUSPENDED status"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">validatedStatusInfo.VmStatus = irs.Running
        return irs.Rebooting, nil</span>
}

func (vmHandler *MockVMHandler) TerminateVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called TerminateVM()!")

        infoList, err := vmHandler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">statusInfoList, err := vmHandler.ListVMStatus()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">mockName := vmHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                }</span>
        }
        <span class="cov8" title="1">vmInfoMap[mockName] = infoList

        for idx, info := range statusInfoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        statusInfoList = append(statusInfoList[:idx], statusInfoList[idx+1:]...)
                }</span>
        }
        <span class="cov8" title="1">vmStatusInfoMap[mockName] = statusInfoList

        return irs.Terminating, nil</span>
}

func (vmHandler *MockVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVMStatus()!")

        mockName := vmHandler.MockName
        infoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VMStatusInfo{}, nil
        }</span>
        // cloning list of VM Status
        <span class="cov8" title="1">resultList := make([]*irs.VMStatusInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (vmHandler *MockVMHandler) GetVMStatus(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVMStatus()!")

        infoList, err := vmHandler.ListVMStatus()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return (*info).VmStatus, nil
                }</span>
        }

        <span class="cov0" title="0">errMSG := iid.NameId + " status iid does not exist!!"
        cblogger.Error(errMSG)
        return "", fmt.Errorf(errMSG)</span>
}

func (vmHandler *MockVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVM()!")

        mockName := vmHandler.MockName
        infoList, ok := vmInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VMInfo{}, nil
        }</span>

        // cloning list of VM
        <span class="cov8" title="1">resultList := make([]*irs.VMInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (vmHandler *MockVMHandler) GetVM(iid irs.IID) (irs.VMInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVM()!")

        infoList, err := vmHandler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // infoList is already cloned in ListVM()
        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">errMSG := iid.NameId + " vm iid does not exist!!"
        cblogger.Error(errMSG)
        return irs.VMInfo{}, fmt.Errorf(errMSG)</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var vmSpecInfoMap map[string][]*irs.VMSpecInfo

type MockVMSpecHandler struct {
        MockName string
}

var PrepareVMSpecInfoList []*irs.VMSpecInfo

func init() <span class="cov8" title="1">{
        vmSpecInfoMap = make(map[string][]*irs.VMSpecInfo)
}</span>

// Be called before using the User function.
// Called in MockDriver
func PrepareVMSpec(mockName string) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called prepare()!")

        if vmSpecInfoMap[mockName] != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">PrepareVMSpecInfoList = []*irs.VMSpecInfo{
                {"default", "mock-vmspec-01", irs.VCpuInfo{"4", "2.7"}, "32768", []irs.GpuInfo{{"2", "NVIDIA", "V100", "16384MB"}}, nil},
                {"default", "mock-vmspec-02", irs.VCpuInfo{"4", "3.2"}, "32768", []irs.GpuInfo{{"1", "NVIDIA", "V100", "16384MB"}}, nil},
                {"default", "mock-vmspec-03", irs.VCpuInfo{"8", "2.7"}, "62464", nil, nil},
                {"default", "mock-vmspec-04", irs.VCpuInfo{"8", "2.7"}, "1024", nil, nil},
        }
        vmSpecInfoMap[mockName] = PrepareVMSpecInfoList</span>
}

func (vmSpecHandler *MockVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVMSpec()!")

        mockName := vmSpecHandler.MockName

        infoList, ok := vmSpecInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VMSpecInfo{}, nil
        }</span>
        <span class="cov8" title="1">var list []*irs.VMSpecInfo
        for _, info := range infoList </span><span class="cov8" title="1">{
                if info.Region == Region </span><span class="cov8" title="1">{
                        list = append(list, info)
                }</span>
        }
        // cloning list of VMSpec
        <span class="cov8" title="1">resultList := make([]*irs.VMSpecInfo, len(list))
        copy(resultList, list)
        return resultList, nil</span>
}

func (vmSpecHandler *MockVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVMSpec()!")

        infoList, err := vmSpecHandler.ListVMSpec(Region)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMSpecInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).Name == Name </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VMSpecInfo{}, fmt.Errorf("%s VMSpec does not exist!!", Name)</span>
}

func (vmSpecHandler *MockVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov8" title="1">{ // return string: json format
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListOrgVMSpec()!")
        return "", nil
}</span>

func (vmSpecHandler *MockVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov8" title="1">{ // return string: json format
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetOrgVMSpec()!")
        return "", nil
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.10.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        _ "github.com/sirupsen/logrus"
)

var vpcInfoMap map[string][]*irs.VPCInfo

type MockVPCHandler struct {
        MockName string
}

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        vpcInfoMap = make(map[string][]*irs.VPCInfo)
}</span>

// (1) create vpcInfo object
// (2) insert vpcInfo into global Map
func (vpcHandler *MockVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateVPC()!")

        mockName := vpcHandler.MockName
        vpcReqInfo.IId.SystemId = vpcReqInfo.IId.NameId

        // set SystemID of Subnet list
        for i, subnetInfo := range vpcReqInfo.SubnetInfoList </span><span class="cov8" title="1">{
                subnetInfo.IId.SystemId = subnetInfo.IId.NameId
                vpcReqInfo.SubnetInfoList[i] = subnetInfo
        }</span>

        // (1) create vpcInfo object
        <span class="cov8" title="1">vpcInfo := irs.VPCInfo{
                vpcReqInfo.IId,
                vpcReqInfo.IPv4_CIDR,
                vpcReqInfo.SubnetInfoList,
                nil}

        // (2) insert VPCInfo into global Map
        infoList, _ := vpcInfoMap[mockName]
        infoList = append(infoList, &amp;vpcInfo)
        vpcInfoMap[mockName] = infoList

        return vpcInfo, nil</span>
}

func (vpcHandler *MockVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVPC()!")

        mockName := vpcHandler.MockName
        infoList, ok := vpcInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VPCInfo{}, nil
        }</span>
        // cloning list of VPC
        <span class="cov8" title="1">resultList := make([]*irs.VPCInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (vpcHandler *MockVPCHandler) GetVPC(iid irs.IID) (irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVPC()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VPCInfo{}, fmt.Errorf("%s VPCGroup does not exist!!", iid.NameId)</span>
}

func (vpcHandler *MockVPCHandler) DeleteVPC(iid irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteVPC()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := vpcHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                        vpcInfoMap[mockName] = infoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (vpcHandler *MockVPCHandler) AddSubnet(iid irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called AddSubnet()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>

        <span class="cov8" title="1">subnetInfo.IId.SystemId = subnetInfo.IId.NameId
        for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        info.SubnetInfoList = append(info.SubnetInfoList, subnetInfo)
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VPCInfo{}, fmt.Errorf("%s VPCGroup does not exist!!", iid.NameId)</span>
}

func (vpcHandler *MockVPCHandler) RemoveSubnet(iid irs.IID, subnetIID irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called RemoveSubnet()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        for idx, subInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                                if subInfo.IId.SystemId == subnetIID.SystemId </span><span class="cov8" title="1">{
                                        info.SubnetInfoList = append(info.SubnetInfoList[:idx], info.SubnetInfoList[idx+1:]...)
                                        return true, nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package openstack

import (
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack"

        oscon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/connect"
        osrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type OpenStackDriver struct{}

func (OpenStackDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "OPENSTACK DRIVER Version 1.0"
}</span>

func (OpenStackDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

// modifiled by powerkim, 2019.07.29.
func (driver *OpenStackDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        // Initialize Logger
        osrs.InitLog()

        Client, err := getServiceClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ImageClient, err := getImageClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">NetworkClient, err := getNetworkClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">VolumeClient, err := getVolumeClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := oscon.OpenStackCloudConnection{Region: connectionInfo.RegionInfo, Client: Client, ImageClient: ImageClient, NetworkClient: NetworkClient, VolumeClient: VolumeClient}

        return &amp;iConn, nil</span>
}

// moved by powerkim, 2019.07.29.
func getServiceClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{

        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }

        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := openstack.NewComputeV2(provider, gophercloud.EndpointOpts{
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, err</span>
}

func getImageClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{

        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }
        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c, err := openstack.NewImageServiceV2(provider, gophercloud.EndpointOpts{
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c, err</span>
}

func getNetworkClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{

        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }

        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := openstack.NewNetworkV2(provider, gophercloud.EndpointOpts{
                Name:   "neutron",
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, err</span>
}
func getVolumeClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{
        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }
        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := openstack.NewBlockStorageV2(provider, gophercloud.EndpointOpts{
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client, err</span>
}

var CloudDriver OpenStackDriver
</pre>
		
		<pre class="file" id="file107" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by CB-Spider Team, 2019.06.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/gophercloud/gophercloud"
        "github.com/sirupsen/logrus"

        osrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

// OpenStackCloudConnection modified by powerkim, 2019.07.29
type OpenStackCloudConnection struct {
        Region        idrv.RegionInfo
        Client        *gophercloud.ServiceClient
        ImageClient   *gophercloud.ServiceClient
        NetworkClient *gophercloud.ServiceClient
        VolumeClient  *gophercloud.ServiceClient
}

func (cloudConn *OpenStackCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateImageHandler()!")
        imageHandler := osrs.OpenStackImageHandler{Client: cloudConn.Client, ImageClient: cloudConn.ImageClient}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := osrs.OpenStackVPCHandler{Client: cloudConn.NetworkClient}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn OpenStackCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateSecurityHandler()!")
        securityHandler := osrs.OpenStackSecurityHandler{Client: cloudConn.Client, NetworkClient: cloudConn.NetworkClient}
        return &amp;securityHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := osrs.OpenStackKeyPairHandler{Client: cloudConn.Client}
        return &amp;keypairHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateVMHandler()!")
        vmHandler := osrs.OpenStackVMHandler{Region: cloudConn.Region, Client: cloudConn.Client, NetworkClient: cloudConn.NetworkClient, VolumeClient: cloudConn.VolumeClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := osrs.OpenStackVMSpecHandler{Client: cloudConn.Client}
        return &amp;vmSpecHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (cloudConn *OpenStackCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/external"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/networks"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/ports"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/subnets"
        "github.com/gophercloud/gophercloud/pagination"
        "github.com/sirupsen/logrus"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
)

const (
        CBVirutalNetworkName = "CB-VNet"
        DNSNameservers       = "8.8.8.8"
)

var once sync.Once
var cblogger *logrus.Logger
var calllogger *logrus.Logger

func InitLog() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                // cblog is a global variable.
                cblogger = cblog.GetLogger("CB-SPIDER")
                calllogger = call.GetLogger("HISCALL")
        }</span>)
}

func LoggingError(hiscallInfo call.CLOUDLOGSCHEMA, err error) <span class="cov0" title="0">{
        cblogger.Error(err.Error())
        hiscallInfo.ErrorMSG = err.Error()
        calllogger.Info(call.String(hiscallInfo))
}</span>

func LoggingInfo(hiscallInfo call.CLOUDLOGSCHEMA, start time.Time) <span class="cov0" title="0">{
        hiscallInfo.ElapsedTime = call.Elapsed(start)
        calllogger.Info(call.String(hiscallInfo))
}</span>

func GetCallLogScheme(endpoint string, resourceType call.RES_TYPE, resourceName string, apiName string) call.CLOUDLOGSCHEMA <span class="cov0" title="0">{
        cblogger.Info(fmt.Sprintf("Call %s %s", call.OPENSTACK, apiName))
        return call.CLOUDLOGSCHEMA{
                CloudOS:      call.OPENSTACK,
                RegionZone:   endpoint,
                ResourceType: resourceType,
                ResourceName: resourceName,
                CloudOSAPI:   apiName,
        }
}</span>

func GetPublicVPCInfo(client *gophercloud.ServiceClient, typeName string) (string, error) <span class="cov0" title="0">{
        // VPC 목록 조회
        iTrue := true
        listOpts := external.ListOptsExt{
                ListOptsBuilder: networks.ListOpts{},
                External:        &amp;iTrue,
        }
        page, err := networks.List(client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get vpc list, err=%s", err)
                return "", err
        }</span>
        // external VPC 필터링
        <span class="cov0" title="0">var extVpcList []NetworkWithExt
        err = networks.ExtractNetworksInto(page, &amp;extVpcList)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get vpc list, err=%s", err)
                getErr := errors.New(fmt.Sprintf("Failed to get vpc list, err=%s", err.Error()))
                return "", getErr
        }</span>
        <span class="cov0" title="0">if len(extVpcList) == 0 </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get vpc list")
                return "", errors.New(fmt.Sprintf("Failed to get vpc list, external vpc not exist"))
        }</span>
        <span class="cov0" title="0">extVpc := extVpcList[0]
        if typeName == "ID" </span><span class="cov0" title="0">{
                return extVpc.ID, nil
        }</span> else<span class="cov0" title="0"> if typeName == "NAME" </span><span class="cov0" title="0">{
                return extVpc.Name, nil
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}

// GetCBVNetId 기본 가상 네트워크(CB-VNet) Id 정보 조회
func GetCBVNetId(client *gophercloud.ServiceClient) (string, error) <span class="cov0" title="0">{
        listOpt := networks.ListOpts{
                Name: CBVirutalNetworkName,
        }

        var vNetworkId string

        pager := networks.List(client, listOpt)
        err := pager.EachPage(func(page pagination.Page) (bool, error) </span><span class="cov0" title="0">{
                // Get vNetwork
                list, err := networks.ExtractNetworks(page)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                // Add to List
                <span class="cov0" title="0">for _, n := range list </span><span class="cov0" title="0">{
                        vNetworkId = n.ID
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return vNetworkId, nil</span>
}

func GetFlavorByName(client *gophercloud.ServiceClient, flavorName string) (string, error) <span class="cov0" title="0">{
        pages, err := flavors.ListDetail(client, nil).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">flavorList, err := flavors.ExtractFlavors(pages)
        for _, flavor := range flavorList </span><span class="cov0" title="0">{
                if flavor.Name == flavorName </span><span class="cov0" title="0">{
                        return flavor.ID, nil
                }</span>
        }
        <span class="cov0" title="0">return "", errors.New(fmt.Sprintf("could not found Flavor with name %s ", flavorName))</span>
}

func GetSecurityByName(networkClient *gophercloud.ServiceClient, securityName string) (*secgroups.SecurityGroup, error) <span class="cov0" title="0">{
        pages, err := secgroups.List(networkClient).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">secGroupList, err := secgroups.ExtractSecurityGroups(pages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range secGroupList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, securityName) </span><span class="cov0" title="0">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New(fmt.Sprintf("could not found SecurityGroups with name %s ", securityName))</span>
}

func GetNetworkByName(networkClient *gophercloud.ServiceClient, networkName string) (*networks.Network, error) <span class="cov0" title="0">{
        pages, err := networks.List(networkClient, networks.ListOpts{Name: networkName}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">netList, err := networks.ExtractNetworks(pages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range netList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, networkName) </span><span class="cov0" title="0">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New(fmt.Sprintf("could not found SecurityGroups with name %s ", networkName))</span>
}

func GetSubnetByID(networkClient *gophercloud.ServiceClient, subnetId string) (*subnets.Subnet, error) <span class="cov0" title="0">{
        subnet, err := subnets.Get(networkClient, subnetId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return subnet, nil</span>
}

func GetPortByDeviceID(networkClient *gophercloud.ServiceClient, deviceID string) (*ports.Port, error) <span class="cov0" title="0">{
        pages, err := ports.List(networkClient, ports.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">portList, err := ports.ExtractPorts(pages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range portList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.DeviceID, deviceID) </span><span class="cov0" title="0">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New(fmt.Sprintf("could not found SecurityGroups with name %s ", deviceID))</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package resources

import (
        "bytes"
        "errors"
        "fmt"
        "io/ioutil"
        "os"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/images"
        "github.com/gophercloud/gophercloud/openstack/imageservice/v2/imagedata"
        imgsvc "github.com/gophercloud/gophercloud/openstack/imageservice/v2/images"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Image = "IMAGE"
)

type OpenStackImageHandler struct {
        Client      *gophercloud.ServiceClient
        ImageClient *gophercloud.ServiceClient
}

func setterImage(image images.Image) *irs.ImageInfo <span class="cov0" title="0">{
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   image.Name,
                        SystemId: image.ID,
                },
                Status: image.Status,
        }

        // 메타 정보 등록
        var metadataList []irs.KeyValue
        for key, val := range image.Metadata </span><span class="cov0" title="0">{
                metadata := irs.KeyValue{
                        Key:   key,
                        Value: val.(string),
                }
                metadataList = append(metadataList, metadata)
        }</span>
        <span class="cov0" title="0">imageInfo.KeyValueList = metadataList

        return imageInfo</span>
}

func (imageHandler *OpenStackImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageReqInfo.IId.NameId, "CreateImage()")

        // @TODO: Image 생성 요청 파라미터 정의 필요
        type ImageReqInfo struct {
                Name            string
                ContainerFormat string
                DiskFormat      string
        }
        reqInfo := ImageReqInfo{
                Name:            imageReqInfo.IId.NameId,
                ContainerFormat: "bare",
                DiskFormat:      "iso",
        }

        createOpts := imgsvc.CreateOpts{
                Name:            reqInfo.Name,
                ContainerFormat: reqInfo.ContainerFormat,
                DiskFormat:      reqInfo.DiskFormat,
        }

        // Check Image file exists
        rootPath := os.Getenv("CBSPIDER_ROOT")
        imageFilePath := fmt.Sprintf("%s/image/%s.iso", rootPath, reqInfo.Name)
        if _, err := os.Stat(imageFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Image files in path %s not exist", imageFilePath))
                LoggingError(hiscallInfo, createErr)
                return irs.ImageInfo{}, createErr
        }</span>

        // Create Image
        <span class="cov0" title="0">start := call.Start()
        image, err := imgsvc.Create(imageHandler.ImageClient, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Upload Image file
        imageBytes, err := ioutil.ReadFile(imageFilePath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">result := imagedata.Upload(imageHandler.ImageClient, image.ID, bytes.NewReader(imageBytes))
        if result.Err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>

        // 생성된 Imgae 정보 리턴
        <span class="cov0" title="0">mappedImageInfo := images.Image{
                ID:       image.ID,
                Created:  image.CreatedAt.String(),
                MinDisk:  image.MinDiskGigabytes,
                MinRAM:   image.MinRAMMegabytes,
                Name:     image.Name,
                Status:   string(image.Status),
                Updated:  image.UpdatedAt.String(),
                Metadata: image.Properties,
        }
        imageInfo := setterImage(mappedImageInfo)
        return *imageInfo, nil</span>
}

func (imageHandler *OpenStackImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, Image, "ListImage()")

        start := call.Start()
        pager, err := images.ListDetail(imageHandler.Client, images.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageList, err := images.ExtractImages(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">imageInfoList := make([]*irs.ImageInfo, len(imageList))
        for i, img := range imageList </span><span class="cov0" title="0">{
                imageInfo := setterImage(img)
                imageInfoList[i] = imageInfo
        }</span>
        <span class="cov0" title="0">return imageInfoList, nil</span>
}

func (imageHandler *OpenStackImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "GetImage()")

        imageId, err := imageHandler.IDFromName(imageHandler.Client, imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">start := call.Start()
        image, err := images.Get(imageHandler.Client, imageId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageInfo := setterImage(*image)
        return *imageInfo, nil</span>
}

func (imageHandler *OpenStackImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "DeleteImage()")

        imageId, err := imageHandler.IDFromName(imageHandler.Client, imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">start := call.Start()
        err = images.Delete(imageHandler.Client, imageId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}

func (imageHandler *OpenStackImageHandler) IDFromName(serviceClient *gophercloud.ServiceClient, imageName string) (string, error) <span class="cov0" title="0">{
        pager, err := images.ListDetail(serviceClient, images.ListOpts{Name: imageName}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">imageList, err := images.ExtractImages(pager)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(imageList) &gt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("found multiple images with name %s", imageName))
        }</span> else<span class="cov0" title="0"> if len(imageList) == 0 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("could not found image with name %s", imageName))
        }</span>
        <span class="cov0" title="0">return imageList[0].ID, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package resources

import (
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        KeyPair = "KEYPAIR"
)

type OpenStackKeyPairHandler struct {
        Client *gophercloud.ServiceClient
}

func setterKeypair(keypair keypairs.KeyPair) *irs.KeyPairInfo <span class="cov0" title="0">{
        keypairInfo := &amp;irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keypair.Name,
                        SystemId: keypair.Name,
                },
                Fingerprint: keypair.Fingerprint,
                PublicKey:   keypair.PublicKey,
                PrivateKey:  keypair.PrivateKey,
        }
        return keypairInfo
}</span>

func (keyPairHandler *OpenStackKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyPairReqInfo.IId.NameId, "CreateKey()")

        create0pts := keypairs.CreateOpts{
                Name:      keyPairReqInfo.IId.NameId,
                PublicKey: "",
        }

        start := call.Start()
        keyPair, err := keypairs.Create(keyPairHandler.Client, create0pts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // 생성된 KeyPair 정보 리턴
        keyPairInfo := setterKeypair(*keyPair)
        return *keyPairInfo, nil</span>
}

func (keyPairHandler *OpenStackKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, KeyPair, "ListKey()")

        // 키페어 목록 조회
        start := call.Start()
        pager, err := keypairs.List(keyPairHandler.Client).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keypair, err := keypairs.ExtractKeyPairs(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        // 키페어 목록 정보 매핑
        <span class="cov0" title="0">keyPairList := make([]*irs.KeyPairInfo, len(keypair))
        for i, k := range keypair </span><span class="cov0" title="0">{
                keyPairList[i] = setterKeypair(k)
        }</span>
        <span class="cov0" title="0">return keyPairList, nil</span>
}

func (keyPairHandler *OpenStackKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "GetKey()")

        start := call.Start()
        keyPair, err := keypairs.Get(keyPairHandler.Client, keyIID.NameId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keyPairInfo := setterKeypair(*keyPair)
        return *keyPairInfo, nil</span>
}

func (keyPairHandler *OpenStackKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "DeleteKey()")

        start := call.Start()
        err := keypairs.Delete(keyPairHandler.Client, keyIID.NameId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/security/rules"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Inbound       = "inbound"
        Outbound      = "outbound"
        ICMP          = "icmp"
        SecurityGroup = "SECURITYGROUP"
)

type OpenStackSecurityHandler struct {
        Client        *gophercloud.ServiceClient
        NetworkClient *gophercloud.ServiceClient
}

func (securityHandler *OpenStackSecurityHandler) setterSeg(secGroup secgroups.SecurityGroup) *irs.SecurityInfo <span class="cov0" title="0">{
        secInfo := &amp;irs.SecurityInfo{
                IId: irs.IID{
                        NameId:   secGroup.Name,
                        SystemId: secGroup.ID,
                },
        }

        listOpts := rules.ListOpts{
                SecGroupID: secGroup.ID,
        }
        pager, err := rules.List(securityHandler.NetworkClient, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">secList, err := rules.ExtractRules(pager)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 보안그룹 룰 정보 등록
        <span class="cov0" title="0">secRuleList := make([]irs.SecurityRuleInfo, len(secList))
        for i, rule := range secList </span><span class="cov0" title="0">{
                var direction string
                if strings.EqualFold(rule.Direction, string(rules.DirIngress)) </span><span class="cov0" title="0">{
                        direction = Inbound
                }</span> else<span class="cov0" title="0"> {
                        direction = Outbound
                }</span>

                <span class="cov0" title="0">ruleInfo := irs.SecurityRuleInfo{
                        Direction:  direction,
                        IPProtocol: strings.ToLower(rule.Protocol),
                        CIDR:       rule.RemoteIPPrefix,
                }

                if strings.ToLower(rule.Protocol) == ICMP </span><span class="cov0" title="0">{
                        ruleInfo.FromPort = "-1"
                        ruleInfo.ToPort = "-1"
                }</span> else<span class="cov0" title="0"> {
                        ruleInfo.FromPort = strconv.Itoa(rule.PortRangeMin)
                        ruleInfo.ToPort = strconv.Itoa(rule.PortRangeMax)
                }</span>

                <span class="cov0" title="0">secRuleList[i] = ruleInfo</span>
        }
        <span class="cov0" title="0">secInfo.SecurityRules = &amp;secRuleList

        return secInfo</span>
}

func (securityHandler *OpenStackSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityReqInfo.IId.NameId, "CreateSecurity()")

        // Check SecurityGroup Exists
        secGroupList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">for _, sg := range secGroupList </span><span class="cov0" title="0">{
                if sg.IId.NameId == securityReqInfo.IId.NameId </span><span class="cov0" title="0">{
                        createErr := errors.New(fmt.Sprintf("Security Group with name %s already exist", securityReqInfo.IId.NameId))
                        LoggingError(hiscallInfo, createErr)
                        return irs.SecurityInfo{}, createErr
                }</span>
        }

        // Create SecurityGroup
        <span class="cov0" title="0">createOpts := secgroups.CreateOpts{
                Name:        securityReqInfo.IId.NameId,
                Description: securityReqInfo.IId.NameId,
        }

        start := call.Start()
        group, err := secgroups.Create(securityHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Create SecurityGroup Rules
        for _, rule := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{

                var direction string
                if strings.EqualFold(strings.ToLower(rule.Direction), Inbound) </span><span class="cov0" title="0">{
                        direction = string(rules.DirIngress)
                }</span> else<span class="cov0" title="0"> {
                        direction = string(rules.DirEgress)
                }</span>

                <span class="cov0" title="0">var createRuleOpts rules.CreateOpts

                if strings.ToLower(rule.IPProtocol) == ICMP </span><span class="cov0" title="0">{
                        createRuleOpts = rules.CreateOpts{
                                Direction:      rules.RuleDirection(direction),
                                EtherType:      rules.EtherType4,
                                SecGroupID:     group.ID,
                                Protocol:       rules.RuleProtocol(strings.ToLower(rule.IPProtocol)),
                                RemoteIPPrefix: rule.CIDR,
                        }
                }</span> else<span class="cov0" title="0"> {
                        fromPort, _ := strconv.Atoi(rule.FromPort)
                        toPort, _ := strconv.Atoi(rule.ToPort)
                        createRuleOpts = rules.CreateOpts{
                                Direction:      rules.RuleDirection(direction),
                                EtherType:      rules.EtherType4,
                                SecGroupID:     group.ID,
                                PortRangeMin:   fromPort,
                                PortRangeMax:   toPort,
                                Protocol:       rules.RuleProtocol(strings.ToLower(rule.IPProtocol)),
                                RemoteIPPrefix: rule.CIDR,
                        }
                }</span>

                <span class="cov0" title="0">_, err := rules.Create(securityHandler.NetworkClient, createRuleOpts).Extract()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.SecurityInfo{}, err
                }</span>
        }

        // 생성된 SecurityGroup 정보 리턴
        <span class="cov0" title="0">securityInfo, err := securityHandler.GetSecurity(irs.IID{SystemId: group.ID})
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *OpenStackSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, SecurityGroup, "ListSecurity()")

        // 보안그룹 목록 조회
        start := call.Start()
        pager, err := secgroups.List(securityHandler.Client).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        security, err := secgroups.ExtractSecurityGroups(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        // 보안그룹 목록 정보 매핑
        <span class="cov0" title="0">var securityList []*irs.SecurityInfo
        securityList = make([]*irs.SecurityInfo, len(security))
        for i, v := range security </span><span class="cov0" title="0">{
                securityList[i] = securityHandler.setterSeg(v)
        }</span>
        <span class="cov0" title="0">return securityList, nil</span>
}

func (securityHandler *OpenStackSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "GetSecurity()")

        start := call.Start()
        securityGroup, err := secgroups.Get(securityHandler.Client, securityIID.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        securityInfo := securityHandler.setterSeg(*securityGroup)
        return *securityInfo, nil</span>
}

func (securityHandler *OpenStackSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "DeleteSecurity()")

        start := call.Start()
        result := secgroups.Delete(securityHandler.Client, securityIID.SystemId)
        if result.Err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, result.Err)
                return false, result.Err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package resources

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "strings"
        "time"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/blockstorage/v2/volumes"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/images"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/servers"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VM             = "VM"
        SSHDefaultUser = "cb-user"
)

type OpenStackVMHandler struct {
        Region        idrv.RegionInfo
        Client        *gophercloud.ServiceClient
        NetworkClient *gophercloud.ServiceClient
        VolumeClient  *gophercloud.ServiceClient
}

func (vmHandler *OpenStackVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmReqInfo.IId.NameId, "StartVM()")

        // 가상서버 이름 중복 체크
        pager, err := servers.List(vmHandler.Client, servers.ListOpts{Name: vmReqInfo.IId.NameId}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get vm with name %s", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>
        <span class="cov0" title="0">existServer, err := servers.ExtractServers(pager)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to extract vm information with name %s", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>
        <span class="cov0" title="0">if len(existServer) != 0 </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("VirtualMachine with name %s already exist", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        /*vNetId, err := GetCBVNetId(vmHandler.NetworkClient)
        if err != nil {
                return irs.VMInfo{}, err
        }
        if vNetId == "" {
                cblogger.Error(fmt.Sprintf("failed to get vnetwork"))
                return irs.VMInfo{}, err
        }*/

        //  이미지 정보 조회 (Name)
        /*imageHandler := OpenStackImageHandler{
                Client: vmHandler.Client,
        }
        image, err := imageHandler.GetImage(vmReqInfo.IId)
        if err != nil {
                cblogger.Error(fmt.Sprintf("failed to get image, err : %s", err))
                return irs.VMInfo{}, err
        }*/

        //  네트워크 정보 조회 (Name)
        /*vNetworkHandler := OpenStackVPCHandler{
                Client: vmHandler.Client,
        }
        vNetwork, err := vNetworkHandler.GetVNetwork(vmReqInfo.VirtualNetworkId)
        if err != nil {
                cblogger.Error(fmt.Sprintf("failed to get virtual network, err : %s", err))
                return irs.VMInfo{}, err
        }*/

        // 보안그룹 정보 조회 (Name)
        /*securityHandler := OpenStackSecurityHandler{
                Client:        vmHandler.Client,
                NetworkClient: vmHandler.NetworkClient,
        }
        secGroups := make([]string, len(vmReqInfo.SecurityGroupIIDs))
        for i, s := range vmReqInfo.SecurityGroupIIDs {
                security, err := securityHandler.GetSecurity(s)
                if err != nil {
                        cblogger.Error(fmt.Sprintf("failed to get security group, err : %s", err))
                        return irs.VMInfo{}, err
                        //continue
                }
                secGroups[i] = security.IId.SystemId
        }*/

        // Flavor 정보 조회 (Name)
        /*flavorId, err := GetFlavor(vmHandler.Client, vmReqInfo.VMSpecName)
        if err != nil {
                cblogger.Error(fmt.Sprintf("failed to get vm spec, err : %s", err))
                return irs.VMInfo{}, err
        }*/

        //  이미지 정보 조회 (Name)
        <span class="cov0" title="0">imageHandler := OpenStackImageHandler{
                Client: vmHandler.Client,
        }
        image, err := imageHandler.GetImage(vmReqInfo.ImageIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(fmt.Sprintf("failed to get image, err : %s", err))
                return irs.VMInfo{}, err
        }</span>

        // Flavor 정보 조회 (Name)
        <span class="cov0" title="0">vmSpecId, err := GetFlavorByName(vmHandler.Client, vmReqInfo.VMSpecName)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        // VM 생성
        <span class="cov0" title="0">serverCreateOpts := servers.CreateOpts{
                Name: vmReqInfo.IId.NameId,
                //ImageName: vmReqInfo.ImageIID.NameId,
                ImageRef: image.IId.SystemId,
                //FlavorName: vmReqInfo.VMSpecName,
                FlavorRef: vmSpecId,
                Networks: []servers.Network{
                        {UUID: vmReqInfo.VpcIID.SystemId},
                },
        }

        sgIdArr := make([]string, len(vmReqInfo.SecurityGroupIIDs))
        for i, sg := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                sgIdArr[i] = sg.SystemId
        }</span>
        <span class="cov0" title="0">serverCreateOpts.SecurityGroups = sgIdArr

        // Add KeyPair
        createOpts := keypairs.CreateOptsExt{
                KeyName: vmReqInfo.KeyPairIID.NameId,
        }

        // KeyPair 정보 가져오기
        keyPair, err := keypairs.Get(vmHandler.Client, vmReqInfo.KeyPairIID.NameId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        // cloud-init 스크립트 설정
        <span class="cov0" title="0">rootPath := os.Getenv("CBSPIDER_ROOT")
        fileData, err := ioutil.ReadFile(rootPath + "/cloud-driver-libs/.cloud-init-openstack/cloud-init")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">fileStr := string(fileData)
        fileStr = strings.ReplaceAll(fileStr, "{{username}}", SSHDefaultUser)
        fileStr = strings.ReplaceAll(fileStr, "{{public_key}}", keyPair.PublicKey)

        // cloud-init 스크립트 적용
        serverCreateOpts.UserData = []byte(fileStr)
        createOpts.CreateOptsBuilder = serverCreateOpts

        start := call.Start()
        server, err := servers.Create(vmHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var serverResult *servers.Server
        var serverInfo irs.VMInfo

        // VM 생성 완료까지 wait
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                // Check VM Deploy Status
                serverResult, err = servers.Get(vmHandler.Client, server.ID).Extract()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VMInfo{}, err
                }</span>

                <span class="cov0" title="0">if strings.ToLower(serverResult.Status) == "active" </span><span class="cov0" title="0">{
                        // Associate Public IP
                        if ok, err := vmHandler.AssociatePublicIP(serverResult.ID); !ok </span><span class="cov0" title="0">{
                                LoggingError(hiscallInfo, err)
                                return irs.VMInfo{}, err
                        }</span>
                        // Get server info
                        <span class="cov0" title="0">serverResult, err = servers.Get(vmHandler.Client, server.ID).Extract()
                        serverInfo = vmHandler.mappingServerInfo(*serverResult)
                        break</span>
                }
                <span class="cov0" title="0">curRetryCnt++
                time.Sleep(1 * time.Second)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                        return irs.VMInfo{}, errors.New(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                }</span>
        }

        <span class="cov0" title="0">return serverInfo, nil</span>
}

func (vmHandler *OpenStackVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "SuspendVM()")

        /*vmID, err := vmHandler.getVmIdByName(vmNameID)
        if err != nil {
                cblogger.Error(err)
                return irs.Failed, err
        }*/
        start := call.Start()
        err := startstop.Stop(vmHandler.Client, vmIID.SystemId).Err
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // 자체생성상태 반환 (OpenStack은 진행 중인 상태에 대한 정보 미제공)
        return irs.Suspending, nil</span>
}

func (vmHandler *OpenStackVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "ResumeVM()")

        /*vmID, err := vmHandler.getVmIdByName(vmNameID)
        if err != nil {
                cblogger.Error(err)
                return irs.Failed, err
        }*/
        start := call.Start()
        err := startstop.Start(vmHandler.Client, vmIID.SystemId).Err
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // 자체생성상태 반환 (OpenStack은 진행 중인 상태에 대한 정보 미제공)
        return irs.Resuming, nil</span>
}

func (vmHandler *OpenStackVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "RebootVM()")

        /*vmID, err := vmHandler.getVmIdByName(vmNameID)
        if err != nil {
                cblogger.Error(err)
                return irs.Failed, err
        }*/
        start := call.Start()
        rebootOpts := servers.RebootOpts{
                Type: servers.SoftReboot,
        }

        err := servers.Reboot(vmHandler.Client, vmIID.SystemId, rebootOpts).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // 자체생성상태 반환 (OpenStack은 진행 중인 상태에 대한 정보 미제공)
        return irs.Rebooting, nil</span>
}

func (vmHandler *OpenStackVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "TerminateVM()")

        // VM 정보 조회
        server, err := vmHandler.GetVM(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // VM에 연결된 PublicIP 삭제
        <span class="cov0" title="0">pager, err := floatingips.List(vmHandler.Client).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">publicIPList, err := floatingips.ExtractFloatingIPs(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // IP 기준 PublicIP 검색
        <span class="cov0" title="0">var publicIPId string
        for _, p := range publicIPList </span><span class="cov0" title="0">{
                if strings.EqualFold(server.PublicIP, p.IP) </span><span class="cov0" title="0">{
                        publicIPId = p.ID
                        break</span>
                }
        }
        // Public IP 삭제
        <span class="cov0" title="0">if publicIPId != "" </span><span class="cov0" title="0">{
                err := floatingips.Delete(vmHandler.Client, publicIPId).ExtractErr()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.Failed, err
                }</span>
        }

        // VM 삭제
        <span class="cov0" title="0">start := call.Start()
        err = servers.Delete(vmHandler.Client, server.IId.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // 자체생성상태 반환 (OpenStack은 진행 중인 상태에 대한 정보 미제공)
        return irs.Terminating, nil</span>
}

func (vmHandler *OpenStackVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVMStatus()")

        start := call.Start()
        pager, err := servers.List(vmHandler.Client, nil).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        servers, err := servers.ExtractServers(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        // Add to List
        <span class="cov0" title="0">vmStatusList := make([]*irs.VMStatusInfo, len(servers))
        for idx, s := range servers </span><span class="cov0" title="0">{
                vmStatus := getVmStatus(s.Status)
                vmStatusInfo := irs.VMStatusInfo{
                        IId: irs.IID{
                                NameId:   s.Name,
                                SystemId: s.ID,
                        },
                        VmStatus: vmStatus,
                }
                vmStatusList[idx] = &amp;vmStatusInfo
        }</span>
        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func (vmHandler *OpenStackVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVMStatus()")

        start := call.Start()
        serverResult, err := servers.Get(vmHandler.Client, vmIID.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmStatus := getVmStatus(serverResult.Status)
        return vmStatus, nil</span>
}

func (vmHandler *OpenStackVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVM()")

        // 가상서버 목록 조회
        start := call.Start()
        pager, err := servers.List(vmHandler.Client, nil).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        servers, err := servers.ExtractServers(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        // 가상서버 목록 정보 매핑
        <span class="cov0" title="0">vmList := make([]*irs.VMInfo, len(servers))
        for i, v := range servers </span><span class="cov0" title="0">{
                serverInfo := vmHandler.mappingServerInfo(v)
                vmList[i] = &amp;serverInfo
        }</span>
        <span class="cov0" title="0">return vmList, nil</span>
}

func (vmHandler *OpenStackVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVM()")

        // 기존의 vmID 기준 가상서버 조회 (old)
        /*serverResult, err := servers.Get(vmHandler.Client, vmID).Extract()
        if err != nil {
                cblogger.Info(err)
                return irs.VMInfo{}, err
        }*/
        /*vmID, err := vmHandler.getVmIdByName(vmIID.NameId)
        if err != nil {
                return irs.VMInfo{}, err
        }*/

        start := call.Start()
        serverResult, err := servers.Get(vmHandler.Client, vmIID.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfo := vmHandler.mappingServerInfo(*serverResult)
        return vmInfo, nil</span>
}

func (vmHandler *OpenStackVMHandler) AssociatePublicIP(serverID string) (bool, error) <span class="cov0" title="0">{
        // PublicIP 생성
        externVPCName, _ := GetPublicVPCInfo(vmHandler.NetworkClient, "NAME")
        createOpts := floatingips.CreateOpts{
                Pool: externVPCName,
        }
        publicIP, err := floatingips.Create(vmHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // PublicIP VM 연결
        <span class="cov0" title="0">curRetryCnt := 0
        //maxRetryCnt := 60
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                associateOpts := floatingips.AssociateOpts{
                        FloatingIP: publicIP.IP,
                }
                err = floatingips.AssociateInstance(vmHandler.Client, serverID, associateOpts).ExtractErr()
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(fmt.Sprintf("[%d] err = %s", curRetryCnt, err))
                }</span>

                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                curRetryCnt++

                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf(fmt.Sprintf("failed to associate floating ip to vm, exceeded maximum retry count %d", maxRetryCnt))
                        return false, errors.New(fmt.Sprintf("failed to associate floating ip to vm, exceeded maximum retry count %d", maxRetryCnt))
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func getVmStatus(vmStatus string) irs.VMStatus <span class="cov0" title="0">{
        var resultStatus string
        switch strings.ToLower(vmStatus) </span>{
        case "build":<span class="cov0" title="0">
                resultStatus = "Creating"</span>
        case "active":<span class="cov0" title="0">
                resultStatus = "Running"</span>
        case "shutoff":<span class="cov0" title="0">
                resultStatus = "Suspended"</span>
        case "reboot":<span class="cov0" title="0">
                resultStatus = "Rebooting"</span>
        case "error":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                resultStatus = "Failed"</span>
        }
        <span class="cov0" title="0">return irs.VMStatus(resultStatus)</span>
}

func (vmHandler *OpenStackVMHandler) mappingServerInfo(server servers.Server) irs.VMInfo <span class="cov0" title="0">{

        // Get Default VM Info
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId:   server.Name,
                        SystemId: server.ID,
                },
                Region: irs.RegionInfo{
                        Zone:   vmHandler.Region.Zone,
                        Region: vmHandler.Region.Region,
                },
                KeyPairIId: irs.IID{
                        NameId:   server.KeyName,
                        SystemId: server.KeyName,
                },
                //VMUserId:          server.UserID,
                //VMUserPasswd:      server.AdminPass,
                NetworkInterface:  server.HostID,
                KeyValueList:      nil,
                SecurityGroupIIds: nil,
        }
        if creatTime, err := time.Parse(time.RFC3339, server.Created.String()); err == nil </span><span class="cov0" title="0">{
                vmInfo.StartTime = creatTime
        }</span>

        // VM Image 정보 설정
        <span class="cov0" title="0">if len(server.Image) != 0 </span><span class="cov0" title="0">{
                imageId := server.Image["id"].(string)
                vmInfo.ImageIId = irs.IID{
                        SystemId: imageId,
                }
                image, _ := images.Get(vmHandler.Client, imageId).Extract()
                if image != nil </span><span class="cov0" title="0">{
                        vmInfo.ImageIId.NameId = image.Name
                }</span>
        }

        // VM Flavor 정보 설정
        <span class="cov0" title="0">flavorId := server.Flavor["id"].(string)
        flavor, _ := flavors.Get(vmHandler.Client, flavorId).Extract()
        if flavor != nil </span><span class="cov0" title="0">{
                vmInfo.VMSpecName = flavor.Name
        }</span>

        // VM SecurityGroup 정보 설정
        <span class="cov0" title="0">if len(server.SecurityGroups) != 0 </span><span class="cov0" title="0">{
                securityGroupIdArr := make([]irs.IID, len(server.SecurityGroups))
                for i, secGroupMap := range server.SecurityGroups </span><span class="cov0" title="0">{
                        secGroupName := secGroupMap["name"].(string)
                        securityGroupIdArr[i] = irs.IID{
                                NameId: secGroupName,
                        }
                        secGroup, _ := GetSecurityByName(vmHandler.Client, secGroupName)
                        if secGroup != nil </span><span class="cov0" title="0">{
                                securityGroupIdArr[i].SystemId = secGroup.ID
                        }</span>
                }
                <span class="cov0" title="0">vmInfo.SecurityGroupIIds = securityGroupIdArr</span>
        }

        <span class="cov0" title="0">for k, subnet := range server.Addresses </span><span class="cov0" title="0">{
                // VPC 정보 설정
                vmInfo.VpcIID.NameId = k
                network, _ := GetNetworkByName(vmHandler.NetworkClient, vmInfo.VpcIID.NameId)
                if network != nil </span><span class="cov0" title="0">{
                        vmInfo.VpcIID.SystemId = network.ID
                }</span>
                // PrivateIP, PublicIp 설정
                <span class="cov0" title="0">for _, addr := range subnet.([]interface{}) </span><span class="cov0" title="0">{
                        addrMap := addr.(map[string]interface{})
                        if addrMap["OS-EXT-IPS:type"] == "floating" </span><span class="cov0" title="0">{
                                vmInfo.PublicIP = addrMap["addr"].(string)
                        }</span> else<span class="cov0" title="0"> if addrMap["OS-EXT-IPS:type"] == "fixed" </span><span class="cov0" title="0">{
                                vmInfo.PrivateIP = addrMap["addr"].(string)
                        }</span>
                }
        }

        // Subnet, Network Interface 정보 설정
        <span class="cov0" title="0">port, _ := GetPortByDeviceID(vmHandler.NetworkClient, vmInfo.IId.SystemId)
        if port != nil </span><span class="cov0" title="0">{
                // Subnet 정보 설정
                if len(port.FixedIPs) &gt; 0 </span><span class="cov0" title="0">{
                        ipInfo := port.FixedIPs[0]
                        vmInfo.SubnetIID.SystemId = ipInfo.SubnetID
                }</span>
                <span class="cov0" title="0">subnet, _ := GetSubnetByID(vmHandler.NetworkClient, vmInfo.SubnetIID.SystemId)
                if subnet != nil </span><span class="cov0" title="0">{
                        vmInfo.SubnetIID.NameId = subnet.Name
                }</span>

                // Network Interface 정보 설정
                <span class="cov0" title="0">vmInfo.NetworkInterface = port.ID</span>
        }

        // Volume Disk 조회
        <span class="cov0" title="0">pages, _ := volumes.List(vmHandler.VolumeClient, volumes.ListOpts{}).AllPages()
        volList, _ := volumes.ExtractVolumes(pages)

        for _, vol := range volList </span><span class="cov0" title="0">{
                for _, attach := range vol.Attachments </span><span class="cov0" title="0">{
                        if attach.ServerID == vmInfo.IId.SystemId </span><span class="cov0" title="0">{
                                vmInfo.VMBlockDisk = attach.Device
                        }</span>
                }
        }

        <span class="cov0" title="0">return vmInfo</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package resources

import (
        "encoding/json"
        "errors"
        "fmt"
        "strconv"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMSpec = "VMSPEC"
)

type OpenStackVMSpecHandler struct {
        Client *gophercloud.ServiceClient
}

func setterVMSpec(region string, vmSpec flavors.Flavor) *irs.VMSpecInfo <span class="cov0" title="0">{
        vmSpecInfo := &amp;irs.VMSpecInfo{
                Region:       region,
                Name:         vmSpec.Name,
                VCpu:         irs.VCpuInfo{Count: strconv.Itoa(vmSpec.VCPUs)},
                Mem:          strconv.Itoa(vmSpec.RAM),
                Gpu:          nil,
                KeyValueList: nil,
        }

        return vmSpecInfo
}</span>

func (vmSpecHandler *OpenStackVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListVMSpec()")

        start := call.Start()
        pager, err := flavors.ListDetail(vmSpecHandler.Client, flavors.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        list, err := flavors.ExtractFlavors(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">vmSpecList := make([]*irs.VMSpecInfo, len(list))
        for i, spec := range list </span><span class="cov0" title="0">{
                vmSpecList[i] = setterVMSpec(Region, spec)
        }</span>
        <span class="cov0" title="0">return vmSpecList, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetVMSpec()")

        vmSpecId, err := vmSpecHandler.getIDFromName(vmSpecHandler.Client, Name)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMSpecInfo{}, err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        vmSpec, err := flavors.Get(vmSpecHandler.Client, vmSpecId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmSpecInfo := setterVMSpec(Region, *vmSpec)
        return *vmSpecInfo, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListOrgVMSpec()")

        start := call.Start()
        pager, err := flavors.ListDetail(vmSpecHandler.Client, flavors.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        list, err := flavors.ExtractFlavors(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">var jsonResult struct {
                Result []flavors.Flavor `json:"list"`
        }
        jsonResult.Result = list
        jsonBytes, err := json.Marshal(jsonResult)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetOrgVMSpec()")

        vmSpecId, err := vmSpecHandler.getIDFromName(vmSpecHandler.Client, Name)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        vmSpec, err := flavors.Get(vmSpecHandler.Client, vmSpecId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        jsonBytes, err := json.Marshal(vmSpec)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) getIDFromName(serviceClient *gophercloud.ServiceClient, imageName string) (string, error) <span class="cov0" title="0">{
        pager, err := flavors.ListDetail(serviceClient, flavors.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">flavorList, err := flavors.ExtractFlavors(pager)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var flavorNameList []flavors.Flavor
        for _, flavor := range flavorList </span><span class="cov0" title="0">{
                if flavor.Name == imageName </span><span class="cov0" title="0">{
                        flavorNameList = append(flavorNameList, flavor)
                }</span>
        }

        <span class="cov0" title="0">if len(flavorNameList) &gt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("found multiple images with name %s", imageName))
        }</span> else<span class="cov0" title="0"> if len(flavorNameList) == 0 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("could not found image with name %s", imageName))
        }</span>
        <span class="cov0" title="0">return flavorNameList[0].ID, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package resources

import (
        "errors"
        "fmt"

        "github.com/Azure/go-autorest/autorest/to"
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/external"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/layer3/routers"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/networks"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/subnets"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VPC = "VPC"
)

type OpenStackVPCHandler struct {
        Client *gophercloud.ServiceClient
}

type NetworkWithExt struct {
        networks.Network
        external.NetworkExternalExt
}

func (vpcHandler *OpenStackVPCHandler) setterVPC(nvpc NetworkWithExt) *irs.VPCInfo <span class="cov0" title="0">{

        // VPC 정보 맵핑
        vpcInfo := irs.VPCInfo{
                IId: irs.IID{
                        NameId:   nvpc.Name,
                        SystemId: nvpc.ID,
                },
        }
        var External string
        if nvpc.External == true </span><span class="cov0" title="0">{
                External = "Yes"
        }</span> else<span class="cov0" title="0"> if nvpc.External == false </span><span class="cov0" title="0">{
                External = "No"
        }</span>
        <span class="cov0" title="0">keyValueList := []irs.KeyValue{
                {Key: "External Network", Value: External},
        }
        vpcInfo.KeyValueList = keyValueList

        // 서브넷 정보 조회
        subnetInfoList := make([]irs.SubnetInfo, len(nvpc.Subnets))

        for i, subnetId := range nvpc.Subnets </span><span class="cov0" title="0">{
                subnetInfo, err := vpcHandler.GetSubnet(irs.IID{SystemId: subnetId})
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error("Failed to get subnet with Id %s, err=%s", subnetId, err)
                        continue</span>
                }
                <span class="cov0" title="0">subnetInfoList[i] = subnetInfo</span>
        }
        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetInfoList

        return &amp;vpcInfo</span>
}

func (vpcHandler *OpenStackVPCHandler) setterSubnet(subnet subnets.Subnet) *irs.SubnetInfo <span class="cov0" title="0">{
        subnetInfo := irs.SubnetInfo{
                IId: irs.IID{
                        NameId:   subnet.Name,
                        SystemId: subnet.ID,
                },
                IPv4_CIDR: subnet.CIDR,
        }
        return &amp;subnetInfo
}</span>

func (vpcHandler *OpenStackVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcReqInfo.IId.NameId, "CreateVPC()")

        // Check VPC Exists
        listOpts := networks.ListOpts{Name: vpcReqInfo.IId.NameId}
        page, err := networks.List(vpcHandler.Client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">vpcList, err := networks.ExtractNetworks(page)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">if len(vpcList) != 0 </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("VPC with name %s already exist", vpcReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // Create VPC
        <span class="cov0" title="0">createOpts := networks.CreateOpts{
                Name: vpcReqInfo.IId.NameId,
        }

        start := call.Start()
        vpc, err := networks.Create(vpcHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Create Subnet
        for _, subnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                _, err := vpcHandler.CreateSubnet(vpc.ID, subnet)
                if err != nil </span><span class="cov0" title="0">{
                        // TODO: VPC 삭제 처리 (rollback)
                        /*if ok, err := vpcHandler.DeleteVPC(irs.IID{SystemId: vpc.ID}); !ok {
                                cblogger.Error("Failed to delete vpc with Id %s, err=%s", vpc.ID, err)
                                return irs.VPCInfo{}, err
                        }*/
                        LoggingError(hiscallInfo, err)
                        return irs.VPCInfo{}, err
                }</span>
        }

        <span class="cov0" title="0">vpcInfo, err := vpcHandler.GetVPC(irs.IID{SystemId: vpc.ID})
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to get vpc with Id %s, err=%s", vpc.ID, err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // TODO: nested flow 개선
        // Create Router
        <span class="cov0" title="0">routerId, err := vpcHandler.CreateRouter(vpcReqInfo.IId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to get create router, err=%s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // TODO: nested flow 개선
        // Create Interface
        <span class="cov0" title="0">for _, subnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                if ok, err := vpcHandler.AddInterface(subnet.IId.SystemId, *routerId); !ok </span><span class="cov0" title="0">{
                        createErr := errors.New(fmt.Sprintf("Failed to get create router interface, err=%s", err.Error()))
                        LoggingError(hiscallInfo, createErr)
                        return irs.VPCInfo{}, createErr
                }</span>
        }

        <span class="cov0" title="0">return vpcInfo, nil</span>
}
func (vpcHandler *OpenStackVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, VPC, "ListVPC()")

        listOpts := external.ListOptsExt{
                ListOptsBuilder: networks.ListOpts{},
        }

        start := call.Start()
        page, err := networks.List(vpcHandler.Client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc list, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return nil, getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var vpcList []NetworkWithExt
        err = networks.ExtractNetworksInto(page, &amp;vpcList)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc list, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return nil, getErr
        }</span>

        // Get VPC List
        <span class="cov0" title="0">vpcInfoList := make([]*irs.VPCInfo, len(vpcList))
        for i, vpc := range vpcList </span><span class="cov0" title="0">{
                vpcInfo := vpcHandler.setterVPC(vpc)
                vpcInfoList[i] = vpcInfo
        }</span>
        <span class="cov0" title="0">return vpcInfoList, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "GetVPC()")

        var vpc NetworkWithExt
        start := call.Start()
        err := networks.Get(vpcHandler.Client, vpcIID.SystemId).ExtractInto(&amp;vpc)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc with Id %s, err=%s", vpcIID.SystemId, err.Error()))
                LoggingError(hiscallInfo, getErr)
                return irs.VPCInfo{}, getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(vpc)
        return *vpcInfo, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "DeleteVPC()")

        vpcInfo, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc with Id %s, err=%s", vpcIID.SystemId, err.Error()))
                LoggingError(hiscallInfo, getErr)
                return false, getErr
        }</span>

        // TODO: nested flow 개선
        // Delete Interface
        <span class="cov0" title="0">routerId, err := vpcHandler.GetRouter(vpcIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get router, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return false, getErr
        }</span>
        <span class="cov0" title="0">for _, subnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                if ok, err := vpcHandler.DeleteInterface(subnet.IId.SystemId, *routerId); !ok </span><span class="cov0" title="0">{
                        getErr := errors.New(fmt.Sprintf("Failed to delete router interface, err=%s", err.Error()))
                        LoggingError(hiscallInfo, getErr)
                        return false, getErr
                }</span>
        }

        // TODO: nested flow 개선
        // Delete Router
        <span class="cov0" title="0">if routerId != nil </span><span class="cov0" title="0">{
                err = routers.Delete(vpcHandler.Client, *routerId).ExtractErr()
                if err != nil </span><span class="cov0" title="0">{
                        getErr := errors.New(fmt.Sprintf("Failed to delete router, err=%s", err.Error()))
                        LoggingError(hiscallInfo, getErr)
                        return false, getErr
                }</span>
        }

        // TODO: nested flow 개선
        // Delete Subnet
        /*for _, subnet := range vpcInfo.SubnetInfoList {
                if ok, err:= vpcHandler.DeleteSubnet(irs.IID{SystemId: subnet.IId.SystemId}); !ok {
                        cblogger.Error("Failed to delete subnet, err=%s", err)
                        return false, err
                }
        }*/

        // TODO: nested flow 개선
        //Delete VPC
        <span class="cov0" title="0">start := call.Start()
        err = networks.Delete(vpcHandler.Client, vpcInfo.IId.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to delete vpc, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return false, getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        subnetCreateOpts := subnets.CreateOpts{
                NetworkID:      vpcId,
                Name:           reqSubnetInfo.IId.NameId,
                CIDR:           reqSubnetInfo.IPv4_CIDR,
                IPVersion:      gophercloud.IPv4,
                DNSNameservers: []string{DNSNameservers},
        }
        subnet, err := subnets.Create(vpcHandler.Client, subnetCreateOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to create Subnet with name %s, err=%s", reqSubnetInfo.IId.NameId, err)
                return irs.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">subnetInfo := vpcHandler.setterSubnet(*subnet)
        return *subnetInfo, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) GetSubnet(subnetIId irs.IID) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        subnet, err := subnets.Get(vpcHandler.Client, subnetIId.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get Subnet with Id %s, err=%s", subnetIId.SystemId, err)
                return irs.SubnetInfo{}, nil
        }</span>
        <span class="cov0" title="0">subnetInfo := vpcHandler.setterSubnet(*subnet)
        return *subnetInfo, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteSubnet(subnetIId irs.IID) (bool, error) <span class="cov0" title="0">{
        err := subnets.Delete(vpcHandler.Client, subnetIId.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to delete Subnet with Id %s, err=%s", subnetIId.SystemId, err)
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) CreateRouter(vpcName string) (*string, error) <span class="cov0" title="0">{
        externVPCId, _ := GetPublicVPCInfo(vpcHandler.Client, "ID")
        routerName := vpcName + "-Router"
        createOpts := routers.CreateOpts{
                Name:         routerName,
                AdminStateUp: to.BoolPtr(true),
                GatewayInfo: &amp;routers.GatewayInfo{
                        NetworkID: externVPCId,
                },
        }

        // Create Router
        router, err := routers.Create(vpcHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;router.ID, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) GetRouter(vpcName string) (*string, error) <span class="cov0" title="0">{
        // Get Router Info
        routerName := vpcName + "-Router"
        listOpts := routers.ListOpts{Name: routerName}
        page, err := routers.List(vpcHandler.Client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to list router, err=%s", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">routerList, err := routers.ExtractRouters(page)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to extract router, err=%s", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(routerList) != 1 </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get router with name %s, err=%s", routerName)
                return nil, err
        }</span>

        <span class="cov0" title="0">routerId := routerList[0].ID
        return &amp;routerId, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteRouter(vpcName string) (bool, error) <span class="cov0" title="0">{
        // Get Router
        routerId, err := vpcHandler.GetRouter(vpcName)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to delete router with Id %s, err=%s", routerId)
                return false, err
        }</span>
        // Delete Router
        <span class="cov0" title="0">err = routers.Delete(vpcHandler.Client, *routerId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to delete router with Id %s, err=%s", routerId)
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) AddInterface(subnetId string, routerId string) (bool, error) <span class="cov0" title="0">{
        createOpts := routers.AddInterfaceOpts{
                SubnetID: subnetId,
        }

        // Add Interface
        _, err := routers.AddInterface(vpcHandler.Client, routerId, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteInterface(subnetId string, routerId string) (bool, error) <span class="cov0" title="0">{
        deleteOpts := routers.RemoveInterfaceOpts{
                SubnetID: subnetId,
        }

        // Delete Interface
        _, err := routers.RemoveInterface(vpcHandler.Client, routerId, deleteOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, subnetInfo.IId.NameId, "AddSubnet()")

        subnetCreateOpts := subnets.CreateOpts{
                NetworkID:      vpcIID.SystemId,
                Name:           subnetInfo.IId.NameId,
                CIDR:           subnetInfo.IPv4_CIDR,
                IPVersion:      gophercloud.IPv4,
                DNSNameservers: []string{DNSNameservers},
        }

        start := call.Start()
        _, err := subnets.Create(vpcHandler.Client, subnetCreateOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to create Subnet with name %s, err=%s", subnetCreateOpts.Name, err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        result, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, subnetIID.NameId, "RemoveSubnet()")

        start := call.Start()
        err := subnets.Delete(vpcHandler.Client, subnetIID.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by CB-Spider Team, 2019.06.

//package main

package tencent

import (
        "errors"

        tcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"

        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/profile"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
)

type TencentDriver struct {
}

func (TencentDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "Test Tencent Driver Version 0.1"
}</span>

func (TencentDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER TencentDriver")
}</span>

func getVmClient(connectionInfo idrv.ConnectionInfo) (*cvm.Client, error) <span class="cov0" title="0">{
        // setup Region
        cblogger.Debug("TencentDriver : getVpcClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - Zone : [" + connectionInfo.RegionInfo.Zone + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - ClientId : [" + connectionInfo.CredentialInfo.ClientId + "]")

        zoneId := connectionInfo.RegionInfo.Zone
        if len(zoneId) &lt; 1 </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return nil, errors.New("Connection 정보에 Zone 정보가 없습니다")
        }</span>

        <span class="cov0" title="0">credential := common.NewCredential(
                connectionInfo.CredentialInfo.ClientId,
                connectionInfo.CredentialInfo.ClientSecret,
        )

        cpf := profile.NewClientProfile()
        cpf.HttpProfile.Endpoint = "cvm.tencentcloudapi.com"
        cpf.Language = "en-US" //메시지를 영어로 설정
        client, err := cvm.NewClient(credential, connectionInfo.RegionInfo.Region, cpf)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Could not create aws New Session")
                cblogger.Error(err)
                // fmt.Println("Could not create aws New Session", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func getVpcClient(connectionInfo idrv.ConnectionInfo) (*vpc.Client, error) <span class="cov0" title="0">{
        // setup Region
        cblogger.Debug("TencentDriver : getVpcClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - Zone : [" + connectionInfo.RegionInfo.Zone + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - ClientId : [" + connectionInfo.CredentialInfo.ClientId + "]")

        zoneId := connectionInfo.RegionInfo.Zone
        if len(zoneId) &lt; 1 </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return nil, errors.New("Connection 정보에 Zone 정보가 없습니다")
        }</span>

        <span class="cov0" title="0">credential := common.NewCredential(
                connectionInfo.CredentialInfo.ClientId,
                connectionInfo.CredentialInfo.ClientSecret,
        )

        cpf := profile.NewClientProfile()
        cpf.HttpProfile.Endpoint = "vpc.tencentcloudapi.com"
        cpf.Language = "en-US" //메시지를 영어로 설정
        client, err := vpc.NewClient(credential, connectionInfo.RegionInfo.Region, cpf)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Could not create aws New Session")
                cblogger.Error(err)
                // fmt.Println("Could not create aws New Session", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func (driver *TencentDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        //fmt.Println("ConnectCloud의 전달 받은 idrv.ConnectionInfo 정보")
        //spew.Dump(connectionInfo)

        // sample code, do not user like this^^
        //var iConn icon.CloudConnection
        vmClient, err := getVmClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">vpcClient, err := getVpcClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := tcon.TencentCloudConnection{
                Region:         connectionInfo.RegionInfo,
                VNetworkClient: vpcClient,

                VMClient:       vmClient,
                KeyPairClient:  vmClient,
                ImageClient:    vmClient,
                SecurityClient: vpcClient,
                VmSpecClient:   vmClient,

                //VNicClient:     vmClient,
                //PublicIPClient: vmClient,
        }

        return &amp;iConn, nil</span> // return type: (icon.CloudConnection, error)
}

/*
func (TencentDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) {
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.
        // sample code, do not user like this^^
        var iConn icon.CloudConnection
        iConn = tcon.TencentCloudConnection{}
        return iConn, nil // return type: (icon.CloudConnection, error)
}
*/
var CloudDriver TencentDriver
</pre>
		
		<pre class="file" id="file116" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by devunet@mz.co.kr, 2021.05.04

package connect

import (
        "github.com/sirupsen/logrus"

        cblog "github.com/cloud-barista/cb-log"
        trs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        //"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        //"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors"
        //"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/profile"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
)

type TencentCloudConnection struct {
        Region         idrv.RegionInfo
        VNetworkClient *vpc.Client

        VMClient       *cvm.Client
        KeyPairClient  *cvm.Client
        ImageClient    *cvm.Client
        SecurityClient *vpc.Client
        VmSpecClient   *cvm.Client

        //VNicClient     *cvm.Client
        //PublicIPClient *cvm.Client
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER TencentCloudConnection")
}</span>

func (cloudConn *TencentCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateKeyPairHandler()")

        keyPairHandler := trs.TencentKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}

        return &amp;keyPairHandler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateVMHandler()")

        vmHandler := trs.TencentVMHandler{cloudConn.Region, cloudConn.VMClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *TencentCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (cloudConn *TencentCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (cloudConn *TencentCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentVPCHandler{cloudConn.Region, cloudConn.VNetworkClient}

        return &amp;handler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentImageHandler{cloudConn.Region, cloudConn.ImageClient}

        return &amp;handler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentSecurityHandler{cloudConn.Region, cloudConn.SecurityClient}

        return &amp;handler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentVmSpecHandler{cloudConn.Region, cloudConn.VmSpecClient}
        return &amp;handler, nil
}</span>

/*
func (cloudConn *TencentCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Start")
        handler := trs.TencentVNicHandler{cloudConn.Region, cloudConn.VNicClient}

        return &amp;handler, nil
}

func (cloudConn *TencentCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Start")
        handler := trs.TencentPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}

        return &amp;handler, nil
}
*/
</pre>
		
		<pre class="file" id="file117" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/ec2"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const CBDefaultVNetName string = "CB-VNet"          // CB Default Virtual Network Name
const CBDefaultSubnetName string = "CB-VNet-Subnet" // CB Default Subnet Name
const CBDefaultCidrBlock string = "192.168.0.0/16"  // CB Default CidrBlock

const CBKeyPairPath string = "/cloud-driver-libs/.ssh-tencent/"
const CBCloudInitFilePath string = "/cloud-driver-libs/.cloud-init-tencent/cloud-init"
const CBDefaultVmUserName string = "cb-user" // default VM User Name

type TencentCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

const CUSTOM_ERR_CODE_TOOMANY string = "600"  //awserr.New("600", "n개 이상의 xxxx 정보가 존재합니다.", nil)
const CUSTOM_ERR_CODE_NOTFOUND string = "404" //awserr.New("404", "XXX 정보가 존재하지 않습니다.", nil)

//VPC
func GetCBDefaultVNetName() string <span class="cov0" title="0">{
        return CBDefaultVNetName
}</span>

//Subnet
func GetCBDefaultSubnetName() string <span class="cov0" title="0">{
        return CBDefaultSubnetName
}</span>

func GetCBDefaultCidrBlock() string <span class="cov0" title="0">{
        return CBDefaultCidrBlock
}</span>

//Name Tag 설정
func SetNameTag(Client *ec2.EC2, Id string, value string) bool <span class="cov0" title="0">{
        // Tag에 Name 설정
        cblogger.Infof("Name Tage 설정 - ResourceId : [%s]  Value : [%s] ", Id, value)
        _, errtag := Client.CreateTags(&amp;ec2.CreateTagsInput{
                Resources: []*string{&amp;Id},
                Tags: []*ec2.Tag{
                        {
                                Key:   aws.String("Name"),
                                Value: aws.String(value),
                        },
                },
        })
        if errtag != nil </span><span class="cov0" title="0">{
                cblogger.Error("Name Tag 설정 실패 : ")
                cblogger.Error(errtag)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func JSONMarshal(t interface{}) ([]byte, error) <span class="cov0" title="0">{
        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err := encoder.Encode(t)
        return buffer.Bytes(), err
}</span>

//Cloud Object를 JSON String 타입으로 변환
func ConvertJsonStringNoEscape(v interface{}) (string, error) <span class="cov0" title="0">{
        //jsonBytes, errJson := json.Marshal(v)

        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        errJson := encoder.Encode(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON 변환 실패")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        //fmt.Println("After marshal", string(buffer.Bytes()))
        //spew.Dump(string(buffer.Bytes()))
        //spew.Dump("\"TEST")

        <span class="cov0" title="0">jsonString := string(buffer.Bytes())
        //jsonString = strings.Replace(jsonString, "\n", "", -1)
        jsonString = strings.Replace(jsonString, "\"", "", -1)

        return jsonString, nil</span>
}

//Cloud Object를 JSON String 타입으로 변환
func ConvertJsonString(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonBytes, errJson := json.Marshal(v)

        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON 변환 실패")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

//CB-KeyValue 등을 위해 String 타입으로 변환
func ConvertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                cblogger.Debugf("Nil Value")
                return "", errors.New("Nil. Value")
        }</span>

        <span class="cov0" title="0">var result string
        t := reflect.ValueOf(value)
        cblogger.Debug("==&gt;ValueOf : ", t)

        switch value.(type) </span>{
        case float32:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 32)</span> // f, fmt, prec, bitSize
        case float64:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 64)</span> // f, fmt, prec, bitSize
                //strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)

        default:<span class="cov0" title="0">
                cblogger.Debug("--&gt; default type:", reflect.ValueOf(value).Type())
                result = fmt.Sprint(value)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

//Cloud Object를 CB-KeyValue 형식으로 변환이 필요할 경우 이용
func ConvertKeyValueList(v interface{}) ([]irs.KeyValue, error) <span class="cov0" title="0">{
        //spew.Dump(v)
        var keyValueList []irs.KeyValue
        var i map[string]interface{}

        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("KeyValue 변환 실패")
                cblogger.Error(errJson)
                return nil, errJson
        }</span>

        <span class="cov0" title="0">json.Unmarshal(jsonBytes, &amp;i)

        for k, v := range i </span><span class="cov0" title="0">{
                cblogger.Debugf("K:[%s]====&gt;", k)
                /*
                        cblogger.Infof("v:[%s]====&gt;", reflect.ValueOf(v))

                        vv := reflect.ValueOf(v)
                        cblogger.Infof("value ====&gt;[%s]", vv.String())
                        s := fmt.Sprint(v)
                        cblogger.Infof("value2 ====&gt;[%s]", s)
                */
                //value := fmt.Sprint(v)
                value, errString := ConvertToString(v)
                if errString != nil </span><span class="cov0" title="0">{
                        //cblogger.Errorf("Key[%s]의 값은 변환 불가 - [%s]", k, errString)
                        cblogger.Debugf("Key[%s]의 값은 변환 불가 - [%s]", k, errString) //요구에 의해서 Error에서 Warn으로 낮춤
                        continue</span>
                }
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, value})</span>

                /*
                        _, ok := v.(string)
                        if !ok {
                                cblogger.Errorf("Key[%s]의 값은 변환 불가", k)
                                continue
                        }
                        keyValueList = append(keyValueList, irs.KeyValue{k, v.(string)})
                */
        }
        <span class="cov0" title="0">cblogger.Debug("getKeyValueList : ", keyValueList)
        //keyValueList = append(keyValueList, irs.KeyValue{"test", typeToString([]float32{3.14, 1.53, 2.0000000000000})})

        return keyValueList, nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Cloud Driver Interface of CB-Spider.  // The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "strings"

        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        //irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/new-resources"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
)

type TencentImageHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

//@TODO - 이미지 생성에 따른 구조체 정의 필요 - 현재는 IID뿐이 없어서 이미지 이름으로만 생성하도록 했음.(인스턴스Id가 없어서 에러 발생함.)
func (imageHandler *TencentImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info(imageReqInfo)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageReqInfo.IId.NameId,
                CloudOSAPI:   "CreateImage()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewCreateImageRequest()
        request.ImageName = common.StringPtr(imageReqInfo.IId.NameId)
        request.ImageDescription = common.StringPtr(imageReqInfo.IId.NameId)
        //request.InstanceId = common.StringPtr("InstanceId") //필수 - 이미지로 만들 인스턴스 Id

        //request.ForcePoweroff = common.StringPtr("ForcePoweroff")        //옵션

        // // Whether to enable Sysprep when creating a Windows image. Click here to learn more about Sysprep.
        // // https://intl.cloud.tencent.com/document/product/213/35876
        // request.Sysprep = common.StringPtr("Sysprep")

        callLogStart := call.Start()
        response, err := imageHandler.Client.CreateImage(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        // imageInfo := irs.ImageInfo{
        //         IId: irs.IID{NameId: imageReqInfo.IId.NameId, SystemId: *response.Response.ImageId},
        // }

        //OS등의 정보 확인을 위해 GetImage를 호출 함.
        imageInfo, errGetImage := imageHandler.GetImage(irs.IID{SystemId: *response.Response.ImageId})
        if errGetImage != nil </span><span class="cov0" title="0">{
                cblogger.Error(errGetImage)
                return irs.ImageInfo{}, errGetImage
        }</span>
        <span class="cov0" title="0">imageInfo.IId.NameId = imageReqInfo.IId.NameId
        return imageInfo, nil</span>
}

func (imageHandler *TencentImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        var imageInfoList []*irs.ImageInfo

        cblogger.Debug("Start")
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "ListImage()",
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeImagesRequest()
        request.Limit = common.Uint64Ptr(100) //default : 20 / max : 100

        callLogStart := call.Start()
        response, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cnt := 0
        for _, curImage := range response.Response.ImageSet </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s] AMI 정보 처리", *curImage.ImageId)
                imageInfo := ExtractImageDescribeInfo(curImage)
                imageInfoList = append(imageInfoList, &amp;imageInfo)
        }</span>

        //spew.Dump(imageInfoList)
        <span class="cov0" title="0">return imageInfoList, nil</span>
}

func ExtractImageDescribeInfo(image *cvm.Image) irs.ImageInfo <span class="cov0" title="0">{
        //spew.Dump(image)
        imageInfo := irs.ImageInfo{
                //IId: irs.IID{*image.Name, *image.ImageId},
                IId:     irs.IID{NameId: *image.ImageId, SystemId: *image.ImageId},
                GuestOS: *image.OsName,
                Status:  *image.ImageState,
        }

        //NORMAL -&gt; available
        if strings.EqualFold(imageInfo.Status, "NORMAL") </span><span class="cov0" title="0">{
                imageInfo.Status = "available"
        }</span>

        //KeyValue 목록 처리
        <span class="cov0" title="0">keyValueList, errKeyValue := ConvertKeyValueList(image)
        if errKeyValue != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%]의 KeyValue 추출 실패", *image.ImageId)
                cblogger.Error(errKeyValue)
        }</span>

        <span class="cov0" title="0">imageInfo.KeyValueList = keyValueList
        return imageInfo</span>
}

func (imageHandler *TencentImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("imageID : [%s]", imageIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeImagesRequest()
        request.ImageIds = common.StringPtrs([]string{imageIID.SystemId})

        callLogStart := call.Start()
        response, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                imageInfo := ExtractImageDescribeInfo(response.Response.ImageSet[0])
                return imageInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.ImageInfo{}, errors.New("정보를 찾을 수 없습니다")
        }</span>

}

func (imageHandler *TencentImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("imageIID : [%s]", imageIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.NameId,
                CloudOSAPI:   "DeleteImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDeleteImagesRequest()
        request.ImageIds = common.StringPtrs([]string{imageIID.NameId})

        callLogStart := call.Start()
        response, err := imageHandler.Client.DeleteImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return false, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package resources

import (
        "bytes"
        "crypto/md5"
        "crypto/rsa"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        _ "github.com/davecgh/go-spew/spew"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
        "golang.org/x/crypto/ssh"
)

type TencentKeyPairHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

func (keyPairHandler *TencentKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        var keyPairList []*irs.KeyPairInfo
        cblogger.Debug("Start ListKey()")

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: "ListKey()",
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeKeyPairsRequest()

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        for _, pair := range response.Response.KeyPairSet </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(pair)
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s] KeyPair는 Local에서 관리하는 대상이 아니기 때문에 Skip합니다.", *pair.KeyName)
                        cblogger.Info(errKeyPair.Error())
                        //return nil, errKeyPair
                }</span> else<span class="cov0" title="0"> {
                        keyPairList = append(keyPairList, &amp;keyPairInfo)
                }</span>
        }

        <span class="cov0" title="0">return keyPairList, nil</span>
}

//KeyPair 정보를 추출함
func ExtractKeyPairDescribeInfo(keyPair *cvm.KeyPair) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        spew.Dump(keyPair)
        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{NameId: *keyPair.KeyName, SystemId: *keyPair.KeyId},
                //PublicKey: *keyPair.PublicKey,
        }

        //PrivateKey는 최초 생성시에만 존재하며 조회 시에는 PrivateKey는 Nil임.
        // if !reflect.ValueOf(keyPair.PrivateKey).IsNil() {
        //         keyPairInfo.PrivateKey = *keyPair.PrivateKey
        //         keyPairInfo.PublicKey = *keyPair.PublicKey
        // }
        //조회 용도

        // Local Keyfile 처리
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString := strings.ReplaceAll(*keyPair.KeyId, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, privateKeyPath)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, publicKeyPath)

        // Private Key, Public Key 파일 정보 가져오기
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair의 Local Private 파일 조회 실패", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair의 Local Public 파일 조회 실패", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo.PublicKey = string(publicKeyBytes)
        keyPairInfo.PrivateKey = string(privateKeyBytes)

        keyValueList := []irs.KeyValue{
                {Key: "KeyId", Value: *keyPair.KeyId},
                //{Key: "KeyMaterial", Value: *keyPair.KeyMaterial},
        }

        keyPairInfo.KeyValueList = keyValueList

        return keyPairInfo, nil</span>
}

//KeyPair 생성시 이름은 알파벳, 숫자 또는 밑줄 "_"만 지원
func (keyPairHandler *TencentKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Info(keyPairReqInfo)

        //=================================================
        // 동일 이름 생성 방지 추가(cb-spider 요청 필수 기능)
        //=================================================
        isExist, errExist := keyPairHandler.isExist(keyPairReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.KeyPairInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, errors.New("A keyPair with the name " + keyPairReqInfo.IId.NameId + " already exists.")
        }</span>

        <span class="cov0" title="0">keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewCreateKeyPairRequest()
        request.KeyName = common.StringPtr(keyPairReqInfo.IId.NameId)
        request.ProjectId = common.Int64Ptr(0)

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.CreateKeyPair(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created [%s]key pair", *response.Response.KeyPair.KeyName)
        //spew.Dump(result)
        keyPairInfo := irs.KeyPairInfo{
                //Name:        *result.KeyName,
                IId:        irs.IID{NameId: keyPairReqInfo.IId.NameId, SystemId: *response.Response.KeyPair.KeyId},
                PublicKey:  *response.Response.KeyPair.PublicKey,
                PrivateKey: *response.Response.KeyPair.PrivateKey,
                KeyValueList: []irs.KeyValue{
                        {Key: "KeyId", Value: *response.Response.KeyPair.KeyId},
                },
        }

        //spew.Dump(keyPairInfo)

        //=============================
        // 키 페어를 로컬 파일에 기록 함.
        //=============================
        hashString := strings.ReplaceAll(*response.Response.KeyPair.KeyId, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        savePrivateFileTo := keyPairPath + hashString + ".pem"
        savePublicFileTo := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Infof("savePrivateFileTo : [%s]", savePrivateFileTo)
        cblogger.Infof("savePublicFileTo : [%s]", savePublicFileTo)

        // 파일에 private Key를 쓴다
        err = writeKeyToFile([]byte(keyPairInfo.PrivateKey), savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        // 파일에 public Key를 쓴다
        <span class="cov0" title="0">err = writeKeyToFile([]byte(keyPairInfo.PublicKey), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

// cb-spider 정책상 이름 기반으로 중복 생성을 막아야 함.
func (keyPairHandler *TencentKeyPairHandler) isExist(chkName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Debugf("chkName : %s", chkName)

        request := cvm.NewDescribeKeyPairsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("key-name"),
                        Values: common.StringPtrs([]string{chkName}),
                },
        }

        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("SSH Key 정보 찾음 - KeyId:[%s] / KeyName:[%s]", *response.Response.KeyPairSet[0].KeyId, *response.Response.KeyPairSet[0].KeyName)
        return true, nil</span>
}

func (keyPairHandler *TencentKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        //keyPairID := keyName
        cblogger.Infof("keyName : [%s]", keyIID.SystemId)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeKeyPairsRequest()
        request.KeyIds = common.StringPtrs([]string{keyIID.SystemId})

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(response.Response.KeyPairSet[0])
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errKeyPair.Error())
                        return irs.KeyPairInfo{}, errKeyPair
                }</span>

                //spew.Dump(keyPairInfo)
                <span class="cov0" title="0">return keyPairInfo, nil</span>
        } else<span class="cov0" title="0"> {
                return irs.KeyPairInfo{}, errors.New("정보를 찾을 수 없습니다.")
        }</span>
}

//Tencent의 경우 FingerPrint같은 고유 값을 조회할 수 없기 때문에 KeyId를 로컬 파일의 고유 키 값으로 이용함.
func (keyPairHandler *TencentKeyPairHandler) GetLocalKeyId(keyIID irs.IID) (string, error) <span class="cov0" title="0">{
        //삭제할 Local Keyfile을 찾기 위해 조회
        request := cvm.NewDescribeKeyPairsRequest()
        request.KeyIds = common.StringPtrs([]string{keyIID.SystemId})
        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                return *response.Response.KeyPairSet[0].KeyId, nil
        }</span> else<span class="cov0" title="0"> {
                return "", errors.New("InvalidKeyPair.NotFound: The KeyPair " + keyIID.SystemId + " does not exist")
        }</span>
}

func (keyPairHandler *TencentKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("삭제 요청된 키페어 : [%s]", keyIID.SystemId)

        keyPairId, errGet := keyPairHandler.GetLocalKeyId(keyIID)
        if errGet != nil </span><span class="cov0" title="0">{
                return false, errGet
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DeleteKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDeleteKeyPairsRequest()
        request.KeyIds = common.StringPtrs([]string{keyIID.SystemId})

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.DeleteKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return false, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        //====================
        // Local Keyfile 처리
        //====================
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString := strings.ReplaceAll(keyPairId, ":", "") // 필요한 경우 리전 정보 추가하면 될 듯. 나중에 키 이름과 리전으로 암복호화를 진행하면 될 것같음.
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"

        // Private Key, Public Key 삭제
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

//=================================
// 공개 키 변환 및 키 정보 로컬 보관 로직 추가
//=================================
func (keyPairHandler *TencentKeyPairHandler) CheckKeyPairFolder(keyPairPath string) error <span class="cov0" title="0">{
        //키페어 생성 시 폴더가 존재하지 않으면 생성 함.
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Path가 존재하지 않아서 생성합니다.", keyPairPath)

                //errDir := os.MkdirAll(keyPairPath, 0755)
                errDir := os.MkdirAll(keyPairPath, 0700)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path가 생성 실패", keyPairPath)
                        cblogger.Error(errDir)
                        return errDir
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ParseKey reads the given RSA private key and create a public one for it.
func makePublicKeyFromPrivateKey(pem string) (string, error) <span class="cov0" title="0">{
        key, err := ssh.ParseRawPrivateKey([]byte(pem))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">rsaKey, ok := key.(*rsa.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q is not a RSA key", pem)
        }</span>
        <span class="cov0" title="0">pub, err := ssh.NewPublicKey(&amp;rsaKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(bytes.TrimRight(ssh.MarshalAuthorizedKey(pub), "\n")), nil</span>
}

// 파일에 Key를 쓴다
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key 저장위치: %s", saveFileTo)
        return nil</span>
}

// @TODO - PK 이슈 처리해야 함. (A User / B User / User 하위의 IAM 계정간의 호환성에 이슈가 없어야 하는데 현재는 안 됨.)
//       - 따라서 AWS는 대안으로 KeyPair의 FingerPrint를 이용하도록 변경 - 필요시 리전및 키 이름과 혼용해서 만들어야할 듯.
// KeyPair 해시 생성 함수 (PK 이슈로 현재는 사용하지 않음)
func CreateHashString(credentialInfo idrv.CredentialInfo, Region idrv.RegionInfo) (string, error) <span class="cov0" title="0">{
        log.Println("credentialInfo.ClientId : " + credentialInfo.ClientId)
        log.Println("Region.Region : " + Region.Region)
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + Region.Region
        //keyString := credentialInfo
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
)

type TencentSecurityHandler struct {
        Region idrv.RegionInfo
        Client *vpc.Client
}

//https://intl.cloud.tencent.com/document/product/213/34272
//https://intl.cloud.tencent.com/ko/document/api/215/36083
/*
@TODO 포트 다양하게 처리 가능해야 함. - 현재는 콤머는 에러 처리
  사용가능 포트 규칙 : 콤머(,) / 대쉬(-) / ALL(전체)
Port: A single port number, or a port range in the format of “8000-8010”. The Port field is accepted only if the value of the Protocol field is TCP or UDP. Otherwise Protocol and Port are mutually exclusive.
Action : ACCEPT or DROP
*/
func (securityHandler *TencentSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityReqInfo : ", securityReqInfo)

        //=================================================
        // 동일 이름 생성 방지 추가(cb-spider 요청 필수 기능)
        //=================================================
        isExist, errExist := securityHandler.isExist(securityReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.SecurityInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("A SecurityGroup with the name " + securityReqInfo.IId.NameId + " already exists.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "CreateSecurityGroupWithPolicies()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewCreateSecurityGroupWithPoliciesRequest()
        request.GroupName = common.StringPtr(securityReqInfo.IId.NameId)
        request.GroupDescription = common.StringPtr(securityReqInfo.IId.NameId) //설명 없으면 에러

        cblogger.Debug("보안 정책 처리")
        securityGroupPolicySet := &amp;vpc.SecurityGroupPolicySet{}
        for _, curPolicy := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                securityGroupPolicy := new(vpc.SecurityGroupPolicy)
                securityGroupPolicy.Protocol = common.StringPtr(curPolicy.IPProtocol)
                //securityGroupPolicy.CidrBlock = common.StringPtr("0.0.0.0/0")
                securityGroupPolicy.CidrBlock = common.StringPtr(curPolicy.CIDR)
                securityGroupPolicy.Action = common.StringPtr("accept")

                if curPolicy.ToPort != "" &amp;&amp; curPolicy.ToPort != curPolicy.FromPort </span><span class="cov0" title="0">{
                        securityGroupPolicy.Port = common.StringPtr(curPolicy.FromPort + "-" + curPolicy.ToPort)
                }</span> else<span class="cov0" title="0"> {
                        securityGroupPolicy.Port = common.StringPtr(curPolicy.FromPort)
                }</span>

                <span class="cov0" title="0">if strings.EqualFold(curPolicy.Direction, "inbound") </span><span class="cov0" title="0">{
                        securityGroupPolicySet.Ingress = append(securityGroupPolicySet.Ingress, securityGroupPolicy)
                }</span> else<span class="cov0" title="0"> {
                        securityGroupPolicySet.Egress = append(securityGroupPolicySet.Egress, securityGroupPolicy)
                }</span>
        }

        <span class="cov0" title="0">request.SecurityGroupPolicySet = securityGroupPolicySet

        callLogStart := call.Start()
        response, err := securityHandler.Client.CreateSecurityGroupWithPolicies(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                spew.Dump(request)
                return irs.SecurityInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        securityInfo, errSecurity := securityHandler.GetSecurity(irs.IID{SystemId: *response.Response.SecurityGroup.SecurityGroupId})
        if errSecurity != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSecurity)
                return irs.SecurityInfo{}, errSecurity
        }</span>

        <span class="cov0" title="0">securityInfo.IId.NameId = securityReqInfo.IId.NameId
        return securityInfo, nil</span>
}

func (securityHandler *TencentSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "ListSecurity()",
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeSecurityGroupsRequest()
        request.Limit = common.StringPtr("100") //default : 20 / max : 100

        callLogStart := call.Start()
        response, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        var results []*irs.SecurityInfo
        for _, securityGroup := range response.Response.SecurityGroupSet </span><span class="cov0" title="0">{
                //         securityInfo := ExtractSecurityInfo(securityGroup)
                securityInfo, errSecurity := securityHandler.GetSecurity(irs.IID{NameId: *securityGroup.SecurityGroupName, SystemId: *securityGroup.SecurityGroupId})
                if errSecurity != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errSecurity)
                        return nil, errSecurity
                }</span>
                <span class="cov0" title="0">results = append(results, &amp;securityInfo)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// cb-spider 정책상 이름 기반으로 중복 생성을 막아야 함.
func (securityHandler *TencentSecurityHandler) isExist(chkName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Debugf("chkName : %s", chkName)

        request := vpc.NewDescribeSecurityGroupsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("security-group-name"),
                        Values: common.StringPtrs([]string{chkName}),
                },
        }

        response, err := securityHandler.Client.DescribeSecurityGroups(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("보안그룹 정보 찾음 - VpcId:[%s] / VpcName:[%s]", *response.Response.SecurityGroupSet[0].SecurityGroupId, *response.Response.SecurityGroupSet[0].SecurityGroupName)
        return true, nil</span>
}

func (securityHandler *TencentSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securitySystemId : [%s]", securityIID.SystemId)
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DescribeSecurityGroupPolicies()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeSecurityGroupsRequest()
        request.SecurityGroupIds = common.StringPtrs([]string{securityIID.SystemId})

        callLogStart := call.Start()
        response, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                securityInfo := irs.SecurityInfo{}
                securityInfo.IId = irs.IID{NameId: *response.Response.SecurityGroupSet[0].SecurityGroupName, SystemId: *response.Response.SecurityGroupSet[0].SecurityGroupId}

                securityInfo.SecurityRules, err = securityHandler.GetSecurityRuleInfo(securityIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return irs.SecurityInfo{}, err
                }</span>
                <span class="cov0" title="0">return securityInfo, nil</span>
        } else<span class="cov0" title="0"> {
                return irs.SecurityInfo{}, errors.New("InvalidSecurityGroupId.NotFound: The SecurityGroup " + securityIID.SystemId + " does not exist")
        }</span>
}

func (securityHandler *TencentSecurityHandler) GetSecurityRuleInfo(securityIID irs.IID) (*[]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securitySystemId : [%s]", securityIID.SystemId)

        request := vpc.NewDescribeSecurityGroupPoliciesRequest()
        request.SecurityGroupId = common.StringPtr(securityIID.SystemId)

        response, err := securityHandler.Client.DescribeSecurityGroupPolicies(request)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())

        var securityRuleInfos []irs.SecurityRuleInfo
        var ingress []irs.SecurityRuleInfo
        var egress []irs.SecurityRuleInfo
        ingress, err = securityHandler.ExtractPolicyGroups(response.Response.SecurityGroupPolicySet.Ingress, "inbound")
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">egress, err = securityHandler.ExtractPolicyGroups(response.Response.SecurityGroupPolicySet.Egress, "outbound")
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">securityRuleInfos = append(ingress, egress...)

        return &amp;securityRuleInfos, nil</span>
}

//@TODO Port에 콤머가 사용된 정책 처리해야 함.
//direction : inbound / outbound
func (securityHandler *TencentSecurityHandler) ExtractPolicyGroups(policyGroups []*vpc.SecurityGroupPolicy, direction string) ([]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        var results []irs.SecurityRuleInfo

        var fromPort string
        var toPort string

        /*
                var newDirection string
                //ingress -&gt; inbound
                if strings.EqualFold(direction, "ingress") {
                        newDirection = "inbound"
                } else if strings.EqualFold(direction, "egress") {
                        newDirection = "outbound"
                } else { //UnKnown
                        newDirection = direction
                }
        */

        for _, curPolicy := range policyGroups </span><span class="cov0" title="0">{
                if len(*curPolicy.Port) &gt; 0 </span><span class="cov0" title="0">{

                        //WEB UI에서는 입력 자체가 불 가능한 것 같지만 혹시 몰라서 콤머 기반으로 파싱 후 대쉬(-)를 처리함.
                        portArr := strings.Split(*curPolicy.Port, ",")
                        for _, curPort := range portArr </span><span class="cov0" title="0">{
                                portRange := strings.Split(curPort, "-")
                                fromPort = portRange[0]
                                if len(portRange) &gt; 1 </span><span class="cov0" title="0">{
                                        toPort = portRange[len(portRange)-1]
                                }</span> else<span class="cov0" title="0"> {
                                        toPort = ""
                                }</span>

                                <span class="cov0" title="0">securityRuleInfo := irs.SecurityRuleInfo{
                                        Direction:  direction, // "inbound | outbound"
                                        CIDR:       *curPolicy.CidrBlock,
                                        IPProtocol: *curPolicy.Protocol,
                                        FromPort:   fromPort,
                                        ToPort:     toPort,
                                }
                                results = append(results, securityRuleInfo)</span>
                        }
                }
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (securityHandler *TencentSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("securityNameId : [%s]", securityIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DeleteSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDeleteSecurityGroupRequest()
        request.SecurityGroupId = common.StringPtr(securityIID.SystemId)

        callLogStart := call.Start()
        response, err := securityHandler.Client.DeleteSecurityGroup(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return false, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">// Proof of Concepts for the Cloud-Barista Multi-Cloud Project.
//      * Cloud-Barista: https://github.com/cloud-barista
//
// EC2 Hander (AWS SDK GO Version 1.16.26, Thanks AWS.)
//
// by CB-Spider Team, 2019.03.
package resources

import (
        "encoding/base64"
        "errors"
        "io/ioutil"
        "os"
        "reflect"
        "strconv"
        "strings"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER Tencent VMHandler")
}</span>

type TencentVMHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

//VM 이름으로 중복 생성을 막아야 해서 VM존재 여부를 체크함.
func (vmHandler *TencentVMHandler) isExist(vmName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("VM조회(Name기반) : %s", vmName)
        request := cvm.NewDescribeInstancesRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("instance-name"),
                        Values: common.StringPtrs([]string{vmName}),
                },
        }

        response, err := vmHandler.Client.DescribeInstances(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("VM 정보 찾음 - VmId:[%s] / VmName:[%s]", *response.Response.InstanceSet[0].InstanceId, *response.Response.InstanceSet[0].InstanceName)
        return true, nil</span>
}

// VM생성 시 Zone이 필수라서 Credential의 Zone에만 생성함.
func (vmHandler *TencentVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vmReqInfo)

        zoneId := vmHandler.Region.Zone
        cblogger.Debugf("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.VMInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다")
        }</span>

        //=================================================
        // 동일 이름 생성 방지 추가(cb-spider 요청 필수 기능)
        //=================================================
        <span class="cov0" title="0">isExist, errExist := vmHandler.isExist(vmReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.VMInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("A VM with the name " + vmReqInfo.IId.NameId + " already exists.")
        }</span>

        // 2021-04-28 cbuser 추가에 따른 Local KeyPair만 VM 생성 가능하도록 강제
        //=============================
        // KeyPair의 PublicKey 정보 처리
        //=============================
        <span class="cov0" title="0">cblogger.Infof("[%s] KeyPair 조회 시작", vmReqInfo.KeyPairIID.SystemId)
        keypairHandler := TencentKeyPairHandler{
                //CredentialInfo:
                Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(keypairHandler)

        keyPairInfo, errKeyPair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair)
                return irs.VMInfo{}, errKeyPair
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmReqInfo.IId.NameId,
                CloudOSAPI:   "RunInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewRunInstancesRequest()
        request.InstanceType = common.StringPtr(vmReqInfo.VMSpecName)

        request.ImageId = common.StringPtr(vmReqInfo.ImageIID.SystemId)
        request.VirtualPrivateCloud = &amp;cvm.VirtualPrivateCloud{
                VpcId:    common.StringPtr(vmReqInfo.VpcIID.SystemId),
                SubnetId: common.StringPtr(vmReqInfo.SubnetIID.SystemId),
        }

        request.InstanceChargeType = common.StringPtr("POSTPAID_BY_HOUR")

        request.InternetAccessible = &amp;cvm.InternetAccessible{
                //         InternetChargeType: common.StringPtr("TRAFFIC_POSTPAID_BY_HOUR"),
                PublicIpAssigned:        common.BoolPtr(true),
                InternetMaxBandwidthOut: common.Int64Ptr(1), //Public Ip를 할당하려면 The maximum outbound bandwidth of the public network가 1Mbps이상이어야 함.
        }

        request.InstanceName = common.StringPtr(vmReqInfo.IId.NameId)
        request.LoginSettings = &amp;cvm.LoginSettings{
                KeyIds: common.StringPtrs([]string{vmReqInfo.KeyPairIID.SystemId}),
        }

        //=============================
        // 보안그룹 처리 - SystemId 기반
        //=============================
        cblogger.Debug("SystemId 기반으로 처리하기 위해 IID 기반의 보안그룹 배열을 SystemId 기반 보안그룹 배열로 조회및 변환함.")
        var newSecurityGroupIds []string
        for _, curSecurityGroup := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                cblogger.Infof("보안그룹 변환 : [%s]", curSecurityGroup)
                newSecurityGroupIds = append(newSecurityGroupIds, curSecurityGroup.SystemId)
        }</span>

        <span class="cov0" title="0">cblogger.Debug("보안그룹 변환 완료")
        cblogger.Debug(newSecurityGroupIds)
        request.SecurityGroupIds = common.StringPtrs(newSecurityGroupIds)

        //=============================
        // Placement 처리
        //=============================
        request.Placement = &amp;cvm.Placement{
                Zone: common.StringPtr(vmHandler.Region.Zone),
        }

        //=============================
        // SystemDisk 처리
        //=============================
        request.SystemDisk = &amp;cvm.SystemDisk{
                DiskType: common.StringPtr("CLOUD_PREMIUM"),
        }

        //=============================
        // UserData생성 처리(File기반)
        //=============================
        // 향후 공통 파일이나 외부에서 수정 가능하도록 cloud-init 스크립트 파일로 설정
        rootPath := os.Getenv("CBSPIDER_ROOT")
        fileDataCloudInit, err := ioutil.ReadFile(rootPath + CBCloudInitFilePath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">userData := string(fileDataCloudInit)
        userData = strings.ReplaceAll(userData, "{{username}}", CBDefaultVmUserName)
        userData = strings.ReplaceAll(userData, "{{public_key}}", keyPairInfo.PublicKey)
        userDataBase64 := base64.StdEncoding.EncodeToString([]byte(userData))
        cblogger.Debugf("cloud-init data : [%s]", userDataBase64)
        request.UserData = common.StringPtr(userDataBase64)

        cblogger.Info("===== 요청 객체====")
        spew.Config.Dump(request)
        callLogStart := call.Start()
        response, err := vmHandler.Client.RunInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">spew.Dump(response)
        callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        //=========================================
        // VM 정보를 조회할 수 있을 때까지 대기
        //-----------------------------------------
        // WaitForRun을 호출하지 않아도 상관 없지만 Public Ip 등은 할당되지 않아서 조회되지 않으며
        // cb-tumblebug에서 일부 정보를 사용하기 때문에 Tencent도 Running 상태가 될때까지 대기 함.
        //=========================================
        newVmIID := irs.IID{SystemId: *response.Response.InstanceIdSet[0]}

        curStatus, errStatus := vmHandler.WaitForRun(newVmIID)
        if errStatus != nil </span><span class="cov0" title="0">{
                cblogger.Error(errStatus.Error())
                return irs.VMInfo{}, nil
        }</span>
        <span class="cov0" title="0">cblogger.Info("==&gt;생성된 VM[%s]의 현재 상태[%s]", newVmIID, curStatus)

        vmInfo, errVmInfo := vmHandler.GetVM(newVmIID)
        vmInfo.IId.NameId = vmReqInfo.IId.NameId
        return vmInfo, errVmInfo</span>
}

func (vmHandler *TencentVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StopInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewStopInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})
        /*
                Whether to force shut down an instance after a normal shutdown fails. Valid values:
                TRUE: force shut down an instance after a normal shutdown fails
                FALSE: do not force shut down an instance after a normal shutdown fails
                Default value: FALSE.
        */
        // request.ForceStop = common.BoolPtr(true)

        /*
                Instance shutdown mode. Valid values:

                SOFT_FIRST: perform a soft shutdown first, and force shut down the instance if the soft shutdown fails
                HARD: force shut down the instance directly
                SOFT: soft shutdown only
                Default value: SOFT.
        */
        // request.StopType = common.StringPtr("SOFT")

        /*
                Billing method of a pay-as-you-go instance after shutdown. Valid values:

                KEEP_CHARGING: billing continues after shutdown
                STOP_CHARGING: billing stops after shutdown
                Default value: KEEP_CHARGING. This parameter is only valid for some pay-as-you-go instances using cloud disks. For more information, see No charges when shut down for pay-as-you-go instances.
                https://intl.cloud.tencent.com/document/product/213/19918
        */
        // request.StoppedMode = common.StringPtr("STOP_CHARGING")

        callLogStart := call.Start()
        response, err := vmHandler.Client.StopInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Suspending"), nil</span>
}

func (vmHandler *TencentVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StartInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewStartInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.StartInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Resuming"), nil</span>
}

func (vmHandler *TencentVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "RebootInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewRebootInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.RebootInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Rebooting"), nil</span>
}

func (vmHandler *TencentVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "TerminateInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewTerminateInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.TerminateInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Terminating"), nil</span>
}

func (vmHandler *TencentVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("VM 정보를 찾을 수 없습니다")
        }</span>

        <span class="cov0" title="0">vmInfo, errVmInfo := vmHandler.ExtractDescribeInstances(response.Response.InstanceSet[0])
        cblogger.Info("vmInfo", vmInfo)
        return vmInfo, errVmInfo</span>
}

func (vmHandler *TencentVMHandler) ExtractDescribeInstances(curVm *cvm.Instance) (irs.VMInfo, error) <span class="cov0" title="0">{
        //cblogger.Info("ExtractDescribeInstances", curVm)
        //spew.Dump(curVm)

        //VM상태와 무관하게 항상 값이 존재하는 항목들만 초기화
        vmInfo := irs.VMInfo{
                IId:        irs.IID{SystemId: *curVm.InstanceId},
                VMSpecName: *curVm.InstanceType,
                VMUserId:   "cb-user",
                //KeyPairIId: irs.IID{SystemId: *curVm.},
        }

        if !reflect.ValueOf(curVm.ImageId).IsNil() </span><span class="cov0" title="0">{
                vmInfo.ImageIId = irs.IID{SystemId: *curVm.ImageId}
        }</span>

        // vmInfo.StartTime = *curVm.CreatedTime
        <span class="cov0" title="0">vmStartTime := *curVm.CreatedTime
        timeLen := len(vmStartTime)
        cblogger.Debug("서버 구동 시간 포멧 변환 처리")
        cblogger.Debugf("======&gt; 생성시간 길이 [%s]", timeLen)
        if timeLen &gt; 7 </span><span class="cov0" title="0">{
                cblogger.Debugf("======&gt; 생성시간 마지막 문자열 [%s]", vmStartTime[timeLen-1:])
                var NewStartTime string
                if vmStartTime[timeLen-1:] == "Z" &amp;&amp; timeLen == 17 </span><span class="cov0" title="0">{
                        //cblogger.Infof("======&gt; 문자열 변환 : [%s]", StartTime[:timeLen-1])
                        NewStartTime = vmStartTime[:timeLen-1] + ":00Z"
                        cblogger.Debugf("======&gt; 최종 문자열 변환 : [%s]", NewStartTime)
                }</span> else<span class="cov0" title="0"> {
                        NewStartTime = vmStartTime
                }</span>

                <span class="cov0" title="0">cblogger.Debugf("Convert StartTime string [%s] to time.time", NewStartTime)

                //layout := "2020-05-07T01:36Z"
                t, err := time.Parse(time.RFC3339, NewStartTime)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Debugf("======&gt; [%v]", t)
                        vmInfo.StartTime = t
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.LoginSettings).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(curVm.LoginSettings.KeyIds).IsNil() </span><span class="cov0" title="0">{
                        if len(curVm.LoginSettings.KeyIds) &gt; 0 </span><span class="cov0" title="0">{
                                vmInfo.KeyPairIId = irs.IID{SystemId: *curVm.LoginSettings.KeyIds[0]}
                        }</span>
                }
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.PublicIpAddresses).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PublicIP = *curVm.PublicIpAddresses[0]
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.Placement.Zone).IsNil() </span><span class="cov0" title="0">{
                vmInfo.Region = irs.RegionInfo{
                        Region: vmHandler.Region.Region, //리전 정보 추가
                        Zone:   *curVm.Placement.Zone,
                }
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.VirtualPrivateCloud.VpcId).IsNil() </span><span class="cov0" title="0">{
                vmInfo.VpcIID = irs.IID{SystemId: *curVm.VirtualPrivateCloud.VpcId}
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.VirtualPrivateCloud.SubnetId).IsNil() </span><span class="cov0" title="0">{
                vmInfo.SubnetIID = irs.IID{SystemId: *curVm.VirtualPrivateCloud.SubnetId}
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.SecurityGroupIds).IsNil() </span><span class="cov0" title="0">{
                for _, curSecurityGroupId := range curVm.SecurityGroupIds </span><span class="cov0" title="0">{
                        vmInfo.SecurityGroupIIds = append(vmInfo.SecurityGroupIIds, irs.IID{SystemId: *curSecurityGroupId})
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.PrivateIpAddresses).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PrivateIP = *curVm.PrivateIpAddresses[0]
        }</span>

        <span class="cov0" title="0">keyValueList := []irs.KeyValue{
                {Key: "InstanceState", Value: *curVm.InstanceState},
                {Key: "OsName", Value: *curVm.OsName},
        }

        //요금타입
        if !reflect.ValueOf(curVm.InstanceChargeType).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "InstanceChargeType", Value: *curVm.InstanceChargeType})
        }</span>

        //데이터 디스크 정보
        <span class="cov0" title="0">if !reflect.ValueOf(curVm.DataDisks).IsNil() </span><span class="cov0" title="0">{
                if len(curVm.DataDisks) &gt; 0 </span><span class="cov0" title="0">{
                        if !reflect.ValueOf(curVm.DataDisks[0].DiskId).IsNil() </span><span class="cov0" title="0">{
                                vmInfo.VMBlockDisk = *curVm.DataDisks[0].DiskId
                        }</span>
                }
        }

        //시스템 디스크 정보
        <span class="cov0" title="0">if !reflect.ValueOf(curVm.SystemDisk).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(curVm.SystemDisk.DiskType).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SystemDiskType", Value: *curVm.SystemDisk.DiskType})
                }</span>
                <span class="cov0" title="0">if !reflect.ValueOf(curVm.SystemDisk.DiskId).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SystemDiskId", Value: *curVm.SystemDisk.DiskId})
                        vmInfo.VMBootDisk = *curVm.SystemDisk.DiskId
                }</span>
                <span class="cov0" title="0">if !reflect.ValueOf(curVm.SystemDisk.DiskSize).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SystemDiskSize", Value: strconv.FormatInt(*curVm.SystemDisk.DiskSize, 10)})
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.InternetAccessible).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(curVm.InternetAccessible.InternetChargeType).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "InternetChargeType", Value: *curVm.InternetAccessible.InternetChargeType})
                }</span>
                <span class="cov0" title="0">if !reflect.ValueOf(curVm.InternetAccessible.InternetMaxBandwidthOut).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "InternetMaxBandwidthOut", Value: strconv.FormatInt(*curVm.InternetAccessible.InternetMaxBandwidthOut, 10)})
                }</span>
        }

        <span class="cov0" title="0">vmInfo.KeyValueList = keyValueList

        return vmInfo, nil</span>
}

func (vmHandler *TencentVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVM()",
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesRequest()
        request.Limit = common.Int64Ptr(100)

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>

        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        var vmInfoList []*irs.VMInfo
        for _, curVm := range response.Response.InstanceSet </span><span class="cov0" title="0">{
                vmInfo, _ := vmHandler.GetVM(irs.IID{SystemId: *curVm.InstanceId})
                vmInfoList = append(vmInfoList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmInfoList, nil</span>
}

func (vmHandler *TencentVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstancesStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesStatusRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstancesStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMStatus("Failed"), errors.New("상태 정보를 찾을 수 없습니다")
        }</span>

        <span class="cov0" title="0">vmStatus, errStatus := ConvertVMStatusString(*response.Response.InstanceStatusSet[0].InstanceState)
        cblogger.Infof("vmStatus : [%s]", vmStatus)
        return vmStatus, errStatus</span>
}

func (vmHandler *TencentVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVMStatus()",
                CloudOSAPI:   "DescribeInstancesStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesStatusRequest()
        request.Limit = common.Int64Ptr(100)

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstancesStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        var vmStatusList []*irs.VMStatusInfo
        for _, curVm := range response.Response.InstanceStatusSet </span><span class="cov0" title="0">{
                vmStatus, _ := ConvertVMStatusString(*curVm.InstanceState)

                vmStatusInfo := irs.VMStatusInfo{
                        IId:      irs.IID{SystemId: *curVm.InstanceId},
                        VmStatus: vmStatus,
                }
                cblogger.Info(vmStatusInfo.IId.SystemId, " Instance Status : ", vmStatusInfo.VmStatus)
                vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
        }</span>

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "pending") </span><span class="cov0" title="0">{
                //resultStatus = "Creating"        // VM 생성 시점의 Pending은 CB에서는 조회가 안되기 때문에 일단 처리하지 않음.
                resultStatus = "Resuming" // Resume 요청을 받아서 재기동되는 단계에도 Pending이 있기 때문에 Pending은 Resuming으로 맵핑함.
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "running") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopping") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopped") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
                //} else if strings.EqualFold(vmStatus, "pending") {
                //        resultStatus = "Resuming"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Rebooting") </span><span class="cov0" title="0">{
                resultStatus = "Rebooting"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "shutting-down") </span><span class="cov0" title="0">{
                resultStatus = "Terminating"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Terminated") </span><span class="cov0" title="0">{
                resultStatus = "Terminated"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]와 일치하는 맵핑 정보를 찾지 못 함.", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "와 일치하는 CB VM 상태정보를 찾을 수 없습니다.")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM 상태 치환 : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

// VM 정보를 조회할 수 있을 때까지 최대 30초간 대기
func (vmHandler *TencentVMHandler) WaitForRun(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt; VM 생성 직후에는 Public IP등 일부 정보 조회가 안되기 때문에 Running 될 때까지 대기함.")

        //waitStatus := "NotExist"        //VM정보 조회가 안됨.
        waitStatus := "Running"
        //waitStatus := "Creating" //너무 일찍 종료 시 리턴할 VM의 세부 항목의 정보 조회가 안됨.

        //===================================
        // Suspending 되도록 3초 정도 대기 함.
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)

                if curStatus == irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM 상태가 [%s]라서 대기를 중단합니다.", curStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM 상태가 [%s]이 아니라서 1초 대기후 조회합니다.", waitStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("장시간(%d 초) 대기해도 VM의 Status 값이 [%s]으로 변경되지 않아서 강제로 중단합니다.", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("장시간 기다렸으나 생성된 VM의 상태가 [" + waitStatus + "]으로 바뀌지 않아서 중단 합니다.")
                }</span>
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package resources

import (
        "errors"
        "reflect"
        "strconv"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
)

//https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.DescribeInstanceTypes
type TencentVmSpecHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

//@TODO : Region : zone id(Region이 아닌 zone id로 조회해야 함.)
func (vmSpecHandler *TencentVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        //cblogger.Infof("ListVMSpec(ZoneId:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return nil, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"),
                        Values: common.StringPtrs([]string{zoneId}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>

        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vmSpecInfoList []*irs.VMSpecInfo
        for _, curSpec := range response.Response.InstanceTypeConfigSet </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s] VM Spec 정보 처리", *curSpec.InstanceType)
                vmSpecInfo := ExtractVMSpecInfo(curSpec)
                vmSpecInfoList = append(vmSpecInfoList, &amp;vmSpecInfo)
        }</span>

        <span class="cov0" title="0">cblogger.Debug(vmSpecInfoList)
        //spew.Dump(vmSpecInfoList)
        return vmSpecInfoList, nil</span>
}

func (vmSpecHandler *TencentVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        //cblogger.Infof("Start GetVMSpec(ZoneId:[%s], Name:[%s])", Region, Name)
        cblogger.Infof("Spec Name:[%s]", Name)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.VMSpecInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"), //존으로 검색
                        Values: common.StringPtrs([]string{zoneId}),
                },
                &amp;cvm.Filter{
                        Name:   common.StringPtr("instance-type"), //인스턴스 타입으로 검색
                        Values: common.StringPtrs([]string{Name}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMSpecInfo{}, err
        }</span>

        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(response.Response.InstanceTypeConfigSet) &gt; 0 </span><span class="cov0" title="0">{
                vmSpecInfo := ExtractVMSpecInfo(response.Response.InstanceTypeConfigSet[0])
                cblogger.Debug(vmSpecInfo)
                return vmSpecInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.VMSpecInfo{}, errors.New("정보를 찾을 수 없습니다")
        }</span>
}

func (vmSpecHandler *TencentVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        //cblogger.Infof("ListOrgVMSpec(ZoneId:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return "", errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListOrgVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"),
                        Values: common.StringPtrs([]string{zoneId}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return "", err
        }</span>

        //spew.Dump(response)
        // cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        jsonString, errJson := ConvertJsonString(response.Response.InstanceTypeConfigSet)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
                return "", errJson
        }</span>
        <span class="cov0" title="0">cblogger.Debug(jsonString)
        return jsonString, errJson</span>
}

func (vmSpecHandler *TencentVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Spec Name:[%s]", Name)
        //cblogger.Infof("Start GetOrgVMSpec(ZoneId:[%s], Name:[%s])", Region, Name)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return "", errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"),
                        Values: common.StringPtrs([]string{zoneId}),
                },
                &amp;cvm.Filter{
                        Name:   common.StringPtr("instance-type"), //인스턴스 타입으로 검색
                        Values: common.StringPtrs([]string{Name}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return "", err
        }</span>

        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(response.Response.InstanceTypeConfigSet) &gt; 0 </span><span class="cov0" title="0">{
                jsonString, errJson := ConvertJsonString(response.Response.InstanceTypeConfigSet[0])
                if errJson != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errJson)
                        return "", errJson
                }</span>
                <span class="cov0" title="0">cblogger.Debug(jsonString)
                return jsonString, errJson</span>
        } else<span class="cov0" title="0"> {
                return "", errors.New("정보를 찾을 수 없습니다")
        }</span>
}

//인스턴스 스펙 정보를 추출함
func ExtractVMSpecInfo(instanceTypeInfo *cvm.InstanceTypeConfig) irs.VMSpecInfo <span class="cov0" title="0">{
        cblogger.Debugf("ExtractVMSpecInfo : SpecName:[%s]", *instanceTypeInfo.InstanceType)
        //spew.Dump(instanceTypeInfo)

        vCpuInfo := irs.VCpuInfo{}
        // gpuInfoList := []irs.GpuInfo{}

        //기본 정보
        vmSpecInfo := irs.VMSpecInfo{
                Name:   *instanceTypeInfo.InstanceType,
                Region: *instanceTypeInfo.Zone,
        }

        //Memory 정보 처리
        if !reflect.ValueOf(instanceTypeInfo.Memory).IsNil() </span><span class="cov0" title="0">{
                vmSpecInfo.Mem = strconv.FormatInt(*instanceTypeInfo.Memory, 10)
        }</span>

        //VCPU 정보 처리 - Count
        <span class="cov0" title="0">if !reflect.ValueOf(instanceTypeInfo.CPU).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Count = strconv.FormatInt(*instanceTypeInfo.CPU, 10)
        }</span>
        <span class="cov0" title="0">vmSpecInfo.VCpu = vCpuInfo

        //GPU 정보가 있는 인스터스는 GPU 처리
        if !reflect.ValueOf(instanceTypeInfo.GPU).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Count = strconv.FormatInt(*instanceTypeInfo.GPU, 10)
                vmSpecInfo.Gpu = []irs.GpuInfo{irs.GpuInfo{Count: strconv.FormatInt(*instanceTypeInfo.GPU, 10)}}
        }</span>

        //KeyValue 목록 처리
        <span class="cov0" title="0">keyValueList, errKeyValue := ConvertKeyValueList(instanceTypeInfo)
        if errKeyValue != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%]의 KeyValue 추출 실패", *instanceTypeInfo.InstanceType)
                cblogger.Error(errKeyValue)
        }</span>
        <span class="cov0" title="0">vmSpecInfo.KeyValueList = keyValueList

        return vmSpecInfo</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr

package resources

import (
        "errors"
        "strconv"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"

        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
)

type TencentVPCHandler struct {
        Region idrv.RegionInfo
        Client *vpc.Client
}

func (VPCHandler *TencentVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        //=================================================
        // 동일 이름 생성 방지 추가(cb-spider 요청 필수 기능)
        //=================================================
        isExist, errExist := VPCHandler.isExist(vpcReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.VPCInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New("A VPC with the name " + vpcReqInfo.IId.NameId + " already exists.")
        }</span>

        <span class="cov0" title="0">zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.VPCInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        //=========================
        // VPC 생성
        //=========================
        request := vpc.NewCreateVpcRequest()
        request.VpcName = common.StringPtr(vpcReqInfo.IId.NameId)
        request.CidrBlock = common.StringPtr(vpcReqInfo.IPv4_CIDR)

        callLogStart := call.Start()
        response, err := VPCHandler.Client.CreateVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        newVpcId := *response.Response.Vpc.VpcId // Subnet이 포함된 정보를 전달해야 하기 때문에 생성된 VPC Id를 보관함.

        //=========================
        // Subnet 생성
        //========================
        requestSubnet := vpc.NewCreateSubnetsRequest()

        requestSubnet.VpcId = common.StringPtr(newVpcId)
        requestSubnet.Subnets = []*vpc.SubnetInput{}

        for _, curSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet 처리", curSubnet.IId.NameId)
                reqSubnet := &amp;vpc.SubnetInput{
                        CidrBlock:  common.StringPtr(curSubnet.IPv4_CIDR),
                        SubnetName: common.StringPtr(curSubnet.IId.NameId),
                        Zone:       common.StringPtr(zoneId),
                        //RouteTableId: common.StringPtr("route"),
                }
                requestSubnet.Subnets = append(requestSubnet.Subnets, reqSubnet)
        }</span>

        <span class="cov0" title="0">responseSubnet, errSubnet := VPCHandler.Client.CreateSubnets(requestSubnet)
        cblogger.Debug(responseSubnet.ToJsonString())
        spew.Dump(responseSubnet)
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>

        //신규로 생성된 VPC와 Subnet 정보를 irs.VPCInfo{}로 치환해도 되지만 수정의 편의및 최신 정보 통일을 위해 GetVPC롤 호출함.
        //생성된 Subnet을 포함한 VPC의 최신 정보를 조회함.
        <span class="cov0" title="0">retVpcInfo, errVpc := VPCHandler.GetVPC(irs.IID{SystemId: newVpcId})
        if errVpc != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpc)
                return irs.VPCInfo{}, errVpc
        }</span>
        <span class="cov0" title="0">retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId // 생성 시에는 NameId는 cb-spider를 위해 요청 받은 값을 그대로 리턴해야 함.

        return retVpcInfo, nil</span>
}

//VPC 정보를 추출함
func ExtractVpcDescribeInfo(vpcInfo *vpc.Vpc) irs.VPCInfo <span class="cov0" title="0">{
        // cblogger.Debug("전달 받은 내용")
        // spew.Dump(vpcInfo)
        resVpcInfo := irs.VPCInfo{
                //NameId는 사용되지 않기 때문에 전달할 필요가 없지만 Tencent는 Name도 필수로 들어가니 전달함.
                IId:       irs.IID{SystemId: *vpcInfo.VpcId, NameId: *vpcInfo.VpcName},
                IPv4_CIDR: *vpcInfo.CidrBlock,
        }

        return resVpcInfo
}</span>

func (VPCHandler *TencentVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start")

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeVpcsRequest()
        callLogStart := call.Start()
        response, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("VPC 개수 : ", *response.Response.TotalCount)

        var vpcInfoList []*irs.VPCInfo
        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                for _, curVpc := range response.Response.VpcSet </span><span class="cov0" title="0">{
                        cblogger.Debugf("[%s] VPC 정보 조회 - [%s]", *curVpc.VpcId, *curVpc.VpcName)
                        vpcInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: *curVpc.VpcId})
                        // cblogger.Info("==&gt;조회 결과")
                        // spew.Dump(vpcInfo)
                        if vpcErr != nil </span><span class="cov0" title="0">{
                                cblogger.Error(vpcErr)
                                return nil, vpcErr
                        }</span>
                        <span class="cov0" title="0">vpcInfoList = append(vpcInfoList, &amp;vpcInfo)</span>
                }
        }

        <span class="cov0" title="0">cblogger.Debugf("리턴 결과 목록 수 : [%d]", len(vpcInfoList))
        // spew.Dump(vpcInfoList)
        return vpcInfoList, nil</span>
}

// cb-spider 정책상 이름 기반으로 중복 생성을 막아야 함.
func (VPCHandler *TencentVPCHandler) isExist(chkName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Debugf("chkName : %s", chkName)

        request := vpc.NewDescribeVpcsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("vpc-name"),
                        Values: common.StringPtrs([]string{chkName}),
                },
        }

        response, err := VPCHandler.Client.DescribeVpcs(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("VPC 정보 찾음 - VpcId:[%s] / VpcName:[%s]", *response.Response.VpcSet[0].VpcId, *response.Response.VpcSet[0].VpcName)
        return true, nil</span>
}

func (VPCHandler *TencentVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "GetVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeVpcsRequest()
        request.VpcIds = common.StringPtrs([]string{vpcIID.SystemId})

        callLogStart := call.Start()
        response, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("An API error has returned: %s", err.Error())
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Debug("VPC 개수 : ", *response.Response.TotalCount)
        if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New("Notfound: '" + vpcIID.SystemId + "' VPC Not found")
        }</span>

        <span class="cov0" title="0">vpcInfo := ExtractVpcDescribeInfo(response.Response.VpcSet[0])
        cblogger.Debug(vpcInfo)

        //=======================
        // Subnet 처리
        //=======================
        var errSubnet error
        vpcInfo.SubnetInfoList, errSubnet = VPCHandler.ListSubnet(vpcIID.SystemId)
        if errSubnet != nil </span><span class="cov0" title="0">{
                callogger.Error(errSubnet)
                return vpcInfo, errSubnet
        }</span>

        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (VPCHandler *TencentVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDeleteVpcRequest()
        request.VpcId = common.StringPtr(vpcIID.SystemId)

        callLogStart := call.Start()
        _, err := VPCHandler.Client.DeleteVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("An API error has returned: %s", err.Error())
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}

func (VPCHandler *TencentVPCHandler) ListSubnet(reqVpcId string) ([]irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("reqVpcId : [%s]", reqVpcId)
        var arrSubnetInfoList []irs.SubnetInfo

        /*
                // logger for HisCall
                callogger := call.GetLogger("HISCALL")
                callLogInfo := call.CLOUDLOGSCHEMA{
                        CloudOS:      call.TENCENT,
                        RegionZone:   VPCHandler.Region.Zone,
                        ResourceType: call.VPCSUBNET,
                        ResourceName: "ListSubnet - VpcId:" + reqVpcId,
                        CloudOSAPI:   "DescribeSubnets()",
                        ElapsedTime:  "",
                        ErrorMSG:     "",
                }
        */

        request := vpc.NewDescribeSubnetsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("vpc-id"),
                        Values: common.StringPtrs([]string{reqVpcId}),
                },
        }

        // callLogStart := call.Start()
        response, err := VPCHandler.Client.DescribeSubnets(request)
        // callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //cblogger.Debug(response.ToJsonString())
        spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                // callLogInfo.ErrorMSG = err.Error()
                // callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        // callogger.Info(call.String(callLogInfo))

        <span class="cov0" title="0">for _, curSubnet := range response.Response.SubnetSet </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet 정보 조회", *curSubnet.SubnetId)
                resSubnetInfo := irs.SubnetInfo{
                        IId:       irs.IID{SystemId: *curSubnet.SubnetId, NameId: *curSubnet.SubnetName},
                        IPv4_CIDR: *curSubnet.CidrBlock,
                        //Status:    *subnetInfo.State,
                }

                keyValueList := []irs.KeyValue{
                        {Key: "VpcId", Value: *curSubnet.VpcId},
                        {Key: "IsDefault", Value: strconv.FormatBool(*curSubnet.IsDefault)},
                        {Key: "AvailabilityZone", Value: *curSubnet.Zone},
                }
                resSubnetInfo.KeyValueList = keyValueList
                arrSubnetInfoList = append(arrSubnetInfoList, resSubnetInfo)
        }</span>

        <span class="cov0" title="0">return arrSubnetInfoList, nil</span>
}

// 동일 이름으로 생성되는 것을 막기 위해 중복 체크함.
// reqSubnetNameId : 서브넷 Name
func (VPCHandler *TencentVPCHandler) isExistSubnet(reqSubnetNameId string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("reqSubnetNameId : [%s]", reqSubnetNameId)

        request := vpc.NewDescribeSubnetsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("subnet-name"),
                        Values: common.StringPtrs([]string{reqSubnetNameId}),
                },
        }

        //spew.Dump(request)
        response, err := VPCHandler.Client.DescribeSubnets(request)
        //cblogger.Debug("서브넷 실행 결과")
        //spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (VPCHandler *TencentVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet 추가 - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.VPCInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">if subnetInfo.IId.NameId == "" </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New("생성할 SubnetId 정보가 없습니다.")
        }</span>

        <span class="cov0" title="0">isExit, errSubnetInfo := VPCHandler.isExistSubnet(subnetInfo.IId.NameId)
        if errSubnetInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnetInfo)
                return irs.VPCInfo{}, errSubnetInfo
        }</span>

        <span class="cov0" title="0">cblogger.Info("Subnet 존재여부 : ")
        cblogger.Info(isExit)

        if isExit </span><span class="cov0" title="0">{
                cblogger.Errorf("이미 [%S] Subnet이 존재하기 때문에 생성하지 않고 기존 정보와 함께 에러를 리턴함.", subnetInfo.IId.NameId)
                return irs.VPCInfo{}, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + subnetInfo.IId.NameId + "' already exists.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewCreateSubnetRequest()

        request.VpcId = common.StringPtr(vpcIID.SystemId)
        request.SubnetName = common.StringPtr(subnetInfo.IId.NameId)
        request.CidrBlock = common.StringPtr(subnetInfo.IPv4_CIDR)
        request.Zone = common.StringPtr(VPCHandler.Region.Zone)

        callLogStart := call.Start()
        response, err := VPCHandler.Client.CreateSubnet(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        retVpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, err
        }</span>

        //retVpcInfo.SubnetInfoList[0].IId.NameId = vpcReqInfo.IId.NameId // 생성 시에는 NameId는 요청 받은 값으로 리턴해야 함.

        <span class="cov0" title="0">return retVpcInfo, nil</span>
}

func (VPCHandler *TencentVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC의 [%s] Subnet 삭제", vpcIID.SystemId, subnetIID.SystemId)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DeleteSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDeleteSubnetRequest()
        request.SubnetId = common.StringPtr(subnetIID.SystemId)

        callLogStart := call.Start()
        response, err := VPCHandler.Client.DeleteSubnet(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        //spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}

/*
func (VPCHandler *TencentVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) {
        cblogger.Info(vpcReqInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" {
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.VPCInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }

        input := &amp;ec2.CreateVpcInput{
                CidrBlock: aws.String(vpcReqInfo.IPv4_CIDR),
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        retVpcInfo := ExtractVpcDescribeInfo(result.Vpc)
        retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId // NameId는 요청 받은 값으로 리턴해야 함.

        //IGW Name Tag 설정
        if SetNameTag(VPCHandler.Client, *result.Vpc.VpcId, vpcReqInfo.IId.NameId) {
                cblogger.Infof("VPC에 %s Name 설정 성공", vpcReqInfo.IId.NameId)
        } else {
                cblogger.Errorf("VPC에 %s Name 설정 실패", vpcReqInfo.IId.NameId)
        }

        //====================================
        // PublicIP 할당을 위해 IGW 생성및 연결
        //====================================
        //IGW 생성
        resultIGW, errIGW := VPCHandler.Client.CreateInternetGateway(&amp;ec2.CreateInternetGatewayInput{})
        if errIGW != nil {
                if aerr, ok := errIGW.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGW.Error())
                }
                return retVpcInfo, errIGW
        }

        cblogger.Info(resultIGW)

        //IGW Name Tag 설정
        if SetNameTag(VPCHandler.Client, *resultIGW.InternetGateway.InternetGatewayId, vpcReqInfo.IId.NameId) {
                cblogger.Infof("IGW에 %s Name 설정 성공", vpcReqInfo.IId.NameId)
        } else {
                cblogger.Errorf("IGW에 %s Name 설정 실패", vpcReqInfo.IId.NameId)
        }

        // VPC에 IGW연결
        inputIGW := &amp;ec2.AttachInternetGatewayInput{
                InternetGatewayId: aws.String(*resultIGW.InternetGateway.InternetGatewayId),
                VpcId:             aws.String(retVpcInfo.IId.SystemId),
        }

        resultIGWAttach, errIGWAttach := VPCHandler.Client.AttachInternetGateway(inputIGW)
        if err != nil {
                if aerr, ok := errIGWAttach.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGWAttach.Error())
                }
                return retVpcInfo, errIGWAttach
        }

        cblogger.Info(resultIGWAttach)

        // 생성된 VPC의 기본 라우팅 테이블에 IGW 라우팅 정보 추가
        errRoute := VPCHandler.CreateRouteIGW(retVpcInfo.IId.SystemId, *resultIGW.InternetGateway.InternetGatewayId)
        if errRoute != nil {
                return retVpcInfo, errRoute
        }

        //==========================
        // Subnet 생성
        //==========================
        //VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, vpcReqInfo.SubnetInfoList[0])
        var resSubnetList []irs.SubnetInfo
        for _, curSubnet := range vpcReqInfo.SubnetInfoList {
                cblogger.Infof("[%s] Subnet 생성", curSubnet.IId.NameId)
                cblogger.Infof("Reqt Subnet Info [%v]", curSubnet)
                resSubnet, errSubnet := VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, curSubnet)

                if errSubnet != nil {
                        return retVpcInfo, errSubnet
                }
                resSubnetList = append(resSubnetList, resSubnet)
        }
        retVpcInfo.SubnetInfoList = resSubnetList
        return retVpcInfo, nil
}

// 생성된 VPC의 라우팅 테이블에 IGW(Internet Gateway) 라우팅 정보를 생성함 (AWS 콘솔의 라우팅 테이블의 [라우팅] Tab 처리)
func (VPCHandler *TencentVPCHandler) CreateRouteIGW(vpcId string, igwId string) error {
        cblogger.Infof("VPC ID : [%s] / IGW ID : [%s]", vpcId, igwId)
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil {
                return errRoute
        }

        cblogger.Infof("RouteTable[%s]에 IGW[%s]에 대한 라우팅(0.0.0.0/0) 정보를 추가 합니다.", routeTableId, igwId)
        input := &amp;ec2.CreateRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                GatewayId:            aws.String(igwId),
                RouteTableId:         aws.String(routeTableId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: igwId,
                CloudOSAPI:   "CreateRoute()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateRoute(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil {
                cblogger.Errorf("RouteTable[%s]에 IGW[%s]에 대한 라우팅(0.0.0.0/0) 정보 추가 실패", routeTableId, igwId)
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return err
        }
        cblogger.Infof("RouteTable[%s]에 IGW[%s]에 대한 라우팅(0.0.0.0/0) 정보를 추가 완료", routeTableId, igwId)
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return nil
}

//https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Route_Tables.html
//https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html
// 자동 생성된 VPC의 기본 라우팅 테이블 정보를 찾음
func (VPCHandler *TencentVPCHandler) GetDefaultRouteTable(vpcId string) (string, error) {
        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return "", err
        }

        cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &gt; 0 {
                routeTableId := *result.RouteTables[0].RouteTableId
                cblogger.Infof("라우팅 테이블 ID 찾음 : [%s]", routeTableId)
                return routeTableId, nil
        } else {
                return "", errors.New("VPC에 할당된 라우팅 테이블 ID를 찾을 수 없습니다.")
        }
}

func (VPCHandler *TencentVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) {
        cblogger.Info(reqSubnetInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" {
                cblogger.Error("Connection 정보에 Zone 정보가 없습니다.")
                return irs.SubnetInfo{}, errors.New("Connection 정보에 Zone 정보가 없습니다.")
        }

        if reqSubnetInfo.IId.SystemId != "" {
                vpcInfo, errVpcInfo := VPCHandler.GetSubnet(reqSubnetInfo.IId.SystemId)
                if errVpcInfo == nil {
                        cblogger.Errorf("이미 [%S] Subnet이 존재하기 때문에 생성하지 않고 기존 정보와 함께 에러를 리턴함.", reqSubnetInfo.IId.SystemId)
                        cblogger.Info(vpcInfo)
                        return vpcInfo, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + reqSubnetInfo.IId.SystemId + "' already exists.")
                }
        }

        //서브넷 생성
        input := &amp;ec2.CreateSubnetInput{
                CidrBlock: aws.String(reqSubnetInfo.IPv4_CIDR),
                VpcId:     aws.String(vpcId),
                //AvailabilityZoneId: aws.String(zoneId),        //use1-az1, use1-az2, use1-az3, use1-az4, use1-az5, use1-az6
                AvailabilityZone: aws.String(zoneId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        cblogger.Info(input)
        result, err := VPCHandler.Client.CreateSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)

        //vNetworkInfo := irs.VNetworkInfo{}
        vNetworkInfo := ExtractSubnetDescribeInfo(result.Subnet)

        //Subnet Name 태깅
        if SetNameTag(VPCHandler.Client, *result.Subnet.SubnetId, reqSubnetInfo.IId.NameId) {
                cblogger.Infof("Subnet에 %s Name 설정 성공", reqSubnetInfo.IId.NameId)
        } else {
                cblogger.Errorf("Subnet에 %s Name 설정 실패", reqSubnetInfo.IId.NameId)
        }

        vNetworkInfo.IId.NameId = reqSubnetInfo.IId.NameId

        // VPC의 라우팅 테이블에 생성된 Subnet 정보를 추가 함.
        errSubnetRoute := VPCHandler.AssociateRouteTable(vpcId, vNetworkInfo.IId.SystemId)
        if errSubnetRoute != nil {
        } else {
                return vNetworkInfo, errSubnetRoute
        }

        return vNetworkInfo, nil
}

// VPC의 라우팅 테이블에 생성된 Subnet을 연결 함.
func (VPCHandler *TencentVPCHandler) AssociateRouteTable(vpcId string, subnetId string) error {
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil {
                return errRoute
        }

        input := &amp;ec2.AssociateRouteTableInput{
                RouteTableId: aws.String(routeTableId),
                SubnetId:     aws.String(subnetId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetId,
                CloudOSAPI:   "AssociateRouteTable()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.AssociateRouteTable(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return err
        }

        callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)
        return nil
}

func (VPCHandler *TencentVPCHandler) ListVPC() ([]*irs.VPCInfo, error) {
        cblogger.Debug("Start")
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(&amp;ec2.DescribeVpcsInput{})
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err
        }
        callogger.Info(call.String(callLogInfo))

        var vNetworkInfoList []*irs.VPCInfo
        for _, curVpc := range result.Vpcs {
                cblogger.Infof("[%s] VPC 정보 조회", *curVpc.VpcId)
                vNetworkInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: *curVpc.VpcId})
                if vpcErr != nil {
                        return nil, vpcErr
                }
                vNetworkInfoList = append(vNetworkInfoList, &amp;vNetworkInfo)
        }

        spew.Dump(vNetworkInfoList)
        return vNetworkInfoList, nil
}

func (VPCHandler *TencentVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) {
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        input := &amp;ec2.DescribeVpcsInput{
                VpcIds: []*string{
                        aws.String(vpcIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        //spew.Dump(result)

        if reflect.ValueOf(result.Vpcs).IsNil() {
                return irs.VPCInfo{}, nil
        }

        var errSubnet error
        awsVpcInfo := ExtractVpcDescribeInfo(result.Vpcs[0])
        awsVpcInfo.SubnetInfoList, errSubnet = VPCHandler.ListSubnet(vpcIID.SystemId)
        if errSubnet != nil {
                return awsVpcInfo, errSubnet
        }

        return awsVpcInfo, nil
}

//VPC 정보를 추출함
func ExtractVpcDescribeInfo(vpcInfo *ec2.Vpc) irs.VPCInfo {
        awsVpcInfo := irs.VPCInfo{
                IId:       irs.IID{SystemId: *vpcInfo.VpcId},
                IPv4_CIDR: *vpcInfo.CidrBlock,
                //IsDefault: *vpcInfo.IsDefault,
                //State:     *vpcInfo.State,
        }

        //Name은 Tag의 "Name" 속성에만 저장됨
        //NameId는 전달할 필요가 없음.
        return awsVpcInfo
}

func (VPCHandler *TencentVPCHandler) DeleteSubnet(subnetIID irs.IID) (bool, error) {
        input := &amp;ec2.DeleteSubnetInput{
                SubnetId: aws.String(subnetIID.SystemId),
        }
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "DeleteSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        _, err := VPCHandler.Client.DeleteSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        cblogger.Info(err)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return false, err
        }

        callogger.Info(call.String(callLogInfo))
        return true, nil
}

func (VPCHandler *TencentVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) {
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil {
                return false, errVpcInfo
        }

        //=================
        // Subnet삭제
        //=================
        for _, curSubnet := range vpcInfo.SubnetInfoList {
                cblogger.Infof("[%s] Subnet 삭제", curSubnet.IId.SystemId)
                delSubnet, errSubnet := VPCHandler.DeleteSubnet(curSubnet.IId)
                if errSubnet != nil {
                        return false, errSubnet
                }

                if delSubnet {
                        cblogger.Infof("  ==&gt; [%s] Subnet 삭제완료", curSubnet.IId.SystemId)
                } else {
                        cblogger.Errorf("  ==&gt; [%s] Subnet 삭제실패", curSubnet.IId.SystemId)
                        return false, errors.New("Subnet 삭제 실패로 VPC를 삭제하지 못 했습니다.") //삭제 실패 이유를 모르는 경우
                }
        }

        cblogger.Infof("[%s] VPC를 삭제 함.", vpcInfo.IId.SystemId)
        cblogger.Info("VPC 제거를 위해 생성된 IGW / Route들 제거 시작")

        // 라우팅 테이블에 추가한 IGW 라우터를 먼저 삭제함.
        errRoute := VPCHandler.DeleteRouteIGW(vpcInfo.IId.SystemId)
        if errRoute != nil {
                cblogger.Error("라우팅 테이블에 추가한 0.0.0.0/0 IGW 라우터 삭제 실패")
                cblogger.Error(errRoute)
                if "InvalidRoute.NotFound" == errRoute.Error() {
                        cblogger.Infof("[%s]예외는 #255예외에 의해 정상으로 간주하고 다음 단계를 진행함.", errRoute)
                } else {
                        return false, errRoute
                }
                //} else {
                //        cblogger.Info("라우팅 테이블에 추가한 0.0.0.0/0 IGW 라우터 삭제 완료")
        }

        //VPC에 연결된 모든 IGW를 삭제함. (VPC에 할당된 모든 IGW조회후 삭제)
        errIgw := VPCHandler.DeleteAllIGW(vpcInfo.IId.SystemId)
        if errIgw != nil {
                cblogger.Error("모든 IGW 삭제 실패 : ", errIgw)
        } else {
                cblogger.Info("모든 IGW 삭제 완료")
        }

        input := &amp;ec2.DeleteVpcInput{
                VpcId: aws.String(vpcInfo.IId.SystemId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcInfo.IId.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DeleteVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return false, err
        }
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return true, nil
}

// VPC에 설정된 0.0.0.0/0 라우터를 제거 함.
// #255예외 처리 보완에 따른 라우팅 정보 삭제전 0.0.0.0 조회후 삭제하도록 로직 변경
func (VPCHandler *TencentVPCHandler) DeleteRouteIGW(vpcId string) error {
        cblogger.Infof("VPC ID : [%s]", vpcId)
        routeTableId := ""

        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil {
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &lt; 1 {
                return errors.New("VPC에 할당된 라우팅 테이블 정보를 찾을 수 없습니다.")
        }

        routeTableId = *result.RouteTables[0].RouteTableId
        cblogger.Infof("라우팅 테이블 ID 찾음 : [%s]", routeTableId)

        cblogger.Infof("RouteTable[%s]에 할당된 라우팅(0.0.0.0/0) 정보를 조회합니다.", routeTableId)

        //ec2.Route
        findIgw := false
        for _, curRoute := range result.RouteTables[0].Routes {
                cblogger.Infof("DestinationCidrBlock[%s] Check", *curRoute.DestinationCidrBlock)

                if "0.0.0.0/0" == *curRoute.DestinationCidrBlock {
                        cblogger.Infof("===&gt;RouteTable[%s]에 할당된 라우팅(0.0.0.0/0) 정보를 찾았습니다!!", routeTableId)
                        findIgw = true
                        break
                }
        }

        if !findIgw {
                cblogger.Infof("RouteTable[%s]에 할당된 IGW의 라우팅(0.0.0.0/0) 정보가 없으므로 라우트 삭제처리는 중단합니다. ", routeTableId)
                return nil
        }

        cblogger.Infof("RouteTable[%s]에 할당된 라우팅(0.0.0.0/0) 정보를 삭제합니다.", routeTableId)
        inputDel := &amp;ec2.DeleteRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                RouteTableId:         aws.String(routeTableId),
        }
        cblogger.Info(inputDel)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteRoute.html
        resultDel, err := VPCHandler.Client.DeleteRoute(inputDel)
        if err != nil {
                cblogger.Errorf("RouteTable[%s]에 대한 라우팅(0.0.0.0/0) 정보 삭제 실패", routeTableId)
                if aerr, ok := err.(awserr.Error); ok {
                        //InvalidRoute.NotFound
                        cblogger.Errorf("Error Code : [%s] - Error:[%s] - Message:[%s]", aerr.Code(), aerr.Error(), aerr.Message())
                        switch aerr.Code() {
                        case "InvalidRoute.NotFound": //NotFound에러는 무시하라고 해서 (예외#255)
                                return errors.New(aerr.Code())
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }
        cblogger.Infof("RouteTable[%s]에 대한 라우팅(0.0.0.0/0) 정보 삭제 완료", routeTableId)

        cblogger.Info(resultDel)
        spew.Dump(resultDel)
        cblogger.Info("라우팅 테이블에 추가한 0.0.0.0/0 IGW 라우터 삭제 완료")
        return nil
}

//VPC에 연결된 모든 IGW를 삭제함.
func (VPCHandler *TencentVPCHandler) DeleteAllIGW(vpcId string) error {
        input := &amp;ec2.DescribeInternetGatewaysInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("attachment.vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeInternetGateways(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)

        // VPC 삭제를 위해 연결된 모든 IGW 제거
        // 일단, 에러는 무시함.
        for _, curIgw := range result.InternetGateways {
                //IGW 삭제전 연결된 IGW의 연결을 끊어야함.
                VPCHandler.DetachInternetGateway(vpcId, *curIgw.InternetGatewayId)
                //IGW 삭제
                VPCHandler.DeleteIGW(*curIgw.InternetGatewayId)
        }

        return nil
}

// VPC에 연결된 IGW의 연결을 해제함.
func (VPCHandler *TencentVPCHandler) DetachInternetGateway(vpcId string, igwId string) error {
        cblogger.Infof("VPC[%s]에 연결된 IGW[%s]의 연결을 해제함.", vpcId, igwId)

        input := &amp;ec2.DetachInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
                VpcId:             aws.String(vpcId),
        }

        result, err := VPCHandler.Client.DetachInternetGateway(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)
        return nil
}

// IGW를 삭제 함.
func (VPCHandler *TencentVPCHandler) DeleteIGW(igwId string) error {
        input := &amp;ec2.DeleteInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
        }

        result, err := VPCHandler.Client.DeleteInternetGateway(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)
        return nil
}

//VPC의 하위 서브넷 목록을 조회함.
func (VPCHandler *TencentVPCHandler) ListSubnet(vpcId string) ([]irs.SubnetInfo, error) {
        cblogger.Debug("Start")
        var arrSubnetInfoList []irs.SubnetInfo

        input := &amp;ec2.DescribeSubnetsInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListSubnet",
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //spew.Dump(input)
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return nil, err
        }
        callogger.Info(call.String(callLogInfo))

        spew.Dump(result)
        for _, curSubnet := range result.Subnets {
                cblogger.Infof("[%s] Subnet 정보 조회", *curSubnet.SubnetId)
                arrSubnetInfo := ExtractSubnetDescribeInfo(curSubnet)
                arrSubnetInfoList = append(arrSubnetInfoList, arrSubnetInfo)
        }

        spew.Dump(arrSubnetInfoList)
        return arrSubnetInfoList, nil
}

func (VPCHandler *TencentVPCHandler) GetSubnet(reqSubnetId string) (irs.SubnetInfo, error) {
        cblogger.Infof("SubnetId : [%s]", reqSubnetId)

        input := &amp;ec2.DescribeSubnetsInput{
                SubnetIds: []*string{
                        aws.String(reqSubnetId),
                },
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetId,
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        //spew.Dump(result)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))

        if !reflect.ValueOf(result.Subnets).IsNil() {
                retSubnetInfo := ExtractSubnetDescribeInfo(result.Subnets[0])
                return retSubnetInfo, nil
        } else {
                return irs.SubnetInfo{}, errors.New("InvalidSubnet.NotFound: The CBVnetwork '" + reqSubnetId + "' does not exist")
        }
}


//Subnet 정보를 추출함
func ExtractSubnetDescribeInfo(subnetInfo *ec2.Subnet) irs.SubnetInfo {
        vNetworkInfo := irs.SubnetInfo{
                IId:       irs.IID{SystemId: *subnetInfo.SubnetId},
                IPv4_CIDR: *subnetInfo.CidrBlock,
                //Status:    *subnetInfo.State,
        }

        keyValueList := []irs.KeyValue{
                {Key: "VpcId", Value: *subnetInfo.VpcId},
                {Key: "MapPublicIpOnLaunch", Value: strconv.FormatBool(*subnetInfo.MapPublicIpOnLaunch)},
                {Key: "AvailableIpAddressCount", Value: strconv.FormatInt(*subnetInfo.AvailableIpAddressCount, 10)},
                {Key: "AvailabilityZone", Value: *subnetInfo.AvailabilityZone},
                {Key: "Status", Value: *subnetInfo.State},
        }
        vNetworkInfo.KeyValueList = keyValueList

        return vNetworkInfo
}

func (VPCHandler *TencentVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) {
        cblogger.Infof("[%s] Subnet 추가 - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        if errSubnet != nil {
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }
        cblogger.Info(resSubnet)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil {
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, errVpcInfo
        }

        findSubnet := false
        cblogger.Debug("============== 체크할 값 =========")
        for posSubnet, curSubnetInfo := range vpcInfo.SubnetInfoList {
                cblogger.Debugf("%d - [%s] Subnet 처리 시작", posSubnet, curSubnetInfo.IId.SystemId)
                if resSubnet.IId.SystemId == curSubnetInfo.IId.SystemId {
                        cblogger.Infof("추가 요청 받은 [%s] Subnet을 발견 했습니다. - SystemID:[%s]", subnetInfo.IId.NameId, curSubnetInfo.IId.SystemId)
                        //for ~ range는 포인터가 아니라서 값 수정이 안됨. for loop으로 직접 서브넷을 체크하거나 vpcInfo의 배열의 값을 수정해야 함.
                        cblogger.Infof("인덱스 위치 : %d", posSubnet)
                        //vpcInfo.SubnetInfoList[posSubnet].IId.NameId = "테스트~"
                        vpcInfo.SubnetInfoList[posSubnet].IId.NameId = subnetInfo.IId.NameId
                        findSubnet = true
                        break
                }
        }

        if !findSubnet {
                cblogger.Errorf("서브넷 생성은 성공했으나 VPC의 서브넷 목록에서 추가 요청한 [%s]서브넷의 정보[%s]를 찾지 못했습니다.", subnetInfo.IId.NameId, resSubnet.IId.SystemId)
                return irs.VPCInfo{}, errors.New("MismatchSubnet.NotFound: No SysmteId[" + resSubnet.IId.SystemId + "] found for newly created Subnet[" + subnetInfo.IId.NameId + "].")
        }
        //spew.Dump(vpcInfo)

        return vpcInfo, nil
}

func (VPCHandler *TencentVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) {
        cblogger.Infof("[%s] VPC의 [%s] Subnet 삭제", vpcIID.SystemId, subnetIID.SystemId)

        return VPCHandler.DeleteSubnet(subnetIID)
        //return false, nil
}
*/
</pre>
		
		<pre class="file" id="file124" style="display: none">// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.03.

package iidmanager

import (
        "fmt"
        "sync"
        "strings"

        "github.com/sirupsen/logrus"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/cloud-barista/cb-store/config"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type IIDRWLOCK struct {
        rwMutex        sync.RWMutex // for global readwrite Locking
}
//====================================================================


//====================================================================
type IIDInfo struct {
        ConnectionName  string  // ex) "aws-seoul-config"
        ResourceType    string  // ex) "VM"
        IId             resources.IID  // ex) {NameId, SystemId} = {"powerkim_vm_01", "i-0bc7123b7e5cbf79d"}
}
//====================================================================

func (iidRWLock *IIDRWLOCK)IsExistIID(connectionName string, resourceType string, iId resources.IID) (bool, error) <span class="cov8" title="1">{
        cblog.Debug("check the IID.NameId:" + iId.NameId + " existence")

iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        return isExist(connectionName, resourceType, iId.NameId)
}</span>

func (iidRWLock *IIDRWLOCK)CreateIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Debug("check the IID.NameId:" + iId.NameId + " existence")

iidRWLock.rwMutex.Lock()
defer iidRWLock.rwMutex.Unlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        ret, err := isExist(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if ret == true </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(iId.NameId + " already exists!")
        }</span>

        <span class="cov8" title="1">iidInfo, err2 := forceCreateIID(connectionName, resourceType, iId)

        // escape: "%2F" =&gt; "/"
        iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err2</span>
}

func (iidRWLock *IIDRWLOCK)UpdateIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov0" title="0">{
        cblog.Debug("check the IID.NameId:" + iId.NameId + " existence")

iidRWLock.rwMutex.Lock()
defer iidRWLock.rwMutex.Unlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        ret, err := isExist(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if ret == false </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(iId.NameId + " does not exists!")
        }</span>

        <span class="cov0" title="0">iidInfo, err2 := forceCreateIID(connectionName, resourceType, iId)

        // escape: "%2F" =&gt; "/"
        iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err2</span>
}

// 1. check params
// 2. check pre-existing id
// 3. insert new IIDInfo into cb-store
func forceCreateIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateIID()")

        cblog.Debug("check params")
        err := checkParams(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        
        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")
        err = insertInfo(connectionName, resourceType, iId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">iidInfo := &amp;IIDInfo{connectionName, resourceType, iId}
        return iidInfo, nil</span>
}

func (iidRWLock *IIDRWLOCK)ListIID(connectionName string, resourceType string) ([]*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListIID()")

iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()
        iIDInfoList, err := listInfo(connectionName, resourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // escape: "%2F" =&gt; "/"
        <span class="cov8" title="1">for i, iidInfo := range iIDInfoList </span><span class="cov8" title="1">{
                iIDInfoList[i].IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")
        }</span>

        <span class="cov8" title="1">return iIDInfoList, nil</span>
}

// 1. check params
// 2. get IIDInfo from cb-store
func (iidRWLock *IIDRWLOCK)GetIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetIID()")

        cblog.Debug("check params")
        err := checkParams(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        iidInfo, err := getInfo(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // escape: "%2F" =&gt; "/"
        <span class="cov8" title="1">iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err</span>
}

// 1. check params
// 2. find IIDInfo from cb-store
func (iidRWLock *IIDRWLOCK)FindIID(connectionName string, resourceType string, keyword string) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call FindIID()")

        cblog.Debug("check params")
        err := checkParamsKeyword(connectionName, resourceType, &amp;keyword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        keyword = strings.ReplaceAll(keyword, "/", "%2F")

        iIDInfoList, err := listInfo(connectionName, resourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, iidInfo := range iIDInfoList </span><span class="cov8" title="1">{
                if strings.Contains(iidInfo.IId.NameId, keyword) </span><span class="cov8" title="1">{
                        // escape: "%2F" =&gt; "/"
                        iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")
                        return iidInfo, nil
                }</span>
        }
        <span class="cov0" title="0">return &amp;IIDInfo{}, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + keyword + "] does not exist!")</span>
}

// 1. check params
// 2. get IIDInfo from cb-store
func (iidRWLock *IIDRWLOCK)GetIIDbySystemID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetIIDbySystemID()")

        cblog.Debug("check params")
        err := checkParamsSystemId(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        iidInfo, err := getInfoByValue(connectionName, resourceType, iId.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // escape: "%2F" =&gt; "/"
        <span class="cov8" title="1">iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err</span>
}


func (iidRWLock *IIDRWLOCK)DeleteIID(connectionName string, resourceType string, iId resources.IID) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteIID()")


        cblog.Debug("check params")
        err := checkParams(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err

        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.Lock()
defer iidRWLock.rwMutex.Unlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        result, err := deleteInfo(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(connectionName string, resourceType string, iId *resources.IID) error <span class="cov8" title="1">{
        if connectionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if resourceType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ResourceType is empty!")
        }</span>
        <span class="cov8" title="1">if iId == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("IID is empty!")
        }</span>
        <span class="cov8" title="1">if iId.NameId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IID.NameId is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func checkParamsSystemId(connectionName string, resourceType string, iId *resources.IID) error <span class="cov8" title="1">{
        if connectionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if resourceType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ResourceType is empty!")
        }</span>
        <span class="cov8" title="1">if iId == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("IID is empty!")
        }</span>
        <span class="cov8" title="1">if iId.SystemId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IID.SystemId is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func checkParamsKeyword(connectionName string, resourceType string, keyword *string) error <span class="cov8" title="1">{
        if connectionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if resourceType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ResourceType is empty!")
        }</span>
        <span class="cov8" title="1">if keyword == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Keyword is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

</pre>
		
		<pre class="file" id="file125" style="display: none">// CloudDriverInfo &lt;-&gt; CB-Store Handler for Cloud Driver Info. Manager.
// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.03.

package iidmanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type IIDInfo struct {
        ConnectionName        string        // ex) "aws-seoul-config"
        ResourceType        string        // ex) "VM"
        IId                resources.IID        // ex) {NameId, SystemId} = {"powerkim_vm_01", "i-0bc7123b7e5cbf79d"}
}
*/ //====================================================================


// format
// /resource-info-spaces/iids/{ConnectionName}/{ResourceType}/&lt;IID.NameId&gt; [IID.SystemId]
        // Key: "/resource-info-spaces/iids/{ConnectionName}/{ResourceType}/&lt;IID.NameId&gt;"
        // Value: "[IID.SystemId]"
// ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

func insertInfo(connectionName string, resourceType string, iid resources.IID) error <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + iid.NameId
        value := iid.SystemId

        err := store.Put(key, value)
        if err != nil </span><span class="cov0" title="0">{
                //cblog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create IIDInfo List &amp; return
func listInfo(connectionName string, resourceType string) ([]*IIDInfo, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">iidInfoList := make([]*IIDInfo, len(keyValueList))
        for count, kv := range keyValueList </span><span class="cov8" title="1">{
                iidInfo := &amp;IIDInfo{connectionName, resourceType, resources.IID{utils.GetNodeValue(kv.Key, 5), kv.Value} }
                iidInfoList[count] = iidInfo
        }</span>

        <span class="cov8" title="1">return iidInfoList, nil</span>
}

// 1. get a key-value
// 2. create IIDInfo &amp; return
func getInfo(connectionName string, resourceType string, nameId string) (*IIDInfo, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + nameId

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

//        if len(keyValueList) &lt; 1 {
//                return nil, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + nameId + "] does not exist!")
//        }

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/..., 
                // so we have to check the sameness of nameId.
                if utils.GetNodeValue(kv.Key, 5) == nameId </span><span class="cov8" title="1">{
                        iidInfo := &amp;IIDInfo{connectionName, resourceType, resources.IID{nameId, kv.Value} }
                        return iidInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + nameId + "] does not exist!")</span>
}

// 1. get list
// 2. find keyvalue by value
// 2. create IIDInfo &amp; return
func getInfoByValue(connectionName string, resourceType string, systemId string) (*IIDInfo, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/??? [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/...,
                // so we have to check the sameness of nameId.
                if kv.Value == systemId </span><span class="cov8" title="1">{
                        iidInfo := &amp;IIDInfo{connectionName, resourceType, resources.IID{utils.GetNodeValue(kv.Key, 5), systemId} }
                        return iidInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return &amp;IIDInfo{}, nil</span>
}

// 1. get a key-value
// 2. return existence of  or not
func isExist(connectionName string, resourceType string, nameId string) (bool, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]


        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + nameId


        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/...,
                // so we have to check the sameness of nameId.
                if utils.GetNodeValue(kv.Key, 5) == nameId </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(connectionName string, resourceType string, nameId string) (bool, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]


        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + nameId

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/..., 
                // so we have to check the sameness of nameId.
                if utils.GetNodeValue(kv.Key, 5) == nameId </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
        }

        <span class="cov0" title="0">return false, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + nameId + "] does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file126" style="display: none">// Package for VM's SSH and SCP of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.

package sshrun

import (
        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"


        "io"
        "github.com/bramvdbogaerde/go-scp"
        "github.com/bramvdbogaerde/go-scp/auth"
        "golang.org/x/crypto/ssh"
        "os"
        "strings"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type SSHInfo struct {
        UserName        string  // ex) "root"
        PrivateKey      []byte  // ex)   []byte(`-----BEGIN RSA PRIVATE KEY-----
                                //              MIIEoQIBAAKCAQEArVNOLwMIp5VmZ4VPZotcoCHdEzimKalAsz+ccLfvAA1Y2ELH
                                //              ...`)
        ServerPort      string  // ex) "node12:22"
}
//====================================================================

func Connect(sshInfo SSHInfo) (scp.Client, error) <span class="cov0" title="0">{
        cblog.Info("call Connect()")

        clientConfig, _ := getClientConfig(sshInfo.UserName, sshInfo.PrivateKey, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

//====================================================================
type SSHKeyPathInfo struct {
        UserName        string  // ex) "root"
        KeyPath             string         // ex) "/root/.ssh/id_rsa // You should use the full path.
        ServerPort      string  // ex) "node12:22"
}
//====================================================================

func ConnectKeyPath(sshKeyPathInfo SSHKeyPathInfo) (scp.Client, error) <span class="cov0" title="0">{
        cblog.Info("call ConnectKeyPath()")

        clientConfig, _ := auth.PrivateKey(sshKeyPathInfo.UserName, sshKeyPathInfo.KeyPath, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshKeyPathInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

func getClientConfig(username string, privateKey []byte, keyCallBack ssh.HostKeyCallback) (ssh.ClientConfig, error) <span class="cov0" title="0">{

        signer, err := ssh.ParsePrivateKey(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return ssh.ClientConfig{}, err
        }</span>

        <span class="cov0" title="0">clientConfig := ssh.ClientConfig{
                User: username,
                Auth: []ssh.AuthMethod{
                        ssh.PublicKeys(signer),
                },
                HostKeyCallback: keyCallBack,
        }
        return clientConfig, nil</span>
}

func Close(client scp.Client)<span class="cov0" title="0">{
        cblog.Info("call Close()")

        client.Close()        
}</span>

func RunCommand(client scp.Client, cmd string) (string, error) <span class="cov0" title="0">{
        cblog.Info("call RunCommand()")

        session := client.Session
        sshOut, err := session.StdoutPipe()
        session.Stderr = os.Stderr

        err = session.Run(cmd)
        //err = session.Start(cmd)

        return stdoutToString(sshOut), err
}</span>

func stdoutToString(sshOut io.Reader) string <span class="cov0" title="0">{
        buf := make([]byte, 1000)
        num, err := sshOut.Read(buf)
        outStr := ""
        if err == nil </span><span class="cov0" title="0">{
                outStr = string(buf[:num])
        }</span>
        <span class="cov0" title="0">for err == nil </span><span class="cov0" title="0">{
                num, err = sshOut.Read(buf)
                outStr += string(buf[:num])
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span><span class="cov0" title="0">{
                                cblog.Error(err)
                        }</span>
                }

        }
        <span class="cov0" title="0">return strings.Trim(outStr, "\n")</span>
}

func Copy(client scp.Client, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        cblog.Info("call Copy()")

        // Open a file
        file, _ := os.Open(sourcePath)
        defer file.Close()
        return client.CopyFile(file, remotePath, "0755")
}</span>

//=============== for One Call Service
func SSHRun(sshInfo SSHInfo, cmd string) (string, error) <span class="cov0" title="0">{
        cblog.Info("call SSHRun()")


        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHRunByKeyPath(sshInfo SSHKeyPathInfo, cmd string) (string, error) <span class="cov0" title="0">{
        cblog.Info("call SSHRunKeyPath()")


        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHCopy(sshInfo SSHInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        cblog.Info("call SSHCopy()")


        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

func SSHCopyByKeyPath(sshInfo SSHKeyPathInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        cblog.Info("call SSHCopyByKeyPath()")


        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

</pre>
		
		<pre class="file" id="file127" style="display: none">package cloudos

import (
        "github.com/sirupsen/logrus"
        "github.com/cloud-barista/cb-store/config"

        "gopkg.in/yaml.v3"
        "io/ioutil"
        "os"
        _ "fmt"
        "strings"
        "sort"
)


var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>



type CloudOSList struct {
        Name []string `yaml:"cloudos"`
}

func readYaml() CloudOSList <span class="cov8" title="1">{
        // Set Environment Value of Project Root Path
        rootPath := os.Getenv("CBSPIDER_ROOT")
        if rootPath == "" </span><span class="cov0" title="0">{
                cblog.Error("$CBSPIDER_ROOT is not set!!")
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">data, err := ioutil.ReadFile(rootPath + "/conf/cloudos.yaml")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                panic(err)</span>
        }

        <span class="cov8" title="1">var coList CloudOSList
        err = yaml.Unmarshal(data, &amp;coList)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                panic(err)</span>
        }

        <span class="cov8" title="1">return coList</span>
}

func ListCloudOS() []string <span class="cov8" title="1">{

        // read YAML file
        cloudosList := readYaml()

        // to Upper
        for n, cloudos := range cloudosList.Name</span><span class="cov8" title="1">{
                cloudosList.Name[n] = strings.ToUpper(cloudos)
        }</span>

        <span class="cov8" title="1">sort.Strings(cloudosList.Name)
        cblog.Info(cloudosList)

/*        for _, cloudos := range cloudosList.Name{
                fmt.Printf("\n%s", cloudos)
        }
*/

        return cloudosList.Name</span>
}

</pre>
		
		<pre class="file" id="file128" style="display: none">// Cloud ConnectionConfig Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package connectionconfiginfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type ConnectionConfigInfo struct {
        ConfigName     string // ex) "config01"
        ProviderName   string // ex) "AWS"
        DriverName     string // ex) "AWS-Test-Driver-V0.5"
        CredentialName string // ex) "credential01"
        RegionName     string // ex) "region01"
}

//====================================================================

func CreateConnectionConfigInfo(configInfo ConnectionConfigInfo) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        return CreateConnectionConfig(configInfo.ConfigName, configInfo.ProviderName, configInfo.DriverName, configInfo.CredentialName, configInfo.RegionName)
}</span>

// 1. check params
// 2. check driver files
// 3. insert them into cb-store
// You should copy the driver library into ~/libs before.
func CreateConnectionConfig(configName string, providerName string, driverName string, credentialName string, regionName string) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateConnectionConfig()")

        cblog.Debug("check params")
        err := checkParams(configName, providerName, driverName, credentialName, regionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        // check the existence of the key to be inserted
        <span class="cov8" title="1">tmpcncInfo, err := getInfo(configName)
        if tmpcncInfo != nil </span><span class="cov8" title="1">{
                if tmpcncInfo.ConfigName == configName </span><span class="cov8" title="1">{
                        cblog.Debug("delete the existed key to update it")
                        _, err := deleteInfo(configName)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                return nil, err
                        }</span>                        
                }
        }


        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = insertInfo(configName, providerName, driverName, credentialName, regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">cncInfo := &amp;ConnectionConfigInfo{configName, providerName, driverName, credentialName, regionName}
        return cncInfo, nil</span>
}

func ListConnectionConfig() ([]*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListConnectionConfig()")

        configInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return configInfoList, nil</span>
}

// 1. check params
// 2. get DriverInfo from cb-store
func GetConnectionConfig(configName string) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetConnectionConfig()")

        if configName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ConnectionName is empty!")
        }</span>

        <span class="cov8" title="1">cncInfo, err := getInfo(configName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return cncInfo, err</span>
}

func DeleteConnectionConfig(configName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteConnectionConfig()")

        if configName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ConnectionName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(configName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(configName string, providerName string, driverName string, credentialName string, regionName string) error <span class="cov8" title="1">{
        if configName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">if driverName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DriverName is empty!")
        }</span>
        <span class="cov8" title="1">if credentialName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("CredentialName is empty!")
        }</span>
        <span class="cov8" title="1">if regionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("RegionName is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">// ConnectionConfigInfo &lt;-&gt; CB-Store Handler for Cloud ConnectionConfig Info. Manager.
// Cloud ConnectionConfig Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package connectionconfiginfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type ConnectionConfigInfo struct {
        ConfigName      string  // ex) "config01"
        ProviderName    string  // ex) "AWS"
        DriverName      string  // ex) "AWS-Test-Driver-V0.5"
        CredentialName  string  // ex) "credential01"
        RegionName      string  // ex) "region01"
}
*/ //====================================================================


// format
// /cloud-info-spaces/connection-configs/&lt;ID&gt;/{Param1}/{Param2}/{Param3}/{Param4} []
// /cloud-info-spaces/connection-configs/&lt;ConfigName&gt;/{ProviderName}/{DriverName}/{CredentialName}/{RegionName} []
// ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

func insertInfo(configName string, providerName string, driverName string, credentialName string, regionName string) error <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

        key := "/cloud-info-spaces/connection-configs/" + configName + "/" + providerName + "/" +
                driverName + "/" + credentialName + "/" + regionName

        var value string

        err := store.Put(key, value)
        if err != nil </span><span class="cov0" title="0">{
                //cblog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create ConnectionConfigInfo List &amp; return
func listInfo() ([]*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

        key := "/cloud-info-spaces/connection-configs"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">configInfoList := make([]*ConnectionConfigInfo, len(keyValueList))
        for count, kv := range keyValueList </span><span class="cov8" title="1">{
                cncInfo := &amp;ConnectionConfigInfo{utils.GetNodeValue(kv.Key, 3), utils.GetNodeValue(kv.Key, 4),
                                                utils.GetNodeValue(kv.Key, 5), utils.GetNodeValue(kv.Key, 6), 
                                                utils.GetNodeValue(kv.Key, 7),
                                                }
                configInfoList[count] = cncInfo
        }</span>

        <span class="cov8" title="1">return configInfoList, nil</span>
}

// 1. get a key-value
// 2. create ConnectionConfigInfo &amp; return
func getInfo(configName string) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01
        
        key := "/cloud-info-spaces/connection-configs/" + configName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(configName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/...,
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == configName </span><span class="cov8" title="1">{
                        cncInfo := &amp;ConnectionConfigInfo{utils.GetNodeValue(kv.Key, 3), utils.GetNodeValue(kv.Key, 4),
                                utils.GetNodeValue(kv.Key, 5), utils.GetNodeValue(kv.Key, 6),
                                utils.GetNodeValue(kv.Key, 7),
                                }
                        return cncInfo, nil
                }</span> // end of if
        } // end of for

        <span class="cov0" title="0">return nil, fmt.Errorf(configName + ": does not exist!")</span>
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(configName string) (bool, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

        key := "/cloud-info-spaces/connection-configs/" + configName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList(
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/...,
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == configName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">return false, fmt.Errorf(configName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file130" style="display: none">// Cloud Credential Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package credentialinfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        icbs "github.com/cloud-barista/cb-store/interfaces"
        "github.com/sirupsen/logrus"

        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "io"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type CredentialInfo struct {
        CredentialName   string          // ex) "credential01"
        ProviderName     string          // ex) "AWS"
        KeyValueInfoList []icbs.KeyValue // ex) { {ClientId, XXX},
        //         {ClientSecret, XXX},
        //         {TenantId, XXX},
        //         {SubscriptionId, XXX} }
}

//====================================================================

func RegisterCredentialInfo(crdInfo CredentialInfo) (*CredentialInfo, error) <span class="cov8" title="1">{
        return RegisterCredential(crdInfo.CredentialName, crdInfo.ProviderName, crdInfo.KeyValueInfoList)
}</span>

// 1. check params
// 2. insert them into cb-store
func RegisterCredential(credentialName string, providerName string, keyValueInfoList []icbs.KeyValue) (*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call RegisterCredential()")

        cblog.Debug("check params")
        err := checkParams(credentialName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = encryptKeyValueList(keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CredentialInfo{}, err
        }</span>

        <span class="cov8" title="1">err = insertInfo(credentialName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">crdInfo := &amp;CredentialInfo{credentialName, providerName, keyValueInfoList}
        return crdInfo, nil</span>
}

func ListCredential() ([]*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListCredential()")

        credentialInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return credentialInfoList, nil</span>
}

// 1. check params
// 2. get CredentialInfo from cb-store
func GetCredential(credentialName string) (*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetCredential()")

        if credentialName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CredentialName is empty!")
        }</span>

        <span class="cov8" title="1">crdInfo, err := getInfo(credentialName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return crdInfo, err</span>
}

// 1. check params
// 2. get CredentialInfo from cb-store
// 3. decrypt CrednetialInfo
func GetCredentialDecrypt(credentialName string) (*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetCredential()")

        if credentialName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CredentialName is empty!")
        }</span>

        <span class="cov8" title="1">crdInfo, err := getInfo(credentialName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = decryptKeyValueList(crdInfo.KeyValueInfoList)        
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CredentialInfo{}, err
        }</span>
        <span class="cov8" title="1">return crdInfo, nil</span>
}

// @todo env by powerkim, 2020.06.01.
var key = []byte("cloud-barista-cb-spider-cloud-ba") // 32 bytes

func encryptKeyValueList(keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{

        for i, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                encb, err := encrypt(key, []byte(kv.Value))
                kv.Value = string(encb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">keyValueInfoList[i] = kv</span>
        }
        <span class="cov8" title="1">return  nil</span>
}

func decryptKeyValueList(keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{

        for i, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                decb, err := decrypt(key, []byte(kv.Value))
                kv.Value = string(decb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">keyValueInfoList[i] = kv</span>
        }
        <span class="cov8" title="1">return nil</span>        
}

func encrypt(key, text []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b := base64.StdEncoding.EncodeToString(text)
        ciphertext := make([]byte, aes.BlockSize+len(b))
        iv := ciphertext[:aes.BlockSize]
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfb := cipher.NewCFBEncrypter(block, iv)
        cfb.XORKeyStream(ciphertext[aes.BlockSize:], []byte(b))
        return ciphertext, nil</span>
}

func decrypt(key, text []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(text) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                err := fmt.Errorf("decryption: " + "ciphertext too short")
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">iv := text[:aes.BlockSize]
        text = text[aes.BlockSize:]
        cfb := cipher.NewCFBDecrypter(block, iv)
        cfb.XORKeyStream(text, text)
        data, err := base64.StdEncoding.DecodeString(string(text))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func UnRegisterCredential(credentialName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call UnRegisterCredential()")

        if credentialName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("CredentialName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(credentialName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(credentialName string, providerName string, keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{
        if credentialName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("CredentialName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                if kv.Key == "" </span><span class="cov0" title="0">{ // Value can be empty.
                        return fmt.Errorf("Key is empty!")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// CredentialInfo &lt;-&gt; CB-Store Handler for Cloud Credential Info. Manager.
// Cloud Credential Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package credentialinfomanager

import (
        "fmt"
        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type CredentialInfo struct {
        CredentialName  string  // ex) "credential01"
        ProviderName    string  // ex) "AWS"
        KeyValueInfoList        []icbs.KeyValue      // ex) { {ClientId, XXX},
                                                         {ClientSecret, XXX},
                                                         {TenantId, XXX},
                                                         {SubscriptionId, XXX} }
}
*/ //====================================================================


// format
// /cloud-info-spaces/credentials/&lt;CredentialName&gt;/{ProviderName}/{key1} [value1]
// /cloud-info-spaces/credentials/&lt;CredentialName&gt;/{ProviderName}/{key2} [value2]
// ex)
// /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
// /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
// /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
// /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]



func insertInfo(credentialName string, providerName string, keyValueList []icbs.KeyValue) error <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]

        format := "/cloud-info-spaces/credentials/" + credentialName + "/" + providerName
// @todo lock
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                key := format + "/" + kv.Key
                value := kv.Value

                err := store.Put(key, value)
                if err != nil </span><span class="cov0" title="0">{
                        //cblog.Error(err)
                        return err
                }</span>
        }
// @todo lock
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create CredentialInfo List &amp; return
func listInfo() ([]*CredentialInfo, error) <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]

        key := "/cloud-info-spaces/credentials"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var credentialInfoList []*CredentialInfo
        var inKeyValueList []icbs.KeyValue
        prevCredName := ""
        prevProviderName := ""
        for _, kv := range keyValueList </span><span class="cov8" title="1">{

                credName := utils.GetNodeValue(kv.Key, 3)
                providerName := utils.GetNodeValue(kv.Key, 4)

                if prevCredName=="" || credName == prevCredName </span><span class="cov8" title="1">{
                        prevCredName = credName
                        prevProviderName = providerName
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span> else<span class="cov0" title="0"> {
                        // insert prev CredentialInfo
                        crdInfo := &amp;CredentialInfo{prevCredName, prevProviderName, inKeyValueList}
                        credentialInfoList = append(credentialInfoList, crdInfo)

                        prevCredName = credName
                        prevProviderName = providerName
                        inKeyValueList = nil
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span>

        }

        <span class="cov8" title="1">if len(keyValueList) &gt; 0 </span><span class="cov8" title="1">{
                // insert last CredentialInfo
                crdInfo := &amp;CredentialInfo{prevCredName, prevProviderName, inKeyValueList}
                credentialInfoList = append(credentialInfoList, crdInfo)
        }</span>

        <span class="cov8" title="1">return credentialInfoList, nil</span>
}

// 1. get a key-value
// 2. create CredentialInfo &amp; return
func getInfo(credentialName string) (*CredentialInfo, error) <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]
        
        key := "/cloud-info-spaces/credentials/" + credentialName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(credentialName + ": does not exist!")
        }</span>

        // keyValueList should have ~/driverName/... or ~/driverName-01/...,
        // so we have to check the sameness of driverName.
        // and make a KeyValueList for only Target key
        <span class="cov8" title="1">var oneKeyValueList []icbs.KeyValue
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                if utils.GetNodeValue(kv.Key, 3) == credentialName </span><span class="cov8" title="1">{
                        oneKeyValueList = append(oneKeyValueList, *kv)
                }</span>
        }

        <span class="cov8" title="1">if len(oneKeyValueList) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(credentialName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">var inKeyValueList []icbs.KeyValue
        // get ProviderName
        providerName := utils.GetNodeValue(oneKeyValueList[0].Key, 4)
        // get KeyValueList
        for _, kv := range oneKeyValueList </span><span class="cov8" title="1">{
                keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                inKeyValueList = append(inKeyValueList, keyValue)
        }</span>
        <span class="cov8" title="1">return &amp;CredentialInfo{credentialName, providerName, inKeyValueList}, nil</span> 
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(credentialName string) (bool, error) <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]

        key := "/cloud-info-spaces/credentials/" + credentialName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var isDelete bool
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == credentialName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">isDelete = true</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">if isDelete </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, fmt.Errorf(credentialName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file132" style="display: none">// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package driverinfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type CloudDriverInfo struct {
        DriverName        string // ex) "AWS-Test-Driver-V0.5"
        ProviderName      string // ex) "AWS"
        DriverLibFileName string // ex) "aws-test-driver-v0.5.so"  //Already, you need to insert "*.so" in $CB_SPIDER_ROOT/cloud-driver/libs.
}

//====================================================================

func RegisterCloudDriverInfo(cldInfo CloudDriverInfo) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        return RegisterCloudDriver(cldInfo.DriverName, cldInfo.ProviderName, cldInfo.DriverLibFileName)
}</span>

// 1. check params
// 2. check driver files
// 3. insert them into cb-store
// You should copy the driver library into ~/libs before.
func RegisterCloudDriver(driverName string, providerName string, driverLibFileName string) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        cblog.Info("call RegisterCloudDriver()")

        cblog.Debug("check params")
        err := checkParams(driverName, providerName, driverLibFileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        <span class="cov8" title="1">cblog.Debug("check the driver library file")
        err = checkDriverLibFile(driverLibFileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = insertInfo(driverName, providerName, driverLibFileName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">drvInfo := &amp;CloudDriverInfo{driverName, providerName, driverLibFileName}
        return drvInfo, nil</span>
}

func ListCloudDriver() ([]*CloudDriverInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListCloudDriver()")

        cloudDriverInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cloudDriverInfoList, nil</span>
}

// 1. check params
// 2. get DriverInfo from cb-store
func GetCloudDriver(driverName string) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetCloudDriver()")

        if driverName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DriverName is empty!")
        }</span>

        <span class="cov8" title="1">drvInfo, err := getInfo(driverName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return drvInfo, err</span>
}

func UnRegisterCloudDriver(driverName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call UnRegisterCloudDriver()")

        if driverName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("DriverName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(driverName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(driverName string, providerName string, driverLibFileName string) error <span class="cov8" title="1">{
        if driverName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DriverName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">if driverLibFileName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DriverLibFileName is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. check to exist file
// 2. check to be a shared library file
func checkDriverLibFile(driverLibFileName string) error <span class="cov8" title="1">{
        // @todo
        return nil
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">// CloudDriverInfo &lt;-&gt; CB-Store Handler for Cloud Driver Info. Manager.
// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package driverinfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type CloudDriverInfo struct {
        DriverName        string        // ex) "AWS-Test-Driver-V0.5"
        ProviderName        string        // ex) "AWS"
        DriverLibFileName        string        // ex) "aws-test-driver-v0.5.so"  //Already, you need to insert "*.so" in $CB_SPIDER_ROOT/cloud-driver/libs.
}
*/ //====================================================================


// format
// /cloud-info-spaces/drivers/&lt;ID&gt;/{Param1} [Value]
// /cloud-info-spaces/drivers/&lt;DriverName&gt;/{ProviderName} [DriverLibFileName]
// ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

func insertInfo(driverName string, providerName string, driverLibFileName string) error <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

        key := "/cloud-info-spaces/drivers/" + driverName + "/" + providerName
        value := driverLibFileName

        err := store.Put(key, value)
        if err != nil </span><span class="cov0" title="0">{
                //cblog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create CloudDriverInfo List &amp; return
func listInfo() ([]*CloudDriverInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

        key := "/cloud-info-spaces/drivers"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cloudDriverInfoList := make([]*CloudDriverInfo, len(keyValueList))
        for count, kv := range keyValueList </span><span class="cov8" title="1">{
                drvInfo := &amp;CloudDriverInfo{utils.GetNodeValue(kv.Key, 3), utils.GetNodeValue(kv.Key, 4), kv.Value}
                cloudDriverInfoList[count] = drvInfo
        }</span>

        <span class="cov8" title="1">return cloudDriverInfoList, nil</span>
}

// 1. get a key-value
// 2. create CloudDriverInfo &amp; return
func getInfo(driverName string) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

        
        key := "/cloud-info-spaces/drivers/" + driverName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(driverName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == driverName </span><span class="cov8" title="1">{
                        providerName := utils.GetNodeValue(kv.Key, 4)
                        driverLibFileName := kv.Value
                        drvInfo := &amp;CloudDriverInfo{driverName, providerName, driverLibFileName}
                        return drvInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf(driverName + ": does not exist!")</span>
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(driverName string) (bool, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]


        key := "/cloud-info-spaces/drivers/" + driverName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == driverName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">return false, fmt.Errorf(driverName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file134" style="display: none">// RegionInfo &lt;-&gt; CB-Store Handler for Cloud Region Info. Manager.
// Cloud Region Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package regioninfomanager

import (
        "fmt"
        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type RegionInfo struct {
        RegionName      string  // ex) "region01"
        ProviderName    string  // ex) "GCP"
        KeyValueInfoList        []icbs.KeyValue // ex) { {region, us-east1},
                                                //       {zone, us-east1-c},
}
*/ //====================================================================


// format
// /cloud-info-spaces/regions/&lt;RegionName&gt;/{ProviderName}/{key1} [value1]
// /cloud-info-spaces/regions/&lt;RegionName&gt;/{ProviderName}/{key2} [value2]
// ex-1)
// /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
// ex-2)
// /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
// /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]



func insertInfo(regionName string, providerName string, keyValueList []icbs.KeyValue) error <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]

        format := "/cloud-info-spaces/regions/" + regionName + "/" + providerName
// @todo lock
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                key := format + "/" + kv.Key
                value := kv.Value

                err := store.Put(key, value)
                if err != nil </span><span class="cov0" title="0">{
                        //cblog.Error(err)
                        return err
                }</span>
        }
// @todo lock
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create RegionInfo List &amp; return
func listInfo() ([]*RegionInfo, error) <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]


        key := "/cloud-info-spaces/regions"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var regionInfoList []*RegionInfo
        var inKeyValueList []icbs.KeyValue
        prevRegionName := ""
        prevProviderName := ""
        for _, kv := range keyValueList </span><span class="cov8" title="1">{

                regionName := utils.GetNodeValue(kv.Key, 3)
                providerName := utils.GetNodeValue(kv.Key, 4)

                if prevRegionName=="" || regionName == prevRegionName </span><span class="cov8" title="1">{
                        prevRegionName = regionName
                        prevProviderName = providerName
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span> else<span class="cov0" title="0"> {
                        // insert prev RegionInfo
                        rgnInfo := &amp;RegionInfo{prevRegionName, prevProviderName, inKeyValueList}
                        regionInfoList = append(regionInfoList, rgnInfo)

                        prevRegionName = regionName
                        prevProviderName = providerName
                        inKeyValueList = nil
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span>

        }

        <span class="cov8" title="1">if len(keyValueList) &gt; 0 </span><span class="cov8" title="1">{
                // insert last RegionInfo
                rgnInfo := &amp;RegionInfo{prevRegionName, prevProviderName, inKeyValueList}
                regionInfoList = append(regionInfoList, rgnInfo)
        }</span>

        <span class="cov8" title="1">return regionInfoList, nil</span>
}

// 1. get a key-value
// 2. create RegionInfo &amp; return
func getInfo(regionName string) (*RegionInfo, error) <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]

        
        key := "/cloud-info-spaces/regions/" + regionName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(regionName + ": does not exist!")
        }</span>

        // keyValueList should have ~/driverName/... or ~/driverName-01/...,
        // so we have to check the sameness of driverName.
        // and make a KeyValueList for only Target key
        <span class="cov8" title="1">var oneKeyValueList []icbs.KeyValue
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                if utils.GetNodeValue(kv.Key, 3) == regionName </span><span class="cov8" title="1">{
                        oneKeyValueList = append(oneKeyValueList, *kv)
                }</span>
        }

        <span class="cov8" title="1">if len(oneKeyValueList) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(regionName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">var inKeyValueList []icbs.KeyValue
        // get ProviderName
        providerName := utils.GetNodeValue(oneKeyValueList[0].Key, 4)
        // get KeyValueList
        for _, kv := range oneKeyValueList </span><span class="cov8" title="1">{
                keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                inKeyValueList = append(inKeyValueList, keyValue)
        }</span>
        <span class="cov8" title="1">return &amp;RegionInfo{regionName, providerName, inKeyValueList}, nil</span> 
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(regionName string) (bool, error) <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]


        key := "/cloud-info-spaces/regions/" + regionName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var isDelete bool
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == regionName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">isDelete = true</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">if isDelete </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, fmt.Errorf(regionName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file135" style="display: none">// Cloud regioninfomanager Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package regioninfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        icbs "github.com/cloud-barista/cb-store/interfaces"
        "github.com/sirupsen/logrus"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type RegionInfo struct {
        RegionName       string          // ex) "region01"
        ProviderName     string          // ex) "GCP"
        KeyValueInfoList []icbs.KeyValue // ex) { {region, us-east1},
        //         {zone, us-east1-c},
}

//====================================================================

func RegisterRegionInfo(rgnInfo RegionInfo) (*RegionInfo, error) <span class="cov8" title="1">{
        return RegisterRegion(rgnInfo.RegionName, rgnInfo.ProviderName, rgnInfo.KeyValueInfoList)
}</span>

// 1. check params
// 2. insert them into cb-store
func RegisterRegion(regionName string, providerName string, keyValueInfoList []icbs.KeyValue) (*RegionInfo, error) <span class="cov8" title="1">{
        cblog.Info("call RegisterRegion()")

        cblog.Debug("check params")
        err := checkParams(regionName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = insertInfo(regionName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">rgnInfo := &amp;RegionInfo{regionName, providerName, keyValueInfoList}
        return rgnInfo, nil</span>
}

func ListRegion() ([]*RegionInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListRegion()")

        regionInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return regionInfoList, nil</span>
}

// 1. check params
// 2. get CredentialInfo from cb-store
func GetRegion(regionName string) (*RegionInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetRegion()")

        if regionName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RegionName is empty!")
        }</span>

        <span class="cov8" title="1">rgnInfo, err := getInfo(regionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return rgnInfo, err</span>
}

func UnRegisterRegion(regionName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call UnRegisterRegion()")

        if regionName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("RegionName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(regionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(regionName string, providerName string, keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{
        if regionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("RegionName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                if kv.Key == "" </span><span class="cov0" title="0">{ // Value can be empty.
                        return fmt.Errorf("Key is empty!")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package api

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
        "github.com/cloud-barista/poc-cicd-spider/interface/api/request"

        "google.golang.org/grpc"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CCMApi - CCM API 구조 정의
type CCMApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientCCM    pb.CCMClient
        clientSSH    pb.SSHClient
        requestCCM   *request.CCMRequest
        requestSSH   *request.SSHRequest
        inType       string
        outType      string
}

// ImageReq - Image 정보 생성 요청 구조 정의
type ImageReq struct {
        ConnectionName string    `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        ImageInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// ImageInfo - Image 정보 구조 정의
type ImageInfo struct {
        Name string `yaml:"Name" json:"Name"`
}

// VPCReq - VPC 정보 생성 요청 구조 정의
type VPCReq struct {
        ConnectionName string  `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        VPCInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// VPCInfo - VPC 정보 구조 정의
type VPCInfo struct {
        Name           string        `yaml:"Name" json:"Name"`
        IPv4_CIDR      string        `yaml:"IPv4_CIDR" json:"IPv4_CIDR"`
        SubnetInfoList *[]SubnetInfo `yaml:"SubnetInfoList" json:"SubnetInfoList"`
}

// SubnetInfo - Subnet 정보 구조 정의
type SubnetInfo struct {
        Name      string `yaml:"Name" json:"Name"`
        IPv4_CIDR string `yaml:"IPv4_CIDR" json:"IPv4_CIDR"`
}

type SubnetReq struct {
        ConnectionName string     `yaml:"ConnectionName" json:"ConnectionName"`
        VPCName        string     `yaml:"VPCName" json:"VPCName"`
        ReqInfo        SubnetInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// SecurityReq - Security 정보 생성 요청 구조 정의
type SecurityReq struct {
        ConnectionName string       `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        SecurityInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// SecurityInfo - Security 정보 구조 정의
type SecurityInfo struct {
        Name          string              `yaml:"Name" json:"Name"`
        VPCName       string              `yaml:"VPCName" json:"VPCName"`
        Direction     string              `yaml:"Direction" json:"Direction"`
        SecurityRules *[]SecurityRuleInfo `yaml:"SecurityRules" json:"SecurityRules"`
}

// SecurityRuleInfo - Security Rule 정보 구조 정의
type SecurityRuleInfo struct {
        FromPort   string `yaml:"FromPort" json:"FromPort"`
        ToPort     string `yaml:"ToPort" json:"ToPort"`
        IPProtocol string `yaml:"IPProtocol" json:"IPProtocol"`
        Direction  string `yaml:"Direction" json:"Direction"`
        CIDR       string `yaml:"CIDR" json:"CIDR"`
}

// KeyReq - Key Pair 정보 생성 요청 구조 정의
type KeyReq struct {
        ConnectionName string  `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        KeyInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// KeyInfo - Key 정보 구조 정의
type KeyInfo struct {
        Name string `yaml:"Name" json:"Name"`
}

// VMReq - VM 정보 생성 요청 구조 정의
type VMReq struct {
        ConnectionName string `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        VMInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

//VMInfo - VM 정보 구조 정의
type VMInfo struct {
        Name               string   `yaml:"Name" json:"Name"`
        ImageName          string   `yaml:"ImageName" json:"ImageName"`
        VPCName            string   `yaml:"VPCName" json:"VPCName"`
        SubnetName         string   `yaml:"SubnetName" json:"SubnetName"`
        SecurityGroupNames []string `yaml:"SecurityGroupNames" json:"SecurityGroupNames"`
        VMSpecName         string   `yaml:"VMSpecName" json:"VMSpecName"`
        KeyPairName        string   `yaml:"KeyPairName" json:"KeyPairName"`

        VMUserId     string `yaml:"VMUserId" json:"VMUserId"`
        VMUserPasswd string `yaml:"VMUserPasswd" json:"VMUserPasswd"`
}

// SSHRUNReq - SSH 실행 요청 구조 정의
type SSHRUNReq struct {
        UserName   string   `yaml:"UserName" json:"UserName"`
        PrivateKey []string `yaml:"PrivateKey" json:"PrivateKey"`
        ServerPort string   `yaml:"ServerPort" json:"ServerPort"`
        Command    string   `yaml:"Command" json:"Command"`
}

// ===== [ Implementations ] =====

// SetServerAddr - Spider 서버 주소 설정
func (ccm *CCMApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">ccm.gConf.GSL.SpiderCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Spider 서버 주소 값 조회
func (ccm *CCMApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return ccm.gConf.GSL.SpiderCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 설정
func (ccm *CCMApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov8" title="1">{
                ccm.gConf.GSL.SpiderCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">ccm.gConf.GSL.SpiderCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA 값 조회
func (ccm *CCMApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if ccm.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return ccm.gConf.GSL.SpiderCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 설정
func (ccm *CCMApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        ccm.gConf.GSL.SpiderCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout 값 조회
func (ccm *CCMApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return ccm.gConf.GSL.SpiderCli.Timeout, nil
}</span>

// SetJWTToken - JWT 인증 토큰 설정
func (ccm *CCMApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov8" title="1">{
                ccm.gConf.GSL.SpiderCli.Interceptors = &amp;config.InterceptorsConfig{}
                ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT 인증 토큰 값 조회
func (ccm *CCMApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if ccm.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath - 환경설정 파일 설정
func (ccm *CCMApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Viper 를 사용하는 설정 파서 생성
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // SPIDER CLIENT 필수 입력 항목 체크
        <span class="cov8" title="1">spidercli := gConf.GSL.SpiderCli

        if spidercli == nil </span><span class="cov0" title="0">{
                return errors.New("spidercli field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("spidercli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.Timeout == 0 </span><span class="cov0" title="0">{
                spidercli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if spidercli.TLS != nil </span><span class="cov0" title="0">{
                if spidercli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("spidercli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if spidercli.Interceptors != nil </span><span class="cov0" title="0">{
                if spidercli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("spidercli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if spidercli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if spidercli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("spidercli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">ccm.gConf = &amp;gConf
        return nil</span>
}

// Open - 연결 설정
func (ccm *CCMApi) Open() error <span class="cov8" title="1">{

        spidercli := ccm.gConf.GSL.SpiderCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(spidercli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                ccm.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">ccm.conn = cbconn.Conn

        // grpc 클라이언트 생성
        ccm.clientCCM = pb.NewCCMClient(ccm.conn)
        ccm.clientSSH = pb.NewSSHClient(ccm.conn)

        // grpc 호출 Wrapper
        ccm.requestCCM = &amp;request.CCMRequest{Client: ccm.clientCCM, Timeout: spidercli.Timeout, InType: ccm.inType, OutType: ccm.outType}
        ccm.requestSSH = &amp;request.SSHRequest{Client: ccm.clientSSH, Timeout: spidercli.Timeout, InType: ccm.inType, OutType: ccm.outType}

        return nil</span>
}

// Close - 연결 종료
func (ccm *CCMApi) Close() <span class="cov8" title="1">{
        if ccm.conn != nil </span><span class="cov8" title="1">{
                ccm.conn.Close()
        }</span>
        <span class="cov8" title="1">if ccm.jaegerCloser != nil </span><span class="cov0" title="0">{
                ccm.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">ccm.jaegerCloser = nil
        ccm.conn = nil
        ccm.clientCCM = nil
        ccm.clientSSH = nil
        ccm.requestCCM = nil
        ccm.requestSSH = nil</span>
}

// SetInType - 입력 문서 타입 설정 (json/yaml)
func (ccm *CCMApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                ccm.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                ccm.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if ccm.requestCCM != nil </span><span class="cov8" title="1">{
                ccm.requestCCM.InType = ccm.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType - 입력 문서 타입 값 조회
func (ccm *CCMApi) GetInType() (string, error) <span class="cov8" title="1">{
        return ccm.inType, nil
}</span>

// SetOutType - 출력 문서 타입 설정 (json/yaml)
func (ccm *CCMApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                ccm.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                ccm.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if ccm.requestCCM != nil </span><span class="cov8" title="1">{
                ccm.requestCCM.OutType = ccm.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType - 출력 문서 타입 값 조회
func (ccm *CCMApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return ccm.outType, nil
}</span>

// CreateImage - Image 생성
func (ccm *CCMApi) CreateImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateImage()</span>
}

// CreateImageByParam - Image 생성
func (ccm *CCMApi) CreateImageByParam(req *ImageReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListImage - Image 목록
func (ccm *CCMApi) ListImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListImage()</span>
}

// ListImageByParam - Image 목록
func (ccm *CCMApi) ListImageByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetImage - Image 조회
func (ccm *CCMApi) GetImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetImage()</span>
}

// GetImageByParam - Image 조회
func (ccm *CCMApi) GetImageByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteImage - Image 삭제
func (ccm *CCMApi) DeleteImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteImage()</span>
}

// DeleteImageByParam - Image 삭제
func (ccm *CCMApi) DeleteImageByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.DeleteImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVMSpec - VM Spec 목록
func (ccm *CCMApi) ListVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVMSpec()</span>
}

// ListVMSpecByParam - VM Spec 목록
func (ccm *CCMApi) ListVMSpecByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVMSpec - VM Spec 조회
func (ccm *CCMApi) GetVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVMSpec()</span>
}

// GetVMSpecByParam - VM Spec 조회
func (ccm *CCMApi) GetVMSpecByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListOrgVMSpec - 클라우드의 원래 VM Spec 목록
func (ccm *CCMApi) ListOrgVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListOrgVMSpec()</span>
}

// ListOrgVMSpecByParam - 클라우드의 원래 VM Spec 목록
func (ccm *CCMApi) ListOrgVMSpecByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListOrgVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetOrgVMSpec - 클라우드의 원래 VM Spec 조회
func (ccm *CCMApi) GetOrgVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetOrgVMSpec()</span>
}

// GetOrgVMSpecByParam - 클라우드의 원래 VM Spec 조회
func (ccm *CCMApi) GetOrgVMSpecByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetOrgVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// CreateVPC - VPC 생성
func (ccm *CCMApi) CreateVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateVPC()</span>
}

// CreateVPCByParam - VPC 생성
func (ccm *CCMApi) CreateVPCByParam(req *VPCReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVPC - VPC 목록
func (ccm *CCMApi) ListVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVPC()</span>
}

// ListVPCByParam - VPC 목록
func (ccm *CCMApi) ListVPCByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVPC - VPC 조회
func (ccm *CCMApi) GetVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVPC()</span>
}

// GetVPCByParam - VPC 조회
func (ccm *CCMApi) GetVPCByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteVPC - VPC 삭제
func (ccm *CCMApi) DeleteVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteVPC()</span>
}

// DeleteVPCByParam - VPC 삭제
func (ccm *CCMApi) DeleteVPCByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.DeleteVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllVPC - 관리 VPC 목록
func (ccm *CCMApi) ListAllVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllVPC()</span>
}

// ListAllVPCByParam - 관리 VPC 목록
func (ccm *CCMApi) ListAllVPCByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteCSPVPC - 관리 VPC 삭제
func (ccm *CCMApi) DeleteCSPVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteCSPVPC()</span>
}

// DeleteCSPVPCByParam - 관리 VPC 삭제
func (ccm *CCMApi) DeleteCSPVPCByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.DeleteCSPVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// AddSubnet - Subnet 추가
func (ccm *CCMApi) AddSubnet(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.AddSubnet()</span>
}

// AddSubnetByParam - Subnet 추가
func (ccm *CCMApi) AddSubnetByParam(req *SubnetReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.AddSubnet()
        ccm.SetInType(holdType)

        return result, err</span>
}

// RemoveSubnet - Subnet 삭제
func (ccm *CCMApi) RemoveSubnet(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.RemoveSubnet()</span>
}

// RemoveSubnetByParam - Subnet 삭제
func (ccm *CCMApi) RemoveSubnetByParam(connectionName string, vpcName string, subnetName string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "VPCName":"` + vpcName + `", "SubnetName":"` + subnetName + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.RemoveSubnet()
        ccm.SetInType(holdType)

        return result, err</span>
}

// RemoveCSPSubnet - CSP Subnet 삭제
func (ccm *CCMApi) RemoveCSPSubnet(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.RemoveCSPSubnet()</span>
}

// RemoveCSPSubnetByParam - CSP Subnet 삭제
func (ccm *CCMApi) RemoveCSPSubnetByParam(connectionName string, vpcName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "VPCName":"` + vpcName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.RemoveCSPSubnet()
        ccm.SetInType(holdType)

        return result, err</span>
}

// CreateSecurity - Security 생성
func (ccm *CCMApi) CreateSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateSecurity()</span>
}

// CreateSecurityByParam - Security 생성
func (ccm *CCMApi) CreateSecurityByParam(req *SecurityReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListSecurity - Security 목록
func (ccm *CCMApi) ListSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListSecurity()</span>
}

// ListSecurityByParam - Security 목록
func (ccm *CCMApi) ListSecurityByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetSecurity - Security 조회
func (ccm *CCMApi) GetSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetSecurity()</span>
}

// GetSecurityByParam - Security 조회
func (ccm *CCMApi) GetSecurityByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteSecurity - Security 삭제
func (ccm *CCMApi) DeleteSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteSecurity()</span>
}

// DeleteSecurityByParam - Security 삭제
func (ccm *CCMApi) DeleteSecurityByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.DeleteSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllSecurity - 관리 Security 목록
func (ccm *CCMApi) ListAllSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllSecurity()</span>
}

// ListAllSecurityByParam - 관리 Security 목록
func (ccm *CCMApi) ListAllSecurityByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteCSPSecurity - 관리 Security 삭제
func (ccm *CCMApi) DeleteCSPSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteCSPSecurity()</span>
}

// DeleteCSPSecurityByParam - 관리 Security 삭제
func (ccm *CCMApi) DeleteCSPSecurityByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.DeleteCSPSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// CreateKey - Key Pair 생성
func (ccm *CCMApi) CreateKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateKey()</span>
}

// CreateKeyByParam - Key Pair 생성
func (ccm *CCMApi) CreateKeyByParam(req *KeyReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListKey - Key Pair 목록
func (ccm *CCMApi) ListKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListKey()</span>
}

// ListKeyByParam - Key Pair 목록
func (ccm *CCMApi) ListKeyByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetKey - Key Pair 조회
func (ccm *CCMApi) GetKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetKey()</span>
}

// GetKeyByParam - Key Pair 조회
func (ccm *CCMApi) GetKeyByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteKey - Key Pair 삭제
func (ccm *CCMApi) DeleteKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteKey()</span>
}

// DeleteKeyByParam - Key Pair 삭제
func (ccm *CCMApi) DeleteKeyByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.DeleteKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllKey - 관리 Key Pair 목록
func (ccm *CCMApi) ListAllKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllKey()</span>
}

// ListAllKeyByParam - 관리 Key Pair 목록
func (ccm *CCMApi) ListAllKeyByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteCSPKey - 관리 Key Pair 삭제
func (ccm *CCMApi) DeleteCSPKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteCSPKey()</span>
}

// DeleteCSPKeyByParam - 관리 Key Pair 삭제
func (ccm *CCMApi) DeleteCSPKeyByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.DeleteCSPKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// StartVM - VM 시작
func (ccm *CCMApi) StartVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.StartVM()</span>
}

// StartVMByParam - VM 시작
func (ccm *CCMApi) StartVMByParam(req *VMReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.StartVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ControlVM - VM 제어
func (ccm *CCMApi) ControlVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ControlVM()</span>
}

// ControlVMByParam - VM 제어
func (ccm *CCMApi) ControlVMByParam(connectionName string, name string, action string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "action":"` + action + `"}`
        result, err := ccm.requestCCM.ControlVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVMStatus - VM 상태 목록
func (ccm *CCMApi) ListVMStatus(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVMStatus()</span>
}

// ListVMStatusByParam - VM 상태 목록
func (ccm *CCMApi) ListVMStatusByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVMStatus()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVMStatus - VM 상태 조회
func (ccm *CCMApi) GetVMStatus(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVMStatus()</span>
}

// GetVMStatusByParam - VM 상태 조회
func (ccm *CCMApi) GetVMStatusByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVMStatus()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVM - VM 목록
func (ccm *CCMApi) ListVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVM()</span>
}

// ListVMByParam - VM 목록
func (ccm *CCMApi) ListVMByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVM - VM 조회
func (ccm *CCMApi) GetVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVM()</span>
}

// GetVMByParam - VM 조회
func (ccm *CCMApi) GetVMByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// TerminateVM - VM 삭제
func (ccm *CCMApi) TerminateVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.TerminateVM()</span>
}

// TerminateVMByParam - VM 삭제
func (ccm *CCMApi) TerminateVMByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.TerminateVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllVM - 관리 VM 목록
func (ccm *CCMApi) ListAllVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllVM()</span>
}

// ListAllVMByParam - 관리 VM 목록
func (ccm *CCMApi) ListAllVMByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// TerminateCSPVM - 관리 VM 삭제
func (ccm *CCMApi) TerminateCSPVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.TerminateCSPVM()</span>
}

// TerminateCSPVMByParam - 관리 VM 삭제
func (ccm *CCMApi) TerminateCSPVMByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.TerminateCSPVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// SSHRun - SSH 실행
func (ccm *CCMApi) SSHRun(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestSSH == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestSSH.InData = doc
        return ccm.requestSSH.SSHRun()</span>
}

// SSHRunByParam - SSH 실행
func (ccm *CCMApi) SSHRunByParam(req *SSHRUNReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestSSH == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestSSH.InData = string(j)
        result, err := ccm.requestSSH.SSHRun()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCloudResourceHandler - CCM API 객체 생성
func NewCloudResourceHandler() (ccm *CCMApi) <span class="cov8" title="1">{

        ccm = &amp;CCMApi{}
        ccm.gConf = &amp;config.GrpcConfig{}
        ccm.gConf.GSL.SpiderCli = &amp;config.GrpcClientConfig{}

        ccm.jaegerCloser = nil
        ccm.conn = nil
        ccm.clientCCM = nil
        ccm.clientSSH = nil
        ccm.requestCCM = nil
        ccm.requestSSH = nil

        ccm.inType = "json"
        ccm.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package api

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
        "github.com/cloud-barista/poc-cicd-spider/interface/api/request"

        "google.golang.org/grpc"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CIMApi - CIM API 구조 정의
type CIMApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientCIM    pb.CIMClient
        requestCIM   *request.CIMRequest
        inType       string
        outType      string
}

// KeyValue - Key / Value 구조 정의
type KeyValue struct {
        Key   string `yaml:"Key" json:"Key"`
        Value string `yaml:"Value" json:"Value"`
}

// CloudDriverReq - Cloud Driver 정보 생성 요청 구조 정의
type CloudDriverReq struct {
        DriverName        string `yaml:"DriverName" json:"DriverName"`
        ProviderName      string `yaml:"ProviderName" json:"ProviderName"`
        DriverLibFileName string `yaml:"DriverLibFileName" json:"DriverLibFileName"`
}

// CredentialReq - Credential 정보 생성 요청 구조 정의
type CredentialReq struct {
        CredentialName   string     `yaml:"CredentialName" json:"CredentialName"`
        ProviderName     string     `yaml:"ProviderName" json:"ProviderName"`
        KeyValueInfoList []KeyValue `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// RegionReq - Region 정보 생성 요청 구조 정의
type RegionReq struct {
        RegionName       string     `yaml:"RegionName" json:"RegionName"`
        ProviderName     string     `yaml:"ProviderName" json:"ProviderName"`
        KeyValueInfoList []KeyValue `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// ConnectionConfigReq - Connection Config 정보 생성 요청 구조 정의
type ConnectionConfigReq struct {
        ConfigName     string `yaml:"ConfigName" json:"ConfigName"`
        ProviderName   string `yaml:"ProviderName" json:"ProviderName"`
        DriverName     string `yaml:"DriverName" json:"DriverName"`
        CredentialName string `yaml:"CredentialName" json:"CredentialName"`
        RegionName     string `yaml:"RegionName" json:"RegionName"`
}

// ===== [ Implementations ] =====

// SetServerAddr - Spider 서버 주소 설정
func (cim *CIMApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">cim.gConf.GSL.SpiderCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Spider 서버 주소 값 조회
func (cim *CIMApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return cim.gConf.GSL.SpiderCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 설정
func (cim *CIMApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov8" title="1">{
                cim.gConf.GSL.SpiderCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">cim.gConf.GSL.SpiderCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA 값 조회
func (cim *CIMApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if cim.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return cim.gConf.GSL.SpiderCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 설정
func (cim *CIMApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        cim.gConf.GSL.SpiderCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout 값 조회
func (cim *CIMApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return cim.gConf.GSL.SpiderCli.Timeout, nil
}</span>

// SetJWTToken - JWT 인증 토큰 설정
func (cim *CIMApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov8" title="1">{
                cim.gConf.GSL.SpiderCli.Interceptors = &amp;config.InterceptorsConfig{}
                cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT 인증 토큰 값 조회
func (cim *CIMApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if cim.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath - 환경설정 파일 설정
func (cim *CIMApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Viper 를 사용하는 설정 파서 생성
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // SPIDER CLIENT 필수 입력 항목 체크
        <span class="cov8" title="1">spidercli := gConf.GSL.SpiderCli

        if spidercli == nil </span><span class="cov0" title="0">{
                return errors.New("spidercli field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("spidercli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.Timeout == 0 </span><span class="cov0" title="0">{
                spidercli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if spidercli.TLS != nil </span><span class="cov0" title="0">{
                if spidercli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("spidercli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if spidercli.Interceptors != nil </span><span class="cov0" title="0">{
                if spidercli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("spidercli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if spidercli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if spidercli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("spidercli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">cim.gConf = &amp;gConf
        return nil</span>
}

// Open - 연결 설정
func (cim *CIMApi) Open() error <span class="cov8" title="1">{

        spidercli := cim.gConf.GSL.SpiderCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(spidercli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                cim.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">cim.conn = cbconn.Conn

        // grpc 클라이언트 생성
        cim.clientCIM = pb.NewCIMClient(cim.conn)

        // grpc 호출 Wrapper
        cim.requestCIM = &amp;request.CIMRequest{Client: cim.clientCIM, Timeout: spidercli.Timeout, InType: cim.inType, OutType: cim.outType}

        return nil</span>
}

// Close - 연결 종료
func (cim *CIMApi) Close() <span class="cov8" title="1">{
        if cim.conn != nil </span><span class="cov8" title="1">{
                cim.conn.Close()
        }</span>
        <span class="cov8" title="1">if cim.jaegerCloser != nil </span><span class="cov0" title="0">{
                cim.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">cim.jaegerCloser = nil
        cim.conn = nil
        cim.clientCIM = nil
        cim.requestCIM = nil</span>
}

// SetInType - 입력 문서 타입 설정 (json/yaml)
func (cim *CIMApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                cim.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                cim.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if cim.requestCIM != nil </span><span class="cov8" title="1">{
                cim.requestCIM.InType = cim.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType - 입력 문서 타입 값 조회
func (cim *CIMApi) GetInType() (string, error) <span class="cov8" title="1">{
        return cim.inType, nil
}</span>

// SetOutType - 출력 문서 타입 설정 (json/yaml)
func (cim *CIMApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                cim.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                cim.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if cim.requestCIM != nil </span><span class="cov8" title="1">{
                cim.requestCIM.OutType = cim.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType - 출력 문서 타입 값 조회
func (cim *CIMApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return cim.outType, nil
}</span>

// ListCloudOS -Cloud OS 목록
func (cim *CIMApi) ListCloudOS() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListCloudOS()</span>
}

// CreateCloudDriver - Cloud Driver 생성
func (cim *CIMApi) CreateCloudDriver(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateCloudDriver()</span>
}

// CreateCloudDriverByParam - Cloud Driver 생성
func (cim *CIMApi) CreateCloudDriverByParam(req *CloudDriverReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateCloudDriver()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListCloudDriver -Cloud Driver 목록
func (cim *CIMApi) ListCloudDriver() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListCloudDriver()</span>
}

// GetCloudDriver - Cloud Driver 조회
func (cim *CIMApi) GetCloudDriver(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetCloudDriver()</span>
}

// GetCloudDriverByParam - Cloud Driver 조회
func (cim *CIMApi) GetCloudDriverByParam(driverName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"DriverName":"` + driverName + `"}`
        result, err := cim.requestCIM.GetCloudDriver()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteCloudDriver - Cloud Driver 삭제
func (cim *CIMApi) DeleteCloudDriver(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteCloudDriver()</span>
}

// DeleteCloudDriverByParam - Cloud Driver 삭제
func (cim *CIMApi) DeleteCloudDriverByParam(driverName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"DriverName":"` + driverName + `"}`
        result, err := cim.requestCIM.DeleteCloudDriver()
        cim.SetInType(holdType)

        return result, err</span>
}

// CreateCredential - Credential 생성
func (cim *CIMApi) CreateCredential(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateCredential()</span>
}

// CreateCredentialByParam - Credential 생성
func (cim *CIMApi) CreateCredentialByParam(req *CredentialReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateCredential()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListCredential -Credential 목록
func (cim *CIMApi) ListCredential() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListCredential()</span>
}

// GetCredential - Credential 조회
func (cim *CIMApi) GetCredential(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetCredential()</span>
}

// GetCredentialByParam - Credential 조회
func (cim *CIMApi) GetCredentialByParam(credentialName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"CredentialName":"` + credentialName + `"}`
        result, err := cim.requestCIM.GetCredential()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteCredential - Credential 삭제
func (cim *CIMApi) DeleteCredential(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteCredential()</span>
}

// DeleteCredentialByParam - Credential 삭제
func (cim *CIMApi) DeleteCredentialByParam(credentialName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"CredentialName":"` + credentialName + `"}`
        result, err := cim.requestCIM.DeleteCredential()
        cim.SetInType(holdType)

        return result, err</span>
}

// CreateRegion - Region 생성
func (cim *CIMApi) CreateRegion(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateRegion()</span>
}

// CreateRegionByParam - Region 생성
func (cim *CIMApi) CreateRegionByParam(req *RegionReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateRegion()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListRegion - Region 목록
func (cim *CIMApi) ListRegion() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListRegion()</span>
}

// GetRegion - Region 조회
func (cim *CIMApi) GetRegion(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetRegion()</span>
}

// GetRegionByParam - Region 조회
func (cim *CIMApi) GetRegionByParam(regionName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"RegionName":"` + regionName + `"}`
        result, err := cim.requestCIM.GetRegion()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteRegion - Region 삭제
func (cim *CIMApi) DeleteRegion(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteRegion()</span>
}

// DeleteRegionByParam - Region 삭제
func (cim *CIMApi) DeleteRegionByParam(regionName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"RegionName":"` + regionName + `"}`
        result, err := cim.requestCIM.DeleteRegion()
        cim.SetInType(holdType)

        return result, err</span>
}

// CreateConnectionConfig - Connection Config 생성
func (cim *CIMApi) CreateConnectionConfig(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateConnectionConfig()</span>
}

// CreateConnectionConfigByParam - Connection Config 생성
func (cim *CIMApi) CreateConnectionConfigByParam(req *ConnectionConfigReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateConnectionConfig()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListConnectionConfig - Connection Config 목록
func (cim *CIMApi) ListConnectionConfig() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListConnectionConfig()</span>
}

// GetConnectionConfig - Connection Config 조회
func (cim *CIMApi) GetConnectionConfig(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetConnectionConfig()</span>
}

// GetConnectionConfigByParam - Connection Config 조회
func (cim *CIMApi) GetConnectionConfigByParam(configName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"ConfigName":"` + configName + `"}`
        result, err := cim.requestCIM.GetConnectionConfig()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteConnectionConfig - Connection Config 삭제
func (cim *CIMApi) DeleteConnectionConfig(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteConnectionConfig()</span>
}

// DeleteConnectionConfigByParam - Connection Config 삭제
func (cim *CIMApi) DeleteConnectionConfigByParam(configName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"ConfigName":"` + configName + `"}`
        result, err := cim.requestCIM.DeleteConnectionConfig()
        cim.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCloudInfoManager - CIM API 객체 생성
func NewCloudInfoManager() (cim *CIMApi) <span class="cov8" title="1">{

        cim = &amp;CIMApi{}
        cim.gConf = &amp;config.GrpcConfig{}
        cim.gConf.GSL.SpiderCli = &amp;config.GrpcClientConfig{}

        cim.jaegerCloser = nil
        cim.conn = nil
        cim.clientCIM = nil
        cim.requestCIM = nil

        cim.inType = "json"
        cim.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateConnectionConfig - Connection Config 생성
func (r *CIMRequest) CreateConnectionConfig() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ConnectionConfigInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateConnectionConfig(ctx, &amp;pb.ConnectionConfigInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListConnectionConfig - Connection Config 목록
func (r *CIMRequest) ListConnectionConfig() (string, error) <span class="cov8" title="1">{
        // 서버에 요청
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListConnectionConfig(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetConnectionConfig - Connection Config 조회
func (r *CIMRequest) GetConnectionConfig() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ConnectionConfigQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetConnectionConfig(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteConnectionConfig - Connection Config 삭제
func (r *CIMRequest) DeleteConnectionConfig() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ConnectionConfigQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteConnectionConfig(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file139" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCredential - Credential 생성
func (r *CIMRequest) CreateCredential() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CredentialInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateCredential(ctx, &amp;pb.CredentialInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListCredential -Credential 목록
func (r *CIMRequest) ListCredential() (string, error) <span class="cov8" title="1">{
        // 서버에 요청
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCredential(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetCredential - Credential 조회
func (r *CIMRequest) GetCredential() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CredentialQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetCredential(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteCredential - Credential 삭제
func (r *CIMRequest) DeleteCredential() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CredentialQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCredential(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file140" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCloudDriver - Cloud Driver 생성
func (r *CIMRequest) CreateCloudDriver() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CloudDriverInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateCloudDriver(ctx, &amp;pb.CloudDriverInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListCloudDriver -Cloud Driver 목록
func (r *CIMRequest) ListCloudDriver() (string, error) <span class="cov8" title="1">{
        // 서버에 요청
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCloudDriver(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetCloudDriver - Cloud Driver 조회
func (r *CIMRequest) GetCloudDriver() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CloudDriverQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetCloudDriver(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteCloudDriver - Cloud Driver 삭제
func (r *CIMRequest) DeleteCloudDriver() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CloudDriverQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCloudDriver(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file141" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateImage - Image 생성
func (r *CCMRequest) CreateImage() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ImageCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateImage(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListImage - Image 목록
func (r *CCMRequest) ListImage() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ImageAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListImage(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetImage - Image 조회
func (r *CCMRequest) GetImage() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ImageQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetImage(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteImage - Image 삭제
func (r *CCMRequest) DeleteImage() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ImageQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteImage(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file142" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateKey - Key Pair 생성
func (r *CCMRequest) CreateKey() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.KeyPairCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListKey - Key Pair 목록
func (r *CCMRequest) ListKey() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.KeyPairAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListKey(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetKey - Key Pair 조회
func (r *CCMRequest) GetKey() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.KeyPairQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteKey - Key Pair 삭제
func (r *CCMRequest) DeleteKey() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.KeyPairQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllKey - 관리 Key Pair 목록
func (r *CCMRequest) ListAllKey() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.KeyPairAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListAllKey(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteCSPKey - 관리 Key Pair 삭제
func (r *CCMRequest) DeleteCSPKey() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CSPKeyPairQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCSPKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file143" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListCloudOS -Cloud OS 목록
func (r *CIMRequest) ListCloudOS() (string, error) <span class="cov8" title="1">{
        // 서버에 요청
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCloudOS(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file144" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateRegion - Region 생성
func (r *CIMRequest) CreateRegion() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.RegionInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateRegion(ctx, &amp;pb.RegionInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListRegion - Region 목록
func (r *CIMRequest) ListRegion() (string, error) <span class="cov8" title="1">{
        // 서버에 요청
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListRegion(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetRegion - Region 조회
func (r *CIMRequest) GetRegion() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.RegionQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetRegion(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteRegion - Region 삭제
func (r *CIMRequest) DeleteRegion() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.RegionQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteRegion(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file145" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSecurity - Security 생성
func (r *CCMRequest) CreateSecurity() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SecurityCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListSecurity - Security 목록
func (r *CCMRequest) ListSecurity() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SecurityAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSecurity(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetSecurity - Security 조회
func (r *CCMRequest) GetSecurity() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SecurityQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteSecurity - Security 삭제
func (r *CCMRequest) DeleteSecurity() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SecurityQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllSecurity - 관리 Security 목록
func (r *CCMRequest) ListAllSecurity() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SecurityAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListAllSecurity(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteCSPSecurity - 관리 Security 삭제
func (r *CCMRequest) DeleteCSPSecurity() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CSPSecurityQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCSPSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file146" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// SSHRun - SSH 실행
func (r *SSHRequest) SSHRun() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SSHRunRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.SSHRun(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file147" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// StartVM - VM 시작
func (r *CCMRequest) StartVM() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.StartVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ControlVM - VM 제어
func (r *CCMRequest) ControlVM() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMActionRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ControlVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListVMStatus - VM 상태 목록
func (r *CCMRequest) ListVMStatus() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ListVMStatus(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVMStatus - VM 상태 조회
func (r *CCMRequest) GetVMStatus() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVMStatus(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListVM - VM 목록
func (r *CCMRequest) ListVM() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ListVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVM - VM 조회
func (r *CCMRequest) GetVM() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// TerminateVM - VM 삭제
func (r *CCMRequest) TerminateVM() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.TerminateVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllVM - 관리 VM 목록
func (r *CCMRequest) ListAllVM() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ListAllVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// TerminateCSPVM - 관리 VM 삭제
func (r *CCMRequest) TerminateCSPVM() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CSPVMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.TerminateCSPVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file148" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListVMSpec - VM Spec 목록
func (r *CCMRequest) ListVMSpec() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMSpecAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListVMSpec(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVMSpec - VM Spec 조회
func (r *CCMRequest) GetVMSpec() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMSpecQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVMSpec(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListOrgVMSpec - 클라우드의 원래 VM Spec 목록
func (r *CCMRequest) ListOrgVMSpec() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMSpecAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListOrgVMSpec(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">out := resp.Result
        return out, nil</span>
}

// GetOrgVMSpec - 클라우드의 원래 VM Spec 조회
func (r *CCMRequest) GetOrgVMSpec() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VMSpecQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetOrgVMSpec(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">out := resp.Result
        return out, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file149" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateVPC - VPC 생성
func (r *CCMRequest) CreateVPC() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VPCCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListVPC - VPC 목록
func (r *CCMRequest) ListVPC() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VPCAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListVPC(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVPC - VPC 조회
func (r *CCMRequest) GetVPC() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VPCQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteVPC - VPC 삭제
func (r *CCMRequest) DeleteVPC() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VPCQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllVPC - 관리 VPC 목록
func (r *CCMRequest) ListAllVPC() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.VPCAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListAllVPC(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteCSPVPC - 관리 VPC 삭제
func (r *CCMRequest) DeleteCSPVPC() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CSPVPCQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCSPVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// AddSubnet - Subnet 추가
func (r *CCMRequest) AddSubnet() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SubnetAddRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.AddSubnet(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// RemoveSubnet - Subnet 삭제
func (r *CCMRequest) RemoveSubnet() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.SubnetQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.RemoveSubnet(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// RemoveCSPSubnet - CSP Subnet 삭제
func (r *CCMRequest) RemoveCSPSubnet() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.CSPSubnetQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.RemoveCSPSubnet(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file150" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewConnectionCmd - Connection Config 관리 기능을 수행하는 Cobra Command 생성
func NewConnectionCmd() *cobra.Command <span class="cov8" title="1">{

        connectionCmd := &amp;cobra.Command{
                Use:   "connection",
                Short: "This is a manageable command for connection config",
                Long:  "This is a manageable command for connection config",
        }

        //  Adds the commands for application.
        connectionCmd.AddCommand(NewConnectionCreateCmd())
        connectionCmd.AddCommand(NewConnectionListCmd())
        connectionCmd.AddCommand(NewConnectionGetCmd())
        connectionCmd.AddCommand(NewConnectionDeleteCmd())

        return connectionCmd
}</span>

// NewConnectionCreateCmd - Connection Config 생성 기능을 수행하는 Cobra Command 생성
func NewConnectionCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for connection config",
                Long:  "This is create command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewConnectionListCmd - Connection Config 목록 기능을 수행하는 Cobra Command 생성
func NewConnectionListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for connection config",
                Long:  "This is list command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewConnectionGetCmd - Connection Config 조회 기능을 수행하는 Cobra Command 생성
func NewConnectionGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for connection config",
                Long:  "This is get command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return getCmd</span>
}

// NewConnectionDeleteCmd - Connection Config 삭제 기능을 수행하는 Cobra Command 생성
func NewConnectionDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for connection config",
                Long:  "This is delete command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCredentialCmd - Credential 관리 기능을 수행하는 Cobra Command 생성
func NewCredentialCmd() *cobra.Command <span class="cov8" title="1">{

        credentialCmd := &amp;cobra.Command{
                Use:   "credential",
                Short: "This is a manageable command for credential",
                Long:  "This is a manageable command for credential",
        }

        //  Adds the commands for application.
        credentialCmd.AddCommand(NewCredentialCreateCmd())
        credentialCmd.AddCommand(NewCredentialListCmd())
        credentialCmd.AddCommand(NewCredentialGetCmd())
        credentialCmd.AddCommand(NewCredentialDeleteCmd())

        return credentialCmd
}</span>

// NewCredentialCreateCmd -Credential 생성 기능을 수행하는 Cobra Command 생성
func NewCredentialCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for credential",
                Long:  "This is create command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewCredentialListCmd - Credential 목록 기능을 수행하는 Cobra Command 생성
func NewCredentialListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for credential",
                Long:  "This is list command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewCredentialGetCmd - Credential 조회 기능을 수행하는 Cobra Command 생성
func NewCredentialGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for credential",
                Long:  "This is get command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return getCmd</span>
}

// NewCredentialDeleteCmd - Credential 삭제 기능을 수행하는 Cobra Command 생성
func NewCredentialDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for credential",
                Long:  "This is delete command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewDriverCmd - Cloud Driver 관리 기능을 수행하는 Cobra Command 생성
func NewDriverCmd() *cobra.Command <span class="cov8" title="1">{

        driverCmd := &amp;cobra.Command{
                Use:   "driver",
                Short: "This is a manageable command for cloud driver",
                Long:  "This is a manageable command for cloud driver",
        }

        //  Adds the commands for application.
        driverCmd.AddCommand(NewDriverCreateCmd())
        driverCmd.AddCommand(NewDriverListCmd())
        driverCmd.AddCommand(NewDriverGetCmd())
        driverCmd.AddCommand(NewDriverDeleteCmd())

        return driverCmd
}</span>

// NewDriverCreateCmd - Cloud Driver 생성 기능을 수행하는 Cobra Command 생성
func NewDriverCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for cloud driver",
                Long:  "This is create command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewDriverListCmd - Cloud Driver 목록 기능을 수행하는 Cobra Command 생성
func NewDriverListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud driver",
                Long:  "This is list command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewDriverGetCmd - Cloud Driver 조회 기능을 수행하는 Cobra Command 생성
func NewDriverGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for cloud driver",
                Long:  "This is get command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return getCmd</span>
}

// NewDriverDeleteCmd - Cloud Driver 삭제 기능을 수행하는 Cobra Command 생성
func NewDriverDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for cloud driver",
                Long:  "This is delete command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "fmt"
        "io/ioutil"

        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        "github.com/cloud-barista/poc-cicd-spider/interface/api"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

func readInDataFromFile() <span class="cov8" title="1">{
        logger := logger.NewLogger()
        if inData == "" </span><span class="cov0" title="0">{
                if inFile != "" </span><span class="cov0" title="0">{
                        dat, err := ioutil.ReadFile(inFile)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to read file : ", inFile)
                                return
                        }</span>
                        <span class="cov0" title="0">inData = string(dat)</span>
                }
        }
}

// ===== [ Public Functions ] =====

// SetupAndRun - SPIDER GRPC CLI 구동
func SetupAndRun(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        var (
                result string
                err    error

                cim *api.CIMApi = nil
                ccm *api.CCMApi = nil
        )

        // panic 처리
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("spider is stopped : ", r)
                }</span>
        }()

        <span class="cov8" title="1">if cmd.Parent().Name() == "os" || cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" ||
                cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connection" </span><span class="cov8" title="1">{

                // CIM API 설정
                cim = api.NewCloudInfoManager()
                err = cim.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("cim api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer cim.Close()</span>

        } else<span class="cov8" title="1"> {

                // CCM API 설정
                ccm = api.NewCloudResourceHandler()
                err = ccm.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("cim api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer ccm.Close()</span>

        }

        // 입력 파라미터 처리
        <span class="cov8" title="1">if outType != "json" &amp;&amp; outType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --output parameter : ", outType)
                return
        }</span>
        <span class="cov8" title="1">if inType != "json" &amp;&amp; inType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --input parameter : ", inType)
                return
        }</span>

        <span class="cov8" title="1">if cmd.Parent().Name() == "os" || cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" ||
                cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connection" </span><span class="cov8" title="1">{
                cim.SetInType(inType)
                cim.SetOutType(outType)
        }</span> else<span class="cov8" title="1"> {
                ccm.SetInType(inType)
                ccm.SetOutType(outType)
        }</span>

        <span class="cov8" title="1">logger.Debug("--input parameter value : ", inType)
        logger.Debug("--output parameter value : ", outType)

        result = ""
        err = nil

        switch cmd.Parent().Name() </span>{
        case "os":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListCloudOS()</span>
                }
        case "driver":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateCloudDriver(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListCloudDriver()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetCloudDriverByParam(driverName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteCloudDriverByParam(driverName)</span>
                }
        case "credential":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateCredential(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListCredential()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetCredentialByParam(credentialName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteCredentialByParam(credentialName)</span>
                }
        case "region":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateRegion(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListRegion()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetRegionByParam(regionName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteRegionByParam(regionName)</span>
                }
        case "connection":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateConnectionConfig(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListConnectionConfig()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetConnectionConfigByParam(configName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteConnectionConfigByParam(configName)</span>
                }
        case "image":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateImage(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListImageByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetImageByParam(connectionName, imageName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteImageByParam(connectionName, imageName)</span>
                }
        case "vmspec":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListVMSpecByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetVMSpecByParam(connectionName, specName)</span>
                case "listorg":<span class="cov8" title="1">
                        result, err = ccm.ListOrgVMSpecByParam(connectionName)</span>
                case "getorg":<span class="cov8" title="1">
                        result, err = ccm.GetOrgVMSpecByParam(connectionName, specName)</span>
                }
        case "vpc":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateVPC(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListVPCByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetVPCByParam(connectionName, vpcName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteVPCByParam(connectionName, vpcName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllVPCByParam(connectionName)</span>
                case "deletecsp":<span class="cov8" title="1">
                        result, err = ccm.DeleteCSPVPCByParam(connectionName, cspID)</span>
                case "add-subnet":<span class="cov8" title="1">
                        result, err = ccm.AddSubnet(inData)</span>
                case "remove-subnet":<span class="cov8" title="1">
                        result, err = ccm.RemoveSubnetByParam(connectionName, vpcName, subnetName, force)</span>
                case "removecsp-subnet":<span class="cov8" title="1">
                        result, err = ccm.RemoveCSPSubnetByParam(connectionName, vpcName, cspID)</span>
                }
        case "security":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateSecurity(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListSecurityByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetSecurityByParam(connectionName, securityName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteSecurityByParam(connectionName, securityName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllSecurityByParam(connectionName)</span>
                case "deletecsp":<span class="cov8" title="1">
                        result, err = ccm.DeleteCSPSecurityByParam(connectionName, cspID)</span>
                }
        case "keypair":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateKey(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListKeyByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetKeyByParam(connectionName, keypairName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteKeyByParam(connectionName, keypairName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllKeyByParam(connectionName)</span>
                case "deletecsp":<span class="cov8" title="1">
                        result, err = ccm.DeleteCSPKeyByParam(connectionName, cspID)</span>
                }
        case "vm":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "start":<span class="cov8" title="1">
                        result, err = ccm.StartVM(inData)</span>
                case "control":<span class="cov0" title="0">
                        result, err = ccm.ControlVMByParam(connectionName, vmName, action)</span>
                case "liststatus":<span class="cov8" title="1">
                        result, err = ccm.ListVMStatusByParam(connectionName)</span>
                case "getstatus":<span class="cov8" title="1">
                        result, err = ccm.GetVMStatusByParam(connectionName, vmName)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListVMByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetVMByParam(connectionName, vmName)</span>
                case "terminate":<span class="cov8" title="1">
                        result, err = ccm.TerminateVMByParam(connectionName, vmName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllVMByParam(connectionName)</span>
                case "terminatecsp":<span class="cov8" title="1">
                        result, err = ccm.TerminateCSPVMByParam(connectionName, cspID)</span>
                }
        case "ssh":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "run":<span class="cov0" title="0">
                        result, err = ccm.SSHRun(inData)</span>
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if outType == "yaml" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "message: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(cmd.OutOrStdout(), "{\"message\": \"%v\"}\n", err)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", result)
        }</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewImageCmd - Image 관리 기능을 수행하는 Cobra Command 생성
func NewImageCmd() *cobra.Command <span class="cov8" title="1">{

        imageCmd := &amp;cobra.Command{
                Use:   "image",
                Short: "This is a manageable command for image",
                Long:  "This is a manageable command for image",
        }

        //  Adds the commands for application.
        imageCmd.AddCommand(NewImageCreateCmd())
        imageCmd.AddCommand(NewImageListCmd())
        imageCmd.AddCommand(NewImageGetCmd())
        imageCmd.AddCommand(NewImageDeleteCmd())

        return imageCmd
}</span>

// NewImageCreateCmd - Image 생성 기능을 수행하는 Cobra Command 생성
func NewImageCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for image",
                Long:  "This is create command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewImageListCmd - Image 목록 기능을 수행하는 Cobra Command 생성
func NewImageListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for image",
                Long:  "This is list command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewImageGetCmd - Image 조회 기능을 수행하는 Cobra Command 생성
func NewImageGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for image",
                Long:  "This is get command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if imageName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", imageName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;imageName, "name", "n", "", "image name")

        return getCmd</span>
}

// NewImageDeleteCmd - Image 삭제 기능을 수행하는 Cobra Command 생성
func NewImageDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for image",
                Long:  "This is delete command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if imageName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", imageName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;imageName, "name", "n", "", "image name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewKeyPairCmd - KeyPair 관리 기능을 수행하는 Cobra Command 생성
func NewKeyPairCmd() *cobra.Command <span class="cov8" title="1">{

        keyPairCmd := &amp;cobra.Command{
                Use:   "keypair",
                Short: "This is a manageable command for keypair",
                Long:  "This is a manageable command for keypair",
        }

        //  Adds the commands for application.
        keyPairCmd.AddCommand(NewKeyPairCreateCmd())
        keyPairCmd.AddCommand(NewKeyPairListCmd())
        keyPairCmd.AddCommand(NewKeyPairGetCmd())
        keyPairCmd.AddCommand(NewKeyPairDeleteCmd())
        keyPairCmd.AddCommand(NewKeyPairListAllCmd())
        keyPairCmd.AddCommand(NewKeyPairDeleteCSPCmd())

        return keyPairCmd
}</span>

// NewKeyPairCreateCmd - KeyPair 생성 기능을 수행하는 Cobra Command 생성
func NewKeyPairCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for keypair",
                Long:  "This is create command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewKeyPairListCmd - KeyPair 목록 기능을 수행하는 Cobra Command 생성
func NewKeyPairListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for keypair",
                Long:  "This is list command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewKeyPairGetCmd - KeyPair 조회 기능을 수행하는 Cobra Command 생성
func NewKeyPairGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for keypair",
                Long:  "This is get command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if keypairName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", keypairName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;keypairName, "name", "n", "", "keypair name")

        return getCmd</span>
}

// NewKeyPairDeleteCmd - KeyPair 삭제 기능을 수행하는 Cobra Command 생성
func NewKeyPairDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for keypair",
                Long:  "This is delete command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if keypairName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", keypairName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;keypairName, "name", "n", "", "keypair name")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return deleteCmd</span>
}

// NewKeyPairListAllCmd - 관리 KeyPair 목록 기능을 수행하는 Cobra Command 생성
func NewKeyPairListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for keypair",
                Long:  "This is list all command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewKeyPairDeleteCSPCmd - 관리 KeyPair 삭제 기능을 수행하는 Cobra Command 생성
func NewKeyPairDeleteCSPCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCSPCmd := &amp;cobra.Command{
                Use:   "deletecsp",
                Short: "This is delete csp command for keypair",
                Long:  "This is delete csp command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return deleteCSPCmd</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewOsCmd - Cloud OS 관리 기능을 수행하는 Cobra Command 생성
func NewOsCmd() *cobra.Command <span class="cov8" title="1">{

        osCmd := &amp;cobra.Command{
                Use:   "os",
                Short: "This is a manageable command for cloud os",
                Long:  "This is a manageable command for cloud os",
        }

        //  Adds the commands for application.
        osCmd.AddCommand(NewOsListCmd())

        return osCmd
}</span>

// NewOsListCmd - Cloud OS 목록 기능을 수행하는 Cobra Command 생성
func NewOsListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud os",
                Long:  "This is list command for cloud os",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRegionCmd - Region 관리 기능을 수행하는 Cobra Command 생성
func NewRegionCmd() *cobra.Command <span class="cov8" title="1">{

        regionCmd := &amp;cobra.Command{
                Use:   "region",
                Short: "This is a manageable command for region",
                Long:  "This is a manageable command for region",
        }

        //  Adds the commands for application.
        regionCmd.AddCommand(NewRegionCreateCmd())
        regionCmd.AddCommand(NewRegionListCmd())
        regionCmd.AddCommand(NewRegionGetCmd())
        regionCmd.AddCommand(NewRegionDeleteCmd())

        return regionCmd
}</span>

// NewRegionCreateCmd - Region 생성 기능을 수행하는 Cobra Command 생성
func NewRegionCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for region",
                Long:  "This is create command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewRegionListCmd - Region 목록 기능을 수행하는 Cobra Command 생성
func NewRegionListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for region",
                Long:  "This is list command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewRegionGetCmd - Region 조회 기능을 수행하는 Cobra Command 생성
func NewRegionGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for region",
                Long:  "This is get command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return getCmd</span>
}

// NewRegionDeleteCmd - Region 삭제 기능을 수행하는 Cobra Command 생성
func NewRegionDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for region",
                Long:  "This is delete command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

// Package cmd - 어플리케이션 실행을 위한 Cobra 기반의 CLI Commands 기능 제공
package cmd

import (
        "fmt"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

var (
        Version   string = "latest"
        CommitSHA string = "development build"
        Time      string = ""
        User      string = ""
)

var (
        configFile string
        inData     string
        inFile     string
        inType     string
        outType    string

        driverName     string
        credentialName string
        regionName     string
        configName     string

        connectionName string
        imageName      string
        specName       string
        vpcName        string
        subnetName     string
        securityName   string
        keypairName    string
        vmName         string
        action         string
        cspID          string
        force          string

        parser config.Parser
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRootCmd - 어플리케이션 진입점으로 사용할 Root Cobra Command 생성
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{

        rootCmd := &amp;cobra.Command{
                Use:     "spctl",
                Version: fmt.Sprintf("%s, build %s", Version, CommitSHA),
                Short:   "spctl is an cb-spider grpc cli tool",
                Long:    "This is a lightweight cb-spider grpc cli tool for Cloud-Barista Spider",
        }

        // 옵션 플래그 설정
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "./grpc_conf.yaml", "config file")
        rootCmd.PersistentFlags().StringVarP(&amp;inType, "input", "i", "yaml", "input format (json/yaml)")
        rootCmd.PersistentFlags().StringVarP(&amp;outType, "output", "o", "yaml", "output format (json/yaml)")

        // Viper 를 사용하는 설정 파서 생성
        parser = config.MakeParser()

        //  Adds the commands for application.
        rootCmd.AddCommand(NewVersionCmd())

        rootCmd.AddCommand(NewOsCmd())
        rootCmd.AddCommand(NewDriverCmd())
        rootCmd.AddCommand(NewCredentialCmd())
        rootCmd.AddCommand(NewRegionCmd())
        rootCmd.AddCommand(NewConnectionCmd())

        rootCmd.AddCommand(NewImageCmd())
        rootCmd.AddCommand(NewVMSpecCmd())
        rootCmd.AddCommand(NewVPCCmd())
        rootCmd.AddCommand(NewSecurityCmd())
        rootCmd.AddCommand(NewKeyPairCmd())
        rootCmd.AddCommand(NewVMCmd())

        rootCmd.AddCommand(NewSSHCmd())

        return rootCmd
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSecurityCmd - Security 관리 기능을 수행하는 Cobra Command 생성
func NewSecurityCmd() *cobra.Command <span class="cov8" title="1">{

        securityCmd := &amp;cobra.Command{
                Use:   "security",
                Short: "This is a manageable command for security",
                Long:  "This is a manageable command for security",
        }

        //  Adds the commands for application.
        securityCmd.AddCommand(NewSecurityCreateCmd())
        securityCmd.AddCommand(NewSecurityListCmd())
        securityCmd.AddCommand(NewSecurityGetCmd())
        securityCmd.AddCommand(NewSecurityDeleteCmd())
        securityCmd.AddCommand(NewSecurityListAllCmd())
        securityCmd.AddCommand(NewSecurityDeleteCSPCmd())

        return securityCmd
}</span>

// NewSecurityCreateCmd - Security 생성 기능을 수행하는 Cobra Command 생성
func NewSecurityCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for security",
                Long:  "This is create command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewSecurityListCmd - Security 목록 기능을 수행하는 Cobra Command 생성
func NewSecurityListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for security",
                Long:  "This is list command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewSecurityGetCmd - Security 조회 기능을 수행하는 Cobra Command 생성
func NewSecurityGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for security",
                Long:  "This is get command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if securityName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", securityName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;securityName, "name", "n", "", "security name")

        return getCmd</span>
}

// NewSecurityDeleteCmd - Security 삭제 기능을 수행하는 Cobra Command 생성
func NewSecurityDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for security",
                Long:  "This is delete command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if securityName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", securityName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;securityName, "name", "n", "", "security name")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return deleteCmd</span>
}

// NewSecurityListAllCmd - 관리 Security 목록 기능을 수행하는 Cobra Command 생성
func NewSecurityListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for security",
                Long:  "This is list all command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewSecurityDeleteCSPCmd - 관리 Security 삭제 기능을 수행하는 Cobra Command 생성
func NewSecurityDeleteCSPCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCSPCmd := &amp;cobra.Command{
                Use:   "deletecsp",
                Short: "This is delete csp command for security",
                Long:  "This is delete csp command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return deleteCSPCmd</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSSHCmd - SSH 관리 기능을 수행하는 Cobra Command 생성
func NewSSHCmd() *cobra.Command <span class="cov8" title="1">{

        sshCmd := &amp;cobra.Command{
                Use:   "ssh",
                Short: "This is a manageable command for ssh",
                Long:  "This is a manageable command for ssh",
        }

        //  Adds the commands for application.
        sshCmd.AddCommand(NewSSHRunCmd())

        return sshCmd
}</span>

// NewSSHRunCmd - SSH 실행 기능을 수행하는 Cobra Command 생성
func NewSSHRunCmd() *cobra.Command <span class="cov8" title="1">{

        runCmd := &amp;cobra.Command{
                Use:   "run",
                Short: "This is run command for ssh",
                Long:  "This is run command for ssh",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">runCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        runCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return runCmd</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "fmt"
        "runtime"

        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVersionCmd - 버전 표시 기능을 수행하는 Cobra Command 생성
func NewVersionCmd() *cobra.Command <span class="cov8" title="1">{

        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "This is a version command for spctl",
                Long:  "This is a version command for spctl",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "spctl:\n    Version: %s\n    Commit SHA: %s\n    Go version: %s\n"+
                                "    OS/Arch: %s\n    Build Time: %s\n    Build User: %s\n",
                                Version, CommitSHA, runtime.Version(), fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH), Time, User)
                }</span>,
        }

        <span class="cov8" title="1">return versionCmd</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVMCmd - VM 관리 기능을 수행하는 Cobra Command 생성
func NewVMCmd() *cobra.Command <span class="cov8" title="1">{

        vmCmd := &amp;cobra.Command{
                Use:   "vm",
                Short: "This is a manageable command for vm",
                Long:  "This is a manageable command for vm",
        }

        //  Adds the commands for application.
        vmCmd.AddCommand(NewVMStartCmd())
        //vmCmd.AddCommand(NewVMControlCmd())
        vmCmd.AddCommand(NewVMListStatusCmd())
        vmCmd.AddCommand(NewVMGetStatusCmd())
        vmCmd.AddCommand(NewVMListCmd())
        vmCmd.AddCommand(NewVMGetCmd())
        vmCmd.AddCommand(NewVMTerminateCmd())
        vmCmd.AddCommand(NewVMListAllCmd())
        vmCmd.AddCommand(NewVMTerminateCSPCmd())

        return vmCmd
}</span>

// NewVMStartCmd - VM 시작 기능을 수행하는 Cobra Command 생성
func NewVMStartCmd() *cobra.Command <span class="cov8" title="1">{

        startCmd := &amp;cobra.Command{
                Use:   "start",
                Short: "This is start command for vm",
                Long:  "This is start command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">startCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        startCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return startCmd</span>
}

// NewVMControlCmd - VM 제어 기능을 수행하는 Cobra Command 생성
func NewVMControlCmd() *cobra.Command <span class="cov0" title="0">{

        controlCmd := &amp;cobra.Command{
                Use:   "control",
                Short: "This is control command for vm",
                Long:  "This is control command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if action == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --action parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)
                        logger.Debug("--action parameter value : ", action)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">controlCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        controlCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")
        controlCmd.PersistentFlags().StringVarP(&amp;action, "action", "a", "", "action name")

        return controlCmd</span>
}

// NewVMListStatusCmd - VM 상태 목록 기능을 수행하는 Cobra Command 생성
func NewVMListStatusCmd() *cobra.Command <span class="cov8" title="1">{

        listStatusCmd := &amp;cobra.Command{
                Use:   "liststatus",
                Short: "This is list status command for vm",
                Long:  "This is list status command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listStatusCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listStatusCmd</span>
}

// NewVMGetStatusCmd - VM 상태 조회 기능을 수행하는 Cobra Command 생성
func NewVMGetStatusCmd() *cobra.Command <span class="cov8" title="1">{

        getStatusCmd := &amp;cobra.Command{
                Use:   "getstatus",
                Short: "This is get status command for vm",
                Long:  "This is get status command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getStatusCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getStatusCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")

        return getStatusCmd</span>
}

// NewVMListCmd - VM 목록 기능을 수행하는 Cobra Command 생성
func NewVMListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for vm",
                Long:  "This is list command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewVMGetCmd - VM 조회 기능을 수행하는 Cobra Command 생성
func NewVMGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for vm",
                Long:  "This is get command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")

        return getCmd</span>
}

// NewVMTerminateCmd - VM 삭제 기능을 수행하는 Cobra Command 생성
func NewVMTerminateCmd() *cobra.Command <span class="cov8" title="1">{

        terminateCmd := &amp;cobra.Command{
                Use:   "terminate",
                Short: "This is terminate command for vm",
                Long:  "This is terminate command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">terminateCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        terminateCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")
        terminateCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return terminateCmd</span>
}

// NewVMListAllCmd - 관리 VM 목록 기능을 수행하는 Cobra Command 생성
func NewVMListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for vm",
                Long:  "This is list all command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewVMTerminateCSPCmd - 관리 VM 삭제 기능을 수행하는 Cobra Command 생성
func NewVMTerminateCSPCmd() *cobra.Command <span class="cov8" title="1">{

        terminateCSPCmd := &amp;cobra.Command{
                Use:   "terminatecsp",
                Short: "This is terminate csp command for vm",
                Long:  "This is terminate csp command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">terminateCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        terminateCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return terminateCSPCmd</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVMSpecCmd - VM Spec 관리 기능을 수행하는 Cobra Command 생성
func NewVMSpecCmd() *cobra.Command <span class="cov8" title="1">{

        vmSpecCmd := &amp;cobra.Command{
                Use:   "vmspec",
                Short: "This is a manageable command for vm spec",
                Long:  "This is a manageable command for vm spec",
        }

        //  Adds the commands for application.
        vmSpecCmd.AddCommand(NewVMSpecListCmd())
        vmSpecCmd.AddCommand(NewVMSpecGetCmd())
        vmSpecCmd.AddCommand(NewVMSpecListOrgCmd())
        vmSpecCmd.AddCommand(NewVMSpecGetOrgCmd())

        return vmSpecCmd
}</span>

// NewVMSpecListCmd - VM Spec 목록 기능을 수행하는 Cobra Command 생성
func NewVMSpecListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for vm spec",
                Long:  "This is list command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewVMSpecGetCmd - VM Spec 조회 기능을 수행하는 Cobra Command 생성
func NewVMSpecGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for vm spec",
                Long:  "This is get command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if specName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", specName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;specName, "name", "n", "", "spec name")

        return getCmd</span>
}

// NewVMSpecListOrgCmd - 클라우드의 원래 VM Spec 목록 기능을 수행하는 Cobra Command 생성
func NewVMSpecListOrgCmd() *cobra.Command <span class="cov8" title="1">{

        listOrgCmd := &amp;cobra.Command{
                Use:   "listorg",
                Short: "This is original list command for vm spec",
                Long:  "This is original list command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listOrgCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listOrgCmd</span>
}

// NewVMSpecGetOrgCmd - 클라우드의 원래 VM Spec 조회 기능을 수행하는 Cobra Command 생성
func NewVMSpecGetOrgCmd() *cobra.Command <span class="cov8" title="1">{

        getOrgCmd := &amp;cobra.Command{
                Use:   "getorg",
                Short: "This is original get command for vm spec",
                Long:  "This is original get command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if specName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", specName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getOrgCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getOrgCmd.PersistentFlags().StringVarP(&amp;specName, "name", "n", "", "spec name")

        return getOrgCmd</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVPCCmd - VPC 관리 기능을 수행하는 Cobra Command 생성
func NewVPCCmd() *cobra.Command <span class="cov8" title="1">{

        vpcCmd := &amp;cobra.Command{
                Use:   "vpc",
                Short: "This is a manageable command for vpc",
                Long:  "This is a manageable command for vpc",
        }

        //  Adds the commands for application.
        vpcCmd.AddCommand(NewVPCCreateCmd())
        vpcCmd.AddCommand(NewVPCListCmd())
        vpcCmd.AddCommand(NewVPCGetCmd())
        vpcCmd.AddCommand(NewVPCDeleteCmd())
        vpcCmd.AddCommand(NewVPCListAllCmd())
        vpcCmd.AddCommand(NewVPCDeleteCSPCmd())
        vpcCmd.AddCommand(NewSubnetAddCmd())
        vpcCmd.AddCommand(NewSubnetRemoveCmd())
        vpcCmd.AddCommand(NewSubnetRemoveCSPCmd())

        return vpcCmd
}</span>

// NewVPCCreateCmd - VPC 생성 기능을 수행하는 Cobra Command 생성
func NewVPCCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for vpc",
                Long:  "This is create command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewVPCListCmd - VPC 목록 기능을 수행하는 Cobra Command 생성
func NewVPCListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for vpc",
                Long:  "This is list command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewVPCGetCmd - VPC 조회 기능을 수행하는 Cobra Command 생성
func NewVPCGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for vpc",
                Long:  "This is get command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vpcName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;vpcName, "name", "n", "", "vpc name")

        return getCmd</span>
}

// NewVPCDeleteCmd - VPC 삭제 기능을 수행하는 Cobra Command 생성
func NewVPCDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for vpc",
                Long:  "This is delete command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vpcName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;vpcName, "name", "n", "", "vpc name")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return deleteCmd</span>
}

// NewVPCListAllCmd - 관리 VPC 목록 기능을 수행하는 Cobra Command 생성
func NewVPCListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for vpc",
                Long:  "This is list all command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewVPCDeleteCSPCmd - 관리 VPC 삭제 기능을 수행하는 Cobra Command 생성
func NewVPCDeleteCSPCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCSPCmd := &amp;cobra.Command{
                Use:   "deletecsp",
                Short: "This is delete csp command for vpc",
                Long:  "This is delete csp command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return deleteCSPCmd</span>
}

// NewSubnetAddCmd - Subnet 추가 기능을 수행하는 Cobra Command 생성
func NewSubnetAddCmd() *cobra.Command <span class="cov8" title="1">{

        addCmd := &amp;cobra.Command{
                Use:   "add-subnet",
                Short: "This is add command for vpc subnet",
                Long:  "This is add command for vpc subnet",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">addCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        addCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return addCmd</span>
}

// NewSubnetRemoveCmd - Subnet 삭제 기능을 수행하는 Cobra Command 생성
func NewSubnetRemoveCmd() *cobra.Command <span class="cov8" title="1">{

        removeCmd := &amp;cobra.Command{
                Use:   "remove-subnet",
                Short: "This is remove command for vpc subnet",
                Long:  "This is remove command for vpc subnet",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if subnetName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --sname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--vname parameter value : ", vpcName)
                        logger.Debug("--sname parameter value : ", subnetName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">removeCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        removeCmd.PersistentFlags().StringVarP(&amp;vpcName, "vname", "", "", "vpc name")
        removeCmd.PersistentFlags().StringVarP(&amp;subnetName, "sname", "", "", "subnet name")
        removeCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return removeCmd</span>
}

// NewSubnetRemoveCSPCmd - CSP Subnet 삭제 기능을 수행하는 Cobra Command 생성
func NewSubnetRemoveCSPCmd() *cobra.Command <span class="cov8" title="1">{

        removeCSPCmd := &amp;cobra.Command{
                Use:   "removecsp-subnet",
                Short: "This is remove csp command for vpc subnet",
                Long:  "This is remove csp command for vpc subnet",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--vname parameter value : ", vpcName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">removeCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        removeCSPCmd.PersistentFlags().StringVarP(&amp;vpcName, "vname", "", "", "vpc name")
        removeCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return removeCSPCmd</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
