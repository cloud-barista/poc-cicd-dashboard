
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common-runtime: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime/CCMCommon.go (59.9%)</option>
				
				<option value="file1">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/cbconnection.go (0.0%)</option>
				
				<option value="file2">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/cbmessage.go (73.8%)</option>
				
				<option value="file3">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/cbserver.go (34.8%)</option>
				
				<option value="file4">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common/grpcstatuserr.go (0.0%)</option>
				
				<option value="file5">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config/config.go (21.7%)</option>
				
				<option value="file6">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config/parser.go (37.5%)</option>
				
				<option value="file7">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog/client_interceptors.go (0.0%)</option>
				
				<option value="file8">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog/server_interceptors.go (55.0%)</option>
				
				<option value="file9">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt/auth.go (0.0%)</option>
				
				<option value="file10">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt/client_interceptors.go (0.0%)</option>
				
				<option value="file11">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt/server_interceptors.go (0.0%)</option>
				
				<option value="file12">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/jaegertracer/jaegertracer.go (0.0%)</option>
				
				<option value="file13">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger/logger.go (33.3%)</option>
				
				<option value="file14">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/connection.go (81.8%)</option>
				
				<option value="file15">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/credential.go (81.8%)</option>
				
				<option value="file16">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/driver.go (81.8%)</option>
				
				<option value="file17">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/image.go (82.9%)</option>
				
				<option value="file18">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/keypair.go (82.8%)</option>
				
				<option value="file19">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/os.go (100.0%)</option>
				
				<option value="file20">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/region.go (81.8%)</option>
				
				<option value="file21">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/security.go (81.5%)</option>
				
				<option value="file22">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/ssh.go (90.0%)</option>
				
				<option value="file23">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/vm.go (83.9%)</option>
				
				<option value="file24">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/vmspec.go (83.3%)</option>
				
				<option value="file25">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/service/vpc.go (82.6%)</option>
				
				<option value="file26">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider/cbspider.pb.go (59.3%)</option>
				
				<option value="file27">github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/gogoproto/gogo.pb.go (100.0%)</option>
				
				<option value="file28">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/CBSpiderRuntime.go (38.2%)</option>
				
				<option value="file29">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/CCMRest.go (83.1%)</option>
				
				<option value="file30">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/CIMRest.go (86.6%)</option>
				
				<option value="file31">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/SSHRUNRest.go (81.8%)</option>
				
				<option value="file32">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb-CCM-MGMT.go (0.0%)</option>
				
				<option value="file33">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb-CCM.go (0.0%)</option>
				
				<option value="file34">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb-CIM.go (0.0%)</option>
				
				<option value="file35">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web/AdminWeb.go (0.7%)</option>
				
				<option value="file36">github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/docs/docs.go (8.3%)</option>
				
				<option value="file37">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/CloudDriverHandler_static.go (38.1%)</option>
				
				<option value="file38">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/calllogger.go (61.0%)</option>
				
				<option value="file39">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/config.go (70.6%)</option>
				
				<option value="file40">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/formatter/formatter.go (0.0%)</option>
				
				<option value="file41">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/AlibabaDriver.go (0.0%)</option>
				
				<option value="file42">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go (4.8%)</option>
				
				<option value="file43">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/CommonAlibabaFunc.go (0.0%)</option>
				
				<option value="file44">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file45">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file46">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file47">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/VMHandler.go (0.3%)</option>
				
				<option value="file48">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file49">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file50">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/AwsDriver.go (0.0%)</option>
				
				<option value="file51">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go (4.8%)</option>
				
				<option value="file52">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/CommonAwsFunc.go (0.0%)</option>
				
				<option value="file53">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file54">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file55">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file56">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/VMHandler.go (0.3%)</option>
				
				<option value="file57">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file58">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file59">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/AzureDriver.go (0.0%)</option>
				
				<option value="file60">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/connect/Azure_CloudConnection.go (4.8%)</option>
				
				<option value="file61">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/CommonAzureFunc.go (0.0%)</option>
				
				<option value="file62">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file63">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file64">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file65">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/VMHandler.go (0.0%)</option>
				
				<option value="file66">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file67">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file68">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/ClouditDriver.go (0.0%)</option>
				
				<option value="file69">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/RestClient.go (0.8%)</option>
				
				<option value="file70">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/image/Request.go (2.9%)</option>
				
				<option value="file71">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/nic/Request.go (2.8%)</option>
				
				<option value="file72">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/server/Request.go (2.0%)</option>
				
				<option value="file73">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/specs/Request.go (10.0%)</option>
				
				<option value="file74">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/adaptiveip/Request.go (2.3%)</option>
				
				<option value="file75">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/subnet/Request.go (2.3%)</option>
				
				<option value="file76">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup/Request.go (1.5%)</option>
				
				<option value="file77">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/connect/Cloudit_CloudConnection.go (4.8%)</option>
				
				<option value="file78">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/CommonClouditFunc.go (0.0%)</option>
				
				<option value="file79">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file80">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file81">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file82">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/VMHandler.go (0.0%)</option>
				
				<option value="file83">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file84">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file85">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/DockerDriver.go (4.8%)</option>
				
				<option value="file86">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/connect/DockerCloudConnection.go (4.3%)</option>
				
				<option value="file87">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/resources/ImageHandler.go (1.5%)</option>
				
				<option value="file88">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/resources/VMHandler.go (0.0%)</option>
				
				<option value="file89">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/GCPDriver.go (0.0%)</option>
				
				<option value="file90">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go (4.8%)</option>
				
				<option value="file91">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/CommonHandler.go (0.0%)</option>
				
				<option value="file92">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/ImageHandler.go (0.5%)</option>
				
				<option value="file93">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file94">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file95">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/VMHandler.go (0.0%)</option>
				
				<option value="file96">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file97">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file98">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/MockDriver.go (31.2%)</option>
				
				<option value="file99">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/connect/MockCloudConnection.go (76.0%)</option>
				
				<option value="file100">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/ImageHandler.go (85.4%)</option>
				
				<option value="file101">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/KeyPairHandler.go (83.3%)</option>
				
				<option value="file102">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/SecurityHandler.go (85.4%)</option>
				
				<option value="file103">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/VMHandler.go (70.6%)</option>
				
				<option value="file104">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/VMSpecHandler.go (88.9%)</option>
				
				<option value="file105">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources/VPCHandler.go (81.4%)</option>
				
				<option value="file106">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/OpenStackDriver.go (0.0%)</option>
				
				<option value="file107">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go (4.8%)</option>
				
				<option value="file108">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/CommonOpenStackFunc.go (0.0%)</option>
				
				<option value="file109">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file110">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file111">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file112">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/VMHandler.go (0.0%)</option>
				
				<option value="file113">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file114">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file115">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/TencentDriver.go (1.8%)</option>
				
				<option value="file116">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go (4.8%)</option>
				
				<option value="file117">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/CommonTencentFunc.go (0.0%)</option>
				
				<option value="file118">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/ImageHandler.go (0.0%)</option>
				
				<option value="file119">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/KeyPairHandler.go (0.0%)</option>
				
				<option value="file120">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/SecurityHandler.go (0.0%)</option>
				
				<option value="file121">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/VMHandler.go (0.3%)</option>
				
				<option value="file122">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/VMSpecHandler.go (0.0%)</option>
				
				<option value="file123">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources/VPCHandler.go (0.0%)</option>
				
				<option value="file124">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/iid-manager/IIDManager.go (68.1%)</option>
				
				<option value="file125">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/iid-manager/InfoStore.go (81.1%)</option>
				
				<option value="file126">github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/vm-ssh/sshrun.go (1.6%)</option>
				
				<option value="file127">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/CloudOSList.go (71.4%)</option>
				
				<option value="file128">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager/ConnectionConfigInfoManager.go (75.9%)</option>
				
				<option value="file129">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager/InfoStore.go (84.2%)</option>
				
				<option value="file130">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager/CredentialInfoManager.go (76.3%)</option>
				
				<option value="file131">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager/InfoStore.go (80.9%)</option>
				
				<option value="file132">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager/DriverInfoManager.go (78.7%)</option>
				
				<option value="file133">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager/InfoStore.go (85.0%)</option>
				
				<option value="file134">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager/InfoStore.go (80.9%)</option>
				
				<option value="file135">github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager/RegionInfoManager.go (79.1%)</option>
				
				<option value="file136">github.com/cloud-barista/poc-cicd-spider/interface/api/ccm.go (81.6%)</option>
				
				<option value="file137">github.com/cloud-barista/poc-cicd-spider/interface/api/cim.go (78.8%)</option>
				
				<option value="file138">github.com/cloud-barista/poc-cicd-spider/interface/api/request/connection.go (76.2%)</option>
				
				<option value="file139">github.com/cloud-barista/poc-cicd-spider/interface/api/request/credential.go (76.2%)</option>
				
				<option value="file140">github.com/cloud-barista/poc-cicd-spider/interface/api/request/driver.go (76.2%)</option>
				
				<option value="file141">github.com/cloud-barista/poc-cicd-spider/interface/api/request/image.go (75.0%)</option>
				
				<option value="file142">github.com/cloud-barista/poc-cicd-spider/interface/api/request/keypair.go (75.0%)</option>
				
				<option value="file143">github.com/cloud-barista/poc-cicd-spider/interface/api/request/os.go (83.3%)</option>
				
				<option value="file144">github.com/cloud-barista/poc-cicd-spider/interface/api/request/region.go (76.2%)</option>
				
				<option value="file145">github.com/cloud-barista/poc-cicd-spider/interface/api/request/security.go (75.0%)</option>
				
				<option value="file146">github.com/cloud-barista/poc-cicd-spider/interface/api/request/ssh.go (75.0%)</option>
				
				<option value="file147">github.com/cloud-barista/poc-cicd-spider/interface/api/request/vm.go (75.0%)</option>
				
				<option value="file148">github.com/cloud-barista/poc-cicd-spider/interface/api/request/vmspec.go (76.0%)</option>
				
				<option value="file149">github.com/cloud-barista/poc-cicd-spider/interface/api/request/vpc.go (75.0%)</option>
				
				<option value="file150">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/connection.go (84.6%)</option>
				
				<option value="file151">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/credential.go (84.6%)</option>
				
				<option value="file152">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/driver.go (84.6%)</option>
				
				<option value="file153">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/gclient.go (79.7%)</option>
				
				<option value="file154">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/image.go (78.2%)</option>
				
				<option value="file155">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/keypair.go (78.0%)</option>
				
				<option value="file156">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/os.go (100.0%)</option>
				
				<option value="file157">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/region.go (84.6%)</option>
				
				<option value="file158">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/root.go (100.0%)</option>
				
				<option value="file159">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/security.go (78.0%)</option>
				
				<option value="file160">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/ssh.go (46.7%)</option>
				
				<option value="file161">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/version.go (66.7%)</option>
				
				<option value="file162">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/vm.go (65.9%)</option>
				
				<option value="file163">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/vmspec.go (76.9%)</option>
				
				<option value="file164">github.com/cloud-barista/poc-cicd-spider/interface/cli/spider/cmd/vpc.go (76.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Cloud Control Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package commonruntime

import (
        "fmt"
        "strconv"
        "strings"
        "sync"
        "time"

        ccm "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        iidm "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/iid-manager"
        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
)

// define string of resource types
const (
        rsImage string = "image"
        rsVPC   string = "vpc"
        // rsSubnet = SUBNET:{VPC NameID} =&gt; cook in code
        rsSG  string = "sg"
        rsKey string = "keypair"
        rsVM  string = "vm"
)

// definition of RWLock for each Resource Ops
var imgRWLock = new(sync.RWMutex)
var vpcRWLock = new(sync.RWMutex)
var sgRWLock = new(sync.RWMutex)
var keyRWLock = new(sync.RWMutex)
var vmRWLock = new(sync.RWMutex)

// definition of IIDManager RWLock
var iidRWLock = new(iidm.IIDRWLOCK)

var cblog *logrus.Logger
var callogger *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
        // logger for HisCall
        callogger = call.GetLogger("HISCALL")
}</span>

type AllResourceList struct {
        AllList struct {
                MappedList     []*cres.IID `json:"MappedList"`
                OnlySpiderList []*cres.IID `json:"OnlySpiderList"`
                OnlyCSPList    []*cres.IID `json:"OnlyCSPList"`
        }
}

//================ Image Handler
// @todo
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateImage(connectionName string, rsType string, reqInfo cres.ImageReqInfo) (*cres.ImageInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">imgRWLock.Lock()
        defer imgRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(reqInfo.IId.NameId + " already exists!")
        }</span>

        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateImage(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) insert IID
        <span class="cov8" title="1">iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteImage(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, err2
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListImage(connectionName string, rsType string) ([]*cres.ImageInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">infoList, err := handler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if infoList == nil || len(infoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.ImageInfo{}
        }</span>

        <span class="cov8" title="1">return infoList, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListRegisterImage(connectionName string, rsType string) ([]*cres.ImageInfo, error) <span class="cov0" title="0">{
        cblog.Info("call ListImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">imgRWLock.RLock()
        defer imgRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var infoList []*cres.ImageInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.ImageInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov0" title="0">infoList, err = handler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov0" title="0">infoList2 := []*cres.ImageInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov0" title="0">{
                exist := false
                for _, info := range infoList </span><span class="cov0" title="0">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov0" title="0">{
                                info.IId.NameId = iidInfo.IId.NameId
                                infoList2 = append(infoList2, info)
                                exist = true
                        }</span>
                }
                <span class="cov0" title="0">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov0" title="0">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetImage(connectionName string, rsType string, nameID string) (*cres.ImageInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // now, NameID = SystemID
        <span class="cov8" title="1">info, err := handler.GetImage(cres.IID{nameID, nameID})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetRegisterImage(connectionName string, rsType string, nameID string) (*cres.ImageInfo, error) <span class="cov0" title="0">{
        cblog.Info("call GetImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">imgRWLock.RLock()
        defer imgRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov0" title="0">start := time.Now()
        info, err := handler.GetImage(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">elapsed := time.Since(start)
        cblog.Infof(connectionName+" : elapsed %d", elapsed.Nanoseconds()/1000000) // msec

        // (3) set ResourceInfo(IID.NameId)
        info.IId.NameId = iidInfo.IId.NameId

        return &amp;info, nil</span>
}

// (1) get IID(NameId)
// (2) delete Resource(SystemId)
// (3) delete IID
func DeleteImage(connectionName string, rsType string, nameID string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteImage()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateImageHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">imgRWLock.Lock()
        defer imgRWLock.Unlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        // keeping for rollback
        <span class="cov8" title="1">info, err := handler.GetImage(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        // (2) delete Resource(SystemId)
        <span class="cov8" title="1">result, err := handler.DeleteImage(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>
        <span class="cov8" title="1">if result == false </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // (3) delete IID
        <span class="cov8" title="1">_, err = iidRWLock.DeleteIID(connectionName, rsType, iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                reqInfo := cres.ImageReqInfo{info.IId} // @todo
                _, err2 := handler.CreateImage(reqInfo)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return false, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

//================ VMSpec Handler
func ListVMSpec(connectionName string) ([]*cres.VMSpecInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">infoList, err := handler.ListVMSpec(regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if infoList == nil || len(infoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VMSpecInfo{}
        }</span>

        <span class="cov8" title="1">return infoList, nil</span>
}

func GetVMSpec(connectionName string, nameID string) (*cres.VMSpecInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">info, err := handler.GetVMSpec(regionName, nameID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

func ListOrgVMSpec(connectionName string) (string, error) <span class="cov8" title="1">{
        cblog.Info("call ListOrgVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">infoList, err := handler.ListOrgVMSpec(regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return infoList, nil</span>
}

func GetOrgVMSpec(connectionName string, nameID string) (string, error) <span class="cov8" title="1">{
        cblog.Info("call GetOrgVMSpec()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">regionName, _, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMSpecHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>
        <span class="cov8" title="1">info, err := handler.GetOrgVMSpec(regionName, nameID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

//================ VPC Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateVPC(connectionName string, rsType string, reqInfo cres.VPCReqInfo) (*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateVPC()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.Lock()
        defer vpcRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>
        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateVPC(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">info.IId.NameId = reqInfo.IId.NameId

        // (3) insert IID
        // for VPC
        iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteVPC(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        // for Subnet list
        <span class="cov8" title="1">for _, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                // key-value structure: /{ConnectionName}/{VPC-NameId}/{Subnet-IId}
                _, err := iidRWLock.CreateIID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        // rollback
                        // (1) for resource
                        cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-CSP&gt;&gt; " + info.IId.SystemId)
                        _, err2 := handler.DeleteVPC(iidInfo.IId)
                        if err2 != nil </span><span class="cov0" title="0">{
                                cblog.Error(err2)
                                return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                        }</span>
                        // (2) for VPC IID
                        <span class="cov0" title="0">cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-IID&gt;&gt; " + info.IId.NameId)
                        _, err3 := iidRWLock.DeleteIID(connectionName, rsType, info.IId)
                        if err3 != nil </span><span class="cov0" title="0">{
                                cblog.Error(err3)
                                return nil, fmt.Errorf(err.Error() + ", " + err3.Error())
                        }</span>
                        // (3) for Subnet IID
                        <span class="cov0" title="0">tmpIIdInfoList, err := iidRWLock.ListIID(connectionName, SUBNET_PREFIX+info.IId.NameId)
                        for _, subnetInfo := range tmpIIdInfoList </span><span class="cov0" title="0">{
                                _, err := iidRWLock.DeleteIID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListVPC(connectionName string, rsType string) ([]*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVPC()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.RLock()
        defer vpcRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.VPCInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VPCInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.VPCInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{

                                //+++++++++++++++++++++++++++++++++++++++++++
                                // set ResourceInfo(IID.NameId)
                                // set VPC NameId
                                IIdInfo, err := iidRWLock.GetIIDbySystemID(connectionName, rsType, info.IId)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">info.IId.NameId = IIdInfo.IId.NameId
                                //+++++++++++++++++++++++++++++++++++++++++++
                                // set NameId for SubnetInfo List
                                // create new SubnetInfo List
                                subnetInfoList := []cres.SubnetInfo{}
                                for _, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                                        subnetIIDInfo, err := iidRWLock.GetIIDbySystemID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                                        if err != nil </span><span class="cov0" title="0">{
                                                cblog.Error(err)
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">if subnetIIDInfo.IId.NameId != "" </span><span class="cov8" title="1">{ // insert only this user created.
                                                subnetInfo.IId.NameId = subnetIIDInfo.IId.NameId
                                                subnetInfoList = append(subnetInfoList, subnetInfo)
                                        }</span>

                                }
                                <span class="cov8" title="1">info.SubnetInfoList = subnetInfoList

                                infoList2 = append(infoList2, info)
                                exist = true</span>
                        }
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetVPC(connectionName string, rsType string, nameID string) (*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetVPC()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.RLock()
        defer vpcRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetVPC(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        // (3) set ResourceInfo(IID.NameId)
        <span class="cov8" title="1">info.IId.NameId = iidInfo.IId.NameId

        // set NameId for SubnetInfo List
        // create new SubnetInfo List
        subnetInfoList := []cres.SubnetInfo{}
        for i, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                subnetIIDInfo, err := iidRWLock.GetIIDbySystemID(connectionName, SUBNET_PREFIX+info.IId.NameId, subnetInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">if subnetIIDInfo.IId.NameId != "" </span><span class="cov8" title="1">{ // insert only this user created.
                        info.SubnetInfoList[i].IId.NameId = subnetIIDInfo.IId.NameId
                        subnetInfoList = append(subnetInfoList, info.SubnetInfoList[i])
                }</span>
        }
        <span class="cov8" title="1">info.SubnetInfoList = subnetInfoList

        return &amp;info, nil</span>
}

// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func AddSubnet(connectionName string, rsType string, vpcName string, reqInfo cres.SubnetInfo) (*cres.VPCInfo, error) <span class="cov8" title="1">{
        cblog.Info("call AddSubnet()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVPCHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcRWLock.Lock()
        defer vpcRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>
        // (2) create Resource
        <span class="cov8" title="1">iidVPCInfo, err := iidRWLock.GetIID(connectionName, rsVPC, cres.IID{vpcName, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">info, err := handler.AddSubnet(iidVPCInfo.IId, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) insert IID
        // for Subnet list
        <span class="cov8" title="1">for _, subnetInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                if subnetInfo.IId.NameId == reqInfo.IId.NameId </span><span class="cov8" title="1">{
                        // key-value structure: /{ConnectionName}/{VPC-NameId}/{Subnet-IId}
                        _, err := iidRWLock.CreateIID(connectionName, SUBNET_PREFIX+iidVPCInfo.IId.NameId, subnetInfo.IId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                // rollback
                                // (1) for resource
                                cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-SUBNET-CSP&gt;&gt; " + subnetInfo.IId.SystemId)
                                _, err2 := handler.RemoveSubnet(iidVPCInfo.IId, subnetInfo.IId)
                                if err2 != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err2)
                                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                                }</span>
                                // (2) for Subnet IID
                                <span class="cov0" title="0">cblog.Info("&lt;&lt;ROLLBACK:TRY:VPC-SUBNET-IID&gt;&gt; " + subnetInfo.IId.NameId)
                                _, err3 := iidRWLock.DeleteIID(connectionName, SUBNET_PREFIX+iidVPCInfo.IId.NameId, subnetInfo.IId)
                                if err3 != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err3)
                                        return nil, fmt.Errorf(err.Error() + ", " + err3.Error())
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                }
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

//================ SecurityGroup Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateSecurity(connectionName string, rsType string, reqInfo cres.SecurityReqInfo) (*cres.SecurityInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateSecurity()")

        //+++++++++++++++++++++++++++++++++++++++++++
        // set VPC SystemId
        vpcIIDInfo, err := iidRWLock.GetIID(connectionName, rsVPC, reqInfo.VpcIID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">reqInfo.VpcIID.SystemId = vpcIIDInfo.IId.SystemId
        //+++++++++++++++++++++++++++++++++++++++++++

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateSecurityHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">sgRWLock.Lock()
        defer sgRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>

        // if no CIDR in input rules, set default ("0.0.0.0/0")
        <span class="cov8" title="1">for n, _ := range *reqInfo.SecurityRules </span><span class="cov8" title="1">{
                if (*reqInfo.SecurityRules)[n].CIDR == "" </span><span class="cov0" title="0">{
                        (*reqInfo.SecurityRules)[n].CIDR = "0.0.0.0/0"
                }</span>
        }

        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateSecurity(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // set VPC NameId
        <span class="cov8" title="1">info.VpcIID.NameId = reqInfo.VpcIID.NameId
        info.VpcIID.SystemId = reqInfo.VpcIID.SystemId

        // (3) insert IID
        iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteSecurity(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // set ResourceInfo(IID.NameId)
        // iidInfo.IId.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">vpc_sg_nameid := strings.Split(info.IId.NameId, SG_DELIMITER)
        info.IId.NameId = vpc_sg_nameid[1]

        return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListSecurity(connectionName string, rsType string) ([]*cres.SecurityInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListSecurity()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateSecurityHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">sgRWLock.RLock()
        defer sgRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.SecurityInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.SecurityInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.SecurityInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{

                                // set ResourceInfo(IID.NameId)
                                // iidInfo.IId.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
                                vpc_sg_nameid := strings.Split(iidInfo.IId.NameId, SG_DELIMITER)
                                info.VpcIID.NameId = vpc_sg_nameid[0]
                                info.IId.NameId = vpc_sg_nameid[1]

                                // set VPC SystemId
                                vpcIIDInfo, err := iidRWLock.GetIID(connectionName, rsVPC, info.VpcIID)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">info.VpcIID.SystemId = vpcIIDInfo.IId.SystemId

                                infoList2 = append(infoList2, info)
                                exist = true</span>
                        }
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetSecurity(connectionName string, rsType string, nameID string) (*cres.SecurityInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetSecurity()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateSecurityHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">sgRWLock.RLock()
        defer sgRWLock.RUnlock()
        // (1) get IID(NameId)
        // SG NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        iidInfo, err := iidRWLock.FindIID(connectionName, rsType, nameID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetSecurity(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) set ResourceInfo(IID.NameId)
        // set ResourceInfo(IID.NameId)
        // iidInfo.IId.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">vpc_sg_nameid := strings.Split(iidInfo.IId.NameId, SG_DELIMITER)
        info.VpcIID.NameId = vpc_sg_nameid[0]
        info.IId.NameId = vpc_sg_nameid[1]

        // set VPC SystemId
        vpcIIDInfo, err := iidRWLock.GetIID(connectionName, rsVPC, info.VpcIID)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">info.VpcIID.SystemId = vpcIIDInfo.IId.SystemId

        return &amp;info, nil</span>
}

//================ KeyPair Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func CreateKey(connectionName string, rsType string, reqInfo cres.KeyPairReqInfo) (*cres.KeyPairInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateKey()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateKeyPairHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">keyRWLock.Lock()
        defer keyRWLock.Unlock()
        // (1) check exist(NameID)
        bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(reqInfo.IId.NameId + " already exists!")
        }</span>

        // (2) create Resource
        <span class="cov8" title="1">info, err := handler.CreateKey(reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) insert IID
        <span class="cov8" title="1">iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.DeleteKey(iidInfo.IId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListKey(connectionName string, rsType string) ([]*cres.KeyPairInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListKey()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateKeyPairHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">keyRWLock.RLock()
        defer keyRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.KeyPairInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.KeyPairInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListKey()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.KeyPairInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{
                                infoList2 = append(infoList2, info)
                                exist = true
                        }</span>
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetKey(connectionName string, rsType string, nameID string) (*cres.KeyPairInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetKey()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateKeyPairHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">keyRWLock.RLock()
        defer keyRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetKey(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) set ResourceInfo(IID.NameId)
        <span class="cov8" title="1">info.IId.NameId = iidInfo.IId.NameId

        return &amp;info, nil</span>
}

func getSetSystemId(ConnectionName string, reqInfo *cres.VMReqInfo) error <span class="cov8" title="1">{

        // set Image SystemId
        // @todo before Image Handling by powerkim
        reqInfo.ImageIID.SystemId = reqInfo.ImageIID.NameId

        // set VPC SystemId
        if reqInfo.VpcIID.NameId != "" </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, rsVPC, reqInfo.VpcIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.VpcIID.SystemId = IIdInfo.IId.SystemId</span>
        }

        // set Subnet SystemId
        <span class="cov8" title="1">if reqInfo.SubnetIID.NameId != "" </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, SUBNET_PREFIX+reqInfo.VpcIID.NameId, reqInfo.SubnetIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.SubnetIID.SystemId = IIdInfo.IId.SystemId</span>
        }

        // set SecurityGroups SystemId
        <span class="cov8" title="1">for i, sgIID := range reqInfo.SecurityGroupIIDs </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, rsSG, sgIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.SecurityGroupIIDs[i].SystemId = IIdInfo.IId.SystemId</span>
        }

        // set KeyPair SystemId
        <span class="cov8" title="1">if reqInfo.KeyPairIID.NameId != "" </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIID(ConnectionName, rsKey, reqInfo.KeyPairIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.KeyPairIID.SystemId = IIdInfo.IId.SystemId</span>
        }

        <span class="cov8" title="1">return nil</span>
}

//================ VM Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func StartVM(connectionName string, rsType string, reqInfo cres.VMReqInfo) (*cres.VMInfo, error) <span class="cov8" title="1">{
        cblog.Info("call StartVM()")

        // get &amp; set SystemId
        err := getSetSystemId(connectionName, &amp;reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // vmRWLock.Lock() @todo undo this until supporting async call. by powerkim, 2020.05.10
        // defer vmRWLock.Unlock() @todo undo this until supporting async call. by powerkim, 2020.05.10
        // (1) check exist(NameID)
        <span class="cov8" title="1">bool_ret, err := iidRWLock.IsExistIID(connectionName, rsType, reqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if bool_ret == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(rsType + "-" + reqInfo.IId.NameId + " already exists!")
        }</span>

        <span class="cov8" title="1">providerName, err := ccm.GetProviderNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">regionName, zoneName, err := ccm.GetRegionNameByConnectionName(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">callInfo := call.CLOUDLOGSCHEMA {
                CloudOS: call.CLOUD_OS(providerName),
                RegionZone: regionName + "/" + zoneName,
                ResourceType: call.VM,
                ResourceName: reqInfo.IId.NameId,
                CloudOSAPI: "CB-Spider:StartVM()",
                ElapsedTime: "",
                ErrorMSG: "",
        }
        start := call.Start()
        // (2) create Resource
        info, err := handler.StartVM(reqInfo)
        callInfo.ElapsedTime = call.Elapsed(start)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                callInfo.ErrorMSG = err.Error()
                return nil, err
        }</span>
        <span class="cov8" title="1">callogger.Info(call.String(callInfo))

        // set NameId for info by reqInfo
        setNameId(connectionName, &amp;info, &amp;reqInfo)

        // (3) insert IID
        iidInfo, err := iidRWLock.CreateIID(connectionName, rsType, info.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                // rollback
                _, err2 := handler.TerminateVM(iidInfo.IId) // @todo check validation
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err2)
                        return nil, fmt.Errorf(err.Error() + ", " + err2.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // set sg NameId from VPCNameId-SecurityGroupNameId
        // IID.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">for i, sgIID := range info.SecurityGroupIIds </span><span class="cov8" title="1">{
                vpc_sg_nameid := strings.Split(sgIID.NameId, SG_DELIMITER)
                info.SecurityGroupIIds[i].NameId = vpc_sg_nameid[1]
        }</span>

        // current: Assume 22 port, except Cloud-Twin, by powerkim, 2021.03.24.
        <span class="cov8" title="1">if info.SSHAccessPoint == "" </span><span class="cov8" title="1">{
                info.SSHAccessPoint = info.PublicIP + ":22"
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

func setNameId(ConnectionName string, vmInfo *cres.VMInfo, reqInfo *cres.VMReqInfo) error <span class="cov8" title="1">{

        // set Image SystemId
        // @todo before Image Handling by powerkim
        if reqInfo.ImageIID.NameId != "" </span><span class="cov8" title="1">{
                vmInfo.ImageIId.NameId = reqInfo.ImageIID.NameId
        }</span>

        // set VPC SystemId
        <span class="cov8" title="1">if reqInfo.VpcIID.NameId != "" </span><span class="cov8" title="1">{
                vmInfo.VpcIID.NameId = reqInfo.VpcIID.NameId
        }</span>

        <span class="cov8" title="1">if reqInfo.SubnetIID.NameId != "" </span><span class="cov8" title="1">{
                // set Subnet SystemId
                vmInfo.SubnetIID.NameId = reqInfo.SubnetIID.NameId
        }</span>

        <span class="cov8" title="1">vmInfo.SecurityGroupIIds = reqInfo.SecurityGroupIIDs

        // set SecurityGroups SystemId
        for i, sgIID := range reqInfo.SecurityGroupIIDs </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsSG, sgIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">reqInfo.SecurityGroupIIDs[i].NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">if reqInfo.KeyPairIID.NameId != "" </span><span class="cov8" title="1">{
                // set KeyPair SystemId
                vmInfo.KeyPairIId.NameId = reqInfo.KeyPairIID.NameId
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
func ListVM(connectionName string, rsType string) ([]*cres.VMInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVM()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.VMInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VMInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">infoList, err = handler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.VMInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{

                                //+++++++++++++++++++++++++++++++++++++++++++
                                // set ResourceInfo(IID.NameId)
                                // set VPC NameId
                                IIdInfo, err := iidRWLock.GetIIDbySystemID(connectionName, rsType, info.IId)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">info.IId.NameId = IIdInfo.IId.NameId
                                //+++++++++++++++++++++++++++++++++++++++++++
                                err = getSetNameId(connectionName, info)
                                if err != nil </span><span class="cov0" title="0">{
                                        cblog.Error(err)
                                        return nil, err
                                }</span>

                                // set sg NameId from VPCNameId-SecurityGroupNameId
                                // IID.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
                                <span class="cov8" title="1">for i, sgIID := range info.SecurityGroupIIds </span><span class="cov8" title="1">{
                                        vpc_sg_nameid := strings.Split(sgIID.NameId, SG_DELIMITER)
                                        info.SecurityGroupIIds[i].NameId = vpc_sg_nameid[1]
                                }</span>

                                // current: Assume 22 port, except Cloud-Twin, by powerkim, 2021.03.24.
                                <span class="cov8" title="1">if info.SSHAccessPoint == "" </span><span class="cov8" title="1">{
                                        info.SSHAccessPoint = info.PublicIP + ":22"
                                }</span>

                                <span class="cov8" title="1">infoList2 = append(infoList2, info)
                                exist = true</span>
                        }
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

func getSetNameId(ConnectionName string, vmInfo *cres.VMInfo) error <span class="cov8" title="1">{

        // set Image NameId
        // @todo before Image Handling by powerkim
        //vmInfo.ImageIId.NameId = vmInfo.ImageIId.SystemId

        if vmInfo.VpcIID.SystemId != "" </span><span class="cov8" title="1">{
                // set VPC NameId
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsVPC, vmInfo.VpcIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.VpcIID.NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">if vmInfo.SubnetIID.SystemId != "" </span><span class="cov8" title="1">{
                // set Subnet NameId
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, SUBNET_PREFIX+vmInfo.VpcIID.NameId, vmInfo.SubnetIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.SubnetIID.NameId = IIdInfo.IId.NameId</span>
        }

        // set SecurityGroups NameId
        <span class="cov8" title="1">for i, sgIID := range vmInfo.SecurityGroupIIds </span><span class="cov8" title="1">{
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsSG, sgIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.SecurityGroupIIds[i].NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">if vmInfo.KeyPairIId.SystemId != "" </span><span class="cov8" title="1">{
                // set KeyPair NameId
                IIdInfo, err := iidRWLock.GetIIDbySystemID(ConnectionName, rsKey, vmInfo.KeyPairIId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">vmInfo.KeyPairIId.NameId = IIdInfo.IId.NameId</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// (1) get IID(NameId)
// (2) get resource(SystemId)
// (3) set ResourceInfo(IID.NameId)
func GetVM(connectionName string, rsType string, nameID string) (*cres.VMInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetVM()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (2) get resource(SystemId)
        <span class="cov8" title="1">info, err := handler.GetVM(iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // (3) set ResourceInfo(IID.NameId)
        <span class="cov8" title="1">info.IId.NameId = iidInfo.IId.NameId

        err = getSetNameId(connectionName, &amp;info)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // set sg NameId from VPCNameId-SecurityGroupNameId
        // IID.NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
        <span class="cov8" title="1">for i, sgIID := range info.SecurityGroupIIds </span><span class="cov8" title="1">{
                vpc_sg_nameid := strings.Split(sgIID.NameId, SG_DELIMITER)
                info.SecurityGroupIIds[i].NameId = vpc_sg_nameid[1]
        }</span>

        // current: Assume 22 port, except Cloud-Twin, by powerkim, 2021.03.24.
        <span class="cov8" title="1">if info.SSHAccessPoint == "" </span><span class="cov0" title="0">{
                info.SSHAccessPoint = info.PublicIP + ":22"
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// (1) get IID:list
// (2) get CSP:VMStatuslist
// (3) filtering CSP-VMStatuslist by IID-list
func ListVMStatus(connectionName string, rsType string) ([]*cres.VMStatusInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListVMStatus()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID:list
        iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var infoList []*cres.VMStatusInfo
        if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                infoList = []*cres.VMStatusInfo{}
                return infoList, nil
        }</span>

        // (2) get CSP:VMStatuslist
        <span class="cov8" title="1">infoList, err = handler.ListVMStatus()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if infoList == nil </span><span class="cov0" title="0">{ // if iidInfoList not null, then infoList has any list.
                return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + " IID List has " + strconv.Itoa(len(iidInfoList)) + ", but " + connectionName + " Resource list has nothing!")
        }</span>

        // (3) filtering CSP-VMStatuslist by IID-list
        <span class="cov8" title="1">infoList2 := []*cres.VMStatusInfo{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, info := range infoList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == info.IId.SystemId </span><span class="cov8" title="1">{
                                info.IId.NameId = iidInfo.IId.NameId
                                infoList2 = append(infoList2, info)
                                exist = true
                        }</span>
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        cblog.Info("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                        //return nil, fmt.Errorf("&lt;IID-CSP mismatch&gt; " + rsType + "-" + iidInfo.IId.NameId + ":" + iidInfo.IId.SystemId + " exsits. but " + connectionName + " does not have!")
                }</span>
        }

        <span class="cov8" title="1">return infoList2, nil</span>
}

// (1) get IID(NameId)
// (2) get CSP:VMStatus(SystemId)
func GetVMStatus(connectionName string, rsType string, nameID string) (cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call GetVMStatus()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        // (2) get CSP:VMStatus(SystemId)
        <span class="cov8" title="1">info, err := handler.GetVMStatus(iidInfo.IId) // type of info =&gt; string
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

// (1) get IID(NameId)
// (2) control CSP:VM(SystemId)
func ControlVM(connectionName string, rsType string, nameID string, action string) (cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call ControlVM()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">handler, err := cldConn.CreateVMHandler()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">vmRWLock.RLock()
        defer vmRWLock.RUnlock()
        // (1) get IID(NameId)
        iidInfo, err := iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        // (2) control CSP:VM(SystemId)
        <span class="cov8" title="1">vmIID := iidInfo.IId

        var info cres.VMStatus

        switch strings.ToLower(action) </span>{
        case "suspend":<span class="cov8" title="1">
                info, err = handler.SuspendVM(vmIID)</span>
        case "resume":<span class="cov8" title="1">
                info, err = handler.ResumeVM(vmIID)</span>
        case "reboot":<span class="cov8" title="1">
                info, err = handler.RebootVM(vmIID)</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf(action + " is not a valid action!!")</span>

        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

// list all Resources for management
// (1) get IID:list
// (2) get CSP:list
// (3) filtering CSP-list by IID-list
// (4) make MappedList, OnlySpiderList, OnlyCSPList
func ListAllResource(connectionName string, rsType string) (AllResourceList, error) <span class="cov8" title="1">{
        cblog.Info("call ListAllResource()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                return AllResourceList{}, err
        }</span>

        <span class="cov8" title="1">var handler interface{}

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                handler, err = cldConn.CreateVPCHandler()</span>
        case rsSG:<span class="cov8" title="1">
                handler, err = cldConn.CreateSecurityHandler()</span>
        case rsKey:<span class="cov8" title="1">
                handler, err = cldConn.CreateKeyPairHandler()</span>
        case rsVM:<span class="cov8" title="1">
                handler, err = cldConn.CreateVMHandler()</span>
        default:<span class="cov0" title="0">
                return AllResourceList{}, fmt.Errorf(rsType + " is not supported Resource!!")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return AllResourceList{}, err
        }</span>

        <span class="cov8" title="1">var allResList AllResourceList

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                vpcRWLock.RLock()
                defer vpcRWLock.RUnlock()</span>
        case rsSG:<span class="cov8" title="1">
                sgRWLock.RLock()
                defer sgRWLock.RUnlock()</span>
        case rsKey:<span class="cov8" title="1">
                keyRWLock.RLock()
                defer keyRWLock.RUnlock()</span>
        case rsVM:<span class="cov8" title="1">
                vmRWLock.RLock()
                defer vmRWLock.RUnlock()</span>
        default:<span class="cov0" title="0">
                return AllResourceList{}, fmt.Errorf(rsType + " is not supported Resource!!")</span>
        }

        // (1) get IID:list
        <span class="cov8" title="1">iidInfoList, err := iidRWLock.ListIID(connectionName, rsType)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return AllResourceList{}, err
        }</span>

        // if iidInfoList is empty, OnlySpiderList is empty.
        <span class="cov8" title="1">if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                emptyIIDInfoList := []*cres.IID{}
                allResList.AllList.MappedList = emptyIIDInfoList
                allResList.AllList.OnlySpiderList = emptyIIDInfoList
        }</span>

        // (2) get CSP:list
        <span class="cov8" title="1">iidCSPList := []*cres.IID{}
        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                infoList, err := handler.(cres.VPCHandler).ListVPC()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        case rsSG:<span class="cov8" title="1">
                infoList, err := handler.(cres.SecurityHandler).ListSecurity()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        case rsKey:<span class="cov8" title="1">
                infoList, err := handler.(cres.KeyPairHandler).ListKey()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        case rsVM:<span class="cov8" title="1">
                infoList, err := handler.(cres.VMHandler).ListVM()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return AllResourceList{}, err
                }</span>
                <span class="cov8" title="1">if infoList != nil </span><span class="cov8" title="1">{
                        for _, info := range infoList </span><span class="cov8" title="1">{
                                iidCSPList = append(iidCSPList, &amp;info.IId)
                        }</span>
                }
        default:<span class="cov0" title="0">
                return AllResourceList{}, fmt.Errorf(rsType + " is not supported Resource!!")</span>
        }

        <span class="cov8" title="1">if iidCSPList == nil || len(iidCSPList) &lt;= 0 </span><span class="cov0" title="0">{
                // if iidCSPList is empty, iidInfoList is empty =&gt; all list is empty &lt;-------------- (1)
                if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                        emptyIIDInfoList := []*cres.IID{}
                        allResList.AllList.OnlyCSPList = emptyIIDInfoList

                        return allResList, nil
                }</span> else<span class="cov0" title="0"> { // iidCSPList is empty and iidInfoList has value =&gt; only OnlySpiderList &lt;--(2)
                        emptyIIDInfoList := []*cres.IID{}
                        allResList.AllList.MappedList = emptyIIDInfoList
                        allResList.AllList.OnlyCSPList = emptyIIDInfoList
                        allResList.AllList.OnlySpiderList = getIIDList(iidInfoList)

                        return allResList, nil
                }</span>
        }

        // iidInfoList is empty, iidCSPList has values =&gt; only OnlyCSPList &lt;--------------------------(3)
        <span class="cov8" title="1">if iidInfoList == nil || len(iidInfoList) &lt;= 0 </span><span class="cov0" title="0">{
                OnlyCSPList := []*cres.IID{}
                for _, iid := range iidCSPList </span><span class="cov0" title="0">{
                        OnlyCSPList = append(OnlyCSPList, iid)
                }</span>
                <span class="cov0" title="0">allResList.AllList.OnlyCSPList = OnlyCSPList

                return allResList, nil</span>
        }

        ////// iidInfoList has values, iidCSPList has values  &lt;----------------------------------(4)
        // (3) filtering CSP-list by IID-list
        <span class="cov8" title="1">MappedList := []*cres.IID{}
        OnlySpiderList := []*cres.IID{}
        for _, iidInfo := range iidInfoList </span><span class="cov8" title="1">{
                exist := false
                for _, iid := range iidCSPList </span><span class="cov8" title="1">{
                        if iidInfo.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                                MappedList = append(MappedList, &amp;iidInfo.IId)
                                exist = true
                        }</span>
                }
                <span class="cov8" title="1">if exist == false </span><span class="cov0" title="0">{
                        OnlySpiderList = append(OnlySpiderList, &amp;iidInfo.IId)
                }</span>
        }

        // if SG then MappedList, OnlySpiderList : remove delimeter and set SG name
        <span class="cov8" title="1">if rsType == rsSG </span><span class="cov8" title="1">{ // vpc-01-delimiter-sg-01 ==&gt; sg-01
                for i, iid := range MappedList </span><span class="cov8" title="1">{
                        vpc_sg_nameid := strings.Split(iid.NameId, SG_DELIMITER)
                        MappedList[i].NameId = vpc_sg_nameid[1]
                }</span>
                <span class="cov8" title="1">for i, iid := range OnlySpiderList </span><span class="cov0" title="0">{
                        vpc_sg_nameid := strings.Split(iid.NameId, SG_DELIMITER)
                        OnlySpiderList[i].NameId = vpc_sg_nameid[1]
                }</span>
        }

        <span class="cov8" title="1">allResList.AllList.MappedList = MappedList
        allResList.AllList.OnlySpiderList = OnlySpiderList

        OnlyCSPList := []*cres.IID{}
        for _, iid := range iidCSPList </span><span class="cov8" title="1">{
                if MappedList == nil || len(MappedList) &lt;= 0 </span><span class="cov0" title="0">{
                        OnlyCSPList = append(OnlyCSPList, iid)
                }</span> else<span class="cov8" title="1"> {
                        isMapped := false
                        for _, mappedInfo := range MappedList </span><span class="cov8" title="1">{
                                if iid.SystemId == mappedInfo.SystemId </span><span class="cov8" title="1">{
                                        isMapped = true
                                }</span>
                        }
                        <span class="cov8" title="1">if isMapped == false </span><span class="cov0" title="0">{
                                OnlyCSPList = append(OnlyCSPList, iid)
                        }</span>
                }
        }
        <span class="cov8" title="1">allResList.AllList.OnlyCSPList = OnlyCSPList

        return allResList, nil</span>
}

func getIIDList(iidInfoList []*iidm.IIDInfo) []*cres.IID <span class="cov0" title="0">{
        iidList := []*cres.IID{}
        for _, iidInfo := range iidInfoList </span><span class="cov0" title="0">{
                iidList = append(iidList, &amp;iidInfo.IId)
        }</span>
        <span class="cov0" title="0">return iidList</span>
}

// (1) get IID(NameId)
// (2) delete Resource(SystemId)
// (3) delete IID
func DeleteResource(connectionName string, rsType string, nameID string, force string) (bool, cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteResource()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, "", err
        }</span>

        <span class="cov8" title="1">var handler interface{}

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                handler, err = cldConn.CreateVPCHandler()</span>
        case rsSG:<span class="cov8" title="1">
                handler, err = cldConn.CreateSecurityHandler()</span>
        case rsKey:<span class="cov8" title="1">
                handler, err = cldConn.CreateKeyPairHandler()</span>
        case rsVM:<span class="cov8" title="1">
                handler, err = cldConn.CreateVMHandler()</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        handler, err = cldConn.CreateVPCHandler()
                }</span> else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, "", err
        }</span>

        <span class="cov8" title="1">switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                vpcRWLock.Lock()
                defer vpcRWLock.Unlock()</span>
        case rsSG:<span class="cov8" title="1">
                sgRWLock.Lock()
                defer sgRWLock.Unlock()</span>
        case rsKey:<span class="cov8" title="1">
                keyRWLock.Lock()
                defer keyRWLock.Unlock()</span>
        case rsVM:<span class="cov8" title="1">
                vmRWLock.Lock()
                defer vmRWLock.Unlock()</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        vpcRWLock.Lock()
                        defer vpcRWLock.Unlock()
                }</span> else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }

        // (1) get IID(NameId) for getting SystemId
        <span class="cov8" title="1">var iidInfo *iidm.IIDInfo
        if rsType == rsSG </span><span class="cov8" title="1">{
                // SG NameID format =&gt; {VPC NameID} + SG_DELIMITER + {SG NameID}
                iidInfo, err = iidRWLock.FindIID(connectionName, rsType, nameID)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        } else<span class="cov8" title="1"> {
                iidInfo, err = iidRWLock.GetIID(connectionName, rsType, cres.IID{nameID, ""})
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        }

        // get VPC IID for remove subnet
        <span class="cov8" title="1">var iidVPCInfo *iidm.IIDInfo
        if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                vpcName := strings.Replace(rsType, SUBNET_PREFIX, "", 1)
                iidVPCInfo, err = iidRWLock.GetIID(connectionName, rsVPC, cres.IID{vpcName, ""})
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        }

        // (2) delete Resource(SystemId)
        <span class="cov8" title="1">result := false
        var vmStatus cres.VMStatus
        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                result, err = handler.(cres.VPCHandler).DeleteVPC(iidInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
        case rsSG:<span class="cov8" title="1">
                result, err = handler.(cres.SecurityHandler).DeleteSecurity(iidInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
        case rsKey:<span class="cov8" title="1">
                result, err = handler.(cres.KeyPairHandler).DeleteKey(iidInfo.IId)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
        case rsVM:<span class="cov8" title="1">
                providerName, err := ccm.GetProviderNameByConnectionName(connectionName)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>

                <span class="cov8" title="1">regionName, zoneName, err := ccm.GetRegionNameByConnectionName(connectionName)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>

                <span class="cov8" title="1">callInfo := call.CLOUDLOGSCHEMA {
                        CloudOS: call.CLOUD_OS(providerName),
                        RegionZone: regionName + "/" + zoneName,
                        ResourceType: call.VM,
                        ResourceName: iidInfo.IId.NameId,
                        CloudOSAPI: "CB-Spider:TerminateVM()",
                        ElapsedTime: "",
                        ErrorMSG: "",
                }
                start := call.Start()
                vmStatus, err = handler.(cres.VMHandler).TerminateVM(iidInfo.IId)
                callInfo.ElapsedTime = call.Elapsed(start)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        callInfo.ErrorMSG = err.Error()
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, vmStatus, err
                        }</span>
                }
                <span class="cov8" title="1">callogger.Info(call.String(callInfo))</span>


        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        result, err = handler.(cres.VPCHandler).RemoveSubnet(iidVPCInfo.IId, iidInfo.IId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                if force != "true" </span><span class="cov0" title="0">{
                                        return false, "", err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }

        <span class="cov8" title="1">if force != "true" </span><span class="cov8" title="1">{
                if rsType != rsVM </span><span class="cov8" title="1">{
                        if result == false </span><span class="cov0" title="0">{
                                return result, "", nil
                        }</span>
                }
        }

        // (3) delete IID
        <span class="cov8" title="1">_, err = iidRWLock.DeleteIID(connectionName, rsType, iidInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                if force != "true" </span><span class="cov0" title="0">{
                        return false, "", err
                }</span>
        }

        // if VPC
        <span class="cov8" title="1">if rsType == rsVPC </span><span class="cov8" title="1">{
                // for Subnet list
                // key-value structure: /{ConnectionName}/SUBNET_PREFIX+{VPC-NameId}/{Subnet-IId}
                subnetInfoList, err2 := iidRWLock.ListIID(connectionName, SUBNET_PREFIX+iidInfo.IId.NameId)
                if err2 != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        if force != "true" </span><span class="cov0" title="0">{
                                return false, "", err
                        }</span>
                }
                <span class="cov8" title="1">for _, subnetInfo := range subnetInfoList </span><span class="cov8" title="1">{
                        // key-value structure: /{ConnectionName}/SUBNET_PREFIX+{VPC-NameId}/{Subnet-IId}
                        _, err := iidRWLock.DeleteIID(connectionName, SUBNET_PREFIX+iidInfo.IId.NameId, subnetInfo.IId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                if force != "true" </span><span class="cov0" title="0">{
                                        return false, "", err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if rsType == rsVM </span><span class="cov8" title="1">{
                return result, vmStatus, nil
        }</span> else<span class="cov8" title="1"> {
                return result, "", nil
        }</span>
}

// (1) delete Resource(SystemId)
func DeleteCSPResource(connectionName string, rsType string, systemID string) (bool, cres.VMStatus, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteResource()")

        cldConn, err := ccm.GetCloudConnection(connectionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, "", err
        }</span>

        <span class="cov8" title="1">var handler interface{}

        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                handler, err = cldConn.CreateVPCHandler()</span>
        case rsSG:<span class="cov8" title="1">
                handler, err = cldConn.CreateSecurityHandler()</span>
        case rsKey:<span class="cov8" title="1">
                handler, err = cldConn.CreateKeyPairHandler()</span>
        case rsVM:<span class="cov8" title="1">
                handler, err = cldConn.CreateVMHandler()</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        handler, err = cldConn.CreateVPCHandler()
                }</span> else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, "", err
        }</span>

        // get VPC IID for remove subnet
        <span class="cov8" title="1">var iidVPCInfo *iidm.IIDInfo
        if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                vpcName := strings.Replace(rsType, SUBNET_PREFIX, "", 1)
                iidVPCInfo, err = iidRWLock.GetIID(connectionName, rsVPC, cres.IID{vpcName, ""})
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        }

        <span class="cov8" title="1">iid := cres.IID{"", systemID}

        // (1) delete Resource(SystemId)
        result := false
        var vmStatus cres.VMStatus
        switch rsType </span>{
        case rsVPC:<span class="cov8" title="1">
                result, err = handler.(cres.VPCHandler).DeleteVPC(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        case rsSG:<span class="cov8" title="1">
                result, err = handler.(cres.SecurityHandler).DeleteSecurity(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        case rsKey:<span class="cov8" title="1">
                result, err = handler.(cres.KeyPairHandler).DeleteKey(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, "", err
                }</span>
        case rsVM:<span class="cov8" title="1">
                vmStatus, err = handler.(cres.VMHandler).TerminateVM(iid)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return false, vmStatus, err
                }</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(rsType, SUBNET_PREFIX) </span><span class="cov8" title="1">{
                        result, err = handler.(cres.VPCHandler).RemoveSubnet(iidVPCInfo.IId, iid)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                return false, "", err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return false, "", fmt.Errorf(rsType + " is not supported Resource!!")
                }</span>
        }

        <span class="cov8" title="1">if rsType != rsVM </span><span class="cov8" title="1">{
                if result == false </span><span class="cov0" title="0">{
                        return result, "", nil
                }</span>
        }

        <span class="cov8" title="1">if rsType == rsVM </span><span class="cov8" title="1">{
                return result, vmStatus, nil
        }</span> else<span class="cov8" title="1"> {
                return result, "", nil
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "errors"
        "io"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/jaegertracer"
        "github.com/opentracing/opentracing-go"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBConnection - CB-GRPC  grpc   Wrapper 
type CBConnection struct {
        Conn *grpc.ClientConn
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBConnection -  grpc   
func NewCBConnection(gConf *config.GrpcClientConfig) (*CBConnection, io.Closer, error) <span class="cov0" title="0">{

        var (
                tracer opentracing.Tracer = nil
                closer io.Closer          = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc connection config is null")
        }</span>

        <span class="cov0" title="0">if gConf.ServerAddr == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("server addr is empty")
        }</span>

        <span class="cov0" title="0">opts := []grpc.DialOption{}

        // TLS 
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewClientTLSFromFile(gConf.TLS.TLSCA, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov0" title="0"> {
                opts = append(opts, grpc.WithInsecure())
        }</span>

        //  
        <span class="cov0" title="0">unaryIntercepters := []grpc.UnaryClientInterceptor{}
        streamIntercepters := []grpc.StreamClientInterceptor{}

        // access    
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryClientInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamClientInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT  
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                }</span>

                // Opentracing  
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                        tracingOpts := []grpc_opentracing.Option{}
                        tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                        unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryClientInterceptor(tracingOpts...))
                        streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamClientInterceptor(tracingOpts...))
                }</span>

        }

        <span class="cov0" title="0">opts = append(opts, grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(unaryIntercepters...)))
        opts = append(opts, grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(streamIntercepters...)))
        conn, err := grpc.Dial(gConf.ServerAddr, opts...)

        return &amp;CBConnection{Conn: conn}, closer, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "encoding/json"
        "strings"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"

        "gopkg.in/yaml.v2"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====s

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvertToMessage -   grpc  
func ConvertToMessage(inType string, inData string, obj interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if inType == "yaml" </span><span class="cov8" title="1">{
                err := yaml.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">if inType == "json" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("json Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertToOutput - grpc   
func ConvertToOutput(outType string, obj interface{}) (string, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if outType == "yaml" </span><span class="cov8" title="1">{
                //    (XXX_  )   json   
                j, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // yaml    control character 
                <span class="cov8" title="1">cleanStr := strings.Map(func(value rune) rune </span><span class="cov8" title="1">{
                        switch </span>{
                        case value == 0x09:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0A:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0D:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x20 &amp;&amp; value &lt;= 0x7E:<span class="cov8" title="1">
                                return value</span>
                        case value == 0x85:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xA0 &amp;&amp; value &lt;= 0xD7FF:<span class="cov8" title="1">
                                return value</span>
                        case value &gt;= 0xE000 &amp;&amp; value &lt;= 0xFFFD:<span class="cov8" title="1">
                                return value</span>
                        case value &gt;= 0x10000 &amp;&amp; value &lt;= 0x10FFFF:<span class="cov0" title="0">
                                return value</span>
                        default:<span class="cov0" title="0">
                                return -1</span> // control characters are not allowed
                        }
                }, string(j))

                //        MapSlice 
                <span class="cov8" title="1">jsonObj := yaml.MapSlice{}
                err2 := yaml.Unmarshal([]byte(cleanStr), &amp;jsonObj)
                if err2 != nil </span><span class="cov0" title="0">{
                        return "", err2
                }</span>

                // yaml 
                <span class="cov8" title="1">y, err3 := yaml.Marshal(jsonObj)
                if err3 != nil </span><span class="cov0" title="0">{
                        return "", err3
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Marshal: \n", string(y))

                return string(y), nil</span>
        }

        <span class="cov8" title="1">if outType == "json" </span><span class="cov8" title="1">{
                j, err := json.MarshalIndent(obj, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">outStr := string(j)

                // json.Marshal   &lt;,&gt;, &amp;  escape ..   
                outStr = strings.Replace(outStr, "\\u003c", "&lt;", -1)
                outStr = strings.Replace(outStr, "\\u003e", "&gt;", -1)
                outStr = strings.Replace(outStr, "\\u0026", "&amp;", -1)

                logger.Debug("json Marshal: \n", outStr)
                return outStr, nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// CopySrcToDest -    
func CopySrcToDest(src interface{}, dest interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        j, err := json.MarshalIndent(src, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("source value : \n", string(j))

        err = json.Unmarshal(j, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">j, err = json.MarshalIndent(dest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("target value : \n", string(j))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/jaegertracer"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        opentracing "github.com/opentracing/opentracing-go"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBServer - CB-GRPC  grpc   Wrapper 
type CBServer struct {
        Server *grpc.Server
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBServer -  grpc   
func NewCBServer(gConf *config.GrpcServerConfig) (*CBServer, io.Closer, error) <span class="cov8" title="1">{

        var (
                tracer      opentracing.Tracer             = nil
                closer      io.Closer                      = nil
                reg         *prometheus.Registry           = nil
                grpcMetrics *grpc_prometheus.ServerMetrics = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc server config is null")
        }</span>

        <span class="cov8" title="1">opts := []grpc.ServerOption{}

        // TLS 
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(gConf.TLS.TLSCert, gConf.TLS.TLSKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        //  
        <span class="cov8" title="1">unaryIntercepters := []grpc.UnaryServerInterceptor{}
        streamIntercepters := []grpc.StreamServerInterceptor{}

        // access    
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamServerInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT  
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                }</span>

                // Opentracing  
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if gConf.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                                tracingOpts := []grpc_opentracing.Option{}
                                tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                                unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryServerInterceptor(tracingOpts...))
                                streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamServerInterceptor(tracingOpts...))
                        }</span>
                }

                // Prometheus Metrics  
                <span class="cov0" title="0">if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{
                        grpcMetrics = grpc_prometheus.NewServerMetrics()
                        grpcMetrics.EnableHandlingTimeHistogram()

                        reg = prometheus.NewRegistry()
                        reg.MustRegister(grpcMetrics)
                        reg.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))
                        reg.MustRegister(prometheus.NewGoCollector())

                        unaryIntercepters = append(unaryIntercepters, grpcMetrics.UnaryServerInterceptor())
                        streamIntercepters = append(streamIntercepters, grpcMetrics.StreamServerInterceptor())
                }</span>

        }

        // recovery   
        <span class="cov8" title="1">unaryIntercepters = append(unaryIntercepters, grpc_recovery.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_recovery.StreamServerInterceptor())

        opts = append(opts, grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(unaryIntercepters...)))
        opts = append(opts, grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(streamIntercepters...)))
        gs := grpc.NewServer(opts...)

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{
                if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{

                        // Create a HTTP server for prometheus.
                        httpServer := &amp;http.Server{
                                Handler: promhttp.HandlerFor(reg, promhttp.HandlerOpts{}),
                                Addr:    fmt.Sprintf("0.0.0.0:%d", gConf.Interceptors.PrometheusMetrics.ListenPort),
                        }
                        // Initialize all metrics.
                        grpcMetrics.InitializeMetrics(gs)
                        // Start your http server for prometheus.
                        go func() </span><span class="cov0" title="0">{
                                if err := httpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                                        log.Fatal("Unable to start a http server for prometheus.")
                                }</span>
                        }()

                }
        }

        <span class="cov8" title="1">return &amp;CBServer{Server: gs}, closer, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package common

import (
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvGrpcStatusErr - GRPC    
func ConvGrpcStatusErr(err error, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        if err != nil </span><span class="cov0" title="0">{
                if errStatus, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        logger.Error(tag, " error while calling ", method, " method: ", errStatus.Message())
                        return status.Errorf(errStatus.Code(), "%s error while calling %s method: %v ", tag, method, errStatus.Message())
                }</span>
                <span class="cov0" title="0">logger.Error(tag, " error while calling ", method, " method: ", err)
                return status.Errorf(codes.Internal, "%s error while calling %s method: %v ", tag, method, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewGrpcStatusErr - GRPC    
func NewGrpcStatusErr(msg string, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Error(tag, " error while calling ", method, " method: ", msg)
        return status.Errorf(codes.Internal, "%s error while calling %s method: %s ", tag, method, msg)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

// Package config - Configuration for Cloud-Barista's GRPC and provides the required process
package config

import (
        "fmt"
        "log"
        "os"
        "strings"
        "time"
)

// ===== [ Constants and Variables ] =====

const (
        // ConfigVersion -    
        ConfigVersion = 1
)

// ===== [ Types ] =====

// GrpcConfig - CB-GRPC   
type GrpcConfig struct {
        Version int             `mapstructure:"version"`
        GSL     GrpcServiceList `mapstructure:"grpc"`
}

// GrpcServiceList - CB-GRPC  
type GrpcServiceList struct {
        SpiderSrv *GrpcServerConfig `mapstructure:"spidersrv"`
        SpiderCli *GrpcClientConfig `mapstructure:"spidercli"`
}

// GrpcServerConfig - CB-GRPC   
type GrpcServerConfig struct {
        Addr         string              `mapstructure:"addr"`
        Reflection   string              `mapstructure:"reflection"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// GrpcClientConfig - CB-GRPC   
type GrpcClientConfig struct {
        ServerAddr   string              `mapstructure:"server_addr"`
        Timeout      time.Duration       `mapstructure:"timeout"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// TLSConfig - TLS  
type TLSConfig struct {
        TLSCert string `mapstructure:"tls_cert"`
        TLSKey  string `mapstructure:"tls_key"`
        TLSCA   string `mapstructure:"tls_ca"`
}

// InterceptorsConfig - GRPC   
type InterceptorsConfig struct {
        AuthJWT           *AuthJWTConfig           `mapstructure:"auth_jwt"`
        PrometheusMetrics *PrometheusMetricsConfig `mapstructure:"prometheus_metrics"`
        Opentracing       *OpentracingConfig       `mapstructure:"opentracing"`
}

// AuthJWTConfig - AuthJWT  
type AuthJWTConfig struct {
        JWTKey   string `mapstructure:"jwt_key"`
        JWTToken string `mapstructure:"jwt_token"`
}

// PrometheusMetricsConfig - Prometheus Metrics  
type PrometheusMetricsConfig struct {
        ListenPort int `mapstructure:"listen_port"`
}

// OpentracingConfig - Opentracing  
type OpentracingConfig struct {
        Jaeger *JaegerClientConfig `mapstructure:"jaeger"`
}

// JaegerClientConfig - Jaeger Client  
type JaegerClientConfig struct {
        Endpoint    string  `mapstructure:"endpoint"`
        ServiceName string  `mapstructure:"service_name"`
        SampleRate  float64 `mapstructure:"sample_rate"`
}

// UnsupportedVersionError -         
type UnsupportedVersionError struct {
        Have int
        Want int
}

// ===== [ Implementations ] =====

// Init -     
func (gConf *GrpcConfig) Init() error <span class="cov8" title="1">{
        //    
        if gConf.Version != ConfigVersion </span><span class="cov0" title="0">{
                return &amp;UnsupportedVersionError{
                        Have: gConf.Version,
                        Want: ConfigVersion,
                }
        }</span>
        //  
        <span class="cov8" title="1">gConf.initGlobalParams()

        return nil</span>
}

// initGlobalParams -   
func (gConf *GrpcConfig) initGlobalParams() <span class="cov8" title="1">{

        if gConf.GSL.SpiderSrv != nil </span><span class="cov8" title="1">{

                if gConf.GSL.SpiderSrv.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderSrv.TLS.TLSCert != "" </span><span class="cov0" title="0">{
                                gConf.GSL.SpiderSrv.TLS.TLSCert = ReplaceEnvPath(gConf.GSL.SpiderSrv.TLS.TLSCert)
                        }</span>
                        <span class="cov0" title="0">if gConf.GSL.SpiderSrv.TLS.TLSKey != "" </span><span class="cov0" title="0">{
                                gConf.GSL.SpiderSrv.TLS.TLSKey = ReplaceEnvPath(gConf.GSL.SpiderSrv.TLS.TLSKey)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.SpiderSrv.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderSrv.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.ServiceName = "grpc spider server"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderSrv.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

        <span class="cov8" title="1">if gConf.GSL.SpiderCli != nil </span><span class="cov8" title="1">{

                if gConf.GSL.SpiderCli.Timeout == 0 </span><span class="cov0" title="0">{
                        gConf.GSL.SpiderCli.Timeout = 90 * time.Second
                }</span>

                <span class="cov8" title="1">if gConf.GSL.SpiderCli.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderCli.TLS.TLSCA != "" </span><span class="cov0" title="0">{
                                gConf.GSL.SpiderCli.TLS.TLSCA = ReplaceEnvPath(gConf.GSL.SpiderCli.TLS.TLSCA)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.SpiderCli.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.SpiderCli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.ServiceName = "grpc spider client"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.SpiderCli.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

}

// Error -       
func (u *UnsupportedVersionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Unsupported version: %d (wanted: %d)", u.Have, u.Want)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ReplaceEnvPath - $ABC/def ==&gt; /abc/def
func ReplaceEnvPath(str string) string <span class="cov0" title="0">{
        if strings.Index(str, "$") == -1 </span><span class="cov0" title="0">{
                return str
        }</span>

        // ex) input "$CBSTORE_ROOT/meta_db/dat"
        <span class="cov0" title="0">strList := strings.Split(str, "/")
        for n, one := range strList </span><span class="cov0" title="0">{
                if strings.Index(one, "$") != -1 </span><span class="cov0" title="0">{
                        cbstoreRootPath := os.Getenv(strings.Trim(one, "$"))
                        if cbstoreRootPath == "" </span><span class="cov0" title="0">{
                                log.Fatal(one + " is not set!")
                        }</span>
                        <span class="cov0" title="0">strList[n] = cbstoreRootPath</span>
                }
        }

        <span class="cov0" title="0">var resultStr string
        for _, one := range strList </span><span class="cov0" title="0">{
                resultStr = resultStr + one + "/"
        }</span>
        // ex) "/root/go/src/github.com/cloud-barista/poc-cicd-spider/meta_db/dat/"
        <span class="cov0" title="0">resultStr = strings.TrimRight(resultStr, "/")
        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        return resultStr</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package config

import (
        "fmt"
        "os"
        "reflect"
        "unsafe"

        "github.com/spf13/viper"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Parser - Viper lib   Parser   
type Parser struct {
        viper *viper.Viper
}

// ===== [ Implementations ] =====

// GrpcParse - Viper lib   CB-GRPC configuration  
func (p Parser) GrpcParse(configFile string) (GrpcConfig, error) <span class="cov8" title="1">{
        p.viper.SetConfigFile(configFile)
        p.viper.AutomaticEnv()
        p.viper.SetConfigType("yaml")

        var cfg GrpcConfig

        // Reading
        if err := p.viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Unmarshal to struct
        <span class="cov8" title="1">if err := p.viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Initialize
        <span class="cov8" title="1">if err := cfg.Init(); err != nil </span><span class="cov0" title="0">{
                return cfg, CheckErr(err, configFile)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// ===== [ Private Functions ] =====

// checkErr - Viper lib     (Nested call)
func checkErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case viper.ConfigParseError:<span class="cov0" title="0">
                var subErr error
                re := reflect.ValueOf(&amp;e).Elem()
                rf := re.Field(0)
                rse := reflect.ValueOf(&amp;subErr).Elem()
                rf = reflect.NewAt(rf.Type(), unsafe.Pointer(rf.UnsafeAddr())).Elem()
                rse.Set(rf)
                return checkErr(subErr, configFile)</span>
        default:<span class="cov0" title="0">
                return CheckErr(err, configFile)</span>
        }
}

// ===== [ Public Functions ] =====

// CheckErr -    
func CheckErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case *os.PathError:<span class="cov0" title="0">
                return fmt.Errorf("'%s' (%s): %s", configFile, e.Op, e.Err.Error())</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("'%s': %v", configFile, err)</span>
        }
}

// MakeParser - Viber lib   Parser 
func MakeParser() Parser <span class="cov8" title="1">{
        return Parser{viper.New()}
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - rpc unary call    
func UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := invoker(ctx, method, req, reply, cc, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client unary call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return err
        }</span>
}

// StreamClientInterceptor - rpc stream call    
func StreamClientInterceptor() grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                clientStream, err := streamer(ctx, desc, cc, method, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client stream call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return clientStream, err
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/peer"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - rpc unary receive    
func UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                startTime := time.Now()
                resp, err := handler(ctx, req)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(ctx); ok </span><span class="cov8" title="1">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov8" title="1">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server unary received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return resp, err</span>
        }
}

// StreamServerInterceptor - rpc stream receive    
func StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov8" title="1">{
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := handler(srv, stream)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(stream.Context()); ok </span><span class="cov0" title="0">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov0" title="0">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server stream received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package authjwt

import (
        "context"
        "fmt"
        "time"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        "github.com/dgrijalva/jwt-go"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

func validateToken(ctx context.Context) (bool, error) <span class="cov0" title="0">{

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.InvalidArgument, "Retrieving metadata is failed")
        }</span>

        <span class="cov0" title="0">authHeader, ok := md["authorization"]
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Authorization jwt token is not supplied")
        }</span>

        <span class="cov0" title="0">tokenStr := authHeader[0]

        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(jwtKey), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Parsing jwt token is failed")
        }</span>

        <span class="cov0" title="0">if token.Valid </span><span class="cov0" title="0">{
                logger := logger.NewLogger()
                var tokenInfo string = "{"
                for key, val := range claims </span><span class="cov0" title="0">{
                        if key == "expire" </span><span class="cov0" title="0">{

                                if getTokenRemainingValidity(val) &lt; 0 </span><span class="cov0" title="0">{
                                        return false, status.Errorf(codes.Unauthenticated, "token is expired")
                                }</span>

                                <span class="cov0" title="0">var timestamp interface{} = val
                                t := time.Unix(int64(timestamp.(float64)), 0)
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %d-%02d-%02dT%02d:%02d:%02d, remainder seconds: %d,", key,
                                        t.Year(), t.Month(), t.Day(),
                                        t.Hour(), t.Minute(), t.Second(),
                                        getTokenRemainingValidity(val),
                                )</span>

                        } else<span class="cov0" title="0"> {
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %v,", key, val)
                        }</span>
                }
                <span class="cov0" title="0">tokenInfo = tokenInfo + " }"
                logger.Debug("token parsing result : ", tokenInfo)

                return true, nil</span>
        }

        <span class="cov0" title="0">return false, status.Errorf(codes.Unauthenticated, "Authorization is failed")</span>
}

func getTokenRemainingValidity(timestamp interface{}) int <span class="cov0" title="0">{
        if validity, ok := timestamp.(float64); ok </span><span class="cov0" title="0">{
                tm := time.Unix(int64(validity), 0)
                remainder := tm.Sub(time.Now())

                return int(remainder.Seconds())
        }</span>
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtToken = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - JWT   Unary  
func UnaryClientInterceptor(token string) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return invoker(ctx, method, req, reply, cc, opts...)</span>
        }
}

// StreamClientInterceptor - JWT   Stream  
func StreamClientInterceptor(token string) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return streamer(ctx, desc, cc, method, opts...)</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtKey = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - authentication   Unary  
func UnaryServerInterceptor(key string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// StreamServerInterceptor - authentication   Stream  
func StreamServerInterceptor(key string) grpc.StreamServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(stream.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return handler(srv, stream)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package jaegertracer

import (
        "fmt"
        "io"

        opentracing "github.com/opentracing/opentracing-go"
        jaeger "github.com/uber/jaeger-client-go"
        config "github.com/uber/jaeger-client-go/config"

        grpcconfig "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
)

// InitJaeger - Jaeger Tracer 
func InitJaeger(jcConf *grpcconfig.JaegerClientConfig) (opentracing.Tracer, io.Closer) <span class="cov0" title="0">{
        cfg := &amp;config.Configuration{
                Sampler: &amp;config.SamplerConfig{
                        Type:  "probabilistic",
                        Param: jcConf.SampleRate,
                },
                Reporter: &amp;config.ReporterConfig{
                        LocalAgentHostPort: jcConf.Endpoint,
                },
        }
        tracer, closer, err := cfg.New(jcConf.ServiceName, config.Logger(jaeger.NullLogger))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))</span>
        }
        <span class="cov0" title="0">return tracer, closer</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package logger

import (
        "io"
        "io/ioutil"
        "os"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Logger - CB-LOG  "logrus" Logger  Wrapper 
type Logger struct {
        *logrus.Logger
}

// ===== [ Implementations ] =====

// SetOutput -   
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.Logger.Out = w
}</span>

// DisableOutput -   
func (l *Logger) DisableOutput() <span class="cov0" title="0">{
        l.SetOutput(ioutil.Discard)
}</span>

// SetFormatter -   
func (l *Logger) SetFormatter(f logrus.Formatter) <span class="cov0" title="0">{
        l.Logger.Formatter = f
}</span>

// SetLogLevel -   
func (l *Logger) SetLogLevel(lv logrus.Level) <span class="cov0" title="0">{
        l.Logger.SetLevel(lv)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewLogger -  Logger  
func NewLogger() *Logger <span class="cov8" title="1">{
        // CBLOG_ROOT        )
        env := os.Getenv("CBLOG_ROOT")
        if env == "" </span><span class="cov0" title="0">{
                if dir, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                        os.Setenv("CBLOG_ROOT", dir)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Logger{
                Logger: cblog.GetLogger("CB-GRPC"),
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateConnectionConfig - Connection Config 
func (s *CIMService) CreateConnectionConfig(ctx context.Context, req *pb.ConnectionConfigInfoRequest) (*pb.ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateConnectionConfig()")

        // GRPC  CIM  
        var cimObj ccim.ConnectionConfigInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateConnectionConfig()")
        }</span>

        <span class="cov8" title="1">connInfo, err := ccim.CreateConnectionConfigInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateConnectionConfig()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.ConnectionConfigInfo
        err = gc.CopySrcToDest(&amp;connInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ConnectionConfigInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListConnectionConfig - Connection Config 
func (s *CIMService) ListConnectionConfig(ctx context.Context, req *pb.Empty) (*pb.ListConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListConnectionConfig()")

        infoList, err := ccim.ListConnectionConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListConnectionConfig()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.ConnectionConfigInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListConnectionConfigInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetConnectionConfig - Connection Config 
func (s *CIMService) GetConnectionConfig(ctx context.Context, req *pb.ConnectionConfigQryRequest) (*pb.ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetConnectionConfig()")

        connInfo, err := ccim.GetConnectionConfig(req.ConfigName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetConnectionConfig()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.ConnectionConfigInfo
        err = gc.CopySrcToDest(&amp;connInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ConnectionConfigInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteConnectionConfig - Connection Config 
func (s *CIMService) DeleteConnectionConfig(ctx context.Context, req *pb.ConnectionConfigQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteConnectionConfig()")

        result, err := ccim.DeleteConnectionConfig(req.ConfigName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteConnectionConfig()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file15" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCredential - Credential 
func (s *CIMService) CreateCredential(ctx context.Context, req *pb.CredentialInfoRequest) (*pb.CredentialInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateCredential()")

        // GRPC  CIM  
        var cimObj cim.CredentialInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCredential()")
        }</span>

        <span class="cov8" title="1">crdInfo, err := cim.RegisterCredentialInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCredential()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.CredentialInfo
        err = gc.CopySrcToDest(&amp;crdInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CredentialInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListCredential - Credential 
func (s *CIMService) ListCredential(ctx context.Context, req *pb.Empty) (*pb.ListCredentialInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListCredential()")

        infoList, err := cim.ListCredential()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCredential()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.CredentialInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListCredentialInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetCredential - Credential 
func (s *CIMService) GetCredential(ctx context.Context, req *pb.CredentialQryRequest) (*pb.CredentialInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetCredential()")

        crdInfo, err := cim.GetCredential(req.CredentialName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCredential()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.CredentialInfo
        err = gc.CopySrcToDest(&amp;crdInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CredentialInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteCredential - Credential 
func (s *CIMService) DeleteCredential(ctx context.Context, req *pb.CredentialQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteCredential()")

        result, err := cim.UnRegisterCredential(req.CredentialName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteCredential()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file16" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCloudDriver - Cloud Driver 
func (s *CIMService) CreateCloudDriver(ctx context.Context, req *pb.CloudDriverInfoRequest) (*pb.CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateCloudDriver()")

        // GRPC  CIM  
        var cimObj dim.CloudDriverInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCloudDriver()")
        }</span>

        <span class="cov8" title="1">drvInfo, err := dim.RegisterCloudDriverInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCloudDriver()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.CloudDriverInfo
        err = gc.CopySrcToDest(&amp;drvInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CloudDriverInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListCloudDriver -Cloud Driver 
func (s *CIMService) ListCloudDriver(ctx context.Context, req *pb.Empty) (*pb.ListCloudDriverInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListCloudDriver()")

        infoList, err := dim.ListCloudDriver()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCloudDriver()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.CloudDriverInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListCloudDriverInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetCloudDriver - Cloud Driver 
func (s *CIMService) GetCloudDriver(ctx context.Context, req *pb.CloudDriverQryRequest) (*pb.CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetCloudDriver()")

        drvInfo, err := dim.GetCloudDriver(req.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCloudDriver()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.CloudDriverInfo
        err = gc.CopySrcToDest(&amp;drvInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.CloudDriverInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteCloudDriver - Cloud Driver 
func (s *CIMService) DeleteCloudDriver(ctx context.Context, req *pb.CloudDriverQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteCloudDriver()")

        result, err := dim.UnRegisterCloudDriver(req.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteCloudDriver()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file17" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateImage - Image 
func (s *CCMService) CreateImage(ctx context.Context, req *pb.ImageCreateRequest) (*pb.ImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateImage()")

        // Grpc RegInfo =&gt; Driver ReqInfo
        reqInfo := cres.ImageReqInfo{
                IId: cres.IID{NameId: req.Item.Name, SystemId: ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateImage(req.ConnectionName, rsImage, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateImage()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.ImageInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListImage - Image 
func (s *CCMService) ListImage(ctx context.Context, req *pb.ImageAllQryRequest) (*pb.ListImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListImage()")

        // Call common-runtime API
        result, err := cmrt.ListImage(req.ConnectionName, rsImage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListImage()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.ImageInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListImageInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetImage - Image 
func (s *CCMService) GetImage(ctx context.Context, req *pb.ImageQryRequest) (*pb.ImageInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetImage()")

        // Call common-runtime API
        result, err := cmrt.GetImage(req.ConnectionName, rsImage, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetImage()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.ImageInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ImageInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteImage - Image 
func (s *CCMService) DeleteImage(ctx context.Context, req *pb.ImageQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteImage()")

        // Call common-runtime API
        result, err := cmrt.DeleteImage(req.ConnectionName, rsImage, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteImage()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file18" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateKey - KeyPair 
func (s *CCMService) CreateKey(ctx context.Context, req *pb.KeyPairCreateRequest) (*pb.KeyPairInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateKey()")

        // Grpc RegInfo =&gt; Driver ReqInfo
        reqInfo := cres.KeyPairReqInfo{
                IId: cres.IID{NameId: req.Item.Name, SystemId: ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateKey(req.ConnectionName, rsKey, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateKey()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.KeyPairInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.KeyPairInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListKey - KeyPair 
func (s *CCMService) ListKey(ctx context.Context, req *pb.KeyPairAllQryRequest) (*pb.ListKeyPairInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListKey()")

        // Call common-runtime API
        result, err := cmrt.ListKey(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListKey()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.KeyPairInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListKeyPairInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetKey - KeyPair 
func (s *CCMService) GetKey(ctx context.Context, req *pb.KeyPairQryRequest) (*pb.KeyPairInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetKey()")

        // Call common-runtime API
        result, err := cmrt.GetKey(req.ConnectionName, rsKey, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetKey()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.KeyPairInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.KeyPairInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteKey - KeyPair 
func (s *CCMService) DeleteKey(ctx context.Context, req *pb.KeyPairQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteKey()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, rsKey, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ListAllKey -  Key 
func (s *CCMService) ListAllKey(ctx context.Context, req *pb.KeyPairAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllKey()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllKey()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllKey()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// DeleteCSPKey - CSP Key 
func (s *CCMService) DeleteCSPKey(ctx context.Context, req *pb.CSPKeyPairQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteCSPKey()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsKey, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteCSPKey()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file19" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        im "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListCloudOS - Cloud OS 
func (s *CIMService) ListCloudOS(ctx context.Context, req *pb.Empty) (*pb.ListCloudOSInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListCloudOS()")

        infoList := im.ListCloudOS()

        resp := &amp;pb.ListCloudOSInfoResponse{Items: infoList}
        return resp, nil
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file20" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateRegion - Region 
func (s *CIMService) CreateRegion(ctx context.Context, req *pb.RegionInfoRequest) (*pb.RegionInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.CreateRegion()")

        // GRPC  CIM  
        var cimObj rim.RegionInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateRegion()")
        }</span>

        <span class="cov8" title="1">regionInfo, err := rim.RegisterRegionInfo(cimObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateRegion()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.RegionInfo
        err = gc.CopySrcToDest(&amp;regionInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.CreateRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.RegionInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListRegion - Region 
func (s *CIMService) ListRegion(ctx context.Context, req *pb.Empty) (*pb.ListRegionInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.ListRegion()")

        infoList, err := rim.ListRegion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListRegion()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.RegionInfo
        err = gc.CopySrcToDest(&amp;infoList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.ListRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListRegionInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetRegion - Region 
func (s *CIMService) GetRegion(ctx context.Context, req *pb.RegionQryRequest) (*pb.RegionInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.GetRegion()")

        regionInfo, err := rim.GetRegion(req.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetRegion()")
        }</span>

        // CIM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.RegionInfo
        err = gc.CopySrcToDest(&amp;regionInfo, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.GetRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.RegionInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteRegion - Region 
func (s *CIMService) DeleteRegion(ctx context.Context, req *pb.RegionQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CIMService.DeleteRegion()")

        result, err := rim.UnRegisterRegion(req.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CIMService.DeleteRegion()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file21" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"
        "strings"

        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSecurity - Security 
func (s *CCMService) CreateSecurity(ctx context.Context, req *pb.SecurityCreateRequest) (*pb.SecurityInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateSecurity()")

        // check the input Name to include the SecurityGroup Delimiter
        if strings.Contains(req.Item.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr(cm.SG_DELIMITER+" cannot be used in Security Group name!!", "", "CCMService.CreateSecurity()")
        }</span>

        // GRPC  CCM  
        <span class="cov8" title="1">var reqInfo cres.SecurityReqInfo
        err := gc.CopySrcToDest(&amp;req.Item, &amp;reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateSecurity()")
        }</span>
        // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
        // transform: SG NameID =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
        //reqInfo.IId = cres.IID{NameId: req.Item.VpcName + cm.SG_DELIMITER + req.Item.Name, SystemId: ""}
        <span class="cov8" title="1">reqInfo.IId = cres.IID{NameId: req.Item.VpcName + cm.SG_DELIMITER + req.Item.Name, SystemId: req.Item.Name} // for NCP: fixed NameID =&gt; SystemID, Driver: (1)search systemID with fixed NameID (2)replace fixed NameID into SysemID
        reqInfo.VpcIID = cres.IID{NameId: req.Item.VpcName, SystemId: ""}

        // Call common-runtime API
        result, err := cmrt.CreateSecurity(req.ConnectionName, rsSG, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateSecurity()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.SecurityInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.SecurityInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListSecurity - Security 
func (s *CCMService) ListSecurity(ctx context.Context, req *pb.SecurityAllQryRequest) (*pb.ListSecurityInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListSecurity()")

        // Call common-runtime API
        result, err := cmrt.ListSecurity(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListSecurity()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.SecurityInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListSecurityInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetSecurity - Security 
func (s *CCMService) GetSecurity(ctx context.Context, req *pb.SecurityQryRequest) (*pb.SecurityInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetSecurity()")

        // Call common-runtime API
        result, err := cmrt.GetSecurity(req.ConnectionName, rsSG, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetSecurity()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.SecurityInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.SecurityInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteSecurity - Security 
func (s *CCMService) DeleteSecurity(ctx context.Context, req *pb.SecurityQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteSecurity()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, rsSG, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ListAllSecurity -  Security 
func (s *CCMService) ListAllSecurity(ctx context.Context, req *pb.SecurityAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllSecurity()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllSecurity()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllSecurity()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// DeleteCSPSecurity - CSP Security 
func (s *CCMService) DeleteCSPSecurity(ctx context.Context, req *pb.CSPSecurityQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteCSPSecurity()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsSG, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteCSPSecurity()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file22" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"
        "strings"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        sshrun "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/vm-ssh"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// SSHRun - SSH 
func (s *SSHService) SSHRun(ctx context.Context, req *pb.SSHRunRequest) (*pb.StringResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling SSHService.SSHRun()")

        strPrivateKey := strings.Join(req.PrivateKey[:], "\n")

        sshInfo := sshrun.SSHInfo{
                UserName:   req.UserName,
                PrivateKey: []byte(strPrivateKey),
                ServerPort: req.ServerPort,
        }

        var result string
        var err error
        if result, err = sshrun.SSHRun(sshInfo, req.Command); err != nil </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr("Error while running cmd: "+req.Command+"]"+err.Error(), "", "SSHService.SSHRun()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StringResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file23" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// StartVM - VM 
func (s *CCMService) StartVM(ctx context.Context, req *pb.VMCreateRequest) (*pb.VMInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.StartVM()")

        // Rest RegInfo =&gt; Driver ReqInfo
        // (1) create SecurityGroup IID List
        sgIIDList := []cres.IID{}
        for _, sgName := range req.Item.SecurityGroupNames </span><span class="cov8" title="1">{
                // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                // transform: SG NameID =&gt; {VPC NameID}-{SG NameID}
                sgIID := cres.IID{NameId: req.Item.VpcName + cm.SG_DELIMITER + sgName, SystemId: ""}
                sgIIDList = append(sgIIDList, sgIID)
        }</span>
        // (2) create VMReqInfo with SecurityGroup IID List
        <span class="cov8" title="1">reqInfo := cres.VMReqInfo{
                IId:               cres.IID{NameId: req.Item.Name, SystemId: ""},
                ImageIID:          cres.IID{NameId: req.Item.ImageName, SystemId: ""},
                VpcIID:            cres.IID{NameId: req.Item.VpcName, SystemId: ""},
                SubnetIID:         cres.IID{NameId: req.Item.SubnetName, SystemId: ""},
                SecurityGroupIIDs: sgIIDList,

                VMSpecName: req.Item.VmSpecName,
                KeyPairIID: cres.IID{NameId: req.Item.KeyPairName, SystemId: ""},

                VMUserId:     req.Item.VmUserId,
                VMUserPasswd: req.Item.VmUserPasswd,
        }

        // Call common-runtime API
        result, err := cmrt.StartVM(req.ConnectionName, rsVM, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.StartVM()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.VMInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.StartVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VMInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ControlVM - VM 
func (s *CCMService) ControlVM(ctx context.Context, req *pb.VMActionRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ControlVM()")

        // Call common-runtime API
        result, err := cmrt.ControlVM(req.ConnectionName, rsVM, req.Name, req.Action)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ControlVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// ListVM - VM 
func (s *CCMService) ListVM(ctx context.Context, req *pb.VMAllQryRequest) (*pb.ListVMInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVM()")

        // Call common-runtime API
        result, err := cmrt.ListVM(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVM()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.VMInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVMInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVM - VM 
func (s *CCMService) GetVM(ctx context.Context, req *pb.VMQryRequest) (*pb.VMInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVM()")

        // Call common-runtime API
        result, err := cmrt.GetVM(req.ConnectionName, rsVM, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVM()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.VMInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VMInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListVMStatus - VM  
func (s *CCMService) ListVMStatus(ctx context.Context, req *pb.VMAllQryRequest) (*pb.ListVMStatusInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVMStatus()")

        // Call common-runtime API
        result, err := cmrt.ListVMStatus(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMStatus()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.VMStatusInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMStatus()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVMStatusInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVMStatus - VM  
func (s *CCMService) GetVMStatus(ctx context.Context, req *pb.VMQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVMStatus()")

        // Call common-runtime API
        result, err := cmrt.GetVMStatus(req.ConnectionName, rsVM, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVMStatus()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// TerminateVM - VM 
func (s *CCMService) TerminateVM(ctx context.Context, req *pb.VMQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.TerminateVM()")

        // Call common-runtime API
        _, result, err := cmrt.DeleteResource(req.ConnectionName, rsVM, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.TerminateVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// ListAllVM -  VM 
func (s *CCMService) ListAllVM(ctx context.Context, req *pb.VMAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllVM()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVM()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVM()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// TerminateCSPVM - CSP VM 
func (s *CCMService) TerminateCSPVM(ctx context.Context, req *pb.CSPVMQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.TerminateCSPVM()")

        // Call common-runtime API
        _, result, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVM, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.TerminateCSPVM()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StatusResponse{Status: string(result)}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file24" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListVMSpec - VM Spec 
func (s *CCMService) ListVMSpec(ctx context.Context, req *pb.VMSpecAllQryRequest) (*pb.ListVMSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVMSpec()")

        // Call common-runtime API
        result, err := cmrt.ListVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMSpec()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.VMSpecInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVMSpecInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVMSpec - VM Spec 
func (s *CCMService) GetVMSpec(ctx context.Context, req *pb.VMSpecQryRequest) (*pb.VMSpecInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVMSpec()")

        // Call common-runtime API
        result, err := cmrt.GetVMSpec(req.ConnectionName, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVMSpec()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.VMSpecInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VMSpecInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListOrgVMSpec -   VM Spec 
func (s *CCMService) ListOrgVMSpec(ctx context.Context, req *pb.VMSpecAllQryRequest) (*pb.StringResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListOrgVMSpec()")

        // Call common-runtime API
        result, err := cmrt.ListOrgVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListOrgVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StringResponse{Result: result}

        return resp, nil</span>
}

// GetOrgVMSpec -   VM Spec 
func (s *CCMService) GetOrgVMSpec(ctx context.Context, req *pb.VMSpecQryRequest) (*pb.StringResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetOrgVMSpec()")

        // Call common-runtime API
        result, err := cmrt.GetOrgVMSpec(req.ConnectionName, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetOrgVMSpec()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.StringResponse{Result: result}

        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file25" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package service

import (
        "context"
        "strings"
        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"

        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateVPC - VPC 
func (s *CCMService) CreateVPC(ctx context.Context, req *pb.VPCCreateRequest) (*pb.VPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.CreateVPC()")

        // check the input Name to include the SUBNET: Prefix
        if strings.HasPrefix(req.Item.Name, cm.SUBNET_PREFIX) </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr(cm.SUBNET_PREFIX+" cannot be used for VPC name prefix!!", "", "CCMService.CreateVPC()")
        }</span>
        // check the input Name to include the SecurityGroup Delimiter
        <span class="cov8" title="1">if strings.HasPrefix(req.Item.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return nil, gc.NewGrpcStatusErr(cm.SG_DELIMITER+" cannot be used in VPC name!!", "", "CCMService.CreateVPC()")
        }</span>

        // Grpc RegInfo =&gt; Driver ReqInfo
        // (1) create SubnetInfo List
        <span class="cov8" title="1">subnetInfoList := []cres.SubnetInfo{}
        for _, info := range req.Item.SubnetInfoList </span><span class="cov8" title="1">{
                subnetInfo := cres.SubnetInfo{IId: cres.IID{NameId: info.Name, SystemId: ""}, IPv4_CIDR: info.Ipv4Cidr}
                subnetInfoList = append(subnetInfoList, subnetInfo)
        }</span>
        // (2) create VPCReqInfo with SubnetInfo List
        <span class="cov8" title="1">reqInfo := cres.VPCReqInfo{
                IId:            cres.IID{NameId: req.Item.Name, SystemId: ""},
                IPv4_CIDR:      req.Item.Ipv4Cidr,
                SubnetInfoList: subnetInfoList,
        }

        // Call common-runtime API
        result, err := cmrt.CreateVPC(req.ConnectionName, rsVPC, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateVPC()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.VPCInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.CreateVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VPCInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListVPC - VPC 
func (s *CCMService) ListVPC(ctx context.Context, req *pb.VPCAllQryRequest) (*pb.ListVPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListVPC()")

        // Call common-runtime API
        result, err := cmrt.ListVPC(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVPC()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj []*pb.VPCInfo
        err = gc.CopySrcToDest(&amp;result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ListVPCInfoResponse{Items: grpcObj}
        return resp, nil</span>
}

// GetVPC - VPC 
func (s *CCMService) GetVPC(ctx context.Context, req *pb.VPCQryRequest) (*pb.VPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.GetVPC()")

        // Call common-runtime API
        result, err := cmrt.GetVPC(req.ConnectionName, rsVPC, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVPC()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.VPCInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.GetVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VPCInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteVPC - VPC 
func (s *CCMService) DeleteVPC(ctx context.Context, req *pb.VPCQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteVPC()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, rsVPC, req.Name, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ListAllVPC -  VPC 
func (s *CCMService) ListAllVPC(ctx context.Context, req *pb.VPCAllQryRequest) (*pb.AllResourceInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.ListAllVPC()")

        // Call common-runtime API
        allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVPC()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.AllResourceInfoResponse
        err = gc.CopySrcToDest(&amp;allResourceList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.ListAllVPC()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// DeleteCSPVPC - CSP VPC 
func (s *CCMService) DeleteCSPVPC(ctx context.Context, req *pb.CSPVPCQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.DeleteCSPVPC()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVPC, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.DeleteCSPVPC()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// AddSubnet - Subnet 
func (s *CCMService) AddSubnet(ctx context.Context, req *pb.SubnetAddRequest) (*pb.VPCInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.AddSubnet()")

        // Grpc RegInfo =&gt; Driver ReqInfo
        reqSubnetInfo := cres.SubnetInfo{IId: cres.IID{req.Item.Name, ""}, IPv4_CIDR: req.Item.Ipv4Cidr}

        // Call common-runtime API
        result, err := cmrt.AddSubnet(req.ConnectionName, cm.SUBNET_PREFIX+req.VpcName, req.VpcName, reqSubnetInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.AddSubnet()")
        }</span>

        // CCM  GRPC  
        <span class="cov8" title="1">var grpcObj pb.VPCInfo
        err = gc.CopySrcToDest(result, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.AddSubnet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.VPCInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// RemoveSubnet - Subnet 
func (s *CCMService) RemoveSubnet(ctx context.Context, req *pb.SubnetQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.RemoveSubnet()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteResource(req.ConnectionName, cm.SUBNET_PREFIX+req.VpcName, req.SubnetName, req.Force)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.RemoveSubnet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// RemoveCSPSubnet - CSP Subnet 
func (s *CCMService) RemoveCSPSubnet(ctx context.Context, req *pb.CSPSubnetQryRequest) (*pb.BooleanResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling CCMService.RemoveCSPSubnet()")

        // Call common-runtime API
        result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, cm.SUBNET_PREFIX+req.VpcName, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "CCMService.RemoveCSPSubnet()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.BooleanResponse{Result: result}
        return resp, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cbspider.proto

package cbspider

import (
        context "context"
        fmt "fmt"
        _ "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/gogoproto"
        proto "github.com/golang/protobuf/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Empty  
type Empty struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         <span class="cov8" title="1">{ *m = Empty{} }</span>
func (m *Empty) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Empty) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Empty) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{0}
}</span>
func (m *Empty) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Empty) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Empty.Merge(m, src)
}</span>
func (m *Empty) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Empty) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Empty.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Empty proto.InternalMessageInfo

// KeyValue  
type KeyValue struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,json=Key,proto3" json:"Key" yaml:"Key"`
        Value                string   `protobuf:"bytes,2,opt,name=value,json=Value,proto3" json:"Value" yaml:"Value"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValue) Reset()         <span class="cov0" title="0">{ *m = KeyValue{} }</span>
func (m *KeyValue) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyValue) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyValue) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{1}
}</span>
func (m *KeyValue) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyValue) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyValue.Merge(m, src)
}</span>
func (m *KeyValue) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyValue) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyValue.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyValue) GetValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// IID  
type IID struct {
        NameId               string   `protobuf:"bytes,1,opt,name=name_id,json=NameId,proto3" json:"NameId" yaml:"NameId"`
        SystemId             string   `protobuf:"bytes,2,opt,name=system_id,json=SystemId,proto3" json:"SystemId" yaml:"SystemId"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *IID) Reset()         <span class="cov0" title="0">{ *m = IID{} }</span>
func (m *IID) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*IID) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*IID) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{2}
}</span>
func (m *IID) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *IID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_IID.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *IID) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_IID.Merge(m, src)
}</span>
func (m *IID) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *IID) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_IID.DiscardUnknown(m)
}</span>

var xxx_messageInfo_IID proto.InternalMessageInfo

func (m *IID) GetNameId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NameId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *IID) GetSystemId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SystemId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Boolean   
type BooleanResponse struct {
        Result               bool     `protobuf:"varint,1,opt,name=result,json=Result,proto3" json:"Result" yaml:"Result"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BooleanResponse) Reset()         <span class="cov8" title="1">{ *m = BooleanResponse{} }</span>
func (m *BooleanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BooleanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BooleanResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{3}
}</span>
func (m *BooleanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *BooleanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_BooleanResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *BooleanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BooleanResponse.Merge(m, src)
}</span>
func (m *BooleanResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *BooleanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BooleanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BooleanResponse proto.InternalMessageInfo

func (m *BooleanResponse) GetResult() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Result
        }</span>
        <span class="cov0" title="0">return false</span>
}

// StringResponse   
type StringResponse struct {
        Result               string   `protobuf:"bytes,1,opt,name=result,json=Result,proto3" json:"Result" yaml:"Result"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *StringResponse) Reset()         <span class="cov8" title="1">{ *m = StringResponse{} }</span>
func (m *StringResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*StringResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*StringResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{4}
}</span>
func (m *StringResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *StringResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_StringResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *StringResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_StringResponse.Merge(m, src)
}</span>
func (m *StringResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *StringResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_StringResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_StringResponse proto.InternalMessageInfo

func (m *StringResponse) GetResult() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Result
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MessageResponse   
type MessageResponse struct {
        Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message" yaml:"message"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MessageResponse) Reset()         <span class="cov0" title="0">{ *m = MessageResponse{} }</span>
func (m *MessageResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MessageResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MessageResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{5}
}</span>
func (m *MessageResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MessageResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MessageResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MessageResponse.Merge(m, src)
}</span>
func (m *MessageResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MessageResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MessageResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MessageResponse proto.InternalMessageInfo

func (m *MessageResponse) GetMessage() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Status   
type StatusResponse struct {
        Status               string   `protobuf:"bytes,1,opt,name=status,json=Status,proto3" json:"Status" yaml:"Status"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *StatusResponse) Reset()         <span class="cov8" title="1">{ *m = StatusResponse{} }</span>
func (m *StatusResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*StatusResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*StatusResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{6}
}</span>
func (m *StatusResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_StatusResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *StatusResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_StatusResponse.Merge(m, src)
}</span>
func (m *StatusResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *StatusResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func (m *StatusResponse) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListCloudOSInfoResponse struct {
        Items                []string `protobuf:"bytes,1,rep,name=items,json=cloudos,proto3" json:"cloudos" yaml:"cloudos"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListCloudOSInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListCloudOSInfoResponse{} }</span>
func (m *ListCloudOSInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListCloudOSInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListCloudOSInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{7}
}</span>
func (m *ListCloudOSInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListCloudOSInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListCloudOSInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListCloudOSInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudOSInfoResponse.Merge(m, src)
}</span>
func (m *ListCloudOSInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListCloudOSInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudOSInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListCloudOSInfoResponse proto.InternalMessageInfo

func (m *ListCloudOSInfoResponse) GetItems() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CloudDriverInfoRequest struct {
        Item                 *CloudDriverInfo `protobuf:"bytes,1,opt,name=item,json=driver,proto3" json:"driver" yaml:"driver"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *CloudDriverInfoRequest) Reset()         <span class="cov8" title="1">{ *m = CloudDriverInfoRequest{} }</span>
func (m *CloudDriverInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{8}
}</span>
func (m *CloudDriverInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoRequest.Merge(m, src)
}</span>
func (m *CloudDriverInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverInfoRequest proto.InternalMessageInfo

func (m *CloudDriverInfoRequest) GetItem() *CloudDriverInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CloudDriverInfoResponse struct {
        Item                 *CloudDriverInfo `protobuf:"bytes,1,opt,name=item,json=driver,proto3" json:"driver" yaml:"driver"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *CloudDriverInfoResponse) Reset()         <span class="cov8" title="1">{ *m = CloudDriverInfoResponse{} }</span>
func (m *CloudDriverInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{9}
}</span>
func (m *CloudDriverInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoResponse.Merge(m, src)
}</span>
func (m *CloudDriverInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverInfoResponse proto.InternalMessageInfo

func (m *CloudDriverInfoResponse) GetItem() *CloudDriverInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListCloudDriverInfoResponse struct {
        Items                []*CloudDriverInfo `protobuf:"bytes,1,rep,name=items,json=driver,proto3" json:"driver" yaml:"driver"`
        XXX_NoUnkeyedLiteral struct{}           `json:"-"`
        XXX_unrecognized     []byte             `json:"-"`
        XXX_sizecache        int32              `json:"-"`
}

func (m *ListCloudDriverInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListCloudDriverInfoResponse{} }</span>
func (m *ListCloudDriverInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListCloudDriverInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListCloudDriverInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{10}
}</span>
func (m *ListCloudDriverInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListCloudDriverInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListCloudDriverInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListCloudDriverInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudDriverInfoResponse.Merge(m, src)
}</span>
func (m *ListCloudDriverInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListCloudDriverInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListCloudDriverInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListCloudDriverInfoResponse proto.InternalMessageInfo

func (m *ListCloudDriverInfoResponse) GetItems() []*CloudDriverInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CloudDriverInfo struct {
        DriverName           string   `protobuf:"bytes,1,opt,name=driver_name,json=DriverName,proto3" json:"DriverName" yaml:"DriverName"`
        ProviderName         string   `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        DriverLibFileName    string   `protobuf:"bytes,3,opt,name=driver_lib_file_name,json=DriverLibFileName,proto3" json:"DriverLibFileName" yaml:"DriverLibFileName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CloudDriverInfo) Reset()         <span class="cov0" title="0">{ *m = CloudDriverInfo{} }</span>
func (m *CloudDriverInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{11}
}</span>
func (m *CloudDriverInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfo.Merge(m, src)
}</span>
func (m *CloudDriverInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverInfo proto.InternalMessageInfo

func (m *CloudDriverInfo) GetDriverName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CloudDriverInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CloudDriverInfo) GetDriverLibFileName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverLibFileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CloudDriverQryRequest struct {
        DriverName           string   `protobuf:"bytes,1,opt,name=driver_name,json=DriverName,proto3" json:"DriverName" yaml:"DriverName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CloudDriverQryRequest) Reset()         <span class="cov8" title="1">{ *m = CloudDriverQryRequest{} }</span>
func (m *CloudDriverQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CloudDriverQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CloudDriverQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{12}
}</span>
func (m *CloudDriverQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CloudDriverQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CloudDriverQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CloudDriverQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverQryRequest.Merge(m, src)
}</span>
func (m *CloudDriverQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CloudDriverQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CloudDriverQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CloudDriverQryRequest proto.InternalMessageInfo

func (m *CloudDriverQryRequest) GetDriverName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CredentialInfoRequest struct {
        Item                 *CredentialInfo `protobuf:"bytes,1,opt,name=item,json=credential,proto3" json:"credential" yaml:"credential"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *CredentialInfoRequest) Reset()         <span class="cov8" title="1">{ *m = CredentialInfoRequest{} }</span>
func (m *CredentialInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{13}
}</span>
func (m *CredentialInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoRequest.Merge(m, src)
}</span>
func (m *CredentialInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialInfoRequest proto.InternalMessageInfo

func (m *CredentialInfoRequest) GetItem() *CredentialInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CredentialInfoResponse struct {
        Item                 *CredentialInfo `protobuf:"bytes,1,opt,name=item,json=credential,proto3" json:"credential" yaml:"credential"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *CredentialInfoResponse) Reset()         <span class="cov8" title="1">{ *m = CredentialInfoResponse{} }</span>
func (m *CredentialInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{14}
}</span>
func (m *CredentialInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoResponse.Merge(m, src)
}</span>
func (m *CredentialInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialInfoResponse proto.InternalMessageInfo

func (m *CredentialInfoResponse) GetItem() *CredentialInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListCredentialInfoResponse struct {
        Items                []*CredentialInfo `protobuf:"bytes,1,rep,name=items,json=credential,proto3" json:"credential" yaml:"credential"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *ListCredentialInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListCredentialInfoResponse{} }</span>
func (m *ListCredentialInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListCredentialInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListCredentialInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{15}
}</span>
func (m *ListCredentialInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListCredentialInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListCredentialInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListCredentialInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListCredentialInfoResponse.Merge(m, src)
}</span>
func (m *ListCredentialInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListCredentialInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListCredentialInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListCredentialInfoResponse proto.InternalMessageInfo

func (m *ListCredentialInfoResponse) GetItems() []*CredentialInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CredentialInfo struct {
        CredentialName       string      `protobuf:"bytes,1,opt,name=credential_name,json=CredentialName,proto3" json:"CredentialName" yaml:"CredentialName"`
        ProviderName         string      `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        KeyValueInfoList     []*KeyValue `protobuf:"bytes,3,rep,name=key_value_info_list,json=KeyValueInfoList,proto3" json:"KeyValueInfoList" yaml:"KeyValueInfoList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *CredentialInfo) Reset()         <span class="cov0" title="0">{ *m = CredentialInfo{} }</span>
func (m *CredentialInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{16}
}</span>
func (m *CredentialInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfo.Merge(m, src)
}</span>
func (m *CredentialInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialInfo proto.InternalMessageInfo

func (m *CredentialInfo) GetCredentialName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CredentialName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CredentialInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CredentialInfo) GetKeyValueInfoList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CredentialQryRequest struct {
        CredentialName       string   `protobuf:"bytes,1,opt,name=credential_name,json=CredentialName,proto3" json:"CredentialName" yaml:"CredentialName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CredentialQryRequest) Reset()         <span class="cov8" title="1">{ *m = CredentialQryRequest{} }</span>
func (m *CredentialQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CredentialQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CredentialQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{17}
}</span>
func (m *CredentialQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CredentialQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CredentialQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CredentialQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CredentialQryRequest.Merge(m, src)
}</span>
func (m *CredentialQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CredentialQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CredentialQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CredentialQryRequest proto.InternalMessageInfo

func (m *CredentialQryRequest) GetCredentialName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CredentialName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegionInfoRequest struct {
        Item                 *RegionInfo `protobuf:"bytes,1,opt,name=item,json=region,proto3" json:"region" yaml:"region"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *RegionInfoRequest) Reset()         <span class="cov8" title="1">{ *m = RegionInfoRequest{} }</span>
func (m *RegionInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{18}
}</span>
func (m *RegionInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoRequest.Merge(m, src)
}</span>
func (m *RegionInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionInfoRequest proto.InternalMessageInfo

func (m *RegionInfoRequest) GetItem() *RegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RegionInfoResponse struct {
        Item                 *RegionInfo `protobuf:"bytes,1,opt,name=item,json=region,proto3" json:"region" yaml:"region"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *RegionInfoResponse) Reset()         <span class="cov8" title="1">{ *m = RegionInfoResponse{} }</span>
func (m *RegionInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{19}
}</span>
func (m *RegionInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoResponse.Merge(m, src)
}</span>
func (m *RegionInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionInfoResponse proto.InternalMessageInfo

func (m *RegionInfoResponse) GetItem() *RegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListRegionInfoResponse struct {
        Items                []*RegionInfo `protobuf:"bytes,1,rep,name=items,json=region,proto3" json:"region" yaml:"region"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *ListRegionInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListRegionInfoResponse{} }</span>
func (m *ListRegionInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListRegionInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListRegionInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{20}
}</span>
func (m *ListRegionInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListRegionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListRegionInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListRegionInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListRegionInfoResponse.Merge(m, src)
}</span>
func (m *ListRegionInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListRegionInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListRegionInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListRegionInfoResponse proto.InternalMessageInfo

func (m *ListRegionInfoResponse) GetItems() []*RegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RegionInfo struct {
        RegionName           string      `protobuf:"bytes,1,opt,name=region_name,json=RegionName,proto3" json:"RegionName" yaml:"RegionName"`
        ProviderName         string      `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        KeyValueInfoList     []*KeyValue `protobuf:"bytes,3,rep,name=key_value_info_list,json=KeyValueInfoList,proto3" json:"KeyValueInfoList" yaml:"KeyValueInfoList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *RegionInfo) Reset()         <span class="cov0" title="0">{ *m = RegionInfo{} }</span>
func (m *RegionInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{21}
}</span>
func (m *RegionInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfo.Merge(m, src)
}</span>
func (m *RegionInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionInfo proto.InternalMessageInfo

func (m *RegionInfo) GetRegionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RegionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RegionInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RegionInfo) GetKeyValueInfoList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RegionQryRequest struct {
        RegionName           string   `protobuf:"bytes,1,opt,name=region_name,json=RegionName,proto3" json:"RegionName" yaml:"RegionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *RegionQryRequest) Reset()         <span class="cov8" title="1">{ *m = RegionQryRequest{} }</span>
func (m *RegionQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegionQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegionQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{22}
}</span>
func (m *RegionQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegionQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegionQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegionQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegionQryRequest.Merge(m, src)
}</span>
func (m *RegionQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegionQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegionQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegionQryRequest proto.InternalMessageInfo

func (m *RegionQryRequest) GetRegionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RegionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ConnectionConfigInfoRequest struct {
        Item                 *ConnectionConfigInfo `protobuf:"bytes,1,opt,name=item,json=connectionconfig,proto3" json:"connectionconfig" yaml:"connectionconfig"`
        XXX_NoUnkeyedLiteral struct{}              `json:"-"`
        XXX_unrecognized     []byte                `json:"-"`
        XXX_sizecache        int32                 `json:"-"`
}

func (m *ConnectionConfigInfoRequest) Reset()         <span class="cov8" title="1">{ *m = ConnectionConfigInfoRequest{} }</span>
func (m *ConnectionConfigInfoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigInfoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigInfoRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{23}
}</span>
func (m *ConnectionConfigInfoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigInfoRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigInfoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoRequest.Merge(m, src)
}</span>
func (m *ConnectionConfigInfoRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigInfoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigInfoRequest proto.InternalMessageInfo

func (m *ConnectionConfigInfoRequest) GetItem() *ConnectionConfigInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConnectionConfigInfoResponse struct {
        Item                 *ConnectionConfigInfo `protobuf:"bytes,1,opt,name=item,json=connectionconfig,proto3" json:"connectionconfig" yaml:"connectionconfig"`
        XXX_NoUnkeyedLiteral struct{}              `json:"-"`
        XXX_unrecognized     []byte                `json:"-"`
        XXX_sizecache        int32                 `json:"-"`
}

func (m *ConnectionConfigInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ConnectionConfigInfoResponse{} }</span>
func (m *ConnectionConfigInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{24}
}</span>
func (m *ConnectionConfigInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoResponse.Merge(m, src)
}</span>
func (m *ConnectionConfigInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigInfoResponse proto.InternalMessageInfo

func (m *ConnectionConfigInfoResponse) GetItem() *ConnectionConfigInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListConnectionConfigInfoResponse struct {
        Items                []*ConnectionConfigInfo `protobuf:"bytes,1,rep,name=items,json=connectionconfig,proto3" json:"connectionconfig" yaml:"connectionconfig"`
        XXX_NoUnkeyedLiteral struct{}                `json:"-"`
        XXX_unrecognized     []byte                  `json:"-"`
        XXX_sizecache        int32                   `json:"-"`
}

func (m *ListConnectionConfigInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListConnectionConfigInfoResponse{} }</span>
func (m *ListConnectionConfigInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListConnectionConfigInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListConnectionConfigInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{25}
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListConnectionConfigInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListConnectionConfigInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListConnectionConfigInfoResponse.Merge(m, src)
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListConnectionConfigInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListConnectionConfigInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListConnectionConfigInfoResponse proto.InternalMessageInfo

func (m *ListConnectionConfigInfoResponse) GetItems() []*ConnectionConfigInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConnectionConfigInfo struct {
        ConfigName           string   `protobuf:"bytes,1,opt,name=config_name,json=ConfigName,proto3" json:"ConfigName" yaml:"ConfigName"`
        ProviderName         string   `protobuf:"bytes,2,opt,name=provider_name,json=ProviderName,proto3" json:"ProviderName" yaml:"ProviderName"`
        DriverName           string   `protobuf:"bytes,3,opt,name=driver_name,json=DriverName,proto3" json:"DriverName" yaml:"DriverName"`
        CredentialName       string   `protobuf:"bytes,4,opt,name=credential_name,json=CredentialName,proto3" json:"CredentialName" yaml:"CredentialName"`
        RegionName           string   `protobuf:"bytes,5,opt,name=region_name,json=RegionName,proto3" json:"RegionName" yaml:"RegionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionConfigInfo) Reset()         <span class="cov0" title="0">{ *m = ConnectionConfigInfo{} }</span>
func (m *ConnectionConfigInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{26}
}</span>
func (m *ConnectionConfigInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfo.Merge(m, src)
}</span>
func (m *ConnectionConfigInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigInfo proto.InternalMessageInfo

func (m *ConnectionConfigInfo) GetConfigName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConfigName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetProviderName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ProviderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetDriverName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DriverName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetCredentialName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CredentialName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ConnectionConfigInfo) GetRegionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RegionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ConnectionConfigQryRequest struct {
        ConfigName           string   `protobuf:"bytes,1,opt,name=config_name,json=ConfigName,proto3" json:"ConfigName" yaml:"ConfigName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionConfigQryRequest) Reset()         <span class="cov8" title="1">{ *m = ConnectionConfigQryRequest{} }</span>
func (m *ConnectionConfigQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ConnectionConfigQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ConnectionConfigQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{27}
}</span>
func (m *ConnectionConfigQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ConnectionConfigQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ConnectionConfigQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ConnectionConfigQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigQryRequest.Merge(m, src)
}</span>
func (m *ConnectionConfigQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ConnectionConfigQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ConnectionConfigQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ConnectionConfigQryRequest proto.InternalMessageInfo

func (m *ConnectionConfigQryRequest) GetConfigName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConfigName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AllResourceInfoResponse struct {
        Item                 *AllResourceInfo `protobuf:"bytes,1,opt,name=item,json=AllList,proto3" json:"AllList" yaml:"AllList"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *AllResourceInfoResponse) Reset()         <span class="cov8" title="1">{ *m = AllResourceInfoResponse{} }</span>
func (m *AllResourceInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AllResourceInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AllResourceInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{28}
}</span>
func (m *AllResourceInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AllResourceInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AllResourceInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AllResourceInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfoResponse.Merge(m, src)
}</span>
func (m *AllResourceInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AllResourceInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AllResourceInfoResponse proto.InternalMessageInfo

func (m *AllResourceInfoResponse) GetItem() *AllResourceInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AllResourceInfo struct {
        MappedList           []*IID   `protobuf:"bytes,1,rep,name=mapped_list,json=MappedList,proto3" json:"MappedList" yaml:"MappedList"`
        OnlySpiderList       []*IID   `protobuf:"bytes,2,rep,name=only_spider_list,json=OnlySpiderList,proto3" json:"OnlySpiderList" yaml:"OnlySpiderList"`
        OnlyCspList          []*IID   `protobuf:"bytes,3,rep,name=only_csp_list,json=OnlyCSPList,proto3" json:"OnlyCSPList" yaml:"OnlyCSPList"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AllResourceInfo) Reset()         <span class="cov0" title="0">{ *m = AllResourceInfo{} }</span>
func (m *AllResourceInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AllResourceInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AllResourceInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{29}
}</span>
func (m *AllResourceInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AllResourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AllResourceInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AllResourceInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfo.Merge(m, src)
}</span>
func (m *AllResourceInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AllResourceInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AllResourceInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AllResourceInfo proto.InternalMessageInfo

func (m *AllResourceInfo) GetMappedList() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MappedList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *AllResourceInfo) GetOnlySpiderList() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.OnlySpiderList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *AllResourceInfo) GetOnlyCspList() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.OnlyCspList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageInfoResponse struct {
        Item                 *ImageInfo `protobuf:"bytes,1,opt,name=item,json=image,proto3" json:"image" yaml:"image"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *ImageInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ImageInfoResponse{} }</span>
func (m *ImageInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{30}
}</span>
func (m *ImageInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfoResponse.Merge(m, src)
}</span>
func (m *ImageInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageInfoResponse proto.InternalMessageInfo

func (m *ImageInfoResponse) GetItem() *ImageInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListImageInfoResponse struct {
        Items                []*ImageInfo `protobuf:"bytes,1,rep,name=items,json=image,proto3" json:"image" yaml:"image"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *ListImageInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListImageInfoResponse{} }</span>
func (m *ListImageInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListImageInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListImageInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{31}
}</span>
func (m *ListImageInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListImageInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListImageInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListImageInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListImageInfoResponse.Merge(m, src)
}</span>
func (m *ListImageInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListImageInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListImageInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListImageInfoResponse proto.InternalMessageInfo

func (m *ListImageInfoResponse) GetItems() []*ImageInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageInfo struct {
        Iid                  *IID        `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        GuestOs              string      `protobuf:"bytes,2,opt,name=guest_os,json=GuestOS,proto3" json:"GuestOS" yaml:"GuestOS"`
        Status               string      `protobuf:"bytes,3,opt,name=status,json=Status,proto3" json:"Status" yaml:"Status"`
        KeyValueList         []*KeyValue `protobuf:"bytes,4,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *ImageInfo) Reset()         <span class="cov0" title="0">{ *m = ImageInfo{} }</span>
func (m *ImageInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{32}
}</span>
func (m *ImageInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfo.Merge(m, src)
}</span>
func (m *ImageInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageInfo proto.InternalMessageInfo

func (m *ImageInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ImageInfo) GetGuestOs() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.GuestOs
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageInfo) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageCreateRequest struct {
        ConnectionName       string           `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *ImageCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *ImageCreateRequest) Reset()         <span class="cov8" title="1">{ *m = ImageCreateRequest{} }</span>
func (m *ImageCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{33}
}</span>
func (m *ImageCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateRequest.Merge(m, src)
}</span>
func (m *ImageCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageCreateRequest proto.InternalMessageInfo

func (m *ImageCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageCreateRequest) GetItem() *ImageCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImageCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ImageCreateInfo) Reset()         <span class="cov0" title="0">{ *m = ImageCreateInfo{} }</span>
func (m *ImageCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{34}
}</span>
func (m *ImageCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateInfo.Merge(m, src)
}</span>
func (m *ImageCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageCreateInfo proto.InternalMessageInfo

func (m *ImageCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ImageAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ImageAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = ImageAllQryRequest{} }</span>
func (m *ImageAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{35}
}</span>
func (m *ImageAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageAllQryRequest.Merge(m, src)
}</span>
func (m *ImageAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageAllQryRequest proto.InternalMessageInfo

func (m *ImageAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ImageQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ImageQryRequest) Reset()         <span class="cov8" title="1">{ *m = ImageQryRequest{} }</span>
func (m *ImageQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ImageQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ImageQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{36}
}</span>
func (m *ImageQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ImageQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ImageQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ImageQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ImageQryRequest.Merge(m, src)
}</span>
func (m *ImageQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ImageQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ImageQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ImageQryRequest proto.InternalMessageInfo

func (m *ImageQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ImageQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMSpecInfoResponse struct {
        Item                 *VMSpecInfo `protobuf:"bytes,1,opt,name=item,json=vmspec,proto3" json:"vmspec" yaml:"vmspec"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *VMSpecInfoResponse) Reset()         <span class="cov8" title="1">{ *m = VMSpecInfoResponse{} }</span>
func (m *VMSpecInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{37}
}</span>
func (m *VMSpecInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfoResponse.Merge(m, src)
}</span>
func (m *VMSpecInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecInfoResponse proto.InternalMessageInfo

func (m *VMSpecInfoResponse) GetItem() *VMSpecInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListVMSpecInfoResponse struct {
        Items                []*VMSpecInfo `protobuf:"bytes,1,rep,name=items,json=vmspec,proto3" json:"vmspec" yaml:"vmspec"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *ListVMSpecInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVMSpecInfoResponse{} }</span>
func (m *ListVMSpecInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVMSpecInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVMSpecInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{38}
}</span>
func (m *ListVMSpecInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVMSpecInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVMSpecInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVMSpecInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVMSpecInfoResponse.Merge(m, src)
}</span>
func (m *ListVMSpecInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVMSpecInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVMSpecInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVMSpecInfoResponse proto.InternalMessageInfo

func (m *ListVMSpecInfoResponse) GetItems() []*VMSpecInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMSpecInfo struct {
        Region               string      `protobuf:"bytes,1,opt,name=region,json=Region,proto3" json:"Region" yaml:"Region"`
        Name                 string      `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        VCpu                 *VCpuInfo   `protobuf:"bytes,3,opt,name=v_cpu,json=VCpu,proto3" json:"VCpu" yaml:"VCpu"`
        Mem                  string      `protobuf:"bytes,4,opt,name=mem,json=Mem,proto3" json:"Mem" yaml:"Mem"`
        Gpu                  []*GpuInfo  `protobuf:"bytes,5,rep,name=gpu,json=Gpu,proto3" json:"Gpu" yaml:"Gpu"`
        KeyValueList         []*KeyValue `protobuf:"bytes,6,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *VMSpecInfo) Reset()         <span class="cov0" title="0">{ *m = VMSpecInfo{} }</span>
func (m *VMSpecInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{39}
}</span>
func (m *VMSpecInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfo.Merge(m, src)
}</span>
func (m *VMSpecInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecInfo proto.InternalMessageInfo

func (m *VMSpecInfo) GetRegion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecInfo) GetVCpu() *VCpuInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VCpu
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMSpecInfo) GetMem() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Mem
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecInfo) GetGpu() []*GpuInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Gpu
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMSpecInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VCpuInfo struct {
        Count                string   `protobuf:"bytes,1,opt,name=count,json=Count,proto3" json:"Count" yaml:"Count"`
        Clock                string   `protobuf:"bytes,2,opt,name=clock,json=Clock,proto3" json:"Clock" yaml:"Clock"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VCpuInfo) Reset()         <span class="cov0" title="0">{ *m = VCpuInfo{} }</span>
func (m *VCpuInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VCpuInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VCpuInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{40}
}</span>
func (m *VCpuInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VCpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VCpuInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VCpuInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VCpuInfo.Merge(m, src)
}</span>
func (m *VCpuInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VCpuInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VCpuInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VCpuInfo proto.InternalMessageInfo

func (m *VCpuInfo) GetCount() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Count
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VCpuInfo) GetClock() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Clock
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GpuInfo struct {
        Count                string   `protobuf:"bytes,1,opt,name=count,json=Count,proto3" json:"Count" yaml:"Count"`
        Mfr                  string   `protobuf:"bytes,2,opt,name=mfr,json=Mfr,proto3" json:"Mfr" yaml:"Mfr"`
        Model                string   `protobuf:"bytes,3,opt,name=model,json=Model,proto3" json:"Model" yaml:"Model"`
        Mem                  string   `protobuf:"bytes,4,opt,name=mem,json=Mem,proto3" json:"Mem" yaml:"Mem"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GpuInfo) Reset()         <span class="cov0" title="0">{ *m = GpuInfo{} }</span>
func (m *GpuInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GpuInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GpuInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{41}
}</span>
func (m *GpuInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GpuInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GpuInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GpuInfo.Merge(m, src)
}</span>
func (m *GpuInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GpuInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GpuInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GpuInfo proto.InternalMessageInfo

func (m *GpuInfo) GetCount() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Count
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GpuInfo) GetMfr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Mfr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GpuInfo) GetModel() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Model
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GpuInfo) GetMem() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Mem
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMSpecAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMSpecAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMSpecAllQryRequest{} }</span>
func (m *VMSpecAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{42}
}</span>
func (m *VMSpecAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecAllQryRequest.Merge(m, src)
}</span>
func (m *VMSpecAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecAllQryRequest proto.InternalMessageInfo

func (m *VMSpecAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMSpecQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMSpecQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMSpecQryRequest{} }</span>
func (m *VMSpecQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMSpecQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMSpecQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{43}
}</span>
func (m *VMSpecQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMSpecQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMSpecQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMSpecQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecQryRequest.Merge(m, src)
}</span>
func (m *VMSpecQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMSpecQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMSpecQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMSpecQryRequest proto.InternalMessageInfo

func (m *VMSpecQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMSpecQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VPCInfoResponse struct {
        Item                 *VPCInfo `protobuf:"bytes,1,opt,name=item,json=vpc,proto3" json:"vpc" yaml:"vpc"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VPCInfoResponse) Reset()         <span class="cov8" title="1">{ *m = VPCInfoResponse{} }</span>
func (m *VPCInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{44}
}</span>
func (m *VPCInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfoResponse.Merge(m, src)
}</span>
func (m *VPCInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCInfoResponse proto.InternalMessageInfo

func (m *VPCInfoResponse) GetItem() *VPCInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListVPCInfoResponse struct {
        Items                []*VPCInfo `protobuf:"bytes,1,rep,name=items,json=vpc,proto3" json:"vpc" yaml:"vpc"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *ListVPCInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVPCInfoResponse{} }</span>
func (m *ListVPCInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVPCInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVPCInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{45}
}</span>
func (m *ListVPCInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVPCInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVPCInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVPCInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVPCInfoResponse.Merge(m, src)
}</span>
func (m *ListVPCInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVPCInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVPCInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVPCInfoResponse proto.InternalMessageInfo

func (m *ListVPCInfoResponse) GetItems() []*VPCInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VPCInfo struct {
        Iid                  *IID          `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        Ipv4Cidr             string        `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        SubnetInfoList       []*SubnetInfo `protobuf:"bytes,3,rep,name=subnet_info_list,json=SubnetInfoList,proto3" json:"SubnetInfoList" yaml:"SubnetInfoList"`
        KeyValueList         []*KeyValue   `protobuf:"bytes,4,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *VPCInfo) Reset()         <span class="cov0" title="0">{ *m = VPCInfo{} }</span>
func (m *VPCInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{46}
}</span>
func (m *VPCInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfo.Merge(m, src)
}</span>
func (m *VPCInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCInfo proto.InternalMessageInfo

func (m *VPCInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VPCInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCInfo) GetSubnetInfoList() []*SubnetInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VPCInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SubnetInfo struct {
        Iid                  *IID        `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        Ipv4Cidr             string      `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        KeyValueList         []*KeyValue `protobuf:"bytes,3,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *SubnetInfo) Reset()         <span class="cov0" title="0">{ *m = SubnetInfo{} }</span>
func (m *SubnetInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{47}
}</span>
func (m *SubnetInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetInfo.Merge(m, src)
}</span>
func (m *SubnetInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetInfo proto.InternalMessageInfo

func (m *SubnetInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SubnetInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VPCCreateRequest struct {
        ConnectionName       string         `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *VPCCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}       `json:"-"`
        XXX_unrecognized     []byte         `json:"-"`
        XXX_sizecache        int32          `json:"-"`
}

func (m *VPCCreateRequest) Reset()         <span class="cov8" title="1">{ *m = VPCCreateRequest{} }</span>
func (m *VPCCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{48}
}</span>
func (m *VPCCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateRequest.Merge(m, src)
}</span>
func (m *VPCCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCCreateRequest proto.InternalMessageInfo

func (m *VPCCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCCreateRequest) GetItem() *VPCCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VPCCreateInfo struct {
        Name                 string              `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Ipv4Cidr             string              `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        SubnetInfoList       []*SubnetCreateInfo `protobuf:"bytes,3,rep,name=subnet_info_list,json=SubnetInfoList,proto3" json:"SubnetInfoList" yaml:"SubnetInfoList"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *VPCCreateInfo) Reset()         <span class="cov0" title="0">{ *m = VPCCreateInfo{} }</span>
func (m *VPCCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{49}
}</span>
func (m *VPCCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateInfo.Merge(m, src)
}</span>
func (m *VPCCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCCreateInfo proto.InternalMessageInfo

func (m *VPCCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCCreateInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCCreateInfo) GetSubnetInfoList() []*SubnetCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetInfoList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SubnetCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Ipv4Cidr             string   `protobuf:"bytes,2,opt,name=ipv4_cidr,json=IPv4_CIDR,proto3" json:"IPv4_CIDR" yaml:"IPv4_CIDR"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetCreateInfo) Reset()         <span class="cov0" title="0">{ *m = SubnetCreateInfo{} }</span>
func (m *SubnetCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{50}
}</span>
func (m *SubnetCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetCreateInfo.Merge(m, src)
}</span>
func (m *SubnetCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetCreateInfo proto.InternalMessageInfo

func (m *SubnetCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetCreateInfo) GetIpv4Cidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ipv4Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VPCAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VPCAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = VPCAllQryRequest{} }</span>
func (m *VPCAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{51}
}</span>
func (m *VPCAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCAllQryRequest.Merge(m, src)
}</span>
func (m *VPCAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCAllQryRequest proto.InternalMessageInfo

func (m *VPCAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VPCQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VPCQryRequest) Reset()         <span class="cov8" title="1">{ *m = VPCQryRequest{} }</span>
func (m *VPCQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VPCQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VPCQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{52}
}</span>
func (m *VPCQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VPCQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VPCQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VPCQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VPCQryRequest.Merge(m, src)
}</span>
func (m *VPCQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VPCQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VPCQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VPCQryRequest proto.InternalMessageInfo

func (m *VPCQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VPCQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPVPCQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPVPCQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPVPCQryRequest{} }</span>
func (m *CSPVPCQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPVPCQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPVPCQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{53}
}</span>
func (m *CSPVPCQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPVPCQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPVPCQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPVPCQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPVPCQryRequest.Merge(m, src)
}</span>
func (m *CSPVPCQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPVPCQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPVPCQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPVPCQryRequest proto.InternalMessageInfo

func (m *CSPVPCQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPVPCQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SubnetAddRequest struct {
        ConnectionName       string            `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        VpcName              string            `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        Item                 *SubnetCreateInfo `protobuf:"bytes,3,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *SubnetAddRequest) Reset()         <span class="cov8" title="1">{ *m = SubnetAddRequest{} }</span>
func (m *SubnetAddRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetAddRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetAddRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{54}
}</span>
func (m *SubnetAddRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetAddRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetAddRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetAddRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetAddRequest.Merge(m, src)
}</span>
func (m *SubnetAddRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetAddRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetAddRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetAddRequest proto.InternalMessageInfo

func (m *SubnetAddRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetAddRequest) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetAddRequest) GetItem() *SubnetCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SubnetQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        VpcName              string   `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        SubnetName           string   `protobuf:"bytes,3,opt,name=subnet_name,json=SubnetName,proto3" json:"SubnetName" yaml:"SubnetName"`
        Force                string   `protobuf:"bytes,4,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetQryRequest) Reset()         <span class="cov8" title="1">{ *m = SubnetQryRequest{} }</span>
func (m *SubnetQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SubnetQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SubnetQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{55}
}</span>
func (m *SubnetQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SubnetQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SubnetQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SubnetQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SubnetQryRequest.Merge(m, src)
}</span>
func (m *SubnetQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SubnetQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SubnetQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SubnetQryRequest proto.InternalMessageInfo

func (m *SubnetQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetQryRequest) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetQryRequest) GetSubnetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SubnetQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPSubnetQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        VpcName              string   `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        Id                   string   `protobuf:"bytes,3,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPSubnetQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPSubnetQryRequest{} }</span>
func (m *CSPSubnetQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPSubnetQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPSubnetQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{56}
}</span>
func (m *CSPSubnetQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPSubnetQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPSubnetQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPSubnetQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPSubnetQryRequest.Merge(m, src)
}</span>
func (m *CSPSubnetQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPSubnetQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPSubnetQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPSubnetQryRequest proto.InternalMessageInfo

func (m *CSPSubnetQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPSubnetQryRequest) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPSubnetQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SecurityInfoResponse struct {
        Item                 *SecurityInfo `protobuf:"bytes,1,opt,name=item,json=securitygroup,proto3" json:"securitygroup" yaml:"securitygroup"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *SecurityInfoResponse) Reset()         <span class="cov8" title="1">{ *m = SecurityInfoResponse{} }</span>
func (m *SecurityInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{57}
}</span>
func (m *SecurityInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfoResponse.Merge(m, src)
}</span>
func (m *SecurityInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityInfoResponse proto.InternalMessageInfo

func (m *SecurityInfoResponse) GetItem() *SecurityInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListSecurityInfoResponse struct {
        Items                []*SecurityInfo `protobuf:"bytes,1,rep,name=items,json=securitygroup,proto3" json:"securitygroup" yaml:"securitygroup"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *ListSecurityInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListSecurityInfoResponse{} }</span>
func (m *ListSecurityInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListSecurityInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListSecurityInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{58}
}</span>
func (m *ListSecurityInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListSecurityInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListSecurityInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListSecurityInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListSecurityInfoResponse.Merge(m, src)
}</span>
func (m *ListSecurityInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListSecurityInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListSecurityInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListSecurityInfoResponse proto.InternalMessageInfo

func (m *ListSecurityInfoResponse) GetItems() []*SecurityInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityInfo struct {
        Iid                  *IID                `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        VpcIid               *IID                `protobuf:"bytes,2,opt,name=vpc_iid,json=VpcIID,proto3" json:"VpcIID" yaml:"VpcIID"`
        Direction            string              `protobuf:"bytes,3,opt,name=direction,json=Direction,proto3" json:"Direction" yaml:"Direction"`
        SecurityRules        []*SecurityRuleInfo `protobuf:"bytes,4,rep,name=security_rules,json=SecurityRules,proto3" json:"SecurityRules" yaml:"SecurityRules"`
        KeyValueList         []*KeyValue         `protobuf:"bytes,5,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityInfo) Reset()         <span class="cov0" title="0">{ *m = SecurityInfo{} }</span>
func (m *SecurityInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{59}
}</span>
func (m *SecurityInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfo.Merge(m, src)
}</span>
func (m *SecurityInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityInfo proto.InternalMessageInfo

func (m *SecurityInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SecurityInfo) GetVpcIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SecurityInfo) GetDirection() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Direction
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityInfo) GetSecurityRules() []*SecurityRuleInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityRules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SecurityInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityRuleInfo struct {
        FromPort             string   `protobuf:"bytes,1,opt,name=from_port,json=FromPort,proto3" json:"FromPort" yaml:"FromPort"`
        ToPort               string   `protobuf:"bytes,2,opt,name=to_port,json=ToPort,proto3" json:"ToPort" yaml:"ToPort"`
        IpProtocol           string   `protobuf:"bytes,3,opt,name=ip_protocol,json=IPProtocol,proto3" json:"IPProtocol" yaml:"IPProtocol"`
        Direction            string   `protobuf:"bytes,4,opt,name=direction,json=Direction,proto3" json:"Direction" yaml:"Direction"`
        Cidr                 string   `protobuf:"bytes,5,opt,name=cidr,json=CIDR,proto3" json:"CIDR" yaml:"CIDR"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityRuleInfo) Reset()         <span class="cov0" title="0">{ *m = SecurityRuleInfo{} }</span>
func (m *SecurityRuleInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityRuleInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityRuleInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{60}
}</span>
func (m *SecurityRuleInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityRuleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityRuleInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityRuleInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityRuleInfo.Merge(m, src)
}</span>
func (m *SecurityRuleInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityRuleInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityRuleInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityRuleInfo proto.InternalMessageInfo

func (m *SecurityRuleInfo) GetFromPort() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FromPort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetToPort() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ToPort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetIpProtocol() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IpProtocol
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetDirection() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Direction
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityRuleInfo) GetCidr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cidr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SecurityCreateRequest struct {
        ConnectionName       string              `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *SecurityCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityCreateRequest) Reset()         <span class="cov8" title="1">{ *m = SecurityCreateRequest{} }</span>
func (m *SecurityCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{61}
}</span>
func (m *SecurityCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateRequest.Merge(m, src)
}</span>
func (m *SecurityCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityCreateRequest proto.InternalMessageInfo

func (m *SecurityCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateRequest) GetItem() *SecurityCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityCreateInfo struct {
        Name                 string              `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        VpcName              string              `protobuf:"bytes,2,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        Direction            string              `protobuf:"bytes,3,opt,name=direction,json=Direction,proto3" json:"Direction" yaml:"Direction"`
        SecurityRules        []*SecurityRuleInfo `protobuf:"bytes,4,rep,name=security_rules,json=SecurityRules,proto3" json:"SecurityRules" yaml:"SecurityRules"`
        XXX_NoUnkeyedLiteral struct{}            `json:"-"`
        XXX_unrecognized     []byte              `json:"-"`
        XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityCreateInfo) Reset()         <span class="cov0" title="0">{ *m = SecurityCreateInfo{} }</span>
func (m *SecurityCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{62}
}</span>
func (m *SecurityCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateInfo.Merge(m, src)
}</span>
func (m *SecurityCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityCreateInfo proto.InternalMessageInfo

func (m *SecurityCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateInfo) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateInfo) GetDirection() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Direction
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityCreateInfo) GetSecurityRules() []*SecurityRuleInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityRules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SecurityAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = SecurityAllQryRequest{} }</span>
func (m *SecurityAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{63}
}</span>
func (m *SecurityAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityAllQryRequest.Merge(m, src)
}</span>
func (m *SecurityAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityAllQryRequest proto.InternalMessageInfo

func (m *SecurityAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SecurityQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityQryRequest) Reset()         <span class="cov8" title="1">{ *m = SecurityQryRequest{} }</span>
func (m *SecurityQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SecurityQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SecurityQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{64}
}</span>
func (m *SecurityQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SecurityQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SecurityQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SecurityQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SecurityQryRequest.Merge(m, src)
}</span>
func (m *SecurityQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SecurityQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SecurityQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SecurityQryRequest proto.InternalMessageInfo

func (m *SecurityQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SecurityQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPSecurityQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPSecurityQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPSecurityQryRequest{} }</span>
func (m *CSPSecurityQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPSecurityQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPSecurityQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{65}
}</span>
func (m *CSPSecurityQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPSecurityQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPSecurityQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPSecurityQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPSecurityQryRequest.Merge(m, src)
}</span>
func (m *CSPSecurityQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPSecurityQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPSecurityQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPSecurityQryRequest proto.InternalMessageInfo

func (m *CSPSecurityQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPSecurityQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KeyPairInfoResponse struct {
        Item                 *KeyPairInfo `protobuf:"bytes,1,opt,name=item,json=keypair,proto3" json:"keypair" yaml:"keypair"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *KeyPairInfoResponse) Reset()         <span class="cov8" title="1">{ *m = KeyPairInfoResponse{} }</span>
func (m *KeyPairInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{66}
}</span>
func (m *KeyPairInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfoResponse.Merge(m, src)
}</span>
func (m *KeyPairInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairInfoResponse proto.InternalMessageInfo

func (m *KeyPairInfoResponse) GetItem() *KeyPairInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListKeyPairInfoResponse struct {
        Items                []*KeyPairInfo `protobuf:"bytes,1,rep,name=items,json=keypair,proto3" json:"keypair" yaml:"keypair"`
        XXX_NoUnkeyedLiteral struct{}       `json:"-"`
        XXX_unrecognized     []byte         `json:"-"`
        XXX_sizecache        int32          `json:"-"`
}

func (m *ListKeyPairInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListKeyPairInfoResponse{} }</span>
func (m *ListKeyPairInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListKeyPairInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListKeyPairInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{67}
}</span>
func (m *ListKeyPairInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListKeyPairInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListKeyPairInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListKeyPairInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListKeyPairInfoResponse.Merge(m, src)
}</span>
func (m *ListKeyPairInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListKeyPairInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListKeyPairInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListKeyPairInfoResponse proto.InternalMessageInfo

func (m *ListKeyPairInfoResponse) GetItems() []*KeyPairInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type KeyPairInfo struct {
        Iid                  *IID        `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        Fingerprint          string      `protobuf:"bytes,2,opt,name=fingerprint,json=Fingerprint,proto3" json:"Fingerprint" yaml:"Fingerprint"`
        PublicKey            string      `protobuf:"bytes,3,opt,name=public_key,json=PublicKey,proto3" json:"PublicKey" yaml:"PublicKey"`
        PrivateKey           string      `protobuf:"bytes,4,opt,name=private_key,json=PrivateKey,proto3" json:"PrivateKey" yaml:"PrivateKey"`
        VmUserId             string      `protobuf:"bytes,5,opt,name=vm_user_id,json=VMUserID,proto3" json:"VMUserID" yaml:"VMUserID"`
        KeyValueList         []*KeyValue `protobuf:"bytes,6,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}    `json:"-"`
        XXX_unrecognized     []byte      `json:"-"`
        XXX_sizecache        int32       `json:"-"`
}

func (m *KeyPairInfo) Reset()         <span class="cov0" title="0">{ *m = KeyPairInfo{} }</span>
func (m *KeyPairInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{68}
}</span>
func (m *KeyPairInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfo.Merge(m, src)
}</span>
func (m *KeyPairInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairInfo proto.InternalMessageInfo

func (m *KeyPairInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *KeyPairInfo) GetFingerprint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Fingerprint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetPublicKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetPrivateKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetVmUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type KeyPairCreateRequest struct {
        ConnectionName       string             `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *KeyPairCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}           `json:"-"`
        XXX_unrecognized     []byte             `json:"-"`
        XXX_sizecache        int32              `json:"-"`
}

func (m *KeyPairCreateRequest) Reset()         <span class="cov8" title="1">{ *m = KeyPairCreateRequest{} }</span>
func (m *KeyPairCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{69}
}</span>
func (m *KeyPairCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateRequest.Merge(m, src)
}</span>
func (m *KeyPairCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairCreateRequest proto.InternalMessageInfo

func (m *KeyPairCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairCreateRequest) GetItem() *KeyPairCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type KeyPairCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyPairCreateInfo) Reset()         <span class="cov0" title="0">{ *m = KeyPairCreateInfo{} }</span>
func (m *KeyPairCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{70}
}</span>
func (m *KeyPairCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateInfo.Merge(m, src)
}</span>
func (m *KeyPairCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairCreateInfo proto.InternalMessageInfo

func (m *KeyPairCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KeyPairAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyPairAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = KeyPairAllQryRequest{} }</span>
func (m *KeyPairAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{71}
}</span>
func (m *KeyPairAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairAllQryRequest.Merge(m, src)
}</span>
func (m *KeyPairAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairAllQryRequest proto.InternalMessageInfo

func (m *KeyPairAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KeyPairQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KeyPairQryRequest) Reset()         <span class="cov8" title="1">{ *m = KeyPairQryRequest{} }</span>
func (m *KeyPairQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KeyPairQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KeyPairQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{72}
}</span>
func (m *KeyPairQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *KeyPairQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_KeyPairQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *KeyPairQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairQryRequest.Merge(m, src)
}</span>
func (m *KeyPairQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *KeyPairQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KeyPairQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KeyPairQryRequest proto.InternalMessageInfo

func (m *KeyPairQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KeyPairQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPKeyPairQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPKeyPairQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPKeyPairQryRequest{} }</span>
func (m *CSPKeyPairQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPKeyPairQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPKeyPairQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{73}
}</span>
func (m *CSPKeyPairQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPKeyPairQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPKeyPairQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPKeyPairQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPKeyPairQryRequest.Merge(m, src)
}</span>
func (m *CSPKeyPairQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPKeyPairQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPKeyPairQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPKeyPairQryRequest proto.InternalMessageInfo

func (m *CSPKeyPairQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPKeyPairQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListVMStatusInfoResponse struct {
        Items                []*VMStatusInfo `protobuf:"bytes,1,rep,name=items,json=vmstatus,proto3" json:"vmstatus" yaml:"vmstatus"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *ListVMStatusInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVMStatusInfoResponse{} }</span>
func (m *ListVMStatusInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVMStatusInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVMStatusInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{74}
}</span>
func (m *ListVMStatusInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVMStatusInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVMStatusInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVMStatusInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVMStatusInfoResponse.Merge(m, src)
}</span>
func (m *ListVMStatusInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVMStatusInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVMStatusInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVMStatusInfoResponse proto.InternalMessageInfo

func (m *ListVMStatusInfoResponse) GetItems() []*VMStatusInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMStatusInfo struct {
        Iid                  *IID     `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        VmStatus             string   `protobuf:"bytes,2,opt,name=vm_status,json=VmStatus,proto3" json:"VmStatus" yaml:"VmStatus"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMStatusInfo) Reset()         <span class="cov0" title="0">{ *m = VMStatusInfo{} }</span>
func (m *VMStatusInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMStatusInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMStatusInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{75}
}</span>
func (m *VMStatusInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMStatusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMStatusInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMStatusInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMStatusInfo.Merge(m, src)
}</span>
func (m *VMStatusInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMStatusInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMStatusInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMStatusInfo proto.InternalMessageInfo

func (m *VMStatusInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMStatusInfo) GetVmStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmStatus
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMInfoResponse struct {
        Item                 *VMInfo  `protobuf:"bytes,1,opt,name=item,json=vm,proto3" json:"vm" yaml:"vm"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMInfoResponse) Reset()         <span class="cov8" title="1">{ *m = VMInfoResponse{} }</span>
func (m *VMInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{76}
}</span>
func (m *VMInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMInfoResponse.Merge(m, src)
}</span>
func (m *VMInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMInfoResponse proto.InternalMessageInfo

func (m *VMInfoResponse) GetItem() *VMInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListVMInfoResponse struct {
        Items                []*VMInfo `protobuf:"bytes,1,rep,name=items,json=vm,proto3" json:"vm" yaml:"vm"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListVMInfoResponse) Reset()         <span class="cov8" title="1">{ *m = ListVMInfoResponse{} }</span>
func (m *ListVMInfoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListVMInfoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListVMInfoResponse) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{77}
}</span>
func (m *ListVMInfoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListVMInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListVMInfoResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListVMInfoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListVMInfoResponse.Merge(m, src)
}</span>
func (m *ListVMInfoResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListVMInfoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListVMInfoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListVMInfoResponse proto.InternalMessageInfo

func (m *ListVMInfoResponse) GetItems() []*VMInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMInfo struct {
        Iid                  *IID          `protobuf:"bytes,1,opt,name=iid,json=IId,proto3" json:"IId" yaml:"IId"`
        StartTime            string        `protobuf:"bytes,2,opt,name=start_time,json=StartTime,proto3" json:"StartTime" yaml:"StartTime"`
        Region               *VMRegionInfo `protobuf:"bytes,3,opt,name=region,json=Region,proto3" json:"Region" yaml:"Region"`
        ImageIid             *IID          `protobuf:"bytes,4,opt,name=image_iid,json=ImageIId,proto3" json:"ImageIId" yaml:"ImageIId"`
        VmSpecName           string        `protobuf:"bytes,5,opt,name=vm_spec_name,json=VMSpecName,proto3" json:"VMSpecName" yaml:"VMSpecName"`
        VpcIid               *IID          `protobuf:"bytes,6,opt,name=vpc_iid,json=VpcIID,proto3" json:"VpcIID" yaml:"VpcIID"`
        SubnetIid            *IID          `protobuf:"bytes,7,opt,name=subnet_iid,json=SubnetIID,proto3" json:"SubnetIID" yaml:"SubnetIID"`
        SecurityGroupIids    []*IID        `protobuf:"bytes,8,rep,name=security_group_iids,json=SecurityGroupIIds,proto3" json:"SecurityGroupIIds" yaml:"SecurityGroupIIds"`
        KeyPairIid           *IID          `protobuf:"bytes,9,opt,name=key_pair_iid,json=KeyPairIId,proto3" json:"KeyPairIId" yaml:"KeyPairIId"`
        VmUserId             string        `protobuf:"bytes,10,opt,name=vm_user_id,json=VMUserId,proto3" json:"VMUserId" yaml:"VMUserId"`
        VmUserPasswd         string        `protobuf:"bytes,11,opt,name=vm_user_passwd,json=VMUserPasswd,proto3" json:"VMUserPasswd" yaml:"VMUserPasswd"`
        NetworkInterface     string        `protobuf:"bytes,12,opt,name=network_interface,json=NetworkInterface,proto3" json:"NetworkInterface" yaml:"NetworkInterface"`
        PublicIp             string        `protobuf:"bytes,13,opt,name=public_ip,json=PublicIP,proto3" json:"PublicIP" yaml:"PublicIP"`
        PublicDns            string        `protobuf:"bytes,14,opt,name=public_dns,json=PublicDNS,proto3" json:"PublicDNS" yaml:"PublicDNS"`
        PrivateIp            string        `protobuf:"bytes,15,opt,name=private_ip,json=PrivateIP,proto3" json:"PrivateIP" yaml:"PrivateIP"`
        PrivateDns           string        `protobuf:"bytes,16,opt,name=private_dns,json=PrivateDNS,proto3" json:"PrivateDNS" yaml:"PrivateDNS"`
        VmBootDisk           string        `protobuf:"bytes,17,opt,name=vm_boot_disk,json=VMBootDisk,proto3" json:"VMBootDisk" yaml:"VMBootDisk"`
        VmBlockDisk          string        `protobuf:"bytes,18,opt,name=vm_block_disk,json=VMBlockDisk,proto3" json:"VMBlockDisk" yaml:"VMBlockDisk"`
        SshAccessPoint       string        `protobuf:"bytes,19,opt,name=ssh_access_point,json=SSHAccessPoint,proto3" json:"SSHAccessPoint" yaml:"SSHAccessPoint"`
        KeyValueList         []*KeyValue   `protobuf:"bytes,20,rep,name=key_value_list,json=KeyValueList,proto3" json:"KeyValueList" yaml:"KeyValueList"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *VMInfo) Reset()         <span class="cov0" title="0">{ *m = VMInfo{} }</span>
func (m *VMInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{78}
}</span>
func (m *VMInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMInfo.Merge(m, src)
}</span>
func (m *VMInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMInfo proto.InternalMessageInfo

func (m *VMInfo) GetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Iid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetStartTime() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StartTime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetRegion() *VMRegionInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetImageIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ImageIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetVmSpecName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmSpecName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVpcIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetSubnetIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetSecurityGroupIids() []*IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityGroupIids
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetKeyPairIid() *IID <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyPairIid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMInfo) GetVmUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVmUserPasswd() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserPasswd
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetNetworkInterface() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NetworkInterface
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPublicIp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicIp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPublicDns() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PublicDns
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPrivateIp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateIp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetPrivateDns() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateDns
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVmBootDisk() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmBootDisk
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetVmBlockDisk() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmBlockDisk
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetSshAccessPoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SshAccessPoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMInfo) GetKeyValueList() []*KeyValue <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyValueList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMRegionInfo struct {
        Region               string   `protobuf:"bytes,1,opt,name=region,json=Region,proto3" json:"Region" yaml:"Region"`
        Zone                 string   `protobuf:"bytes,2,opt,name=zone,json=Zone,proto3" json:"Zone" yaml:"Zone"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMRegionInfo) Reset()         <span class="cov0" title="0">{ *m = VMRegionInfo{} }</span>
func (m *VMRegionInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMRegionInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMRegionInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{79}
}</span>
func (m *VMRegionInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMRegionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMRegionInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMRegionInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMRegionInfo.Merge(m, src)
}</span>
func (m *VMRegionInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMRegionInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMRegionInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMRegionInfo proto.InternalMessageInfo

func (m *VMRegionInfo) GetRegion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMRegionInfo) GetZone() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Zone
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMCreateRequest struct {
        ConnectionName       string        `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Item                 *VMCreateInfo `protobuf:"bytes,2,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
        XXX_NoUnkeyedLiteral struct{}      `json:"-"`
        XXX_unrecognized     []byte        `json:"-"`
        XXX_sizecache        int32         `json:"-"`
}

func (m *VMCreateRequest) Reset()         <span class="cov8" title="1">{ *m = VMCreateRequest{} }</span>
func (m *VMCreateRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMCreateRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMCreateRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{80}
}</span>
func (m *VMCreateRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMCreateRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMCreateRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateRequest.Merge(m, src)
}</span>
func (m *VMCreateRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMCreateRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMCreateRequest proto.InternalMessageInfo

func (m *VMCreateRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateRequest) GetItem() *VMCreateInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type VMCreateInfo struct {
        Name                 string   `protobuf:"bytes,1,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        ImageName            string   `protobuf:"bytes,2,opt,name=image_name,json=ImageName,proto3" json:"ImageName" yaml:"ImageName"`
        VpcName              string   `protobuf:"bytes,3,opt,name=vpc_name,json=VPCName,proto3" json:"VPCName" yaml:"VPCName"`
        SubnetName           string   `protobuf:"bytes,4,opt,name=subnet_name,json=SubnetName,proto3" json:"SubnetName" yaml:"SubnetName"`
        SecurityGroupNames   []string `protobuf:"bytes,5,rep,name=security_group_names,json=SecurityGroupNames,proto3" json:"SecurityGroupNames" yaml:"SecurityGroupNames"`
        VmSpecName           string   `protobuf:"bytes,6,opt,name=vm_spec_name,json=VMSpecName,proto3" json:"VMSpecName" yaml:"VMSpecName"`
        KeyPairName          string   `protobuf:"bytes,7,opt,name=key_pair_name,json=KeyPairName,proto3" json:"KeyPairName" yaml:"KeyPairName"`
        VmUserId             string   `protobuf:"bytes,8,opt,name=vm_user_id,json=VMUserId,proto3" json:"VMUserId" yaml:"VMUserId"`
        VmUserPasswd         string   `protobuf:"bytes,9,opt,name=vm_user_passwd,json=VMUserPasswd,proto3" json:"VMUserPasswd" yaml:"VMUserPasswd"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMCreateInfo) Reset()         <span class="cov0" title="0">{ *m = VMCreateInfo{} }</span>
func (m *VMCreateInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMCreateInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMCreateInfo) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{81}
}</span>
func (m *VMCreateInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMCreateInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMCreateInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateInfo.Merge(m, src)
}</span>
func (m *VMCreateInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMCreateInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMCreateInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMCreateInfo proto.InternalMessageInfo

func (m *VMCreateInfo) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetImageName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ImageName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetVpcName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VpcName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetSubnetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SubnetName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetSecurityGroupNames() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SecurityGroupNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *VMCreateInfo) GetVmSpecName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmSpecName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetKeyPairName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyPairName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetVmUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMCreateInfo) GetVmUserPasswd() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VmUserPasswd
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMAllQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMAllQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMAllQryRequest{} }</span>
func (m *VMAllQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMAllQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMAllQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{82}
}</span>
func (m *VMAllQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMAllQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMAllQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMAllQryRequest.Merge(m, src)
}</span>
func (m *VMAllQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMAllQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMAllQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMAllQryRequest proto.InternalMessageInfo

func (m *VMAllQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Force                string   `protobuf:"bytes,3,opt,name=force,proto3" json:"force" yaml:"force"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMQryRequest) Reset()         <span class="cov8" title="1">{ *m = VMQryRequest{} }</span>
func (m *VMQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{83}
}</span>
func (m *VMQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMQryRequest.Merge(m, src)
}</span>
func (m *VMQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMQryRequest proto.InternalMessageInfo

func (m *VMQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMQryRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMQryRequest) GetForce() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Force
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CSPVMQryRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Id                   string   `protobuf:"bytes,2,opt,name=id,json=Id,proto3" json:"Id" yaml:"Id"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CSPVMQryRequest) Reset()         <span class="cov8" title="1">{ *m = CSPVMQryRequest{} }</span>
func (m *CSPVMQryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CSPVMQryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CSPVMQryRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{84}
}</span>
func (m *CSPVMQryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CSPVMQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CSPVMQryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CSPVMQryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CSPVMQryRequest.Merge(m, src)
}</span>
func (m *CSPVMQryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CSPVMQryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CSPVMQryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CSPVMQryRequest proto.InternalMessageInfo

func (m *CSPVMQryRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CSPVMQryRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VMActionRequest struct {
        ConnectionName       string   `protobuf:"bytes,1,opt,name=connection_name,json=ConnectionName,proto3" json:"ConnectionName" yaml:"ConnectionName"`
        Name                 string   `protobuf:"bytes,2,opt,name=name,json=Name,proto3" json:"Name" yaml:"Name"`
        Action               string   `protobuf:"bytes,3,opt,name=action,proto3" json:"action" yaml:"action"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *VMActionRequest) Reset()         <span class="cov8" title="1">{ *m = VMActionRequest{} }</span>
func (m *VMActionRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VMActionRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VMActionRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{85}
}</span>
func (m *VMActionRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VMActionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VMActionRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VMActionRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VMActionRequest.Merge(m, src)
}</span>
func (m *VMActionRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VMActionRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VMActionRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VMActionRequest proto.InternalMessageInfo

func (m *VMActionRequest) GetConnectionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnectionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMActionRequest) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *VMActionRequest) GetAction() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Action
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SSHRunRequest struct {
        UserName             string   `protobuf:"bytes,1,opt,name=user_name,json=UserName,proto3" json:"UserName" yaml:"UserName"`
        PrivateKey           []string `protobuf:"bytes,2,rep,name=private_key,json=PrivateKey,proto3" json:"PrivateKey" yaml:"PrivateKey"`
        ServerPort           string   `protobuf:"bytes,3,opt,name=server_port,json=ServerPort,proto3" json:"ServerPort" yaml:"ServerPort"`
        Command              string   `protobuf:"bytes,4,opt,name=command,json=Command,proto3" json:"Command" yaml:"Command"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *SSHRunRequest) Reset()         <span class="cov8" title="1">{ *m = SSHRunRequest{} }</span>
func (m *SSHRunRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*SSHRunRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*SSHRunRequest) Descriptor() ([]byte, []int) <span class="cov8" title="1">{
        return fileDescriptor_024d57f2826cd0d0, []int{86}
}</span>
func (m *SSHRunRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *SSHRunRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_SSHRunRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *SSHRunRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_SSHRunRequest.Merge(m, src)
}</span>
func (m *SSHRunRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *SSHRunRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_SSHRunRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_SSHRunRequest proto.InternalMessageInfo

func (m *SSHRunRequest) GetUserName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SSHRunRequest) GetPrivateKey() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrivateKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *SSHRunRequest) GetServerPort() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ServerPort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *SSHRunRequest) GetCommand() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Command
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Empty)(nil), "cbspider.Empty")
        proto.RegisterType((*KeyValue)(nil), "cbspider.KeyValue")
        proto.RegisterType((*IID)(nil), "cbspider.IID")
        proto.RegisterType((*BooleanResponse)(nil), "cbspider.BooleanResponse")
        proto.RegisterType((*StringResponse)(nil), "cbspider.StringResponse")
        proto.RegisterType((*MessageResponse)(nil), "cbspider.MessageResponse")
        proto.RegisterType((*StatusResponse)(nil), "cbspider.StatusResponse")
        proto.RegisterType((*ListCloudOSInfoResponse)(nil), "cbspider.ListCloudOSInfoResponse")
        proto.RegisterType((*CloudDriverInfoRequest)(nil), "cbspider.CloudDriverInfoRequest")
        proto.RegisterType((*CloudDriverInfoResponse)(nil), "cbspider.CloudDriverInfoResponse")
        proto.RegisterType((*ListCloudDriverInfoResponse)(nil), "cbspider.ListCloudDriverInfoResponse")
        proto.RegisterType((*CloudDriverInfo)(nil), "cbspider.CloudDriverInfo")
        proto.RegisterType((*CloudDriverQryRequest)(nil), "cbspider.CloudDriverQryRequest")
        proto.RegisterType((*CredentialInfoRequest)(nil), "cbspider.CredentialInfoRequest")
        proto.RegisterType((*CredentialInfoResponse)(nil), "cbspider.CredentialInfoResponse")
        proto.RegisterType((*ListCredentialInfoResponse)(nil), "cbspider.ListCredentialInfoResponse")
        proto.RegisterType((*CredentialInfo)(nil), "cbspider.CredentialInfo")
        proto.RegisterType((*CredentialQryRequest)(nil), "cbspider.CredentialQryRequest")
        proto.RegisterType((*RegionInfoRequest)(nil), "cbspider.RegionInfoRequest")
        proto.RegisterType((*RegionInfoResponse)(nil), "cbspider.RegionInfoResponse")
        proto.RegisterType((*ListRegionInfoResponse)(nil), "cbspider.ListRegionInfoResponse")
        proto.RegisterType((*RegionInfo)(nil), "cbspider.RegionInfo")
        proto.RegisterType((*RegionQryRequest)(nil), "cbspider.RegionQryRequest")
        proto.RegisterType((*ConnectionConfigInfoRequest)(nil), "cbspider.ConnectionConfigInfoRequest")
        proto.RegisterType((*ConnectionConfigInfoResponse)(nil), "cbspider.ConnectionConfigInfoResponse")
        proto.RegisterType((*ListConnectionConfigInfoResponse)(nil), "cbspider.ListConnectionConfigInfoResponse")
        proto.RegisterType((*ConnectionConfigInfo)(nil), "cbspider.ConnectionConfigInfo")
        proto.RegisterType((*ConnectionConfigQryRequest)(nil), "cbspider.ConnectionConfigQryRequest")
        proto.RegisterType((*AllResourceInfoResponse)(nil), "cbspider.AllResourceInfoResponse")
        proto.RegisterType((*AllResourceInfo)(nil), "cbspider.AllResourceInfo")
        proto.RegisterType((*ImageInfoResponse)(nil), "cbspider.ImageInfoResponse")
        proto.RegisterType((*ListImageInfoResponse)(nil), "cbspider.ListImageInfoResponse")
        proto.RegisterType((*ImageInfo)(nil), "cbspider.ImageInfo")
        proto.RegisterType((*ImageCreateRequest)(nil), "cbspider.ImageCreateRequest")
        proto.RegisterType((*ImageCreateInfo)(nil), "cbspider.ImageCreateInfo")
        proto.RegisterType((*ImageAllQryRequest)(nil), "cbspider.ImageAllQryRequest")
        proto.RegisterType((*ImageQryRequest)(nil), "cbspider.ImageQryRequest")
        proto.RegisterType((*VMSpecInfoResponse)(nil), "cbspider.VMSpecInfoResponse")
        proto.RegisterType((*ListVMSpecInfoResponse)(nil), "cbspider.ListVMSpecInfoResponse")
        proto.RegisterType((*VMSpecInfo)(nil), "cbspider.VMSpecInfo")
        proto.RegisterType((*VCpuInfo)(nil), "cbspider.VCpuInfo")
        proto.RegisterType((*GpuInfo)(nil), "cbspider.GpuInfo")
        proto.RegisterType((*VMSpecAllQryRequest)(nil), "cbspider.VMSpecAllQryRequest")
        proto.RegisterType((*VMSpecQryRequest)(nil), "cbspider.VMSpecQryRequest")
        proto.RegisterType((*VPCInfoResponse)(nil), "cbspider.VPCInfoResponse")
        proto.RegisterType((*ListVPCInfoResponse)(nil), "cbspider.ListVPCInfoResponse")
        proto.RegisterType((*VPCInfo)(nil), "cbspider.VPCInfo")
        proto.RegisterType((*SubnetInfo)(nil), "cbspider.SubnetInfo")
        proto.RegisterType((*VPCCreateRequest)(nil), "cbspider.VPCCreateRequest")
        proto.RegisterType((*VPCCreateInfo)(nil), "cbspider.VPCCreateInfo")
        proto.RegisterType((*SubnetCreateInfo)(nil), "cbspider.SubnetCreateInfo")
        proto.RegisterType((*VPCAllQryRequest)(nil), "cbspider.VPCAllQryRequest")
        proto.RegisterType((*VPCQryRequest)(nil), "cbspider.VPCQryRequest")
        proto.RegisterType((*CSPVPCQryRequest)(nil), "cbspider.CSPVPCQryRequest")
        proto.RegisterType((*SubnetAddRequest)(nil), "cbspider.SubnetAddRequest")
        proto.RegisterType((*SubnetQryRequest)(nil), "cbspider.SubnetQryRequest")
        proto.RegisterType((*CSPSubnetQryRequest)(nil), "cbspider.CSPSubnetQryRequest")
        proto.RegisterType((*SecurityInfoResponse)(nil), "cbspider.SecurityInfoResponse")
        proto.RegisterType((*ListSecurityInfoResponse)(nil), "cbspider.ListSecurityInfoResponse")
        proto.RegisterType((*SecurityInfo)(nil), "cbspider.SecurityInfo")
        proto.RegisterType((*SecurityRuleInfo)(nil), "cbspider.SecurityRuleInfo")
        proto.RegisterType((*SecurityCreateRequest)(nil), "cbspider.SecurityCreateRequest")
        proto.RegisterType((*SecurityCreateInfo)(nil), "cbspider.SecurityCreateInfo")
        proto.RegisterType((*SecurityAllQryRequest)(nil), "cbspider.SecurityAllQryRequest")
        proto.RegisterType((*SecurityQryRequest)(nil), "cbspider.SecurityQryRequest")
        proto.RegisterType((*CSPSecurityQryRequest)(nil), "cbspider.CSPSecurityQryRequest")
        proto.RegisterType((*KeyPairInfoResponse)(nil), "cbspider.KeyPairInfoResponse")
        proto.RegisterType((*ListKeyPairInfoResponse)(nil), "cbspider.ListKeyPairInfoResponse")
        proto.RegisterType((*KeyPairInfo)(nil), "cbspider.KeyPairInfo")
        proto.RegisterType((*KeyPairCreateRequest)(nil), "cbspider.KeyPairCreateRequest")
        proto.RegisterType((*KeyPairCreateInfo)(nil), "cbspider.KeyPairCreateInfo")
        proto.RegisterType((*KeyPairAllQryRequest)(nil), "cbspider.KeyPairAllQryRequest")
        proto.RegisterType((*KeyPairQryRequest)(nil), "cbspider.KeyPairQryRequest")
        proto.RegisterType((*CSPKeyPairQryRequest)(nil), "cbspider.CSPKeyPairQryRequest")
        proto.RegisterType((*ListVMStatusInfoResponse)(nil), "cbspider.ListVMStatusInfoResponse")
        proto.RegisterType((*VMStatusInfo)(nil), "cbspider.VMStatusInfo")
        proto.RegisterType((*VMInfoResponse)(nil), "cbspider.VMInfoResponse")
        proto.RegisterType((*ListVMInfoResponse)(nil), "cbspider.ListVMInfoResponse")
        proto.RegisterType((*VMInfo)(nil), "cbspider.VMInfo")
        proto.RegisterType((*VMRegionInfo)(nil), "cbspider.VMRegionInfo")
        proto.RegisterType((*VMCreateRequest)(nil), "cbspider.VMCreateRequest")
        proto.RegisterType((*VMCreateInfo)(nil), "cbspider.VMCreateInfo")
        proto.RegisterType((*VMAllQryRequest)(nil), "cbspider.VMAllQryRequest")
        proto.RegisterType((*VMQryRequest)(nil), "cbspider.VMQryRequest")
        proto.RegisterType((*CSPVMQryRequest)(nil), "cbspider.CSPVMQryRequest")
        proto.RegisterType((*VMActionRequest)(nil), "cbspider.VMActionRequest")
        proto.RegisterType((*SSHRunRequest)(nil), "cbspider.SSHRunRequest")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("cbspider.proto", fileDescriptor_024d57f2826cd0d0) }</span>

var fileDescriptor_024d57f2826cd0d0 = []byte{
        // 4103 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5c, 0xcd, 0x8f, 0x23, 0x49,
        0x56, 0x6f, 0xdb, 0xf5, 0xe5, 0x57, 0x5f, 0xae, 0xa8, 0xea, 0xee, 0x9a, 0xea, 0x9e, 0x76, 0x4f,
        0xec, 0x0e, 0x03, 0x8c, 0xb4, 0x23, 0x66, 0x06, 0x66, 0xb4, 0xdb, 0xbb, 0x74, 0x95, 0xdd, 0xed,
        0xf1, 0x54, 0xbb, 0xdb, 0x13, 0xee, 0xf1, 0x8e, 0x96, 0x1d, 0x2c, 0x97, 0x1d, 0x55, 0x9b, 0x54,
        0xda, 0x99, 0x93, 0x69, 0x7b, 0x65, 0xb8, 0x80, 0xb4, 0x17, 0xa4, 0xe5, 0x6b, 0xb5, 0x2b, 0xe0,
        0xc0, 0x15, 0x21, 0xee, 0x08, 0x04, 0x42, 0x08, 0x38, 0xb0, 0x70, 0x42, 0xfc, 0x01, 0x16, 0x1a,
        0x2e, 0xc8, 0x27, 0xd4, 0xe2, 0xc0, 0x11, 0xc5, 0x47, 0x66, 0x44, 0x64, 0xa6, 0x5d, 0x2e, 0x57,
        0xb5, 0x99, 0xe1, 0x54, 0x15, 0x2f, 0x5e, 0xfc, 0xe2, 0xc5, 0x8b, 0x17, 0xef, 0xbd, 0x88, 0x8c,
        0x30, 0x6c, 0xb5, 0x4e, 0x7c, 0xd7, 0x6a, 0x53, 0xef, 0x6b, 0xae, 0xe7, 0xf4, 0x1c, 0xb4, 0x16,
        0x94, 0x0f, 0xe0, 0xcc, 0x39, 0x73, 0x04, 0x15, 0xaf, 0xc2, 0xf2, 0xa3, 0x8e, 0xdb, 0x1b, 0xe2,
        0x36, 0xac, 0x1d, 0xd3, 0x61, 0xbd, 0x69, 0xf7, 0x29, 0x7a, 0x03, 0x32, 0xe7, 0x74, 0xb8, 0x9f,
        0xba, 0x9f, 0xfa, 0xd9, 0xec, 0xd1, 0xcd, 0xf1, 0x28, 0x9f, 0x39, 0xa6, 0xc3, 0x17, 0xa3, 0x3c,
        0x0c, 0x9b, 0x1d, 0xfb, 0xeb, 0xf8, 0x98, 0x0e, 0x31, 0x61, 0x24, 0xf4, 0x16, 0x2c, 0x0f, 0x58,
        0x8b, 0xfd, 0x34, 0x67, 0x7d, 0x65, 0x3c, 0xca, 0x2f, 0x73, 0x88, 0x17, 0xa3, 0xfc, 0x86, 0x60,
        0xe6, 0x45, 0x4c, 0x04, 0x19, 0x0f, 0x21, 0x53, 0x2e, 0x17, 0xd1, 0xbb, 0xb0, 0xda, 0x6d, 0x76,
        0x68, 0xc3, 0x6a, 0xcb, 0x4e, 0xee, 0x8c, 0x47, 0xf9, 0x95, 0xa7, 0xcd, 0x0e, 0x2d, 0xb7, 0x5f,
        0x8c, 0xf2, 0x9b, 0xa2, 0xa9, 0x28, 0x63, 0x22, 0x2b, 0xd0, 0x03, 0xc8, 0xfa, 0x43, 0xbf, 0x47,
        0x3b, 0xac, 0x9d, 0xe8, 0x31, 0x3f, 0x1e, 0xe5, 0xd7, 0x6a, 0x9c, 0xc8, 0x5b, 0x6e, 0x8b, 0x96,
        0x01, 0x05, 0x93, 0xb0, 0x12, 0x3f, 0x86, 0xed, 0x23, 0xc7, 0xb1, 0x69, 0xb3, 0x4b, 0xa8, 0xef,
        0x3a, 0x5d, 0x9f, 0xa2, 0x77, 0x60, 0xc5, 0xa3, 0x7e, 0xdf, 0xee, 0x71, 0x29, 0xd6, 0x84, 0x14,
        0x84, 0x53, 0x94, 0x14, 0xa2, 0x8c, 0x89, 0xac, 0xc0, 0x8f, 0x60, 0xab, 0xd6, 0xf3, 0xac, 0xee,
        0xd9, 0x04, 0x98, 0xec, 0x6c, 0x30, 0x1f, 0xc2, 0x76, 0x85, 0xfa, 0x7e, 0xf3, 0x8c, 0x86, 0x38,
        0xef, 0xc1, 0x6a, 0x47, 0x90, 0x24, 0xd0, 0xab, 0xe3, 0x51, 0x3e, 0x20, 0xbd, 0x18, 0xe5, 0xb7,
        0x04, 0x92, 0x24, 0x60, 0x12, 0x54, 0x09, 0x91, 0x9a, 0xbd, 0xbe, 0xaf, 0x8b, 0xe4, 0x73, 0x8a,
        0x2e, 0x92, 0xe0, 0x51, 0x22, 0x89, 0x32, 0x26, 0xb2, 0x02, 0x57, 0xe1, 0xf6, 0x13, 0xcb, 0xef,
        0x15, 0x6c, 0xa7, 0xdf, 0x7e, 0x56, 0x2b, 0x77, 0x4f, 0x9d, 0x10, 0xef, 0x17, 0x61, 0xd9, 0xea,
        0xd1, 0x0e, 0x83, 0xcb, 0x04, 0x82, 0xb5, 0x18, 0x9f, 0xe3, 0x2b, 0xc1, 0x24, 0x01, 0x93, 0xa0,
        0x0a, 0x9f, 0xc2, 0x2d, 0x8e, 0x56, 0xf4, 0xac, 0x01, 0xf5, 0x04, 0xe2, 0x67, 0x7d, 0xea, 0xf7,
        0xd0, 0x13, 0x58, 0x62, 0x80, 0x5c, 0xbc, 0xf5, 0xb7, 0x5f, 0xf9, 0x5a, 0x68, 0xac, 0x11, 0x7e,
        0x21, 0x79, 0x9b, 0x97, 0x95, 0xe4, 0xa2, 0x8c, 0x89, 0xac, 0xc0, 0x67, 0x70, 0x3b, 0xd6, 0x8f,
        0x94, 0xfc, 0x7a, 0x3b, 0xb2, 0xe1, 0x4e, 0xa8, 0xa2, 0x84, 0xce, 0x2a, 0xba, 0x9a, 0xae, 0xde,
        0xdb, 0x6f, 0xa7, 0x61, 0x3b, 0xd2, 0x10, 0x15, 0x61, 0x5d, 0xd4, 0x36, 0xd8, 0x0a, 0x92, 0xd3,
        0xfb, 0x95, 0xf1, 0x28, 0x0f, 0x82, 0x89, 0xad, 0x95, 0x17, 0xa3, 0xfc, 0x8e, 0x40, 0x54, 0x34,
        0x4c, 0x34, 0x06, 0xf4, 0x04, 0x36, 0x5d, 0xcf, 0x19, 0x30, 0xd1, 0x04, 0x8e, 0x58, 0x4e, 0x6f,
        0x8c, 0x47, 0xf9, 0x8d, 0xaa, 0xac, 0x90, 0x48, 0xbb, 0x02, 0x49, 0xa7, 0x62, 0x62, 0x30, 0xa1,
        0x13, 0xd8, 0x93, 0x32, 0xd9, 0xd6, 0x49, 0xe3, 0xd4, 0xb2, 0xa9, 0x00, 0xcd, 0x70, 0xd0, 0x5f,
        0x18, 0x8f, 0xf2, 0x3b, 0xa2, 0xef, 0x27, 0xd6, 0xc9, 0x63, 0xcb, 0xa6, 0x12, 0x79, 0x5f, 0x97,
        0x51, 0xab, 0xc2, 0x24, 0xce, 0x8e, 0x3f, 0x85, 0x9b, 0x9a, 0x2a, 0x3e, 0xf2, 0x86, 0x81, 0x25,
        0x5d, 0x8b, 0x42, 0xb0, 0x0b, 0x37, 0x0b, 0x1e, 0x6d, 0xd3, 0x6e, 0xcf, 0x6a, 0xda, 0xba, 0xa1,
        0x7e, 0xdb, 0xb0, 0x9f, 0x7d, 0x6d, 0x46, 0x0d, 0x76, 0xd1, 0x63, 0x2b, 0xa4, 0xa9, 0x1e, 0x15,
        0x0d, 0x13, 0x8d, 0x01, 0x7f, 0x06, 0xb7, 0xa2, 0x3d, 0x4a, 0x2b, 0x7a, 0x69, 0x5d, 0x0e, 0xe0,
        0x80, 0x5b, 0x6f, 0x72, 0xb7, 0x9f, 0x98, 0xc6, 0x7b, 0x8d, 0xfd, 0xfe, 0x59, 0x1a, 0xb6, 0x4c,
        0x0c, 0xf4, 0x1c, 0xb6, 0x15, 0x83, 0x3e, 0x73, 0x6f, 0x8e, 0x47, 0x79, 0x8d, 0x59, 0xce, 0xde,
        0x4d, 0xd1, 0x81, 0x49, 0xc7, 0x24, 0xc2, 0x78, 0xcd, 0x66, 0xed, 0xc1, 0xee, 0x39, 0x1d, 0x36,
        0x78, 0x84, 0x6b, 0x58, 0xdd, 0x53, 0xa7, 0x61, 0x5b, 0x7e, 0x6f, 0x3f, 0xc3, 0xd5, 0x83, 0x94,
        0x7a, 0x82, 0xb8, 0x79, 0xf4, 0xd6, 0x78, 0x94, 0xcf, 0x05, 0x25, 0x36, 0x4c, 0xa6, 0xed, 0x17,
        0xa3, 0xfc, 0xed, 0x30, 0x6e, 0x1a, 0x35, 0x98, 0xc4, 0x98, 0xb1, 0x0d, 0x7b, 0x6a, 0x4c, 0x9a,
        0x95, 0xbf, 0x14, 0x7d, 0xe1, 0xef, 0xc2, 0x0e, 0xa1, 0x67, 0x96, 0xd3, 0xd5, 0x2d, 0xbe, 0x64,
        0x98, 0xdf, 0x9e, 0x1a, 0xa7, 0x62, 0x15, 0xee, 0xcb, 0xe3, 0x65, 0xe5, 0xbe, 0x44, 0x19, 0x13,
        0x59, 0x81, 0x3f, 0x05, 0xa4, 0xa3, 0x4b, 0x33, 0xbb, 0x36, 0xf8, 0x13, 0xb8, 0xc5, 0x54, 0x96,
        0xd0, 0xc5, 0x07, 0xa6, 0x25, 0x5f, 0xa1, 0x8f, 0x1f, 0xa7, 0x01, 0x54, 0x1b, 0xe6, 0x6b, 0x44,
        0x45, 0xcc, 0xd7, 0x08, 0x26, 0xd3, 0xd7, 0x28, 0x1a, 0x26, 0x1a, 0xc3, 0xff, 0x03, 0x2b, 0xfd,
        0x04, 0x72, 0x62, 0x3c, 0xa6, 0x1f, 0xbe, 0xba, 0x6e, 0xf0, 0xef, 0xa6, 0xe0, 0x4e, 0xc1, 0xe9,
        0x76, 0x69, 0xab, 0x67, 0x39, 0xdd, 0x82, 0xd3, 0x3d, 0xb5, 0xce, 0x74, 0xe3, 0x74, 0x0c, 0xeb,
        0xb9, 0xa7, 0xf9, 0xa8, 0x84, 0x46, 0x62, 0xa8, 0xad, 0xb0, 0xa6, 0xc5, 0x6b, 0xd4, 0x50, 0xa3,
        0x35, 0x98, 0xc4, 0x98, 0xf1, 0xef, 0xa5, 0xe0, 0x6e, 0xb2, 0x40, 0xd2, 0xd8, 0x16, 0x2e, 0xd1,
        0x8f, 0x53, 0x70, 0x9f, 0xbb, 0xf1, 0x69, 0x52, 0xb9, 0xe6, 0x12, 0x58, 0x80, 0x58, 0x3f, 0xcc,
        0xc0, 0x5e, 0x12, 0x36, 0x33, 0x0c, 0xc1, 0x12, 0x33, 0x0c, 0xc1, 0x64, 0x1a, 0x86, 0xa2, 0x61,
        0xa2, 0x31, 0x5c, 0xf3, 0xa2, 0x89, 0x24, 0x0d, 0x99, 0xf9, 0xb2, 0xa8, 0x04, 0xa7, 0xbc, 0x74,
        0xf5, 0x20, 0x16, 0x59, 0x48, 0xcb, 0xf3, 0x2d, 0xa4, 0x13, 0x38, 0x88, 0xce, 0x86, 0xb9, 0x58,
        0xaf, 0x3e, 0x27, 0xf8, 0xd7, 0xe0, 0xf6, 0xa1, 0x6d, 0x13, 0xea, 0x3b, 0x7d, 0xaf, 0x45, 0x0d,
        0xfb, 0x7b, 0x36, 0x29, 0xed, 0x8e, 0x34, 0x10, 0x5b, 0x89, 0x43, 0xdb, 0x96, 0x4e, 0x48, 0x6e,
        0x25, 0x24, 0x01, 0x93, 0xa0, 0x0a, 0xff, 0x69, 0x1a, 0xb6, 0x23, 0x6d, 0x51, 0x0d, 0xd6, 0x3b,
        0x4d, 0xd7, 0xa5, 0x6d, 0xe1, 0xf2, 0x84, 0xa9, 0x6f, 0xaa, 0xbe, 0xca, 0xe5, 0xa2, 0x18, 0x54,
        0x85, 0x73, 0xc9, 0x2e, 0xe4, 0xa0, 0x14, 0x0d, 0x13, 0x8d, 0x01, 0xb5, 0x21, 0xe7, 0x74, 0xed,
        0x61, 0x43, 0x60, 0x08, 0xe4, 0x74, 0x12, 0x32, 0x9f, 0xe4, 0x67, 0x5d, 0x7b, 0x58, 0xe3, 0x34,
        0x89, 0x2e, 0x27, 0xd9, 0xa4, 0x63, 0x12, 0x61, 0x44, 0x9f, 0xc0, 0x26, 0xef, 0xa5, 0xe5, 0xbb,
        0xba, 0xbf, 0x8e, 0x74, 0xf1, 0xfa, 0x78, 0x94, 0x5f, 0x67, 0x2d, 0x0b, 0xb5, 0xaa, 0xc4, 0x47,
        0x0a, 0x5f, 0x12, 0x31, 0xd1, 0x59, 0xf0, 0x27, 0xb0, 0x53, 0xee, 0x34, 0xcf, 0xcc, 0xe9, 0x28,
        0x18, 0xd3, 0xb1, 0xab, 0xf5, 0x12, 0xb0, 0x8a, 0xcd, 0xbb, 0xd5, 0x11, 0x5b, 0x4d, 0xb9, 0x79,
        0xe7, 0x45, 0x4c, 0x04, 0x99, 0xa5, 0xe0, 0xac, 0x87, 0x38, 0x7a, 0xd1, 0x74, 0x36, 0x73, 0xc2,
        0xff, 0x24, 0x0d, 0xd9, 0x90, 0x1f, 0xfd, 0x12, 0x64, 0x2c, 0x79, 0x3c, 0x10, 0x53, 0x0b, 0x3f,
        0x92, 0x28, 0xf3, 0x0d, 0xbf, 0x3c, 0x92, 0x28, 0xb3, 0xbd, 0x3e, 0x23, 0xa1, 0xf7, 0x61, 0xed,
        0x8c, 0x99, 0x78, 0xc3, 0xf1, 0xa5, 0x8b, 0xe0, 0x16, 0x56, 0x62, 0xb4, 0x67, 0x35, 0x65, 0x61,
        0x92, 0x80, 0x49, 0x50, 0xa5, 0xed, 0x99, 0x33, 0x33, 0xef, 0x99, 0x51, 0x13, 0xb6, 0x54, 0xf4,
        0xe5, 0x13, 0xb9, 0x34, 0x31, 0xf0, 0x72, 0x5f, 0x15, 0x94, 0xe4, 0x74, 0xee, 0x9a, 0x41, 0x57,
        0xcc, 0xa7, 0xc1, 0x84, 0xff, 0x26, 0x05, 0x88, 0xeb, 0xa5, 0xe0, 0xd1, 0x66, 0x8f, 0xea, 0x19,
        0x61, 0xb8, 0xc0, 0xe3, 0x19, 0x61, 0x58, 0x15, 0x71, 0x3e, 0x06, 0x9d, 0x39, 0x1f, 0x83, 0x10,
        0xae, 0xdb, 0x74, 0x74, 0xdd, 0x6a, 0x12, 0xa8, 0x75, 0x4b, 0xe8, 0x67, 0xac, 0xa0, 0xb4, 0x2a,
        0x09, 0x98, 0x04, 0x55, 0xf8, 0x5b, 0xb0, 0x1d, 0x69, 0x8a, 0xde, 0x84, 0x25, 0x4d, 0xdc, 0xdb,
        0xe3, 0x51, 0x7e, 0x49, 0x0a, 0xb9, 0xae, 0x0e, 0x7e, 0x30, 0x59, 0x92, 0x3e, 0x46, 0x0c, 0xfe,
        0xd0, 0x8e, 0xa6, 0xc3, 0xd7, 0x3e, 0x78, 0x16, 0x59, 0x85, 0xb0, 0x2f, 0xbb, 0xa7, 0x50, 0x05,
        0xe9, 0x59, 0x54, 0xf0, 0x29, 0xa0, 0x7a, 0xa5, 0xe6, 0xd2, 0xd6, 0x6c, 0x79, 0xb4, 0xe2, 0x15,
        0x26, 0x3c, 0xe8, 0xf8, 0x2e, 0x6d, 0x29, 0x13, 0x16, 0x65, 0x4c, 0x64, 0x45, 0x90, 0x47, 0x27,
        0x74, 0x31, 0x39, 0x8f, 0xbe, 0x6c, 0x1f, 0xff, 0x93, 0x06, 0x50, 0x6d, 0xc4, 0x89, 0x19, 0x0b,
        0x55, 0xe6, 0x89, 0x99, 0x99, 0x8b, 0x93, 0x20, 0x17, 0x17, 0xff, 0x5c, 0x4a, 0x67, 0xe8, 0x21,
        0x2c, 0x0f, 0x1a, 0x2d, 0xb7, 0xcf, 0xd7, 0xb2, 0xb1, 0x1c, 0xeb, 0x05, 0xb7, 0xcf, 0x05, 0xe7,
        0x08, 0xac, 0xa4, 0x10, 0x58, 0x09, 0x13, 0x4e, 0x44, 0x6f, 0x40, 0xa6, 0x43, 0x3b, 0x32, 0xa0,
        0x73, 0x8f, 0x53, 0xa1, 0x1d, 0xe5, 0x71, 0x2a, 0xb4, 0x83, 0x09, 0x23, 0xa1, 0xaf, 0x43, 0xe6,
        0xcc, 0xed, 0xef, 0x2f, 0x73, 0x1d, 0xed, 0xa8, 0x8e, 0x4a, 0xb2, 0x1f, 0xde, 0xb6, 0xc4, 0xbb,
        0x91, 0x6d, 0x4b, 0xac, 0x17, 0x46, 0x4a, 0x70, 0x1f, 0x2b, 0xd7, 0xed, 0x3e, 0x6c, 0x58, 0x0b,
        0x86, 0x8c, 0xde, 0x82, 0xe5, 0x96, 0xd3, 0xef, 0x06, 0x07, 0x95, 0xdc, 0x27, 0x17, 0x18, 0x41,
        0xf9, 0x64, 0x5e, 0xc4, 0x44, 0x90, 0x79, 0x03, 0xdb, 0x69, 0x9d, 0xeb, 0x07, 0xbc, 0x05, 0x46,
        0xd0, 0x1a, 0xb0, 0x22, 0x6b, 0xc0, 0xff, 0xfe, 0x6d, 0x0a, 0x56, 0x4b, 0xf3, 0xf6, 0xc6, 0x54,
        0x7e, 0xea, 0xc9, 0xbe, 0x84, 0xca, 0x4f, 0x3d, 0x4d, 0xe5, 0xa7, 0x1e, 0x53, 0xf9, 0xa9, 0xc7,
        0x90, 0x3b, 0x4e, 0x9b, 0xda, 0xd2, 0x53, 0x73, 0xe4, 0x0a, 0x23, 0x28, 0x64, 0x5e, 0xc4, 0x44,
        0x90, 0x67, 0x9e, 0x4c, 0x7c, 0x0e, 0xbb, 0xc2, 0x4e, 0x17, 0xe1, 0x6f, 0x7e, 0x92, 0x82, 0x9c,
        0xe8, 0xed, 0x8b, 0xe5, 0x70, 0x9e, 0xc2, 0x76, 0xbd, 0x5a, 0x30, 0x5c, 0xc1, 0x37, 0x0c, 0x6f,
        0xa3, 0x59, 0xb9, 0x64, 0x14, 0x4a, 0x1d, 0xb8, 0x2d, 0xa5, 0xd4, 0x81, 0xdb, 0xc2, 0x84, 0x91,
        0x70, 0x0d, 0x76, 0xb9, 0x87, 0x89, 0x60, 0x3e, 0x30, 0xdd, 0xcb, 0x25, 0x41, 0xff, 0x2d, 0x0d,
        0xab, 0x92, 0x6f, 0xee, 0x64, 0xe1, 0x97, 0x21, 0x6b, 0xb9, 0x83, 0x77, 0x1b, 0x2d, 0xab, 0x1d,
        0x98, 0xdd, 0x6b, 0xe3, 0x51, 0x3e, 0x5b, 0xae, 0x0e, 0xde, 0x6d, 0x14, 0xca, 0x45, 0xf2, 0x62,
        0x94, 0xcf, 0xc9, 0x46, 0x01, 0x09, 0x13, 0x55, 0x8d, 0xce, 0x21, 0xe7, 0xf7, 0x4f, 0xba, 0xb4,
        0x17, 0xdb, 0x79, 0x6b, 0xce, 0xb2, 0xc6, 0x39, 0xf8, 0x80, 0xf8, 0x1c, 0xaa, 0xb2, 0x99, 0x33,
        0x9a, 0x74, 0x4c, 0x22, 0x8c, 0x8b, 0xc8, 0x35, 0xfe, 0x33, 0x05, 0xa0, 0x7a, 0xfd, 0xbf, 0xd3,
        0x6b, 0x7c, 0xa8, 0x99, 0xeb, 0x1e, 0xea, 0x5f, 0xb2, 0xc5, 0x57, 0x2d, 0x2c, 0x22, 0xa9, 0xaa,
        0x18, 0x49, 0xd5, 0x6d, 0xc3, 0xce, 0xe7, 0x48, 0xa9, 0xfe, 0x2b, 0x05, 0x9b, 0x46, 0xcb, 0x4b,
        0x65, 0x54, 0x57, 0x9f, 0x9c, 0xcf, 0x26, 0x1a, 0xfd, 0x41, 0xd4, 0xe8, 0xb5, 0xd1, 0x5d, 0xc5,
        0xf4, 0xf1, 0x6f, 0xa6, 0x20, 0x17, 0x45, 0x5c, 0xec, 0xa8, 0xf1, 0xf7, 0xb8, 0xb9, 0x2c, 0x22,
        0x2c, 0xfc, 0xa3, 0x98, 0xdf, 0x2f, 0x54, 0x4c, 0x60, 0x21, 0xf7, 0xd4, 0xf1, 0x5a, 0x54, 0x0f,
        0xb9, 0x9c, 0xa0, 0x42, 0x2e, 0x2f, 0x62, 0x22, 0xc8, 0xf8, 0x77, 0x52, 0x90, 0x2b, 0xd4, 0xaa,
        0x8b, 0x18, 0xc8, 0x57, 0x20, 0x1d, 0x7e, 0x11, 0xde, 0x1d, 0x8f, 0xf2, 0x69, 0xee, 0x95, 0xb2,
        0x72, 0x36, 0xdb, 0x98, 0xa4, 0xcb, 0x6d, 0xfc, 0xdf, 0xa1, 0x09, 0x1d, 0xb6, 0xdb, 0x2f, 0x57,
        0x9e, 0xf7, 0x61, 0x6d, 0xe0, 0xb6, 0xf4, 0x63, 0x2a, 0xbe, 0xb4, 0xeb, 0xd5, 0x82, 0xc4, 0x91,
        0x4b, 0x5b, 0x12, 0x30, 0x09, 0xaa, 0x50, 0x55, 0x7a, 0x0a, 0x91, 0xb5, 0x4e, 0x5b, 0x4e, 0xb3,
        0x3a, 0x8b, 0x3f, 0x4e, 0x07, 0xc3, 0x7e, 0xe9, 0xd3, 0x30, 0xff, 0xb0, 0x8b, 0xb0, 0x2e, 0x3d,
        0x4a, 0xf4, 0x38, 0x4e, 0x88, 0x6e, 0x1e, 0x47, 0x29, 0x1a, 0x26, 0x1a, 0x83, 0x32, 0xd1, 0xa5,
        0x19, 0x4d, 0xf4, 0x5f, 0x52, 0xb0, 0x5b, 0xa8, 0x55, 0xbf, 0xf0, 0xea, 0x11, 0xf6, 0x9d, 0x99,
        0x6e, 0xdf, 0x03, 0xd8, 0xab, 0xd1, 0x56, 0xdf, 0xb3, 0x7a, 0x43, 0x23, 0xcb, 0xfa, 0x55, 0x23,
        0x73, 0xbb, 0xa5, 0x99, 0x94, 0xc6, 0x7d, 0xf4, 0x73, 0xe3, 0x51, 0x7e, 0xd3, 0x97, 0x94, 0x33,
        0xcf, 0xe9, 0xbb, 0x2f, 0x46, 0xf9, 0x3d, 0xd1, 0x83, 0x41, 0xc6, 0xc4, 0x64, 0xc3, 0xbf, 0x01,
        0xfb, 0xcc, 0x45, 0x27, 0xf6, 0xdd, 0x30, 0x33, 0xbc, 0xeb, 0xef, 0xfc, 0x4f, 0x32, 0xb0, 0xa1,
        0x43, 0xcd, 0x9d, 0xb1, 0x14, 0x60, 0x95, 0x4d, 0x8e, 0x25, 0xfd, 0x48, 0xac, 0x2d, 0xdf, 0xa1,
        0xd6, 0xdd, 0x56, 0xb9, 0x5c, 0x54, 0x3b, 0x54, 0x51, 0xc6, 0x44, 0x56, 0xb0, 0x18, 0xd3, 0xb6,
        0x3c, 0x31, 0xe5, 0x72, 0xba, 0x78, 0x8c, 0x29, 0x06, 0x44, 0x15, 0x63, 0x42, 0x12, 0x26, 0xaa,
        0x1a, 0xd9, 0xb0, 0x15, 0x8c, 0xaf, 0xe1, 0xf5, 0x6d, 0xea, 0xcb, 0x0c, 0xef, 0x20, 0xae, 0x38,
        0xd2, 0xb7, 0xa9, 0x52, 0x9e, 0x4e, 0xf5, 0x95, 0xf2, 0x0c, 0x32, 0x26, 0x26, 0x5b, 0x42, 0x92,
        0xb5, 0x7c, 0xdd, 0x49, 0xd6, 0x5f, 0x33, 0xef, 0x13, 0x91, 0x18, 0x3d, 0x80, 0xec, 0xa9, 0xe7,
        0x74, 0x1a, 0xae, 0xe3, 0x05, 0x7b, 0x43, 0x7e, 0x8f, 0xe7, 0xb1, 0xe7, 0x74, 0xaa, 0x8e, 0xd7,
        0x53, 0xf7, 0x78, 0x02, 0x0a, 0x26, 0x61, 0x25, 0x7a, 0x17, 0x56, 0x7b, 0x8e, 0x68, 0x9b, 0x56,
        0x87, 0x07, 0xcf, 0x1d, 0xd9, 0x52, 0x4e, 0x8d, 0x28, 0x63, 0x22, 0x2b, 0x98, 0x87, 0xb1, 0xdc,
        0x06, 0xbf, 0xf3, 0xd4, 0x72, 0x6c, 0xdd, 0xc3, 0x94, 0xab, 0x55, 0x49, 0x55, 0x1e, 0x46, 0xd1,
        0x30, 0xd1, 0x18, 0xcc, 0x09, 0x5e, 0x9a, 0x63, 0x82, 0xdf, 0x84, 0x25, 0x9e, 0x80, 0x2c, 0xab,
        0x90, 0x2b, 0x73, 0x0f, 0x19, 0x72, 0x45, 0xda, 0xc1, 0x89, 0xf8, 0xef, 0x53, 0x70, 0x33, 0x50,
        0xde, 0x22, 0xd2, 0x54, 0x62, 0xa4, 0xa9, 0x77, 0xe3, 0x36, 0x37, 0x47, 0xf8, 0xf9, 0xf3, 0x34,
        0xa0, 0x78, 0xf3, 0xcb, 0xa5, 0x6e, 0xf3, 0x3b, 0xce, 0x2f, 0xd7, 0x82, 0xc4, 0x1d, 0x35, 0xdf,
        0x8b, 0xc8, 0x33, 0x7f, 0x9a, 0x52, 0x73, 0xf3, 0x25, 0x4f, 0x36, 0x7f, 0x94, 0x82, 0x9b, 0x2c,
        0x92, 0x2f, 0x6a, 0x34, 0x33, 0x65, 0x9c, 0x27, 0xb0, 0x7b, 0x4c, 0x87, 0xd5, 0xa6, 0x65, 0x5e,
        0x12, 0x3b, 0x36, 0x02, 0xf2, 0x4d, 0xc3, 0xd9, 0x06, 0xcc, 0xc2, 0xc2, 0xcf, 0xe9, 0xd0, 0x6d,
        0x5a, 0x9e, 0xb2, 0x70, 0x49, 0xc0, 0x24, 0xa8, 0xc2, 0x67, 0xe2, 0xce, 0x5e, 0x52, 0x3f, 0x4f,
        0xcc, 0xe0, 0x7b, 0xc5, 0x8e, 0xfe, 0x2a, 0x03, 0xeb, 0x5a, 0xbb, 0xb9, 0x03, 0x6d, 0x09, 0xd6,
        0x4f, 0xad, 0xee, 0x19, 0xf5, 0x5c, 0xcf, 0xea, 0x06, 0x2e, 0x9c, 0x7f, 0xe7, 0x7a, 0xac, 0xc8,
        0xea, 0x3b, 0x97, 0x46, 0xc4, 0x44, 0x67, 0x41, 0x0f, 0x01, 0xdc, 0xfe, 0x89, 0x6d, 0xb5, 0x1a,
        0xe7, 0x74, 0xa8, 0x2f, 0xee, 0x2a, 0xa7, 0x8a, 0x1b, 0xab, 0x72, 0x71, 0x87, 0x24, 0x4c, 0x54,
        0x35, 0x8b, 0x09, 0xae, 0x67, 0x0d, 0x9a, 0x3d, 0xca, 0x21, 0x96, 0x54, 0x4c, 0xa8, 0x0a, 0xb2,
        0xc0, 0xd8, 0x09, 0x3e, 0x27, 0x07, 0x34, 0x4c, 0x34, 0x06, 0xf4, 0x4d, 0x80, 0x41, 0xa7, 0xd1,
        0xf7, 0xa9, 0xd7, 0xb0, 0xda, 0xd2, 0xb1, 0xf3, 0x70, 0x56, 0xaf, 0x7c, 0xec, 0x53, 0x8f, 0xe7,
        0x0b, 0x32, 0x9c, 0x05, 0x14, 0x4c, 0xc2, 0xca, 0x45, 0x9c, 0x00, 0xff, 0x5d, 0x0a, 0xf6, 0xe4,
        0xd4, 0x2d, 0x22, 0x8c, 0x7c, 0x64, 0x84, 0x91, 0x3b, 0x31, 0xb3, 0x9b, 0x23, 0x8a, 0x3c, 0x84,
        0x9d, 0x58, 0xe3, 0xcb, 0x7d, 0x46, 0xb2, 0x43, 0x15, 0x2c, 0xc2, 0xb3, 0xfe, 0x53, 0x2a, 0x14,
        0xf8, 0x4b, 0xee, 0x58, 0xff, 0x20, 0x05, 0x7b, 0x85, 0x5a, 0x75, 0x51, 0x83, 0x99, 0xc9, 0xaf,
        0xda, 0x62, 0xc7, 0x51, 0xaf, 0x88, 0x6f, 0xb0, 0x86, 0xd3, 0xab, 0x4e, 0xdc, 0x71, 0xe8, 0xec,
        0x62, 0x81, 0x0e, 0x3a, 0x7e, 0xf0, 0x75, 0x77, 0x3b, 0xfc, 0x6c, 0x25, 0xbf, 0xef, 0x86, 0x95,
        0xf8, 0x07, 0x29, 0xd8, 0xd0, 0xdb, 0xce, 0xed, 0xf9, 0x1e, 0x40, 0x76, 0xd0, 0x69, 0xc8, 0x4f,
        0xcc, 0xda, 0xf5, 0xf5, 0x7a, 0xa7, 0x16, 0x11, 0x23, 0xa0, 0x30, 0x3f, 0x11, 0xfc, 0x5b, 0x86,
        0xad, 0x7a, 0xc5, 0x18, 0xea, 0x7b, 0x46, 0x1c, 0xc9, 0xe9, 0x23, 0xe5, 0x63, 0xe4, 0xfa, 0x1b,
        0x74, 0x94, 0xfe, 0x06, 0x1d, 0x4c, 0xd2, 0x83, 0x0e, 0x7e, 0x0a, 0x48, 0xe8, 0xcf, 0x80, 0x7b,
        0xdf, 0xd4, 0xdc, 0x25, 0xf0, 0x7e, 0x6b, 0x03, 0x56, 0x04, 0xcf, 0xdc, 0xba, 0x79, 0x08, 0xe0,
        0xf7, 0x9a, 0x5e, 0xaf, 0xd1, 0xb3, 0x42, 0x53, 0xe6, 0xce, 0xbc, 0xc6, 0xa8, 0xcf, 0x2d, 0x6e,
        0x43, 0xb9, 0xf0, 0x13, 0xbc, 0x20, 0x61, 0xa2, 0xaa, 0xd1, 0x71, 0xf8, 0x49, 0x31, 0x13, 0xdd,
        0xe8, 0xd6, 0x2b, 0xd1, 0x6b, 0x7f, 0x17, 0x7d, 0x6a, 0x3c, 0x86, 0x2c, 0xbf, 0x93, 0xc0, 0xf7,
        0x83, 0x4b, 0x49, 0x83, 0xe1, 0x33, 0x27, 0x6e, 0x2b, 0xe8, 0x0f, 0x0f, 0x02, 0x0a, 0x26, 0x61,
        0x25, 0x7a, 0x04, 0x1b, 0x6c, 0xde, 0x5d, 0xda, 0x8a, 0x5d, 0xe8, 0x11, 0x1f, 0x7f, 0xcc, 0xd3,
        0x0d, 0x45, 0xc3, 0x44, 0x63, 0xd0, 0x77, 0xa8, 0x2b, 0x73, 0xef, 0x50, 0x9f, 0x01, 0x04, 0x47,
        0xb7, 0x56, 0x7b, 0x7f, 0x35, 0x09, 0x47, 0xa8, 0x5d, 0x1c, 0xbf, 0x72, 0xa8, 0x9c, 0x71, 0x44,
        0xcb, 0xd0, 0x54, 0x35, 0x72, 0x61, 0x37, 0x4c, 0x90, 0xf9, 0x96, 0x9c, 0x01, 0xfb, 0xfb, 0x6b,
        0x49, 0xb7, 0x59, 0xf8, 0x45, 0xf0, 0x20, 0x45, 0x2b, 0x31, 0xe6, 0x72, 0xb9, 0xed, 0xab, 0x8b,
        0xe0, 0xb1, 0x2a, 0x4c, 0xe2, 0xec, 0xe8, 0x39, 0x6c, 0xb0, 0x80, 0xc9, 0x92, 0x12, 0x3e, 0x88,
        0x6c, 0xd2, 0x20, 0xb8, 0x76, 0x83, 0x74, 0x85, 0x4f, 0xd0, 0x4e, 0x18, 0x27, 0x25, 0x0d, 0x13,
        0x8d, 0x21, 0x12, 0xc5, 0x21, 0x16, 0xc5, 0xdb, 0xb1, 0x28, 0xde, 0x56, 0x51, 0xbc, 0x8d, 0x2a,
        0xb0, 0x15, 0x34, 0x77, 0x9b, 0xbe, 0xff, 0xfd, 0xf6, 0xfe, 0xba, 0xba, 0x9e, 0x26, 0xb8, 0xaa,
        0x9c, 0xae, 0x22, 0xb6, 0x4e, 0xc5, 0xc4, 0x60, 0x42, 0xdf, 0x85, 0x9d, 0x2e, 0xed, 0x7d, 0xdf,
        0xf1, 0xce, 0x1b, 0x56, 0xb7, 0x47, 0xbd, 0xd3, 0x66, 0x8b, 0xee, 0x6f, 0x70, 0x44, 0x7e, 0x53,
        0xef, 0xa9, 0xa8, 0x2c, 0x07, 0x75, 0xea, 0xa6, 0x5e, 0xb4, 0x06, 0x93, 0x18, 0x33, 0x73, 0x44,
        0x32, 0x73, 0xb2, 0xdc, 0xfd, 0x4d, 0x35, 0x54, 0x91, 0x19, 0x95, 0xab, 0x6a, 0xa8, 0x01, 0x05,
        0x93, 0xb0, 0x52, 0xcb, 0xbb, 0xda, 0x5d, 0x7f, 0x7f, 0x2b, 0x9a, 0x77, 0x15, 0x9f, 0xd6, 0xa2,
        0x79, 0x57, 0xf1, 0x69, 0x2d, 0xcc, 0xbb, 0x8a, 0x4f, 0x6b, 0x1c, 0x41, 0xe6, 0x5d, 0x96, 0xbb,
        0xbf, 0xad, 0x21, 0x08, 0x2a, 0x97, 0x20, 0x67, 0x64, 0x5d, 0x4c, 0x04, 0x55, 0xad, 0x67, 0x6e,
        0x4c, 0x88, 0x5c, 0x2c, 0x73, 0x13, 0x52, 0x98, 0x99, 0x1b, 0x17, 0x43, 0x63, 0x90, 0x0b, 0xf3,
        0xc4, 0x71, 0x7a, 0x8d, 0xb6, 0xe5, 0x9f, 0xef, 0xef, 0xe8, 0x0b, 0xf3, 0xc8, 0x71, 0x7a, 0x45,
        0xcb, 0x3f, 0xd7, 0x17, 0x66, 0x40, 0xe3, 0x0b, 0x33, 0x28, 0xa0, 0x32, 0x6c, 0x32, 0x18, 0xdb,
        0x69, 0x9d, 0x0b, 0x1c, 0xa4, 0x72, 0xda, 0x7a, 0xe5, 0x88, 0xd1, 0x25, 0x10, 0x0a, 0x81, 0x02,
        0x22, 0x26, 0x3a, 0x0b, 0xfa, 0x18, 0x72, 0xbe, 0xff, 0xbd, 0x46, 0xb3, 0xd5, 0xa2, 0xbe, 0xdf,
        0x70, 0x1d, 0x96, 0x21, 0xef, 0xaa, 0xa8, 0x5a, 0xab, 0x7d, 0x70, 0xc8, 0xab, 0xaa, 0x8e, 0x48,
        0x92, 0x83, 0xaf, 0x27, 0x06, 0x1d, 0x93, 0x08, 0x63, 0x42, 0x8e, 0xb9, 0x77, 0xdd, 0x39, 0xa6,
        0xcb, 0x82, 0xa4, 0x76, 0x53, 0x7a, 0xde, 0x1b, 0x1e, 0xbf, 0xee, 0x74, 0x8d, 0x54, 0xe6, 0x3b,
        0x4e, 0x57, 0x4b, 0x65, 0x58, 0x09, 0x13, 0x4e, 0xc4, 0x7f, 0x91, 0x82, 0xed, 0x7a, 0x65, 0x11,
        0x09, 0xed, 0x13, 0x23, 0xa1, 0x35, 0x02, 0xcb, 0x1c, 0xb9, 0xec, 0x0f, 0x96, 0x99, 0xaa, 0xe6,
        0x3d, 0x0b, 0x79, 0x08, 0x20, 0x22, 0x93, 0x96, 0xf3, 0x89, 0xef, 0x58, 0x8c, 0x2a, 0xdb, 0xe5,
        0xb4, 0x60, 0x24, 0x1a, 0xab, 0x6a, 0xe3, 0x34, 0x25, 0x73, 0x95, 0x53, 0xfa, 0xa5, 0xf9, 0x4e,
        0xe9, 0x29, 0xec, 0x45, 0x22, 0x06, 0x43, 0xf3, 0xf9, 0xd9, 0x63, 0xf6, 0xe8, 0x9d, 0xf1, 0x28,
        0x8f, 0x0c, 0xa7, 0xcf, 0x1a, 0xb1, 0x20, 0xf1, 0x4a, 0x42, 0x90, 0xe0, 0x75, 0x98, 0x24, 0x34,
        0x88, 0x45, 0xdd, 0x95, 0xf9, 0xa2, 0x6e, 0x19, 0x36, 0xc3, 0x68, 0xc3, 0x71, 0x56, 0xd5, 0xe2,
        0x96, 0xe1, 0x43, 0x02, 0x21, 0x23, 0xc0, 0x08, 0x24, 0x9d, 0x25, 0x12, 0x62, 0xd6, 0xae, 0x1e,
        0x62, 0xb2, 0x57, 0x08, 0x31, 0xf8, 0x8c, 0xad, 0x9e, 0x45, 0xec, 0x85, 0xfe, 0x81, 0xe7, 0xcf,
        0x5f, 0xf2, 0x6d, 0xd0, 0x0f, 0x53, 0xb0, 0x5d, 0xa8, 0x55, 0x17, 0x30, 0x8e, 0x99, 0x76, 0x40,
        0xff, 0xcc, 0x7d, 0xdf, 0x21, 0x6f, 0xf5, 0x05, 0x52, 0xeb, 0x3b, 0xb0, 0xd2, 0xd4, 0xcf, 0x5a,
        0xb9, 0xd3, 0x6f, 0x06, 0x07, 0xad, 0xd2, 0xe9, 0x37, 0xe5, 0x29, 0xab, 0xac, 0xc0, 0x3f, 0x4a,
        0xc3, 0x66, 0xad, 0xf6, 0x01, 0xe9, 0x87, 0x23, 0x79, 0x00, 0x59, 0x6e, 0xe6, 0xda, 0x18, 0xf8,
        0x3a, 0x61, 0xd6, 0x2b, 0x3b, 0x97, 0xeb, 0x24, 0xa0, 0x60, 0x12, 0x56, 0x46, 0x4f, 0x75, 0xd2,
        0xdc, 0xad, 0x5c, 0xfa, 0x54, 0x87, 0xf9, 0x3a, 0xea, 0x0d, 0xd8, 0x62, 0x73, 0xbc, 0x9e, 0xf1,
        0x45, 0x92, 0x93, 0xe5, 0xd7, 0x86, 0xc0, 0xd7, 0x85, 0x34, 0xe6, 0xeb, 0xc2, 0x02, 0x7a, 0x0f,
        0x56, 0x5b, 0x4e, 0xa7, 0xd3, 0xec, 0xb6, 0xa5, 0xb7, 0xe4, 0xae, 0xb6, 0x20, 0x48, 0xca, 0xd5,
        0x4a, 0x02, 0x26, 0x41, 0xd5, 0xdb, 0xbf, 0xbf, 0x0e, 0x99, 0x42, 0xb9, 0x82, 0x0a, 0xb0, 0xae,
        0x3d, 0xc9, 0x45, 0xdb, 0x2a, 0xf6, 0xf0, 0x57, 0xdb, 0x07, 0xaf, 0x29, 0xc2, 0x84, 0xa7, 0xbb,
        0xf8, 0x06, 0xfa, 0x0e, 0xec, 0x88, 0x70, 0xa3, 0x3d, 0xa0, 0x44, 0xf7, 0x27, 0xbe, 0x4d, 0x95,
        0xd3, 0xa0, 0x63, 0x4f, 0x78, 0xef, 0x8a, 0x6f, 0xa0, 0x63, 0xd8, 0x8e, 0x3c, 0x88, 0x8d, 0x0b,
        0xf9, 0x7a, 0x82, 0x90, 0x89, 0x60, 0x75, 0xd8, 0x2a, 0x51, 0x03, 0x2b, 0x9f, 0x28, 0x83, 0x5a,
        0x84, 0xb3, 0x09, 0xf9, 0x11, 0xec, 0x14, 0xa9, 0x4d, 0x4d, 0x05, 0x5c, 0x08, 0xad, 0x5d, 0x7e,
        0x8e, 0x3c, 0x1c, 0xc7, 0x37, 0xd0, 0xb7, 0x21, 0x27, 0x75, 0x1a, 0x3e, 0xde, 0x30, 0x10, 0x93,
        0xde, 0x92, 0x1e, 0xdc, 0x9f, 0xcc, 0x10, 0x02, 0x97, 0x61, 0xcb, 0x7c, 0xa3, 0x19, 0xd7, 0xe7,
        0x57, 0x23, 0xfa, 0x9c, 0x04, 0x55, 0x83, 0xcd, 0x12, 0xd5, 0x91, 0xee, 0x25, 0xf5, 0xaf, 0x8d,
        0x78, 0x16, 0xf9, 0x9e, 0x41, 0x4e, 0xea, 0x72, 0x76, 0xdc, 0xa9, 0x9a, 0x3c, 0x86, 0x8d, 0x20,
        0x89, 0xe3, 0x49, 0xe0, 0x9d, 0xa4, 0xd7, 0x7a, 0x01, 0xd2, 0xdd, 0xe4, 0xca, 0x10, 0xec, 0x10,
        0x40, 0xbd, 0x09, 0x8c, 0x6b, 0xee, 0xbe, 0xa9, 0xb9, 0x44, 0x88, 0x12, 0x64, 0x4b, 0x34, 0x40,
        0x38, 0x88, 0xf6, 0xa7, 0x8d, 0xea, 0x22, 0x59, 0x4a, 0xb0, 0x21, 0x34, 0x35, 0x03, 0xd6, 0x54,
        0x0d, 0x59, 0xfc, 0xa5, 0x30, 0xb3, 0xb5, 0xc8, 0x83, 0x1e, 0xf4, 0xfa, 0xf4, 0x67, 0x5d, 0x01,
        0xfa, 0xcf, 0x5c, 0xc4, 0x16, 0x76, 0xf5, 0x31, 0xec, 0x25, 0x3d, 0x2d, 0x8b, 0x6b, 0xf2, 0xe7,
        0x23, 0x36, 0x38, 0x1d, 0x96, 0xc2, 0x2e, 0xb3, 0xc4, 0x28, 0xea, 0x57, 0x27, 0xcb, 0xa5, 0xe9,
        0x66, 0x76, 0xe9, 0x7f, 0x05, 0x6e, 0x49, 0xdb, 0x9c, 0xaf, 0xa7, 0x69, 0xb3, 0xf0, 0xf6, 0x1f,
        0xde, 0x82, 0x4c, 0xa1, 0x50, 0x41, 0x1f, 0xc2, 0xba, 0x4c, 0xde, 0x59, 0x4a, 0x8d, 0xee, 0x26,
        0x3e, 0x91, 0x08, 0x10, 0xef, 0x24, 0x3c, 0x85, 0xd1, 0x04, 0x7e, 0x02, 0xd9, 0xf0, 0x45, 0x4d,
        0x0c, 0xc9, 0x48, 0xce, 0x0e, 0xf2, 0xa6, 0xc2, 0x93, 0xd0, 0x8a, 0xb0, 0x56, 0xa2, 0x12, 0x2c,
        0xfa, 0x72, 0x43, 0x43, 0xba, 0x40, 0xa6, 0x47, 0xb0, 0x2e, 0x94, 0x78, 0x21, 0xd0, 0x54, 0xa3,
        0x7d, 0x26, 0x56, 0xa2, 0x48, 0xa5, 0xd1, 0xab, 0xd1, 0xa7, 0x03, 0xe6, 0xe0, 0x22, 0xeb, 0x32,
        0xfe, 0x14, 0x21, 0x5c, 0x97, 0x12, 0xef, 0x20, 0x8a, 0x97, 0xbc, 0x2e, 0x13, 0x81, 0x3e, 0x84,
        0x4d, 0xd6, 0xc9, 0x33, 0xef, 0x6c, 0x36, 0xe1, 0xb4, 0x87, 0xf0, 0xe6, 0x0f, 0x7f, 0xe0, 0x1b,
        0xe8, 0x31, 0x6c, 0x94, 0xa8, 0x06, 0x35, 0x4d, 0xae, 0x69, 0x38, 0x45, 0xc8, 0x0a, 0xc3, 0xa9,
        0x57, 0x0b, 0x06, 0x48, 0xe4, 0x82, 0xaa, 0xae, 0xf3, 0xc8, 0x75, 0x6a, 0x2e, 0xcd, 0xaa, 0xbc,
        0x67, 0x1d, 0xc1, 0x30, 0x07, 0xf4, 0x6a, 0x44, 0xdb, 0x31, 0x9c, 0x6f, 0xc1, 0x0a, 0x53, 0x75,
        0xb5, 0x80, 0xcc, 0xbb, 0xaa, 0xc9, 0x73, 0x1f, 0x6f, 0x7f, 0x08, 0x59, 0x61, 0x42, 0xb3, 0x42,
        0xc4, 0xcd, 0xa7, 0x22, 0xcc, 0xe7, 0xd0, 0xb6, 0x2f, 0x1a, 0xcd, 0x6b, 0x13, 0xdf, 0x16, 0x26,
        0xf9, 0x62, 0x71, 0x23, 0x51, 0x07, 0x8c, 0xde, 0x51, 0x9c, 0x2e, 0x57, 0x11, 0xb2, 0x87, 0xed,
        0xb6, 0xd8, 0xce, 0xa2, 0xd8, 0xfd, 0x3c, 0x75, 0xb3, 0x70, 0xba, 0x82, 0x4a, 0xb0, 0x41, 0x68,
        0xc7, 0x19, 0xd0, 0x49, 0x40, 0xb3, 0xab, 0x69, 0x5b, 0x00, 0x85, 0xd7, 0xd8, 0x74, 0x6b, 0x4e,
        0xb8, 0xdb, 0x36, 0x1d, 0xae, 0xc6, 0x7f, 0xa7, 0xa1, 0xd9, 0xa3, 0xc1, 0x86, 0x5a, 0xcf, 0x69,
        0x12, 0xaf, 0xa2, 0x1c, 0xdc, 0x4b, 0xbe, 0xd3, 0x65, 0xc4, 0x94, 0x0d, 0xfd, 0x82, 0x58, 0x12,
        0xa4, 0x39, 0xa3, 0xd8, 0xb4, 0xcf, 0x09, 0xb0, 0x15, 0x58, 0x2f, 0x51, 0x85, 0x9a, 0x70, 0x5d,
        0x45, 0x83, 0xbc, 0x58, 0xca, 0x63, 0xd8, 0x12, 0x16, 0x32, 0x23, 0xe2, 0x05, 0xd9, 0xe1, 0xb6,
        0xb4, 0xde, 0xd9, 0x47, 0x3d, 0x93, 0x1d, 0xab, 0x4c, 0x56, 0x5d, 0x76, 0x30, 0xf2, 0xce, 0xa4,
        0x3b, 0x10, 0xd3, 0x65, 0x7d, 0x12, 0xb8, 0x1e, 0xb6, 0xed, 0xb9, 0x37, 0xe1, 0x6b, 0x6d, 0x82,
        0xeb, 0x48, 0xb8, 0x72, 0x80, 0x6f, 0xa0, 0xa7, 0xc2, 0x05, 0x25, 0x63, 0x4d, 0x1c, 0xf0, 0x84,
        0x2b, 0x0c, 0xdc, 0xa5, 0x31, 0x57, 0xc4, 0xe0, 0xe2, 0x1f, 0x92, 0x93, 0x5d, 0x5a, 0x32, 0xce,
        0xa3, 0xc0, 0x25, 0x5d, 0x08, 0x35, 0x55, 0x59, 0x1f, 0x85, 0x6e, 0xe9, 0x92, 0x23, 0x9c, 0x3c,
        0xa5, 0xc7, 0x9a, 0x6b, 0x8a, 0x80, 0x26, 0x7d, 0x78, 0x9d, 0x2e, 0xdf, 0x43, 0x58, 0xe5, 0x9f,
        0xc4, 0xea, 0x15, 0x3d, 0x70, 0x47, 0x8e, 0x49, 0xf5, 0x48, 0x64, 0x7e, 0x04, 0xc4, 0x37, 0xd0,
        0x11, 0x64, 0x0b, 0x4e, 0xb7, 0xe7, 0x39, 0x76, 0x14, 0xc3, 0x38, 0x6e, 0x30, 0xa3, 0x99, 0xfe,
        0xdb, 0x53, 0x3c, 0xf6, 0x6f, 0xe8, 0x1f, 0x68, 0x23, 0x30, 0xd3, 0xd6, 0x7a, 0xd2, 0x37, 0x5d,
        0x1e, 0x50, 0xd6, 0x45, 0xec, 0x17, 0x78, 0xc6, 0x11, 0xec, 0xa4, 0x08, 0x1b, 0x91, 0xa9, 0x00,
        0x2b, 0xa2, 0x83, 0x69, 0xd2, 0xdc, 0x8d, 0x4a, 0x13, 0x91, 0xe3, 0x1b, 0xb0, 0xcc, 0xe5, 0x98,
        0x45, 0x82, 0x58, 0xe3, 0x43, 0x58, 0x7f, 0x4e, 0xbd, 0x8e, 0xd5, 0x65, 0x61, 0xbe, 0x32, 0xd7,
        0x20, 0x8e, 0x45, 0xbe, 0xc8, 0xa2, 0xe2, 0xd4, 0x71, 0xcc, 0x18, 0x13, 0xb7, 0x42, 0x79, 0xf8,
        0xd9, 0x96, 0x8e, 0x18, 0x39, 0xec, 0x9a, 0x26, 0xd5, 0xdb, 0x45, 0xc8, 0xd4, 0x6a, 0x1f, 0xa0,
        0x6f, 0xc2, 0x8a, 0x38, 0xc7, 0xd1, 0x43, 0xbe, 0x71, 0xb2, 0x33, 0x2d, 0x05, 0x3a, 0xca, 0xfd,
        0xf4, 0xf3, 0x7b, 0xa9, 0x7f, 0xfd, 0xfc, 0x5e, 0xea, 0xdf, 0x3f, 0xbf, 0x97, 0xfa, 0xa3, 0xff,
        0xb8, 0x77, 0xe3, 0x64, 0x85, 0x5f, 0xd7, 0x7c, 0xe7, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb5,
        0x76, 0xe2, 0xc3, 0xca, 0x4e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CIMClient is the client API for CIM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CIMClient interface {
        ListCloudOS(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudOSInfoResponse, error)
        CreateCloudDriver(ctx context.Context, in *CloudDriverInfoRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error)
        ListCloudDriver(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudDriverInfoResponse, error)
        GetCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error)
        DeleteCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateCredential(ctx context.Context, in *CredentialInfoRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error)
        ListCredential(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCredentialInfoResponse, error)
        GetCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error)
        DeleteCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateRegion(ctx context.Context, in *RegionInfoRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error)
        ListRegion(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListRegionInfoResponse, error)
        GetRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error)
        DeleteRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateConnectionConfig(ctx context.Context, in *ConnectionConfigInfoRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error)
        ListConnectionConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListConnectionConfigInfoResponse, error)
        GetConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error)
        DeleteConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
}

type cIMClient struct {
        cc *grpc.ClientConn
}

func NewCIMClient(cc *grpc.ClientConn) CIMClient <span class="cov8" title="1">{
        return &amp;cIMClient{cc}
}</span>

func (c *cIMClient) ListCloudOS(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudOSInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListCloudOSInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListCloudOS", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateCloudDriver(ctx context.Context, in *CloudDriverInfoRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        out := new(CloudDriverInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListCloudDriver(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCloudDriverInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListCloudDriverInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*CloudDriverInfoResponse, error) <span class="cov8" title="1">{
        out := new(CloudDriverInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteCloudDriver(ctx context.Context, in *CloudDriverQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteCloudDriver", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateCredential(ctx context.Context, in *CredentialInfoRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error) <span class="cov8" title="1">{
        out := new(CredentialInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListCredential(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCredentialInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListCredentialInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*CredentialInfoResponse, error) <span class="cov8" title="1">{
        out := new(CredentialInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteCredential(ctx context.Context, in *CredentialQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteCredential", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateRegion(ctx context.Context, in *RegionInfoRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error) <span class="cov8" title="1">{
        out := new(RegionInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListRegion(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListRegionInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListRegionInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error) <span class="cov8" title="1">{
        out := new(RegionInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteRegion(ctx context.Context, in *RegionQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteRegion", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) CreateConnectionConfig(ctx context.Context, in *ConnectionConfigInfoRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        out := new(ConnectionConfigInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/CreateConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) ListConnectionConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListConnectionConfigInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/ListConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) GetConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*ConnectionConfigInfoResponse, error) <span class="cov8" title="1">{
        out := new(ConnectionConfigInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/GetConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cIMClient) DeleteConnectionConfig(ctx context.Context, in *ConnectionConfigQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CIM/DeleteConnectionConfig", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// CIMServer is the server API for CIM service.
type CIMServer interface {
        ListCloudOS(context.Context, *Empty) (*ListCloudOSInfoResponse, error)
        CreateCloudDriver(context.Context, *CloudDriverInfoRequest) (*CloudDriverInfoResponse, error)
        ListCloudDriver(context.Context, *Empty) (*ListCloudDriverInfoResponse, error)
        GetCloudDriver(context.Context, *CloudDriverQryRequest) (*CloudDriverInfoResponse, error)
        DeleteCloudDriver(context.Context, *CloudDriverQryRequest) (*BooleanResponse, error)
        CreateCredential(context.Context, *CredentialInfoRequest) (*CredentialInfoResponse, error)
        ListCredential(context.Context, *Empty) (*ListCredentialInfoResponse, error)
        GetCredential(context.Context, *CredentialQryRequest) (*CredentialInfoResponse, error)
        DeleteCredential(context.Context, *CredentialQryRequest) (*BooleanResponse, error)
        CreateRegion(context.Context, *RegionInfoRequest) (*RegionInfoResponse, error)
        ListRegion(context.Context, *Empty) (*ListRegionInfoResponse, error)
        GetRegion(context.Context, *RegionQryRequest) (*RegionInfoResponse, error)
        DeleteRegion(context.Context, *RegionQryRequest) (*BooleanResponse, error)
        CreateConnectionConfig(context.Context, *ConnectionConfigInfoRequest) (*ConnectionConfigInfoResponse, error)
        ListConnectionConfig(context.Context, *Empty) (*ListConnectionConfigInfoResponse, error)
        GetConnectionConfig(context.Context, *ConnectionConfigQryRequest) (*ConnectionConfigInfoResponse, error)
        DeleteConnectionConfig(context.Context, *ConnectionConfigQryRequest) (*BooleanResponse, error)
}

// UnimplementedCIMServer can be embedded to have forward compatible implementations.
type UnimplementedCIMServer struct {
}

func (*UnimplementedCIMServer) ListCloudOS(ctx context.Context, req *Empty) (*ListCloudOSInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCloudOS not implemented")
}</span>
func (*UnimplementedCIMServer) CreateCloudDriver(ctx context.Context, req *CloudDriverInfoRequest) (*CloudDriverInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) ListCloudDriver(ctx context.Context, req *Empty) (*ListCloudDriverInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) GetCloudDriver(ctx context.Context, req *CloudDriverQryRequest) (*CloudDriverInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteCloudDriver(ctx context.Context, req *CloudDriverQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCloudDriver not implemented")
}</span>
func (*UnimplementedCIMServer) CreateCredential(ctx context.Context, req *CredentialInfoRequest) (*CredentialInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateCredential not implemented")
}</span>
func (*UnimplementedCIMServer) ListCredential(ctx context.Context, req *Empty) (*ListCredentialInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCredential not implemented")
}</span>
func (*UnimplementedCIMServer) GetCredential(ctx context.Context, req *CredentialQryRequest) (*CredentialInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCredential not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteCredential(ctx context.Context, req *CredentialQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCredential not implemented")
}</span>
func (*UnimplementedCIMServer) CreateRegion(ctx context.Context, req *RegionInfoRequest) (*RegionInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateRegion not implemented")
}</span>
func (*UnimplementedCIMServer) ListRegion(ctx context.Context, req *Empty) (*ListRegionInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListRegion not implemented")
}</span>
func (*UnimplementedCIMServer) GetRegion(ctx context.Context, req *RegionQryRequest) (*RegionInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetRegion not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteRegion(ctx context.Context, req *RegionQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteRegion not implemented")
}</span>
func (*UnimplementedCIMServer) CreateConnectionConfig(ctx context.Context, req *ConnectionConfigInfoRequest) (*ConnectionConfigInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateConnectionConfig not implemented")
}</span>
func (*UnimplementedCIMServer) ListConnectionConfig(ctx context.Context, req *Empty) (*ListConnectionConfigInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListConnectionConfig not implemented")
}</span>
func (*UnimplementedCIMServer) GetConnectionConfig(ctx context.Context, req *ConnectionConfigQryRequest) (*ConnectionConfigInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetConnectionConfig not implemented")
}</span>
func (*UnimplementedCIMServer) DeleteConnectionConfig(ctx context.Context, req *ConnectionConfigQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteConnectionConfig not implemented")
}</span>

func RegisterCIMServer(s *grpc.Server, srv CIMServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_CIM_serviceDesc, srv)
}</span>

func _CIM_ListCloudOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListCloudOS(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListCloudOS",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListCloudOS(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CloudDriverInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateCloudDriver(ctx, req.(*CloudDriverInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListCloudDriver(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CloudDriverQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetCloudDriver(ctx, req.(*CloudDriverQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteCloudDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CloudDriverQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteCloudDriver(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteCloudDriver",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteCloudDriver(ctx, req.(*CloudDriverQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CredentialInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateCredential(ctx, req.(*CredentialInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListCredential(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CredentialQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetCredential(ctx, req.(*CredentialQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CredentialQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteCredential(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteCredential",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteCredential(ctx, req.(*CredentialQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RegionInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateRegion(ctx, req.(*RegionInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListRegion(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RegionQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetRegion(ctx, req.(*RegionQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RegionQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteRegion(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteRegion",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteRegion(ctx, req.(*RegionQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_CreateConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ConnectionConfigInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).CreateConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/CreateConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).CreateConnectionConfig(ctx, req.(*ConnectionConfigInfoRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_ListConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).ListConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/ListConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).ListConnectionConfig(ctx, req.(*Empty))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_GetConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ConnectionConfigQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).GetConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/GetConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).GetConnectionConfig(ctx, req.(*ConnectionConfigQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CIM_DeleteConnectionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ConnectionConfigQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CIMServer).DeleteConnectionConfig(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CIM/DeleteConnectionConfig",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CIMServer).DeleteConnectionConfig(ctx, req.(*ConnectionConfigQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

var _CIM_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cbspider.CIM",
        HandlerType: (*CIMServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "ListCloudOS",
                        Handler:    _CIM_ListCloudOS_Handler,
                },
                {
                        MethodName: "CreateCloudDriver",
                        Handler:    _CIM_CreateCloudDriver_Handler,
                },
                {
                        MethodName: "ListCloudDriver",
                        Handler:    _CIM_ListCloudDriver_Handler,
                },
                {
                        MethodName: "GetCloudDriver",
                        Handler:    _CIM_GetCloudDriver_Handler,
                },
                {
                        MethodName: "DeleteCloudDriver",
                        Handler:    _CIM_DeleteCloudDriver_Handler,
                },
                {
                        MethodName: "CreateCredential",
                        Handler:    _CIM_CreateCredential_Handler,
                },
                {
                        MethodName: "ListCredential",
                        Handler:    _CIM_ListCredential_Handler,
                },
                {
                        MethodName: "GetCredential",
                        Handler:    _CIM_GetCredential_Handler,
                },
                {
                        MethodName: "DeleteCredential",
                        Handler:    _CIM_DeleteCredential_Handler,
                },
                {
                        MethodName: "CreateRegion",
                        Handler:    _CIM_CreateRegion_Handler,
                },
                {
                        MethodName: "ListRegion",
                        Handler:    _CIM_ListRegion_Handler,
                },
                {
                        MethodName: "GetRegion",
                        Handler:    _CIM_GetRegion_Handler,
                },
                {
                        MethodName: "DeleteRegion",
                        Handler:    _CIM_DeleteRegion_Handler,
                },
                {
                        MethodName: "CreateConnectionConfig",
                        Handler:    _CIM_CreateConnectionConfig_Handler,
                },
                {
                        MethodName: "ListConnectionConfig",
                        Handler:    _CIM_ListConnectionConfig_Handler,
                },
                {
                        MethodName: "GetConnectionConfig",
                        Handler:    _CIM_GetConnectionConfig_Handler,
                },
                {
                        MethodName: "DeleteConnectionConfig",
                        Handler:    _CIM_DeleteConnectionConfig_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cbspider.proto",
}

// CCMClient is the client API for CCM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CCMClient interface {
        CreateImage(ctx context.Context, in *ImageCreateRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error)
        ListImage(ctx context.Context, in *ImageAllQryRequest, opts ...grpc.CallOption) (*ListImageInfoResponse, error)
        GetImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error)
        DeleteImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*ListVMSpecInfoResponse, error)
        GetVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*VMSpecInfoResponse, error)
        ListOrgVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*StringResponse, error)
        GetOrgVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*StringResponse, error)
        CreateVPC(ctx context.Context, in *VPCCreateRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error)
        ListVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*ListVPCInfoResponse, error)
        GetVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error)
        DeleteVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListAllVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        DeleteCSPVPC(ctx context.Context, in *CSPVPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        AddSubnet(ctx context.Context, in *SubnetAddRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error)
        RemoveSubnet(ctx context.Context, in *SubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        RemoveCSPSubnet(ctx context.Context, in *CSPSubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateSecurity(ctx context.Context, in *SecurityCreateRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error)
        ListSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*ListSecurityInfoResponse, error)
        GetSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error)
        DeleteSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListAllSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        DeleteCSPSecurity(ctx context.Context, in *CSPSecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        CreateKey(ctx context.Context, in *KeyPairCreateRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error)
        ListKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*ListKeyPairInfoResponse, error)
        GetKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error)
        DeleteKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        ListAllKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        DeleteCSPKey(ctx context.Context, in *CSPKeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
        StartVM(ctx context.Context, in *VMCreateRequest, opts ...grpc.CallOption) (*VMInfoResponse, error)
        ControlVM(ctx context.Context, in *VMActionRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        ListVMStatus(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMStatusInfoResponse, error)
        GetVMStatus(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        ListVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMInfoResponse, error)
        GetVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*VMInfoResponse, error)
        TerminateVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        ListAllVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error)
        TerminateCSPVM(ctx context.Context, in *CSPVMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type cCMClient struct {
        cc *grpc.ClientConn
}

func NewCCMClient(cc *grpc.ClientConn) CCMClient <span class="cov8" title="1">{
        return &amp;cCMClient{cc}
}</span>

func (c *cCMClient) CreateImage(ctx context.Context, in *ImageCreateRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error) <span class="cov8" title="1">{
        out := new(ImageInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListImage(ctx context.Context, in *ImageAllQryRequest, opts ...grpc.CallOption) (*ListImageInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListImageInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*ImageInfoResponse, error) <span class="cov8" title="1">{
        out := new(ImageInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteImage(ctx context.Context, in *ImageQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteImage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*ListVMSpecInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVMSpecInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*VMSpecInfoResponse, error) <span class="cov8" title="1">{
        out := new(VMSpecInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListOrgVMSpec(ctx context.Context, in *VMSpecAllQryRequest, opts ...grpc.CallOption) (*StringResponse, error) <span class="cov8" title="1">{
        out := new(StringResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListOrgVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetOrgVMSpec(ctx context.Context, in *VMSpecQryRequest, opts ...grpc.CallOption) (*StringResponse, error) <span class="cov8" title="1">{
        out := new(StringResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetOrgVMSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) CreateVPC(ctx context.Context, in *VPCCreateRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(VPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*ListVPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(VPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteVPC(ctx context.Context, in *VPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllVPC(ctx context.Context, in *VPCAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteCSPVPC(ctx context.Context, in *CSPVPCQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteCSPVPC", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) AddSubnet(ctx context.Context, in *SubnetAddRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error) <span class="cov8" title="1">{
        out := new(VPCInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/AddSubnet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) RemoveSubnet(ctx context.Context, in *SubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/RemoveSubnet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) RemoveCSPSubnet(ctx context.Context, in *CSPSubnetQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/RemoveCSPSubnet", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) CreateSecurity(ctx context.Context, in *SecurityCreateRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error) <span class="cov8" title="1">{
        out := new(SecurityInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*ListSecurityInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListSecurityInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*SecurityInfoResponse, error) <span class="cov8" title="1">{
        out := new(SecurityInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteSecurity(ctx context.Context, in *SecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllSecurity(ctx context.Context, in *SecurityAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteCSPSecurity(ctx context.Context, in *CSPSecurityQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteCSPSecurity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) CreateKey(ctx context.Context, in *KeyPairCreateRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error) <span class="cov8" title="1">{
        out := new(KeyPairInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/CreateKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*ListKeyPairInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListKeyPairInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*KeyPairInfoResponse, error) <span class="cov8" title="1">{
        out := new(KeyPairInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteKey(ctx context.Context, in *KeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllKey(ctx context.Context, in *KeyPairAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) DeleteCSPKey(ctx context.Context, in *CSPKeyPairQryRequest, opts ...grpc.CallOption) (*BooleanResponse, error) <span class="cov8" title="1">{
        out := new(BooleanResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/DeleteCSPKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) StartVM(ctx context.Context, in *VMCreateRequest, opts ...grpc.CallOption) (*VMInfoResponse, error) <span class="cov8" title="1">{
        out := new(VMInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/StartVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ControlVM(ctx context.Context, in *VMActionRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ControlVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVMStatus(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMStatusInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVMStatusInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVMStatus", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVMStatus(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVMStatus", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*ListVMInfoResponse, error) <span class="cov8" title="1">{
        out := new(ListVMInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) GetVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*VMInfoResponse, error) <span class="cov8" title="1">{
        out := new(VMInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/GetVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) TerminateVM(ctx context.Context, in *VMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/TerminateVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) ListAllVM(ctx context.Context, in *VMAllQryRequest, opts ...grpc.CallOption) (*AllResourceInfoResponse, error) <span class="cov8" title="1">{
        out := new(AllResourceInfoResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/ListAllVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *cCMClient) TerminateCSPVM(ctx context.Context, in *CSPVMQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov8" title="1">{
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, "/cbspider.CCM/TerminateCSPVM", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// CCMServer is the server API for CCM service.
type CCMServer interface {
        CreateImage(context.Context, *ImageCreateRequest) (*ImageInfoResponse, error)
        ListImage(context.Context, *ImageAllQryRequest) (*ListImageInfoResponse, error)
        GetImage(context.Context, *ImageQryRequest) (*ImageInfoResponse, error)
        DeleteImage(context.Context, *ImageQryRequest) (*BooleanResponse, error)
        ListVMSpec(context.Context, *VMSpecAllQryRequest) (*ListVMSpecInfoResponse, error)
        GetVMSpec(context.Context, *VMSpecQryRequest) (*VMSpecInfoResponse, error)
        ListOrgVMSpec(context.Context, *VMSpecAllQryRequest) (*StringResponse, error)
        GetOrgVMSpec(context.Context, *VMSpecQryRequest) (*StringResponse, error)
        CreateVPC(context.Context, *VPCCreateRequest) (*VPCInfoResponse, error)
        ListVPC(context.Context, *VPCAllQryRequest) (*ListVPCInfoResponse, error)
        GetVPC(context.Context, *VPCQryRequest) (*VPCInfoResponse, error)
        DeleteVPC(context.Context, *VPCQryRequest) (*BooleanResponse, error)
        ListAllVPC(context.Context, *VPCAllQryRequest) (*AllResourceInfoResponse, error)
        DeleteCSPVPC(context.Context, *CSPVPCQryRequest) (*BooleanResponse, error)
        AddSubnet(context.Context, *SubnetAddRequest) (*VPCInfoResponse, error)
        RemoveSubnet(context.Context, *SubnetQryRequest) (*BooleanResponse, error)
        RemoveCSPSubnet(context.Context, *CSPSubnetQryRequest) (*BooleanResponse, error)
        CreateSecurity(context.Context, *SecurityCreateRequest) (*SecurityInfoResponse, error)
        ListSecurity(context.Context, *SecurityAllQryRequest) (*ListSecurityInfoResponse, error)
        GetSecurity(context.Context, *SecurityQryRequest) (*SecurityInfoResponse, error)
        DeleteSecurity(context.Context, *SecurityQryRequest) (*BooleanResponse, error)
        ListAllSecurity(context.Context, *SecurityAllQryRequest) (*AllResourceInfoResponse, error)
        DeleteCSPSecurity(context.Context, *CSPSecurityQryRequest) (*BooleanResponse, error)
        CreateKey(context.Context, *KeyPairCreateRequest) (*KeyPairInfoResponse, error)
        ListKey(context.Context, *KeyPairAllQryRequest) (*ListKeyPairInfoResponse, error)
        GetKey(context.Context, *KeyPairQryRequest) (*KeyPairInfoResponse, error)
        DeleteKey(context.Context, *KeyPairQryRequest) (*BooleanResponse, error)
        ListAllKey(context.Context, *KeyPairAllQryRequest) (*AllResourceInfoResponse, error)
        DeleteCSPKey(context.Context, *CSPKeyPairQryRequest) (*BooleanResponse, error)
        StartVM(context.Context, *VMCreateRequest) (*VMInfoResponse, error)
        ControlVM(context.Context, *VMActionRequest) (*StatusResponse, error)
        ListVMStatus(context.Context, *VMAllQryRequest) (*ListVMStatusInfoResponse, error)
        GetVMStatus(context.Context, *VMQryRequest) (*StatusResponse, error)
        ListVM(context.Context, *VMAllQryRequest) (*ListVMInfoResponse, error)
        GetVM(context.Context, *VMQryRequest) (*VMInfoResponse, error)
        TerminateVM(context.Context, *VMQryRequest) (*StatusResponse, error)
        ListAllVM(context.Context, *VMAllQryRequest) (*AllResourceInfoResponse, error)
        TerminateCSPVM(context.Context, *CSPVMQryRequest) (*StatusResponse, error)
}

// UnimplementedCCMServer can be embedded to have forward compatible implementations.
type UnimplementedCCMServer struct {
}

func (*UnimplementedCCMServer) CreateImage(ctx context.Context, req *ImageCreateRequest) (*ImageInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateImage not implemented")
}</span>
func (*UnimplementedCCMServer) ListImage(ctx context.Context, req *ImageAllQryRequest) (*ListImageInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListImage not implemented")
}</span>
func (*UnimplementedCCMServer) GetImage(ctx context.Context, req *ImageQryRequest) (*ImageInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetImage not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteImage(ctx context.Context, req *ImageQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}</span>
func (*UnimplementedCCMServer) ListVMSpec(ctx context.Context, req *VMSpecAllQryRequest) (*ListVMSpecInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) GetVMSpec(ctx context.Context, req *VMSpecQryRequest) (*VMSpecInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) ListOrgVMSpec(ctx context.Context, req *VMSpecAllQryRequest) (*StringResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListOrgVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) GetOrgVMSpec(ctx context.Context, req *VMSpecQryRequest) (*StringResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOrgVMSpec not implemented")
}</span>
func (*UnimplementedCCMServer) CreateVPC(ctx context.Context, req *VPCCreateRequest) (*VPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateVPC not implemented")
}</span>
func (*UnimplementedCCMServer) ListVPC(ctx context.Context, req *VPCAllQryRequest) (*ListVPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVPC not implemented")
}</span>
func (*UnimplementedCCMServer) GetVPC(ctx context.Context, req *VPCQryRequest) (*VPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVPC not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteVPC(ctx context.Context, req *VPCQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteVPC not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllVPC(ctx context.Context, req *VPCAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllVPC not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteCSPVPC(ctx context.Context, req *CSPVPCQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCSPVPC not implemented")
}</span>
func (*UnimplementedCCMServer) AddSubnet(ctx context.Context, req *SubnetAddRequest) (*VPCInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddSubnet not implemented")
}</span>
func (*UnimplementedCCMServer) RemoveSubnet(ctx context.Context, req *SubnetQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveSubnet not implemented")
}</span>
func (*UnimplementedCCMServer) RemoveCSPSubnet(ctx context.Context, req *CSPSubnetQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveCSPSubnet not implemented")
}</span>
func (*UnimplementedCCMServer) CreateSecurity(ctx context.Context, req *SecurityCreateRequest) (*SecurityInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) ListSecurity(ctx context.Context, req *SecurityAllQryRequest) (*ListSecurityInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) GetSecurity(ctx context.Context, req *SecurityQryRequest) (*SecurityInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteSecurity(ctx context.Context, req *SecurityQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllSecurity(ctx context.Context, req *SecurityAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteCSPSecurity(ctx context.Context, req *CSPSecurityQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCSPSecurity not implemented")
}</span>
func (*UnimplementedCCMServer) CreateKey(ctx context.Context, req *KeyPairCreateRequest) (*KeyPairInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateKey not implemented")
}</span>
func (*UnimplementedCCMServer) ListKey(ctx context.Context, req *KeyPairAllQryRequest) (*ListKeyPairInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListKey not implemented")
}</span>
func (*UnimplementedCCMServer) GetKey(ctx context.Context, req *KeyPairQryRequest) (*KeyPairInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteKey(ctx context.Context, req *KeyPairQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteKey not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllKey(ctx context.Context, req *KeyPairAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllKey not implemented")
}</span>
func (*UnimplementedCCMServer) DeleteCSPKey(ctx context.Context, req *CSPKeyPairQryRequest) (*BooleanResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteCSPKey not implemented")
}</span>
func (*UnimplementedCCMServer) StartVM(ctx context.Context, req *VMCreateRequest) (*VMInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StartVM not implemented")
}</span>
func (*UnimplementedCCMServer) ControlVM(ctx context.Context, req *VMActionRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ControlVM not implemented")
}</span>
func (*UnimplementedCCMServer) ListVMStatus(ctx context.Context, req *VMAllQryRequest) (*ListVMStatusInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVMStatus not implemented")
}</span>
func (*UnimplementedCCMServer) GetVMStatus(ctx context.Context, req *VMQryRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVMStatus not implemented")
}</span>
func (*UnimplementedCCMServer) ListVM(ctx context.Context, req *VMAllQryRequest) (*ListVMInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVM not implemented")
}</span>
func (*UnimplementedCCMServer) GetVM(ctx context.Context, req *VMQryRequest) (*VMInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVM not implemented")
}</span>
func (*UnimplementedCCMServer) TerminateVM(ctx context.Context, req *VMQryRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TerminateVM not implemented")
}</span>
func (*UnimplementedCCMServer) ListAllVM(ctx context.Context, req *VMAllQryRequest) (*AllResourceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListAllVM not implemented")
}</span>
func (*UnimplementedCCMServer) TerminateCSPVM(ctx context.Context, req *CSPVMQryRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TerminateCSPVM not implemented")
}</span>

func RegisterCCMServer(s *grpc.Server, srv CCMServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_CCM_serviceDesc, srv)
}</span>

func _CCM_CreateImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateImage(ctx, req.(*ImageCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListImage(ctx, req.(*ImageAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetImage(ctx, req.(*ImageQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(ImageQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteImage(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteImage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteImage(ctx, req.(*ImageQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVMSpec(ctx, req.(*VMSpecAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVMSpec(ctx, req.(*VMSpecQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListOrgVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListOrgVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListOrgVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListOrgVMSpec(ctx, req.(*VMSpecAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetOrgVMSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMSpecQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetOrgVMSpec(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetOrgVMSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetOrgVMSpec(ctx, req.(*VMSpecQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_CreateVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateVPC(ctx, req.(*VPCCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVPC(ctx, req.(*VPCAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVPC(ctx, req.(*VPCQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteVPC(ctx, req.(*VPCQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VPCAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllVPC(ctx, req.(*VPCAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteCSPVPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPVPCQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteCSPVPC(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteCSPVPC",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteCSPVPC(ctx, req.(*CSPVPCQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_AddSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SubnetAddRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).AddSubnet(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/AddSubnet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).AddSubnet(ctx, req.(*SubnetAddRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_RemoveSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SubnetQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).RemoveSubnet(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/RemoveSubnet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).RemoveSubnet(ctx, req.(*SubnetQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_RemoveCSPSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPSubnetQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).RemoveCSPSubnet(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/RemoveCSPSubnet",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).RemoveCSPSubnet(ctx, req.(*CSPSubnetQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_CreateSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateSecurity(ctx, req.(*SecurityCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListSecurity(ctx, req.(*SecurityAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetSecurity(ctx, req.(*SecurityQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteSecurity(ctx, req.(*SecurityQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SecurityAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllSecurity(ctx, req.(*SecurityAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteCSPSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPSecurityQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteCSPSecurity(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteCSPSecurity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteCSPSecurity(ctx, req.(*CSPSecurityQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).CreateKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/CreateKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).CreateKey(ctx, req.(*KeyPairCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListKey(ctx, req.(*KeyPairAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetKey(ctx, req.(*KeyPairQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteKey(ctx, req.(*KeyPairQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(KeyPairAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllKey(ctx, req.(*KeyPairAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_DeleteCSPKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPKeyPairQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).DeleteCSPKey(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/DeleteCSPKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).DeleteCSPKey(ctx, req.(*CSPKeyPairQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_StartVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMCreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).StartVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/StartVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).StartVM(ctx, req.(*VMCreateRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ControlVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMActionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ControlVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ControlVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ControlVM(ctx, req.(*VMActionRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVMStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVMStatus(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVMStatus",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVMStatus(ctx, req.(*VMAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVMStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVMStatus(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVMStatus",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVMStatus(ctx, req.(*VMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListVM(ctx, req.(*VMAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).GetVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/GetVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).GetVM(ctx, req.(*VMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_TerminateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).TerminateVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/TerminateVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).TerminateVM(ctx, req.(*VMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_ListAllVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(VMAllQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).ListAllVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/ListAllVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).ListAllVM(ctx, req.(*VMAllQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

func _CCM_TerminateCSPVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(CSPVMQryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CCMServer).TerminateCSPVM(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.CCM/TerminateCSPVM",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(CCMServer).TerminateCSPVM(ctx, req.(*CSPVMQryRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

var _CCM_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cbspider.CCM",
        HandlerType: (*CCMServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateImage",
                        Handler:    _CCM_CreateImage_Handler,
                },
                {
                        MethodName: "ListImage",
                        Handler:    _CCM_ListImage_Handler,
                },
                {
                        MethodName: "GetImage",
                        Handler:    _CCM_GetImage_Handler,
                },
                {
                        MethodName: "DeleteImage",
                        Handler:    _CCM_DeleteImage_Handler,
                },
                {
                        MethodName: "ListVMSpec",
                        Handler:    _CCM_ListVMSpec_Handler,
                },
                {
                        MethodName: "GetVMSpec",
                        Handler:    _CCM_GetVMSpec_Handler,
                },
                {
                        MethodName: "ListOrgVMSpec",
                        Handler:    _CCM_ListOrgVMSpec_Handler,
                },
                {
                        MethodName: "GetOrgVMSpec",
                        Handler:    _CCM_GetOrgVMSpec_Handler,
                },
                {
                        MethodName: "CreateVPC",
                        Handler:    _CCM_CreateVPC_Handler,
                },
                {
                        MethodName: "ListVPC",
                        Handler:    _CCM_ListVPC_Handler,
                },
                {
                        MethodName: "GetVPC",
                        Handler:    _CCM_GetVPC_Handler,
                },
                {
                        MethodName: "DeleteVPC",
                        Handler:    _CCM_DeleteVPC_Handler,
                },
                {
                        MethodName: "ListAllVPC",
                        Handler:    _CCM_ListAllVPC_Handler,
                },
                {
                        MethodName: "DeleteCSPVPC",
                        Handler:    _CCM_DeleteCSPVPC_Handler,
                },
                {
                        MethodName: "AddSubnet",
                        Handler:    _CCM_AddSubnet_Handler,
                },
                {
                        MethodName: "RemoveSubnet",
                        Handler:    _CCM_RemoveSubnet_Handler,
                },
                {
                        MethodName: "RemoveCSPSubnet",
                        Handler:    _CCM_RemoveCSPSubnet_Handler,
                },
                {
                        MethodName: "CreateSecurity",
                        Handler:    _CCM_CreateSecurity_Handler,
                },
                {
                        MethodName: "ListSecurity",
                        Handler:    _CCM_ListSecurity_Handler,
                },
                {
                        MethodName: "GetSecurity",
                        Handler:    _CCM_GetSecurity_Handler,
                },
                {
                        MethodName: "DeleteSecurity",
                        Handler:    _CCM_DeleteSecurity_Handler,
                },
                {
                        MethodName: "ListAllSecurity",
                        Handler:    _CCM_ListAllSecurity_Handler,
                },
                {
                        MethodName: "DeleteCSPSecurity",
                        Handler:    _CCM_DeleteCSPSecurity_Handler,
                },
                {
                        MethodName: "CreateKey",
                        Handler:    _CCM_CreateKey_Handler,
                },
                {
                        MethodName: "ListKey",
                        Handler:    _CCM_ListKey_Handler,
                },
                {
                        MethodName: "GetKey",
                        Handler:    _CCM_GetKey_Handler,
                },
                {
                        MethodName: "DeleteKey",
                        Handler:    _CCM_DeleteKey_Handler,
                },
                {
                        MethodName: "ListAllKey",
                        Handler:    _CCM_ListAllKey_Handler,
                },
                {
                        MethodName: "DeleteCSPKey",
                        Handler:    _CCM_DeleteCSPKey_Handler,
                },
                {
                        MethodName: "StartVM",
                        Handler:    _CCM_StartVM_Handler,
                },
                {
                        MethodName: "ControlVM",
                        Handler:    _CCM_ControlVM_Handler,
                },
                {
                        MethodName: "ListVMStatus",
                        Handler:    _CCM_ListVMStatus_Handler,
                },
                {
                        MethodName: "GetVMStatus",
                        Handler:    _CCM_GetVMStatus_Handler,
                },
                {
                        MethodName: "ListVM",
                        Handler:    _CCM_ListVM_Handler,
                },
                {
                        MethodName: "GetVM",
                        Handler:    _CCM_GetVM_Handler,
                },
                {
                        MethodName: "TerminateVM",
                        Handler:    _CCM_TerminateVM_Handler,
                },
                {
                        MethodName: "ListAllVM",
                        Handler:    _CCM_ListAllVM_Handler,
                },
                {
                        MethodName: "TerminateCSPVM",
                        Handler:    _CCM_TerminateCSPVM_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cbspider.proto",
}

// SSHClient is the client API for SSH service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SSHClient interface {
        SSHRun(ctx context.Context, in *SSHRunRequest, opts ...grpc.CallOption) (*StringResponse, error)
}

type sSHClient struct {
        cc *grpc.ClientConn
}

func NewSSHClient(cc *grpc.ClientConn) SSHClient <span class="cov8" title="1">{
        return &amp;sSHClient{cc}
}</span>

func (c *sSHClient) SSHRun(ctx context.Context, in *SSHRunRequest, opts ...grpc.CallOption) (*StringResponse, error) <span class="cov8" title="1">{
        out := new(StringResponse)
        err := c.cc.Invoke(ctx, "/cbspider.SSH/SSHRun", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SSHServer is the server API for SSH service.
type SSHServer interface {
        SSHRun(context.Context, *SSHRunRequest) (*StringResponse, error)
}

// UnimplementedSSHServer can be embedded to have forward compatible implementations.
type UnimplementedSSHServer struct {
}

func (*UnimplementedSSHServer) SSHRun(ctx context.Context, req *SSHRunRequest) (*StringResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SSHRun not implemented")
}</span>

func RegisterSSHServer(s *grpc.Server, srv SSHServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_SSH_serviceDesc, srv)
}</span>

func _SSH_SSHRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(SSHRunRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SSHServer).SSHRun(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cbspider.SSH/SSHRun",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(SSHServer).SSHRun(ctx, req.(*SSHRunRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

var _SSH_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cbspider.SSH",
        HandlerType: (*SSHServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "SSHRun",
                        Handler:    _SSH_SSHRun_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cbspider.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Value) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Value)
                copy(dAtA[i:], m.Value)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Value)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Key) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Key)
                copy(dAtA[i:], m.Key)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Key)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *IID) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *IID) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *IID) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.SystemId) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SystemId)
                copy(dAtA[i:], m.SystemId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SystemId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.NameId) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.NameId)
                copy(dAtA[i:], m.NameId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.NameId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *BooleanResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *BooleanResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *BooleanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Result </span><span class="cov8" title="1">{
                i--
                if m.Result </span><span class="cov8" title="1">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov8" title="1">i--
                dAtA[i] = 0x8</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *StringResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *StringResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *StringResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Result) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Result)
                copy(dAtA[i:], m.Result)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Result)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *MessageResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MessageResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov0" title="0">if len(m.Message) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Message)
                copy(dAtA[i:], m.Message)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Message)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *StatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Status) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Status)
                copy(dAtA[i:], m.Status)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Status)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListCloudOSInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListCloudOSInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListCloudOSInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        i -= len(m.Items[iNdEx])
                        copy(dAtA[i:], m.Items[iNdEx])
                        i = encodeVarintCbspider(dAtA, i, uint64(len(m.Items[iNdEx])))
                        i--
                        dAtA[i] = 0xa
                }</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CloudDriverInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CloudDriverInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListCloudDriverInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListCloudDriverInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListCloudDriverInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CloudDriverInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.DriverLibFileName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverLibFileName)
                copy(dAtA[i:], m.DriverLibFileName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverLibFileName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.DriverName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverName)
                copy(dAtA[i:], m.DriverName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CloudDriverQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CloudDriverQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CloudDriverQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.DriverName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverName)
                copy(dAtA[i:], m.DriverName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CredentialInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CredentialInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListCredentialInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListCredentialInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListCredentialInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CredentialInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.KeyValueInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.KeyValueInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.CredentialName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.CredentialName)
                copy(dAtA[i:], m.CredentialName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.CredentialName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CredentialQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CredentialQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CredentialQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.CredentialName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.CredentialName)
                copy(dAtA[i:], m.CredentialName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.CredentialName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *RegionInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *RegionInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListRegionInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListRegionInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListRegionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *RegionInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.KeyValueInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.KeyValueInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.RegionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.RegionName)
                copy(dAtA[i:], m.RegionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.RegionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *RegionQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *RegionQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegionQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.RegionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.RegionName)
                copy(dAtA[i:], m.RegionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.RegionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigInfoRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigInfoRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListConnectionConfigInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListConnectionConfigInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListConnectionConfigInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.RegionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.RegionName)
                copy(dAtA[i:], m.RegionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.RegionName)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if len(m.CredentialName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.CredentialName)
                copy(dAtA[i:], m.CredentialName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.CredentialName)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.DriverName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.DriverName)
                copy(dAtA[i:], m.DriverName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.DriverName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ProviderName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ProviderName)
                copy(dAtA[i:], m.ProviderName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ProviderName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConfigName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConfigName)
                copy(dAtA[i:], m.ConfigName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConfigName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ConnectionConfigQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ConnectionConfigQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ConnectionConfigQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConfigName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConfigName)
                copy(dAtA[i:], m.ConfigName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConfigName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *AllResourceInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *AllResourceInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AllResourceInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *AllResourceInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AllResourceInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AllResourceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.OnlyCspList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.OnlyCspList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.OnlyCspList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.OnlySpiderList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.OnlySpiderList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.OnlySpiderList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x12</span>
                }
        }
        <span class="cov8" title="1">if len(m.MappedList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.MappedList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.MappedList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListImageInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListImageInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListImageInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ImageInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.Status) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Status)
                copy(dAtA[i:], m.Status)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Status)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.GuestOs) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.GuestOs)
                copy(dAtA[i:], m.GuestOs)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.GuestOs)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ImageCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ImageQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ImageQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ImageQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMSpecInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVMSpecInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVMSpecInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVMSpecInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMSpecInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x32</span>
                }
        }
        <span class="cov8" title="1">if len(m.Gpu) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Gpu) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Gpu[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x2a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Mem) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Mem)
                copy(dAtA[i:], m.Mem)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Mem)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if m.VCpu != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.VCpu.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Region) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Region)
                copy(dAtA[i:], m.Region)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Region)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VCpuInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VCpuInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VCpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Clock) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Clock)
                copy(dAtA[i:], m.Clock)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Clock)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Count) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Count)
                copy(dAtA[i:], m.Count)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Count)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *GpuInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GpuInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Mem) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Mem)
                copy(dAtA[i:], m.Mem)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Mem)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.Model) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Model)
                copy(dAtA[i:], m.Model)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Model)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Mfr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Mfr)
                copy(dAtA[i:], m.Mfr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Mfr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Count) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Count)
                copy(dAtA[i:], m.Count)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Count)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMSpecAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMSpecQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMSpecQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMSpecQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVPCInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVPCInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVPCInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VPCInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SubnetInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SubnetInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SubnetInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VPCCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SubnetInfoList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SubnetInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SubnetCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Ipv4Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Ipv4Cidr)
                copy(dAtA[i:], m.Ipv4Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Ipv4Cidr)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VPCQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VPCQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VPCQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPVPCQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPVPCQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPVPCQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetAddRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SubnetAddRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetAddRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SubnetQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SubnetQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SubnetQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.SubnetName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SubnetName)
                copy(dAtA[i:], m.SubnetName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SubnetName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPSubnetQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPSubnetQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPSubnetQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListSecurityInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListSecurityInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListSecurityInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SecurityInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x2a</span>
                }
        }
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityRules) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SecurityRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.Direction) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Direction)
                copy(dAtA[i:], m.Direction)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Direction)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.VpcIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityRuleInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SecurityRuleInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityRuleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Cidr) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Cidr)
                copy(dAtA[i:], m.Cidr)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Cidr)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if len(m.Direction) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Direction)
                copy(dAtA[i:], m.Direction)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Direction)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.IpProtocol) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.IpProtocol)
                copy(dAtA[i:], m.IpProtocol)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.IpProtocol)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ToPort) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ToPort)
                copy(dAtA[i:], m.ToPort)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ToPort)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.FromPort) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.FromPort)
                copy(dAtA[i:], m.FromPort)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.FromPort)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *SecurityCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityRules) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SecurityRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov8" title="1">if len(m.Direction) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Direction)
                copy(dAtA[i:], m.Direction)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Direction)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SecurityQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SecurityQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SecurityQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPSecurityQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPSecurityQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPSecurityQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListKeyPairInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListKeyPairInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListKeyPairInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyPairInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x32</span>
                }
        }
        <span class="cov8" title="1">if len(m.VmUserId) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmUserId)
                copy(dAtA[i:], m.VmUserId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserId)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if len(m.PrivateKey) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PrivateKey)
                copy(dAtA[i:], m.PrivateKey)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateKey)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.PublicKey) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PublicKey)
                copy(dAtA[i:], m.PublicKey)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PublicKey)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Fingerprint) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Fingerprint)
                copy(dAtA[i:], m.Fingerprint)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Fingerprint)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *KeyPairCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *KeyPairQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *KeyPairQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *KeyPairQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPKeyPairQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPKeyPairQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPKeyPairQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVMStatusInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVMStatusInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVMStatusInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMStatusInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMStatusInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMStatusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.VmStatus) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmStatus)
                copy(dAtA[i:], m.VmStatus)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmStatus)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *ListVMInfoResponse) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *ListVMInfoResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListVMInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.Items) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.KeyValueList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.KeyValueList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1
                        i--
                        dAtA[i] = 0xa2</span>
                }
        }
        <span class="cov8" title="1">if len(m.SshAccessPoint) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SshAccessPoint)
                copy(dAtA[i:], m.SshAccessPoint)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SshAccessPoint)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x9a
        }</span>
        <span class="cov8" title="1">if len(m.VmBlockDisk) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmBlockDisk)
                copy(dAtA[i:], m.VmBlockDisk)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmBlockDisk)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x92
        }</span>
        <span class="cov8" title="1">if len(m.VmBootDisk) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmBootDisk)
                copy(dAtA[i:], m.VmBootDisk)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmBootDisk)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x8a
        }</span>
        <span class="cov8" title="1">if len(m.PrivateDns) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PrivateDns)
                copy(dAtA[i:], m.PrivateDns)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateDns)))
                i--
                dAtA[i] = 0x1
                i--
                dAtA[i] = 0x82
        }</span>
        <span class="cov8" title="1">if len(m.PrivateIp) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PrivateIp)
                copy(dAtA[i:], m.PrivateIp)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateIp)))
                i--
                dAtA[i] = 0x7a
        }</span>
        <span class="cov8" title="1">if len(m.PublicDns) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PublicDns)
                copy(dAtA[i:], m.PublicDns)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PublicDns)))
                i--
                dAtA[i] = 0x72
        }</span>
        <span class="cov8" title="1">if len(m.PublicIp) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.PublicIp)
                copy(dAtA[i:], m.PublicIp)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.PublicIp)))
                i--
                dAtA[i] = 0x6a
        }</span>
        <span class="cov8" title="1">if len(m.NetworkInterface) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.NetworkInterface)
                copy(dAtA[i:], m.NetworkInterface)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.NetworkInterface)))
                i--
                dAtA[i] = 0x62
        }</span>
        <span class="cov8" title="1">if len(m.VmUserPasswd) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserPasswd)
                copy(dAtA[i:], m.VmUserPasswd)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserPasswd)))
                i--
                dAtA[i] = 0x5a
        }</span>
        <span class="cov8" title="1">if len(m.VmUserId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserId)
                copy(dAtA[i:], m.VmUserId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserId)))
                i--
                dAtA[i] = 0x52
        }</span>
        <span class="cov8" title="1">if m.KeyPairIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.KeyPairIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x4a</span>
        }
        <span class="cov8" title="1">if len(m.SecurityGroupIids) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityGroupIids) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                size, err := m.SecurityGroupIids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov8" title="1">i -= size
                                i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov8" title="1">i--
                        dAtA[i] = 0x42</span>
                }
        }
        <span class="cov8" title="1">if m.SubnetIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.SubnetIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x3a</span>
        }
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.VpcIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x32</span>
        }
        <span class="cov8" title="1">if len(m.VmSpecName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmSpecName)
                copy(dAtA[i:], m.VmSpecName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmSpecName)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov8" title="1">if m.ImageIid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.ImageIid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x22</span>
        }
        <span class="cov8" title="1">if m.Region != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov8" title="1">if len(m.StartTime) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.StartTime)
                copy(dAtA[i:], m.StartTime)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.StartTime)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Iid != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Iid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMRegionInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMRegionInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMRegionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Zone) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Zone)
                copy(dAtA[i:], m.Zone)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Zone)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Region) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Region)
                copy(dAtA[i:], m.Region)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Region)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMCreateRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMCreateRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintCbspider(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMCreateInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VMCreateInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.VmUserPasswd) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserPasswd)
                copy(dAtA[i:], m.VmUserPasswd)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserPasswd)))
                i--
                dAtA[i] = 0x4a
        }</span>
        <span class="cov8" title="1">if len(m.VmUserId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.VmUserId)
                copy(dAtA[i:], m.VmUserId)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmUserId)))
                i--
                dAtA[i] = 0x42
        }</span>
        <span class="cov8" title="1">if len(m.KeyPairName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.KeyPairName)
                copy(dAtA[i:], m.KeyPairName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.KeyPairName)))
                i--
                dAtA[i] = 0x3a
        }</span>
        <span class="cov8" title="1">if len(m.VmSpecName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VmSpecName)
                copy(dAtA[i:], m.VmSpecName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VmSpecName)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov8" title="1">if len(m.SecurityGroupNames) &gt; 0 </span><span class="cov8" title="1">{
                for iNdEx := len(m.SecurityGroupNames) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov8" title="1">{
                        i -= len(m.SecurityGroupNames[iNdEx])
                        copy(dAtA[i:], m.SecurityGroupNames[iNdEx])
                        i = encodeVarintCbspider(dAtA, i, uint64(len(m.SecurityGroupNames[iNdEx])))
                        i--
                        dAtA[i] = 0x2a
                }</span>
        }
        <span class="cov8" title="1">if len(m.SubnetName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.SubnetName)
                copy(dAtA[i:], m.SubnetName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.SubnetName)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.VpcName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.VpcName)
                copy(dAtA[i:], m.VpcName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.VpcName)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.ImageName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ImageName)
                copy(dAtA[i:], m.ImageName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ImageName)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMAllQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMAllQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Force) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Force)
                copy(dAtA[i:], m.Force)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Force)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CSPVMQryRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *CSPVMQryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CSPVMQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Id) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Id)
                copy(dAtA[i:], m.Id)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Id)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *VMActionRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *VMActionRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VMActionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Action) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Action)
                copy(dAtA[i:], m.Action)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Action)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.ConnectionName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ConnectionName)
                copy(dAtA[i:], m.ConnectionName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ConnectionName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *SSHRunRequest) Marshal() (dAtA []byte, err error) <span class="cov8" title="1">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dAtA[:n], nil</span>
}

func (m *SSHRunRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *SSHRunRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Command) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Command)
                copy(dAtA[i:], m.Command)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.Command)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov8" title="1">if len(m.ServerPort) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.ServerPort)
                copy(dAtA[i:], m.ServerPort)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.ServerPort)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov8" title="1">if len(m.PrivateKey) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.PrivateKey) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.PrivateKey[iNdEx])
                        copy(dAtA[i:], m.PrivateKey[iNdEx])
                        i = encodeVarintCbspider(dAtA, i, uint64(len(m.PrivateKey[iNdEx])))
                        i--
                        dAtA[i] = 0x12
                }</span>
        }
        <span class="cov8" title="1">if len(m.UserName) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.UserName)
                copy(dAtA[i:], m.UserName)
                i = encodeVarintCbspider(dAtA, i, uint64(len(m.UserName)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func encodeVarintCbspider(dAtA []byte, offset int, v uint64) int <span class="cov8" title="1">{
        offset -= sovCbspider(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov8" title="1">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov8" title="1">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Empty) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyValue) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Key)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Value)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *IID) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.NameId)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SystemId)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *BooleanResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Result </span><span class="cov8" title="1">{
                n += 2
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *StringResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Result)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *MessageResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Message)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *StatusResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Status)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListCloudOSInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, s := range m.Items </span><span class="cov8" title="1">{
                        l = len(s)
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListCloudDriverInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.DriverName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.DriverLibFileName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CloudDriverQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.DriverName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListCredentialInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.CredentialName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.KeyValueInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CredentialQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.CredentialName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListRegionInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.RegionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.KeyValueInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *RegionQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.RegionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigInfoRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListConnectionConfigInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConfigName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ProviderName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.DriverName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.CredentialName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.RegionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ConnectionConfigQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConfigName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *AllResourceInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *AllResourceInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.MappedList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.MappedList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.OnlySpiderList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.OnlySpiderList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.OnlyCspList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.OnlyCspList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListImageInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.GuestOs)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Status)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ImageQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVMSpecInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Region)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.VCpu != nil </span><span class="cov8" title="1">{
                l = m.VCpu.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Mem)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.Gpu) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Gpu </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VCpuInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Count)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Clock)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *GpuInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Count)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Mfr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Model)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Mem)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMSpecQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVPCInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SubnetInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SubnetInfoList) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SubnetInfoList </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Ipv4Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VPCQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPVPCQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetAddRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SubnetQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SubnetName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPSubnetQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListSecurityInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                l = m.VpcIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Direction)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SecurityRules </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityRuleInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.FromPort)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ToPort)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.IpProtocol)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Direction)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Cidr)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Direction)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityRules) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SecurityRules </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SecurityQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPSecurityQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListKeyPairInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Fingerprint)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PublicKey)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PrivateKey)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserId)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *KeyPairQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPKeyPairQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVMStatusInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMStatusInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmStatus)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *ListVMInfoResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if len(m.Items) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.Items </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Iid != nil </span><span class="cov8" title="1">{
                l = m.Iid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.StartTime)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Region != nil </span><span class="cov8" title="1">{
                l = m.Region.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.ImageIid != nil </span><span class="cov8" title="1">{
                l = m.ImageIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmSpecName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.VpcIid != nil </span><span class="cov8" title="1">{
                l = m.VpcIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.SubnetIid != nil </span><span class="cov8" title="1">{
                l = m.SubnetIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityGroupIids) &gt; 0 </span><span class="cov8" title="1">{
                for _, e := range m.SecurityGroupIids </span><span class="cov8" title="1">{
                        l = e.Size()
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.KeyPairIid != nil </span><span class="cov8" title="1">{
                l = m.KeyPairIid.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserPasswd)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.NetworkInterface)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PublicIp)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PublicDns)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PrivateIp)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.PrivateDns)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmBootDisk)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmBlockDisk)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SshAccessPoint)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 2 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.KeyValueList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.KeyValueList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 2 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMRegionInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Region)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Zone)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMCreateRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Item != nil </span><span class="cov8" title="1">{
                l = m.Item.Size()
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMCreateInfo) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.ImageName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VpcName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.SubnetName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.SecurityGroupNames) &gt; 0 </span><span class="cov8" title="1">{
                for _, s := range m.SecurityGroupNames </span><span class="cov8" title="1">{
                        l = len(s)
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">l = len(m.VmSpecName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.KeyPairName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.VmUserPasswd)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMAllQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Force)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CSPVMQryRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Id)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *VMActionRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.ConnectionName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Name)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Action)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *SSHRunRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.UserName)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if len(m.PrivateKey) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.PrivateKey </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovCbspider(uint64(l))
                }</span>
        }
        <span class="cov8" title="1">l = len(m.ServerPort)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Command)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovCbspider(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func sovCbspider(x uint64) (n int) <span class="cov8" title="1">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozCbspider(x uint64) (n int) <span class="cov0" title="0">{
        return sovCbspider(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Empty) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Empty: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyValue) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Key = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Value = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *IID) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: IID: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: IID: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NameId", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.NameId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SystemId", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SystemId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *BooleanResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BooleanResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BooleanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
                        }</span>
                        <span class="cov8" title="1">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">m.Result = bool(v != 0)</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *StringResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StringResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StringResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Result = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *MessageResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MessageResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Message = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Status = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListCloudOSInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudOSInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudOSInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CloudDriverInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CloudDriverInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListCloudDriverInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudDriverInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCloudDriverInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;CloudDriverInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverLibFileName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverLibFileName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CloudDriverQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CloudDriverQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CredentialInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;CredentialInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListCredentialInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCredentialInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListCredentialInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;CredentialInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.CredentialName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.KeyValueInfoList = append(m.KeyValueInfoList, &amp;KeyValue{})
                        if err := m.KeyValueInfoList[len(m.KeyValueInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CredentialQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CredentialQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.CredentialName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;RegionInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;RegionInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListRegionInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListRegionInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListRegionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;RegionInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.RegionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.KeyValueInfoList = append(m.KeyValueInfoList, &amp;KeyValue{})
                        if err := m.KeyValueInfoList[len(m.KeyValueInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *RegionQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegionQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.RegionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigInfoRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ConnectionConfigInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ConnectionConfigInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListConnectionConfigInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListConnectionConfigInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListConnectionConfigInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;ConnectionConfigInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConfigName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConfigName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ProviderName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DriverName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.DriverName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.CredentialName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.RegionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ConnectionConfigQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ConnectionConfigQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConfigName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConfigName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *AllResourceInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;AllResourceInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *AllResourceInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AllResourceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MappedList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.MappedList = append(m.MappedList, &amp;IID{})
                        if err := m.MappedList[len(m.MappedList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field OnlySpiderList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.OnlySpiderList = append(m.OnlySpiderList, &amp;IID{})
                        if err := m.OnlySpiderList[len(m.OnlySpiderList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field OnlyCspList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.OnlyCspList = append(m.OnlyCspList, &amp;IID{})
                        if err := m.OnlyCspList[len(m.OnlyCspList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ImageInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListImageInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListImageInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListImageInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;ImageInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field GuestOs", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.GuestOs = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Status = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;ImageCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ImageQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ImageQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VMSpecInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVMSpecInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMSpecInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMSpecInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VMSpecInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Region = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VCpu", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.VCpu == nil </span><span class="cov8" title="1">{
                                m.VCpu = &amp;VCpuInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.VCpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Mem", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Mem = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Gpu = append(m.Gpu, &amp;GpuInfo{})
                        if err := m.Gpu[len(m.Gpu)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VCpuInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VCpuInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VCpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Count = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Clock = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *GpuInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GpuInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Count = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Mfr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Mfr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Model = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Mem", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Mem = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMSpecQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMSpecQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VPCInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVPCInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVPCInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVPCInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VPCInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetInfoList = append(m.SubnetInfoList, &amp;SubnetInfo{})
                        if err := m.SubnetInfoList[len(m.SubnetInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VPCCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetInfoList", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetInfoList = append(m.SubnetInfoList, &amp;SubnetCreateInfo{})
                        if err := m.SubnetInfoList[len(m.SubnetInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Ipv4Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VPCQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VPCQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPVPCQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVPCQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVPCQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetAddRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetAddRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetAddRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;SubnetCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SubnetQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SubnetQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPSubnetQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSubnetQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSubnetQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;SecurityInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListSecurityInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListSecurityInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListSecurityInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;SecurityInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.VpcIid == nil </span><span class="cov8" title="1">{
                                m.VpcIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.VpcIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Direction = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityRules", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityRules = append(m.SecurityRules, &amp;SecurityRuleInfo{})
                        if err := m.SecurityRules[len(m.SecurityRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityRuleInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityRuleInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityRuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FromPort", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.FromPort = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ToPort", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ToPort = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.IpProtocol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Direction = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cidr", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Cidr = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;SecurityCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Direction = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityRules", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityRules = append(m.SecurityRules, &amp;SecurityRuleInfo{})
                        if err := m.SecurityRules[len(m.SecurityRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SecurityQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SecurityQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPSecurityQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSecurityQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPSecurityQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;KeyPairInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListKeyPairInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListKeyPairInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListKeyPairInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;KeyPairInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Fingerprint = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PublicKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PrivateKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserId", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmUserId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;KeyPairCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *KeyPairQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: KeyPairQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPKeyPairQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPKeyPairQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPKeyPairQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVMStatusInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMStatusInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMStatusInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VMStatusInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMStatusInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMStatusInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMStatusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmStatus", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmStatus = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VMInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *ListVMInfoResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMInfoResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListVMInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Items = append(m.Items, &amp;VMInfo{})
                        if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Iid == nil </span><span class="cov8" title="1">{
                                m.Iid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Iid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.StartTime = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Region == nil </span><span class="cov8" title="1">{
                                m.Region = &amp;VMRegionInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ImageIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.ImageIid == nil </span><span class="cov8" title="1">{
                                m.ImageIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.ImageIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmSpecName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmSpecName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.VpcIid == nil </span><span class="cov8" title="1">{
                                m.VpcIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.VpcIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 7:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.SubnetIid == nil </span><span class="cov8" title="1">{
                                m.SubnetIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.SubnetIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 8:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupIids", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityGroupIids = append(m.SecurityGroupIids, &amp;IID{})
                        if err := m.SecurityGroupIids[len(m.SecurityGroupIids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 9:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyPairIid", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.KeyPairIid == nil </span><span class="cov8" title="1">{
                                m.KeyPairIid = &amp;IID{}
                        }</span>
                        <span class="cov8" title="1">if err := m.KeyPairIid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 10:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 11:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserPasswd", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserPasswd = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 12:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.NetworkInterface = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 13:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PublicIp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 14:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PublicDns", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PublicDns = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 15:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateIp", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PrivateIp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 16:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateDns", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.PrivateDns = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 17:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmBootDisk", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmBootDisk = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 18:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmBlockDisk", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmBlockDisk = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 19:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SshAccessPoint", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SshAccessPoint = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 20:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyValueList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.KeyValueList = append(m.KeyValueList, &amp;KeyValue{})
                        if err := m.KeyValueList[len(m.KeyValueList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMRegionInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMRegionInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMRegionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Region = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Zone = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMCreateRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Item == nil </span><span class="cov8" title="1">{
                                m.Item = &amp;VMCreateInfo{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMCreateInfo) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateInfo: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ImageName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VpcName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VpcName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SubnetName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupNames", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.SecurityGroupNames = append(m.SecurityGroupNames, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 6:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmSpecName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.VmSpecName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 7:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field KeyPairName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.KeyPairName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 9:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VmUserPasswd", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.VmUserPasswd = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMAllQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMAllQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Force = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CSPVMQryRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVMQryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CSPVMQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Id = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *VMActionRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMActionRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VMActionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ConnectionName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Action = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *SSHRunRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCbspider
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SSHRunRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: SSHRunRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.UserName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PrivateKey = append(m.PrivateKey, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.ServerPort = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCbspider
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Command = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCbspider(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func skipCbspider(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowCbspider
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCbspider
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthCbspider
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupCbspider
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthCbspider
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthCbspider        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowCbspider          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupCbspider = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gogo.proto

package gogoproto

import (
        fmt "fmt"
        descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
        proto "github.com/golang/protobuf/proto"
        math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

var E_GoprotoEnumPrefix = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62001,
        Name:          "gogoproto.goproto_enum_prefix",
        Tag:           "varint,62001,opt,name=goproto_enum_prefix",
        Filename:      "gogo.proto",
}

var E_GoprotoEnumStringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62021,
        Name:          "gogoproto.goproto_enum_stringer",
        Tag:           "varint,62021,opt,name=goproto_enum_stringer",
        Filename:      "gogo.proto",
}

var E_EnumStringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62022,
        Name:          "gogoproto.enum_stringer",
        Tag:           "varint,62022,opt,name=enum_stringer",
        Filename:      "gogo.proto",
}

var E_EnumCustomname = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         62023,
        Name:          "gogoproto.enum_customname",
        Tag:           "bytes,62023,opt,name=enum_customname",
        Filename:      "gogo.proto",
}

var E_Enumdecl = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         62024,
        Name:          "gogoproto.enumdecl",
        Tag:           "varint,62024,opt,name=enumdecl",
        Filename:      "gogo.proto",
}

var E_EnumvalueCustomname = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.EnumValueOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         66001,
        Name:          "gogoproto.enumvalue_customname",
        Tag:           "bytes,66001,opt,name=enumvalue_customname",
        Filename:      "gogo.proto",
}

var E_GoprotoGettersAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63001,
        Name:          "gogoproto.goproto_getters_all",
        Tag:           "varint,63001,opt,name=goproto_getters_all",
        Filename:      "gogo.proto",
}

var E_GoprotoEnumPrefixAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63002,
        Name:          "gogoproto.goproto_enum_prefix_all",
        Tag:           "varint,63002,opt,name=goproto_enum_prefix_all",
        Filename:      "gogo.proto",
}

var E_GoprotoStringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63003,
        Name:          "gogoproto.goproto_stringer_all",
        Tag:           "varint,63003,opt,name=goproto_stringer_all",
        Filename:      "gogo.proto",
}

var E_VerboseEqualAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63004,
        Name:          "gogoproto.verbose_equal_all",
        Tag:           "varint,63004,opt,name=verbose_equal_all",
        Filename:      "gogo.proto",
}

var E_FaceAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63005,
        Name:          "gogoproto.face_all",
        Tag:           "varint,63005,opt,name=face_all",
        Filename:      "gogo.proto",
}

var E_GostringAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63006,
        Name:          "gogoproto.gostring_all",
        Tag:           "varint,63006,opt,name=gostring_all",
        Filename:      "gogo.proto",
}

var E_PopulateAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63007,
        Name:          "gogoproto.populate_all",
        Tag:           "varint,63007,opt,name=populate_all",
        Filename:      "gogo.proto",
}

var E_StringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63008,
        Name:          "gogoproto.stringer_all",
        Tag:           "varint,63008,opt,name=stringer_all",
        Filename:      "gogo.proto",
}

var E_OnlyoneAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63009,
        Name:          "gogoproto.onlyone_all",
        Tag:           "varint,63009,opt,name=onlyone_all",
        Filename:      "gogo.proto",
}

var E_EqualAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63013,
        Name:          "gogoproto.equal_all",
        Tag:           "varint,63013,opt,name=equal_all",
        Filename:      "gogo.proto",
}

var E_DescriptionAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63014,
        Name:          "gogoproto.description_all",
        Tag:           "varint,63014,opt,name=description_all",
        Filename:      "gogo.proto",
}

var E_TestgenAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63015,
        Name:          "gogoproto.testgen_all",
        Tag:           "varint,63015,opt,name=testgen_all",
        Filename:      "gogo.proto",
}

var E_BenchgenAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63016,
        Name:          "gogoproto.benchgen_all",
        Tag:           "varint,63016,opt,name=benchgen_all",
        Filename:      "gogo.proto",
}

var E_MarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63017,
        Name:          "gogoproto.marshaler_all",
        Tag:           "varint,63017,opt,name=marshaler_all",
        Filename:      "gogo.proto",
}

var E_UnmarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63018,
        Name:          "gogoproto.unmarshaler_all",
        Tag:           "varint,63018,opt,name=unmarshaler_all",
        Filename:      "gogo.proto",
}

var E_StableMarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63019,
        Name:          "gogoproto.stable_marshaler_all",
        Tag:           "varint,63019,opt,name=stable_marshaler_all",
        Filename:      "gogo.proto",
}

var E_SizerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63020,
        Name:          "gogoproto.sizer_all",
        Tag:           "varint,63020,opt,name=sizer_all",
        Filename:      "gogo.proto",
}

var E_GoprotoEnumStringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63021,
        Name:          "gogoproto.goproto_enum_stringer_all",
        Tag:           "varint,63021,opt,name=goproto_enum_stringer_all",
        Filename:      "gogo.proto",
}

var E_EnumStringerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63022,
        Name:          "gogoproto.enum_stringer_all",
        Tag:           "varint,63022,opt,name=enum_stringer_all",
        Filename:      "gogo.proto",
}

var E_UnsafeMarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63023,
        Name:          "gogoproto.unsafe_marshaler_all",
        Tag:           "varint,63023,opt,name=unsafe_marshaler_all",
        Filename:      "gogo.proto",
}

var E_UnsafeUnmarshalerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63024,
        Name:          "gogoproto.unsafe_unmarshaler_all",
        Tag:           "varint,63024,opt,name=unsafe_unmarshaler_all",
        Filename:      "gogo.proto",
}

var E_GoprotoExtensionsMapAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63025,
        Name:          "gogoproto.goproto_extensions_map_all",
        Tag:           "varint,63025,opt,name=goproto_extensions_map_all",
        Filename:      "gogo.proto",
}

var E_GoprotoUnrecognizedAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63026,
        Name:          "gogoproto.goproto_unrecognized_all",
        Tag:           "varint,63026,opt,name=goproto_unrecognized_all",
        Filename:      "gogo.proto",
}

var E_GogoprotoImport = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63027,
        Name:          "gogoproto.gogoproto_import",
        Tag:           "varint,63027,opt,name=gogoproto_import",
        Filename:      "gogo.proto",
}

var E_ProtosizerAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63028,
        Name:          "gogoproto.protosizer_all",
        Tag:           "varint,63028,opt,name=protosizer_all",
        Filename:      "gogo.proto",
}

var E_CompareAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63029,
        Name:          "gogoproto.compare_all",
        Tag:           "varint,63029,opt,name=compare_all",
        Filename:      "gogo.proto",
}

var E_TypedeclAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63030,
        Name:          "gogoproto.typedecl_all",
        Tag:           "varint,63030,opt,name=typedecl_all",
        Filename:      "gogo.proto",
}

var E_EnumdeclAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63031,
        Name:          "gogoproto.enumdecl_all",
        Tag:           "varint,63031,opt,name=enumdecl_all",
        Filename:      "gogo.proto",
}

var E_GoprotoRegistration = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63032,
        Name:          "gogoproto.goproto_registration",
        Tag:           "varint,63032,opt,name=goproto_registration",
        Filename:      "gogo.proto",
}

var E_MessagenameAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63033,
        Name:          "gogoproto.messagename_all",
        Tag:           "varint,63033,opt,name=messagename_all",
        Filename:      "gogo.proto",
}

var E_GoprotoSizecacheAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63034,
        Name:          "gogoproto.goproto_sizecache_all",
        Tag:           "varint,63034,opt,name=goproto_sizecache_all",
        Filename:      "gogo.proto",
}

var E_GoprotoUnkeyedAll = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FileOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         63035,
        Name:          "gogoproto.goproto_unkeyed_all",
        Tag:           "varint,63035,opt,name=goproto_unkeyed_all",
        Filename:      "gogo.proto",
}

var E_GoprotoGetters = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64001,
        Name:          "gogoproto.goproto_getters",
        Tag:           "varint,64001,opt,name=goproto_getters",
        Filename:      "gogo.proto",
}

var E_GoprotoStringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64003,
        Name:          "gogoproto.goproto_stringer",
        Tag:           "varint,64003,opt,name=goproto_stringer",
        Filename:      "gogo.proto",
}

var E_VerboseEqual = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64004,
        Name:          "gogoproto.verbose_equal",
        Tag:           "varint,64004,opt,name=verbose_equal",
        Filename:      "gogo.proto",
}

var E_Face = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64005,
        Name:          "gogoproto.face",
        Tag:           "varint,64005,opt,name=face",
        Filename:      "gogo.proto",
}

var E_Gostring = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64006,
        Name:          "gogoproto.gostring",
        Tag:           "varint,64006,opt,name=gostring",
        Filename:      "gogo.proto",
}

var E_Populate = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64007,
        Name:          "gogoproto.populate",
        Tag:           "varint,64007,opt,name=populate",
        Filename:      "gogo.proto",
}

var E_Stringer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         67008,
        Name:          "gogoproto.stringer",
        Tag:           "varint,67008,opt,name=stringer",
        Filename:      "gogo.proto",
}

var E_Onlyone = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64009,
        Name:          "gogoproto.onlyone",
        Tag:           "varint,64009,opt,name=onlyone",
        Filename:      "gogo.proto",
}

var E_Equal = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64013,
        Name:          "gogoproto.equal",
        Tag:           "varint,64013,opt,name=equal",
        Filename:      "gogo.proto",
}

var E_Description = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64014,
        Name:          "gogoproto.description",
        Tag:           "varint,64014,opt,name=description",
        Filename:      "gogo.proto",
}

var E_Testgen = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64015,
        Name:          "gogoproto.testgen",
        Tag:           "varint,64015,opt,name=testgen",
        Filename:      "gogo.proto",
}

var E_Benchgen = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64016,
        Name:          "gogoproto.benchgen",
        Tag:           "varint,64016,opt,name=benchgen",
        Filename:      "gogo.proto",
}

var E_Marshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64017,
        Name:          "gogoproto.marshaler",
        Tag:           "varint,64017,opt,name=marshaler",
        Filename:      "gogo.proto",
}

var E_Unmarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64018,
        Name:          "gogoproto.unmarshaler",
        Tag:           "varint,64018,opt,name=unmarshaler",
        Filename:      "gogo.proto",
}

var E_StableMarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64019,
        Name:          "gogoproto.stable_marshaler",
        Tag:           "varint,64019,opt,name=stable_marshaler",
        Filename:      "gogo.proto",
}

var E_Sizer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64020,
        Name:          "gogoproto.sizer",
        Tag:           "varint,64020,opt,name=sizer",
        Filename:      "gogo.proto",
}

var E_UnsafeMarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64023,
        Name:          "gogoproto.unsafe_marshaler",
        Tag:           "varint,64023,opt,name=unsafe_marshaler",
        Filename:      "gogo.proto",
}

var E_UnsafeUnmarshaler = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64024,
        Name:          "gogoproto.unsafe_unmarshaler",
        Tag:           "varint,64024,opt,name=unsafe_unmarshaler",
        Filename:      "gogo.proto",
}

var E_GoprotoExtensionsMap = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64025,
        Name:          "gogoproto.goproto_extensions_map",
        Tag:           "varint,64025,opt,name=goproto_extensions_map",
        Filename:      "gogo.proto",
}

var E_GoprotoUnrecognized = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64026,
        Name:          "gogoproto.goproto_unrecognized",
        Tag:           "varint,64026,opt,name=goproto_unrecognized",
        Filename:      "gogo.proto",
}

var E_Protosizer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64028,
        Name:          "gogoproto.protosizer",
        Tag:           "varint,64028,opt,name=protosizer",
        Filename:      "gogo.proto",
}

var E_Compare = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64029,
        Name:          "gogoproto.compare",
        Tag:           "varint,64029,opt,name=compare",
        Filename:      "gogo.proto",
}

var E_Typedecl = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64030,
        Name:          "gogoproto.typedecl",
        Tag:           "varint,64030,opt,name=typedecl",
        Filename:      "gogo.proto",
}

var E_Messagename = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64033,
        Name:          "gogoproto.messagename",
        Tag:           "varint,64033,opt,name=messagename",
        Filename:      "gogo.proto",
}

var E_GoprotoSizecache = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64034,
        Name:          "gogoproto.goproto_sizecache",
        Tag:           "varint,64034,opt,name=goproto_sizecache",
        Filename:      "gogo.proto",
}

var E_GoprotoUnkeyed = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.MessageOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         64035,
        Name:          "gogoproto.goproto_unkeyed",
        Tag:           "varint,64035,opt,name=goproto_unkeyed",
        Filename:      "gogo.proto",
}

var E_Nullable = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65001,
        Name:          "gogoproto.nullable",
        Tag:           "varint,65001,opt,name=nullable",
        Filename:      "gogo.proto",
}

var E_Embed = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65002,
        Name:          "gogoproto.embed",
        Tag:           "varint,65002,opt,name=embed",
        Filename:      "gogo.proto",
}

var E_Customtype = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65003,
        Name:          "gogoproto.customtype",
        Tag:           "bytes,65003,opt,name=customtype",
        Filename:      "gogo.proto",
}

var E_Customname = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65004,
        Name:          "gogoproto.customname",
        Tag:           "bytes,65004,opt,name=customname",
        Filename:      "gogo.proto",
}

var E_Jsontag = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65005,
        Name:          "gogoproto.jsontag",
        Tag:           "bytes,65005,opt,name=jsontag",
        Filename:      "gogo.proto",
}

var E_Moretags = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65006,
        Name:          "gogoproto.moretags",
        Tag:           "bytes,65006,opt,name=moretags",
        Filename:      "gogo.proto",
}

var E_Casttype = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65007,
        Name:          "gogoproto.casttype",
        Tag:           "bytes,65007,opt,name=casttype",
        Filename:      "gogo.proto",
}

var E_Castkey = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65008,
        Name:          "gogoproto.castkey",
        Tag:           "bytes,65008,opt,name=castkey",
        Filename:      "gogo.proto",
}

var E_Castvalue = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*string)(nil),
        Field:         65009,
        Name:          "gogoproto.castvalue",
        Tag:           "bytes,65009,opt,name=castvalue",
        Filename:      "gogo.proto",
}

var E_Stdtime = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65010,
        Name:          "gogoproto.stdtime",
        Tag:           "varint,65010,opt,name=stdtime",
        Filename:      "gogo.proto",
}

var E_Stdduration = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65011,
        Name:          "gogoproto.stdduration",
        Tag:           "varint,65011,opt,name=stdduration",
        Filename:      "gogo.proto",
}

var E_Wktpointer = &amp;proto.ExtensionDesc{
        ExtendedType:  (*descriptor.FieldOptions)(nil),
        ExtensionType: (*bool)(nil),
        Field:         65012,
        Name:          "gogoproto.wktpointer",
        Tag:           "varint,65012,opt,name=wktpointer",
        Filename:      "gogo.proto",
}

func init() <span class="cov8" title="1">{
        proto.RegisterExtension(E_GoprotoEnumPrefix)
        proto.RegisterExtension(E_GoprotoEnumStringer)
        proto.RegisterExtension(E_EnumStringer)
        proto.RegisterExtension(E_EnumCustomname)
        proto.RegisterExtension(E_Enumdecl)
        proto.RegisterExtension(E_EnumvalueCustomname)
        proto.RegisterExtension(E_GoprotoGettersAll)
        proto.RegisterExtension(E_GoprotoEnumPrefixAll)
        proto.RegisterExtension(E_GoprotoStringerAll)
        proto.RegisterExtension(E_VerboseEqualAll)
        proto.RegisterExtension(E_FaceAll)
        proto.RegisterExtension(E_GostringAll)
        proto.RegisterExtension(E_PopulateAll)
        proto.RegisterExtension(E_StringerAll)
        proto.RegisterExtension(E_OnlyoneAll)
        proto.RegisterExtension(E_EqualAll)
        proto.RegisterExtension(E_DescriptionAll)
        proto.RegisterExtension(E_TestgenAll)
        proto.RegisterExtension(E_BenchgenAll)
        proto.RegisterExtension(E_MarshalerAll)
        proto.RegisterExtension(E_UnmarshalerAll)
        proto.RegisterExtension(E_StableMarshalerAll)
        proto.RegisterExtension(E_SizerAll)
        proto.RegisterExtension(E_GoprotoEnumStringerAll)
        proto.RegisterExtension(E_EnumStringerAll)
        proto.RegisterExtension(E_UnsafeMarshalerAll)
        proto.RegisterExtension(E_UnsafeUnmarshalerAll)
        proto.RegisterExtension(E_GoprotoExtensionsMapAll)
        proto.RegisterExtension(E_GoprotoUnrecognizedAll)
        proto.RegisterExtension(E_GogoprotoImport)
        proto.RegisterExtension(E_ProtosizerAll)
        proto.RegisterExtension(E_CompareAll)
        proto.RegisterExtension(E_TypedeclAll)
        proto.RegisterExtension(E_EnumdeclAll)
        proto.RegisterExtension(E_GoprotoRegistration)
        proto.RegisterExtension(E_MessagenameAll)
        proto.RegisterExtension(E_GoprotoSizecacheAll)
        proto.RegisterExtension(E_GoprotoUnkeyedAll)
        proto.RegisterExtension(E_GoprotoGetters)
        proto.RegisterExtension(E_GoprotoStringer)
        proto.RegisterExtension(E_VerboseEqual)
        proto.RegisterExtension(E_Face)
        proto.RegisterExtension(E_Gostring)
        proto.RegisterExtension(E_Populate)
        proto.RegisterExtension(E_Stringer)
        proto.RegisterExtension(E_Onlyone)
        proto.RegisterExtension(E_Equal)
        proto.RegisterExtension(E_Description)
        proto.RegisterExtension(E_Testgen)
        proto.RegisterExtension(E_Benchgen)
        proto.RegisterExtension(E_Marshaler)
        proto.RegisterExtension(E_Unmarshaler)
        proto.RegisterExtension(E_StableMarshaler)
        proto.RegisterExtension(E_Sizer)
        proto.RegisterExtension(E_UnsafeMarshaler)
        proto.RegisterExtension(E_UnsafeUnmarshaler)
        proto.RegisterExtension(E_GoprotoExtensionsMap)
        proto.RegisterExtension(E_GoprotoUnrecognized)
        proto.RegisterExtension(E_Protosizer)
        proto.RegisterExtension(E_Compare)
        proto.RegisterExtension(E_Typedecl)
        proto.RegisterExtension(E_Messagename)
        proto.RegisterExtension(E_GoprotoSizecache)
        proto.RegisterExtension(E_GoprotoUnkeyed)
        proto.RegisterExtension(E_Nullable)
        proto.RegisterExtension(E_Embed)
        proto.RegisterExtension(E_Customtype)
        proto.RegisterExtension(E_Customname)
        proto.RegisterExtension(E_Jsontag)
        proto.RegisterExtension(E_Moretags)
        proto.RegisterExtension(E_Casttype)
        proto.RegisterExtension(E_Castkey)
        proto.RegisterExtension(E_Castvalue)
        proto.RegisterExtension(E_Stdtime)
        proto.RegisterExtension(E_Stdduration)
        proto.RegisterExtension(E_Wktpointer)
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("gogo.proto", fileDescriptor_592445b5231bc2b9) }</span>

var fileDescriptor_592445b5231bc2b9 = []byte{
        // 1383 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x98, 0x49, 0x6f, 0x1c, 0x45,
        0x14, 0x80, 0xb1, 0x48, 0x14, 0xbb, 0x6c, 0xc7, 0xb1, 0x1d, 0x42, 0x88, 0xc0, 0x84, 0x1b, 0x97,
        0x78, 0x4e, 0x11, 0x4a, 0x59, 0x51, 0xe4, 0x58, 0x8e, 0x95, 0x88, 0x04, 0xe3, 0xc4, 0x61, 0x3b,
        0x8c, 0x7a, 0x7a, 0xca, 0xed, 0x26, 0xdd, 0x5d, 0x4d, 0x77, 0x75, 0x88, 0x23, 0x71, 0x40, 0x61,
        0x11, 0x42, 0xec, 0x48, 0x24, 0x21, 0x09, 0x04, 0xc4, 0xbe, 0x86, 0x7d, 0xb9, 0x70, 0x01, 0x72,
        0x84, 0x7f, 0x80, 0x02, 0x17, 0xc0, 0xec, 0xbe, 0xf9, 0x82, 0x5e, 0xf7, 0x7b, 0x3d, 0x35, 0xed,
        0x91, 0xaa, 0xe6, 0xd6, 0x63, 0xd7, 0xf7, 0xb9, 0xfa, 0xbd, 0xaa, 0xf7, 0x9e, 0x87, 0x31, 0x4f,
        0x7a, 0x72, 0x3c, 0x4e, 0xa4, 0x92, 0x23, 0x7d, 0xf0, 0x9c, 0x3f, 0x6e, 0xdb, 0xee, 0x49, 0xe9,
        0x05, 0xa2, 0x96, 0x7f, 0x6a, 0x64, 0x0b, 0xb5, 0xa6, 0x48, 0xdd, 0xc4, 0x8f, 0x95, 0x4c, 0x8a,
        0xc5, 0xfc, 0x10, 0x1b, 0xc5, 0xc5, 0x75, 0x11, 0x65, 0x61, 0x3d, 0x4e, 0xc4, 0x82, 0x7f, 0x62,
        0xe4, 0xfa, 0xf1, 0x82, 0x1c, 0x27, 0x72, 0x7c, 0x3a, 0xca, 0xc2, 0xdb, 0x62, 0xe5, 0xcb, 0x28,
        0xdd, 0x7a, 0xe9, 0x97, 0xab, 0xb7, 0xf7, 0xdc, 0xdc, 0x3b, 0x37, 0x8c, 0x28, 0xfc, 0x6e, 0x36,
        0x07, 0xf9, 0x1c, 0xbb, 0xa6, 0xcd, 0x97, 0xaa, 0xc4, 0x8f, 0x3c, 0x91, 0x18, 0x8c, 0xdf, 0xa2,
        0x71, 0x54, 0x33, 0x1e, 0x46, 0x94, 0x4f, 0xb1, 0xc1, 0x6e, 0x5c, 0xdf, 0xa1, 0x6b, 0x40, 0xe8,
        0x92, 0x19, 0x36, 0x94, 0x4b, 0xdc, 0x2c, 0x55, 0x32, 0x8c, 0x9c, 0x50, 0x18, 0x34, 0xdf, 0xe7,
        0x9a, 0xbe, 0xb9, 0x8d, 0x80, 0x4d, 0x95, 0x14, 0xe7, 0xac, 0x17, 0x7e, 0xd2, 0x14, 0x6e, 0x60,
        0x30, 0x5c, 0xc6, 0x8d, 0x94, 0xeb, 0xf9, 0x51, 0xb6, 0x19, 0x9e, 0x8f, 0x3b, 0x41, 0x26, 0xf4,
        0x9d, 0xdc, 0xd4, 0xd1, 0x73, 0x14, 0x96, 0x91, 0xec, 0xc7, 0x53, 0xeb, 0xf2, 0xed, 0x8c, 0x96,
        0x02, 0x6d, 0x4f, 0x5a, 0x16, 0x3d, 0xa1, 0x94, 0x48, 0xd2, 0xba, 0x13, 0x74, 0xda, 0xde, 0x3e,
        0x3f, 0x28, 0x8d, 0x67, 0x96, 0xdb, 0xb3, 0x38, 0x53, 0x90, 0x93, 0x41, 0xc0, 0xe7, 0xd9, 0xb5,
        0x1d, 0x4e, 0x85, 0x85, 0xf3, 0x2c, 0x3a, 0x37, 0xaf, 0x39, 0x19, 0xa0, 0x9d, 0x65, 0xf4, 0xf3,
        0x32, 0x97, 0x16, 0xce, 0x17, 0xd1, 0x39, 0x82, 0x2c, 0xa5, 0x14, 0x8c, 0x07, 0xd8, 0xf0, 0x71,
        0x91, 0x34, 0x64, 0x2a, 0xea, 0xe2, 0xbe, 0xcc, 0x09, 0x2c, 0x74, 0xe7, 0x50, 0x37, 0x84, 0xe0,
        0x34, 0x70, 0xe0, 0xda, 0xc5, 0x7a, 0x17, 0x1c, 0x57, 0x58, 0x28, 0xce, 0xa3, 0x62, 0x03, 0xac,
        0x07, 0x74, 0x92, 0x0d, 0x78, 0xb2, 0x78, 0x25, 0x0b, 0xfc, 0x02, 0xe2, 0xfd, 0xc4, 0xa0, 0x22,
        0x96, 0x71, 0x16, 0x38, 0xca, 0x66, 0x07, 0x2f, 0x91, 0x82, 0x18, 0x54, 0x74, 0x11, 0xd6, 0x97,
        0x49, 0x91, 0x6a, 0xf1, 0xdc, 0xc3, 0xfa, 0x65, 0x14, 0x2c, 0xc9, 0xc8, 0x66, 0x13, 0x17, 0xd1,
        0xc0, 0x10, 0x01, 0xc1, 0x04, 0xeb, 0xb3, 0x4d, 0xc4, 0x6b, 0xcb, 0x74, 0x3d, 0x28, 0x03, 0x33,
        0x6c, 0x88, 0x0a, 0x94, 0x2f, 0x23, 0x0b, 0xc5, 0xeb, 0xa8, 0xd8, 0xa8, 0x61, 0xf8, 0x1a, 0x4a,
        0xa4, 0xca, 0x13, 0x36, 0x92, 0x37, 0xe8, 0x35, 0x10, 0xc1, 0x50, 0x36, 0x44, 0xe4, 0x2e, 0xda,
        0x19, 0xde, 0xa4, 0x50, 0x12, 0x03, 0x8a, 0x29, 0x36, 0x18, 0x3a, 0x49, 0xba, 0xe8, 0x04, 0x56,
        0xe9, 0x78, 0x0b, 0x1d, 0x03, 0x25, 0x84, 0x11, 0xc9, 0xa2, 0x6e, 0x34, 0x6f, 0x53, 0x44, 0x34,
        0x0c, 0xaf, 0x5e, 0xaa, 0x9c, 0x46, 0x20, 0xea, 0xdd, 0xd8, 0xde, 0xa1, 0xab, 0x57, 0xb0, 0x07,
        0x75, 0xe3, 0x04, 0xeb, 0x4b, 0xfd, 0x93, 0x56, 0x9a, 0x77, 0x29, 0xd3, 0x39, 0x00, 0xf0, 0x5d,
        0xec, 0xba, 0x8e, 0x6d, 0xc2, 0x42, 0xf6, 0x1e, 0xca, 0xb6, 0x74, 0x68, 0x15, 0x58, 0x12, 0xba,
        0x55, 0xbe, 0x4f, 0x25, 0x41, 0x54, 0x5c, 0xb3, 0x6c, 0x73, 0x16, 0xa5, 0xce, 0x42, 0x77, 0x51,
        0xfb, 0x80, 0xa2, 0x56, 0xb0, 0x6d, 0x51, 0x3b, 0xc2, 0xb6, 0xa0, 0xb1, 0xbb, 0xbc, 0x7e, 0x48,
        0x85, 0xb5, 0xa0, 0xe7, 0xdb, 0xb3, 0x7b, 0x0f, 0xdb, 0x56, 0x86, 0xf3, 0x84, 0x12, 0x51, 0x0a,
        0x4c, 0x3d, 0x74, 0x62, 0x0b, 0xf3, 0x25, 0x34, 0x53, 0xc5, 0x9f, 0x2e, 0x05, 0x07, 0x9d, 0x18,
        0xe4, 0x77, 0xb2, 0xad, 0x24, 0xcf, 0xa2, 0x44, 0xb8, 0xd2, 0x8b, 0xfc, 0x93, 0xa2, 0x69, 0xa1,
        0xfe, 0xa8, 0x92, 0xaa, 0x79, 0x0d, 0x07, 0xf3, 0x7e, 0xb6, 0xa9, 0x9c, 0x55, 0xea, 0x7e, 0x18,
        0xcb, 0x44, 0x19, 0x8c, 0x1f, 0x53, 0xa6, 0x4a, 0x6e, 0x7f, 0x8e, 0xf1, 0x69, 0xb6, 0x31, 0xff,
        0x68, 0x7b, 0x24, 0x3f, 0x41, 0xd1, 0x60, 0x8b, 0xc2, 0xc2, 0xe1, 0xca, 0x30, 0x76, 0x12, 0x9b,
        0xfa, 0xf7, 0x29, 0x15, 0x0e, 0x44, 0xb0, 0x70, 0xa8, 0xa5, 0x58, 0x40, 0xb7, 0xb7, 0x30, 0x7c,
        0x46, 0x85, 0x83, 0x18, 0x54, 0xd0, 0xc0, 0x60, 0xa1, 0xf8, 0x9c, 0x14, 0xc4, 0x80, 0xe2, 0xf6,
        0x56, 0xa3, 0x4d, 0x84, 0xe7, 0xa7, 0x2a, 0x71, 0x60, 0xb5, 0x41, 0xf5, 0xc5, 0x72, 0xfb, 0x10,
        0x36, 0xa7, 0xa1, 0x50, 0x89, 0x42, 0x91, 0xa6, 0x8e, 0x27, 0x60, 0xe2, 0xb0, 0xd8, 0xd8, 0x97,
        0x54, 0x89, 0x34, 0x0c, 0xf6, 0xa6, 0x4d, 0x88, 0x10, 0x76, 0xd7, 0x71, 0x17, 0x6d, 0x74, 0x5f,
        0x55, 0x36, 0x77, 0x98, 0x58, 0x70, 0x6a, 0xf3, 0x4f, 0x16, 0x1d, 0x13, 0x4b, 0x56, 0xa7, 0xf3,
        0xeb, 0xca, 0xfc, 0x33, 0x5f, 0x90, 0x45, 0x0d, 0x19, 0xaa, 0xcc, 0x53, 0x23, 0x37, 0xae, 0x71,
        0x1d, 0x2c, 0xde, 0x8b, 0x74, 0x0f, 0xae, 0xe0, 0xfb, 0xb6, 0x8f, 0x53, 0xfc, 0x56, 0x38, 0xe4,
        0xed, 0x43, 0x8f, 0x59, 0x76, 0x6a, 0xa5, 0x3c, 0xe7, 0x6d, 0x33, 0x0f, 0xdf, 0xc7, 0x06, 0xdb,
        0x06, 0x1e, 0xb3, 0xea, 0x21, 0x54, 0x0d, 0xe8, 0xf3, 0x0e, 0xdf, 0xc9, 0xd6, 0xc1, 0xf0, 0x62,
        0xc6, 0x1f, 0x46, 0x3c, 0x5f, 0xce, 0x77, 0xb3, 0x5e, 0x1a, 0x5a, 0xcc, 0xe8, 0x23, 0x88, 0x96,
        0x08, 0xe0, 0x34, 0xb0, 0x98, 0xf1, 0x47, 0x09, 0x27, 0x04, 0x70, 0xfb, 0x10, 0x7e, 0xf3, 0xf8,
        0x3a, 0x6c, 0x3a, 0x14, 0xbb, 0x09, 0xb6, 0x01, 0x27, 0x15, 0x33, 0xfd, 0x18, 0xfe, 0x71, 0x22,
        0xf8, 0x2d, 0x6c, 0xbd, 0x65, 0xc0, 0x9f, 0x40, 0xb4, 0x58, 0xcf, 0xa7, 0x58, 0xbf, 0x36, 0x9d,
        0x98, 0xf1, 0x27, 0x11, 0xd7, 0x29, 0xd8, 0x3a, 0x4e, 0x27, 0x66, 0xc1, 0x53, 0xb4, 0x75, 0x24,
        0x20, 0x6c, 0x34, 0x98, 0x98, 0xe9, 0xa7, 0x29, 0xea, 0x84, 0xf0, 0x3d, 0xac, 0xaf, 0x6c, 0x36,
        0x66, 0xfe, 0x19, 0xe4, 0x5b, 0x0c, 0x44, 0x40, 0x6b, 0x76, 0x66, 0xc5, 0xb3, 0x14, 0x01, 0x8d,
        0x82, 0x6b, 0x54, 0x1d, 0x60, 0xcc, 0xa6, 0xe7, 0xe8, 0x1a, 0x55, 0xe6, 0x17, 0xc8, 0x66, 0x5e,
        0xf3, 0xcd, 0x8a, 0xe7, 0x29, 0x9b, 0xf9, 0x7a, 0xd8, 0x46, 0x75, 0x22, 0x30, 0x3b, 0x5e, 0xa0,
        0x6d, 0x54, 0x06, 0x02, 0x3e, 0xcb, 0x46, 0xd6, 0x4e, 0x03, 0x66, 0xdf, 0x69, 0xf4, 0x0d, 0xaf,
        0x19, 0x06, 0xf8, 0x1d, 0x6c, 0x4b, 0xe7, 0x49, 0xc0, 0x6c, 0x3d, 0xb3, 0x52, 0xf9, 0xdf, 0x4d,
        0x1f, 0x04, 0xf8, 0x91, 0x56, 0x4b, 0xd1, 0xa7, 0x00, 0xb3, 0xf6, 0xec, 0x4a, 0x7b, 0xe1, 0xd6,
        0x87, 0x00, 0x3e, 0xc9, 0x58, 0xab, 0x01, 0x9b, 0x5d, 0xe7, 0xd0, 0xa5, 0x41, 0x70, 0x35, 0xb0,
        0xff, 0x9a, 0xf9, 0xf3, 0x74, 0x35, 0x90, 0x80, 0xab, 0x41, 0xad, 0xd7, 0x4c, 0x5f, 0xa0, 0xab,
        0x41, 0x08, 0x9c, 0x6c, 0xad, 0xbb, 0x99, 0x0d, 0x17, 0xe9, 0x64, 0x6b, 0x14, 0x3f, 0xc4, 0x86,
        0xd7, 0x34, 0x44, 0xb3, 0xea, 0x15, 0x54, 0x6d, 0xaa, 0xf6, 0x43, 0xbd, 0x79, 0x61, 0x33, 0x34,
        0xdb, 0x5e, 0xad, 0x34, 0x2f, 0xec, 0x85, 0x7c, 0x82, 0xf5, 0x46, 0x59, 0x10, 0xc0, 0xe5, 0x19,
        0xb9, 0xa1, 0x43, 0x37, 0x15, 0x41, 0x93, 0x14, 0xbf, 0xae, 0x62, 0x74, 0x08, 0xe0, 0x3b, 0xd9,
        0x7a, 0x11, 0x36, 0x44, 0xd3, 0x44, 0xfe, 0xb6, 0x4a, 0x05, 0x13, 0x56, 0xf3, 0x3d, 0x8c, 0x15,
        0x5f, 0x8d, 0x40, 0x98, 0x4d, 0xec, 0xef, 0xab, 0xc5, 0xb7, 0x34, 0x1a, 0xd2, 0x12, 0xe4, 0x49,
        0x31, 0x08, 0x96, 0xdb, 0x05, 0x79, 0x46, 0x76, 0xb1, 0x0d, 0xf7, 0xa6, 0x32, 0x52, 0x8e, 0x67,
        0xa2, 0xff, 0x40, 0x9a, 0xd6, 0x43, 0xc0, 0x42, 0x99, 0x08, 0xe5, 0x78, 0xa9, 0x89, 0xfd, 0x13,
        0xd9, 0x12, 0x00, 0xd8, 0x75, 0x52, 0x65, 0xf3, 0xde, 0x7f, 0x11, 0x4c, 0x00, 0x6c, 0x1a, 0x9e,
        0x8f, 0x89, 0x25, 0x13, 0xfb, 0x37, 0x6d, 0x1a, 0xd7, 0xf3, 0xdd, 0xac, 0x0f, 0x1e, 0xf3, 0x6f,
        0x95, 0x4c, 0xf0, 0x3f, 0x08, 0xb7, 0x08, 0xf8, 0xcb, 0xa9, 0x6a, 0x2a, 0xdf, 0x1c, 0xec, 0x7f,
        0x31, 0xd3, 0xb4, 0x9e, 0x4f, 0xb2, 0xfe, 0x54, 0x35, 0x9b, 0x19, 0xce, 0xa7, 0x06, 0xfc, 0xbf,
        0xd5, 0xf2, 0x2b, 0x8b, 0x92, 0x81, 0x6c, 0xdf, 0x7f, 0x4c, 0xc5, 0xd2, 0x8f, 0x94, 0x48, 0x4c,
        0x86, 0x15, 0x34, 0x68, 0xc8, 0xde, 0x07, 0x2e, 0x5f, 0x19, 0xeb, 0xf9, 0xe1, 0xca, 0x58, 0xcf,
        0x4f, 0x57, 0xc6, 0x7a, 0x4e, 0xff, 0x3c, 0x76, 0x15, 0x1b, 0x75, 0x65, 0x58, 0xf5, 0xec, 0x65,
        0x33, 0x72, 0x46, 0xce, 0xe6, 0x75, 0xe7, 0xee, 0x03, 0x9e, 0xaf, 0x16, 0xb3, 0xc6, 0xb8, 0x2b,
        0xc3, 0x9a, 0x1b, 0xc8, 0xac, 0xb9, 0xa3, 0xe1, 0x24, 0x7e, 0xaa, 0x9c, 0x9a, 0xdb, 0xd8, 0x91,
        0xc6, 0x7e, 0x53, 0x24, 0x35, 0x27, 0xf6, 0x77, 0x24, 0x59, 0x04, 0xaf, 0x59, 0xf3, 0x92, 0xd8,
        0x2d, 0x3f, 0xa4, 0x2a, 0x6b, 0xd4, 0xca, 0xff, 0x5f, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xe7,
        0x7c, 0x8d, 0x64, 0xbb, 0x15, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Rest Runtime Server of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.

package restruntime

import (
        "crypto/subtle"
        "fmt"
        "strings"
        "time"

        "net/http"
        "os"

        "github.com/chyeh/pubip"

        "github.com/cloud-barista/cb-store/config"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        aw "github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/admin-web"
        "github.com/sirupsen/logrus"

        // REST API (echo)
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"

        // echo-swagger middleware
        _ "github.com/cloud-barista/poc-cicd-spider/api-runtime/rest-runtime/docs"
        echoSwagger "github.com/swaggo/echo-swagger"
)

var cblog *logrus.Logger

// @title CB-Spider REST API
// @version latest
// @description CB-Spider REST API

// @contact.name API Support
// @contact.url http://cloud-barista.github.io
// @contact.email contact-to-cloud-barista@googlegroups.com

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:1024
// @BasePath /spider

// @securityDefinitions.basic BasicAuth

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
        currentTime := time.Now()
        cr.StartTime = currentTime.Format("2006.01.02 15:04:05 Mon")
        cr.MiddleStartTime = currentTime.Format("2006.01.02.15:04:05")
        cr.ShortStartTime = fmt.Sprintf("T%02d:%02d:%02d", currentTime.Hour(), currentTime.Minute(), currentTime.Second())

        // REST and GO SERVER_ADDRESS since v0.4.4
        cr.ServerIPorName = getServerIPorName("SERVER_ADDRESS")
        cr.ServerPort = getServerPort("SERVER_ADDRESS")

        // REST SERVICE_ADDRESS for AdminWeb since v0.4.4
        cr.ServiceIPorName = getServiceIPorName("SERVICE_ADDRESS")
        cr.ServicePort = getServicePort("SERVICE_ADDRESS")
}</span>

// REST API Return struct for boolean type
type BooleanInfo struct {
        Result string // true or false
}

type StatusInfo struct {
        Status string // PENDING | RUNNING | SUSPENDING | SUSPENDED | REBOOTING | TERMINATING | TERMINATED
}

//ex) {"POST", "/driver", registerCloudDriver}
type route struct {
        method, path string
        function     echo.HandlerFunc
}

// JSON Simple message struct
type SimpleMsg struct {
        Message string `json:"message" example:"Any message"`
}

//// CB-Spider Servcie Address Configuration
////   cf)  https://github.com/cloud-barista/poc-cicd-spider/wiki/CB-Spider-Service-Address-Configuration

// REST and GO SERVER_ADDRESS since v0.4.4

// unset                           # default: like 'curl ifconfig.co':1024
// SERVER_ADDRESS="1.2.3.4:3000"  # =&gt; 1.2.3.4:3000
// SERVER_ADDRESS=":3000"         # =&gt; like 'curl ifconfig.co':3000
// SERVER_ADDRESS="localhost"      # =&gt; localhost:1024
// SERVER_ADDRESS="1.2.3.4:3000"        # =&gt; 1.2.3.4::3000
func getServerIPorName(env string) string <span class="cov8" title="1">{

        hostEnv := os.Getenv(env) // SERVER_ADDRESS or SERVICE_ADDRESS

        if hostEnv == "" </span><span class="cov8" title="1">{
                return getPublicIP()
        }</span>

        // "1.2.3.4" or "localhost"
        <span class="cov0" title="0">if !strings.Contains(hostEnv, ":") </span><span class="cov0" title="0">{
                return hostEnv
        }</span>

        <span class="cov0" title="0">strs := strings.Split(hostEnv, ":")
        fmt.Println(len(strs))
        if strs[0] == "" </span><span class="cov0" title="0">{ // ":31024"
                return getPublicIP()
        }</span> else<span class="cov0" title="0"> { // "1.2.3.4:31024" or "localhost:31024"
                return strs[0]
        }</span>
}

func getPublicIP() string <span class="cov8" title="1">{
        ip, err := pubip.Get()
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                hostName, err := os.Hostname()
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                }</span>
                <span class="cov0" title="0">return hostName</span>
        }

        <span class="cov8" title="1">return ip.String()</span>
}

func getServerPort(env string) string <span class="cov8" title="1">{
        // default REST Service Port
        servicePort := ":1024"

        hostEnv := os.Getenv(env) // SERVER_ADDRESS or SERVICE_ADDRESS
        if hostEnv == "" </span><span class="cov8" title="1">{
                return servicePort
        }</span>

        // "1.2.3.4" or "localhost"
        <span class="cov0" title="0">if !strings.Contains(hostEnv, ":") </span><span class="cov0" title="0">{
                return servicePort
        }</span>

        // ":31024" or "1.2.3.4:31024" or "localhost:31024"
        <span class="cov0" title="0">strs := strings.Split(hostEnv, ":")
        servicePort = ":" + strs[1]

        return servicePort</span>
}

// unset  SERVER_ADDRESS =&gt; SERVICE_ADDRESS
func getServiceIPorName(env string) string <span class="cov8" title="1">{
        hostEnv := os.Getenv(env)
        if hostEnv == "" </span><span class="cov8" title="1">{
                return cr.ServerIPorName
        }</span>
        <span class="cov0" title="0">return getServerIPorName(env)</span>
}

// unset  SERVER_ADDRESS =&gt; SERVICE_ADDRESS
func getServicePort(env string) string <span class="cov8" title="1">{
        hostEnv := os.Getenv(env)
        if hostEnv == "" </span><span class="cov8" title="1">{
                return cr.ServerPort
        }</span>
        <span class="cov0" title="0">return getServerPort(env)</span>
}

func RunServer() <span class="cov0" title="0">{

        //======================================= setup routes
        routes := []route{
                //----------root
                {"GET", "", aw.SpiderInfo},
                {"GET", "/", aw.SpiderInfo},

                //----------Swagger
                {"GET", "/swagger/*", echoSwagger.WrapHandler},

                //----------EndpointInfo
                {"GET", "/endpointinfo", EndpointInfo},

                //----------CloudOS
                {"GET", "/cloudos", ListCloudOS},

                //----------CloudDriverInfo
                {"POST", "/driver", RegisterCloudDriver},
                {"GET", "/driver", ListCloudDriver},
                {"GET", "/driver/:DriverName", GetCloudDriver},
                {"DELETE", "/driver/:DriverName", UnRegisterCloudDriver},

                //----------CredentialInfo
                {"POST", "/credential", RegisterCredential},
                {"GET", "/credential", ListCredential},
                {"GET", "/credential/:CredentialName", GetCredential},
                {"DELETE", "/credential/:CredentialName", UnRegisterCredential},

                //----------RegionInfo
                {"POST", "/region", RegisterRegion},
                {"GET", "/region", ListRegion},
                {"GET", "/region/:RegionName", GetRegion},
                {"DELETE", "/region/:RegionName", UnRegisterRegion},

                //----------ConnectionConfigInfo
                {"POST", "/connectionconfig", CreateConnectionConfig},
                {"GET", "/connectionconfig", ListConnectionConfig},
                {"GET", "/connectionconfig/:ConfigName", GetConnectionConfig},
                {"DELETE", "/connectionconfig/:ConfigName", DeleteConnectionConfig},

                //-------------------------------------------------------------------//

                //----------Image Handler
                {"POST", "/vmimage", CreateImage},
                {"GET", "/vmimage", ListImage},
                {"GET", "/vmimage/:Name", GetImage},
                {"DELETE", "/vmimage/:Name", DeleteImage},

                //----------VMSpec Handler
                {"GET", "/vmspec", ListVMSpec},
                {"GET", "/vmspec/:Name", GetVMSpec},
                {"GET", "/vmorgspec", ListOrgVMSpec},
                {"GET", "/vmorgspec/:Name", GetOrgVMSpec},

                //----------VPC Handler
                {"POST", "/vpc", CreateVPC},
                {"GET", "/vpc", ListVPC},
                {"GET", "/vpc/:Name", GetVPC},
                {"DELETE", "/vpc/:Name", DeleteVPC},
                //-- for subnet
                {"POST", "/vpc/:VPCName/subnet", AddSubnet},
                {"DELETE", "/vpc/:VPCName/subnet/:SubnetName", RemoveSubnet},
                {"DELETE", "/vpc/:VPCName/cspsubnet/:Id", RemoveCSPSubnet},
                //-- for management
                {"GET", "/allvpc", ListAllVPC},
                {"DELETE", "/cspvpc/:Id", DeleteCSPVPC},

                //----------SecurityGroup Handler
                {"POST", "/securitygroup", CreateSecurity},
                {"GET", "/securitygroup", ListSecurity},
                {"GET", "/securitygroup/:Name", GetSecurity},
                {"DELETE", "/securitygroup/:Name", DeleteSecurity},
                //-- for management
                {"GET", "/allsecuritygroup", ListAllSecurity},
                {"DELETE", "/cspsecuritygroup/:Id", DeleteCSPSecurity},

                //----------KeyPair Handler
                {"POST", "/keypair", CreateKey},
                {"GET", "/keypair", ListKey},
                {"GET", "/keypair/:Name", GetKey},
                {"DELETE", "/keypair/:Name", DeleteKey},
                //-- for management
                {"GET", "/allkeypair", ListAllKey},
                {"DELETE", "/cspkeypair/:Id", DeleteCSPKey},
                /*
                        //----------VNic Handler
                        {"POST", "/vnic", createVNic},
                        {"GET", "/vnic", listVNic},
                        {"GET", "/vnic/:VNicId", getVNic},
                        {"DELETE", "/vnic/:VNicId", deleteVNic},

                        //----------PublicIP Handler
                        {"POST", "/publicip", createPublicIP},
                        {"GET", "/publicip", listPublicIP},
                        {"GET", "/publicip/:PublicIPId", getPublicIP},
                        {"DELETE", "/publicip/:PublicIPId", deletePublicIP},
                */
                //----------VM Handler
                {"POST", "/vm", StartVM},
                {"GET", "/vm", ListVM},
                {"GET", "/vm/:Name", GetVM},
                {"DELETE", "/vm/:Name", TerminateVM},
                //-- for management
                {"GET", "/allvm", ListAllVM},
                {"DELETE", "/cspvm/:Id", TerminateCSPVM},

                {"GET", "/vmstatus", ListVMStatus},
                {"GET", "/vmstatus/:Name", GetVMStatus},

                {"GET", "/controlvm/:Name", ControlVM}, // suspend, resume, reboot

                //-------------------------------------------------------------------//
                //----------SSH RUN
                {"POST", "/sshrun", SSHRun},

                //----------AdminWeb Handler
                {"GET", "/adminweb", aw.Frame},
                {"GET", "/adminweb/top", aw.Top},
                {"GET", "/adminweb/driver", aw.Driver},
                {"GET", "/adminweb/credential", aw.Credential},
                {"GET", "/adminweb/region", aw.Region},
                {"GET", "/adminweb/connectionconfig", aw.Connectionconfig},
                {"GET", "/adminweb/spiderinfo", aw.SpiderInfo},

                {"GET", "/adminweb/vpc/:ConnectConfig", aw.VPC},
                {"GET", "/adminweb/vpcmgmt/:ConnectConfig", aw.VPCMgmt},
                {"GET", "/adminweb/securitygroup/:ConnectConfig", aw.SecurityGroup},
                {"GET", "/adminweb/securitygroupmgmt/:ConnectConfig", aw.SecurityGroupMgmt},
                {"GET", "/adminweb/keypair/:ConnectConfig", aw.KeyPair},
                {"GET", "/adminweb/keypairmgmt/:ConnectConfig", aw.KeyPairMgmt},
                {"GET", "/adminweb/vm/:ConnectConfig", aw.VM},
                {"GET", "/adminweb/vmmgmt/:ConnectConfig", aw.VMMgmt},

                {"GET", "/adminweb/vmimage/:ConnectConfig", aw.VMImage},
                {"GET", "/adminweb/vmspec/:ConnectConfig", aw.VMSpec},
        }
        //======================================= setup routes

        // Run API Server
        ApiServer(routes)

}</span>

//================ REST API Server: setup &amp; start
func ApiServer(routes []route) <span class="cov0" title="0">{
        e := echo.New()

        // Middleware
        e.Use(middleware.CORS())
        e.Use(middleware.Logger())
        e.Use(middleware.Recover())

        API_USERNAME := os.Getenv("API_USERNAME")
        API_PASSWORD := os.Getenv("API_PASSWORD")

        if API_USERNAME != "" &amp;&amp; API_PASSWORD != "" </span><span class="cov0" title="0">{
                cblog.Info("**** Rest Auth Enabled ****")
                e.Use(middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) </span><span class="cov0" title="0">{
                        // Be careful to use constant time comparison to prevent timing attacks
                        if subtle.ConstantTimeCompare([]byte(username), []byte(API_USERNAME)) == 1 &amp;&amp;
                                subtle.ConstantTimeCompare([]byte(password), []byte(API_PASSWORD)) == 1 </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">return false, nil</span>
                }))
        } else<span class="cov0" title="0"> {
                cblog.Info("**** Rest Auth Disabled ****")
        }</span>

        <span class="cov0" title="0">for _, route := range routes </span><span class="cov0" title="0">{
                // /driver =&gt; /spider/driver
                route.path = "/spider" + route.path
                switch route.method </span>{
                case "POST":<span class="cov0" title="0">
                        e.POST(route.path, route.function)</span>
                case "GET":<span class="cov0" title="0">
                        e.GET(route.path, route.function)</span>
                case "PUT":<span class="cov0" title="0">
                        e.PUT(route.path, route.function)</span>
                case "DELETE":<span class="cov0" title="0">
                        e.DELETE(route.path, route.function)</span>

                }
        }

        // for spider logo
        <span class="cov0" title="0">cbspiderRoot := os.Getenv("CBSPIDER_ROOT")
        e.File("/spider/adminweb/images/logo.png", cbspiderRoot+"/api-runtime/rest-runtime/admin-web/images/cb-spider-circle-logo.png")

        e.HideBanner = true
        e.HidePort = true

        spiderBanner()

        e.Logger.Fatal(e.Start(cr.ServerPort))</span>
}

//================ API Info
func apiInfo(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call apiInfo()")

        apiInfo := "api info"
        return c.String(http.StatusOK, apiInfo)
}</span>

//================ Endpoint Info
func EndpointInfo(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call endpointInfo()")

        endpointInfo := fmt.Sprintf("\n  &lt;CB-Spider&gt; Multi-Cloud Infrastructure Federation Framework\n")
        adminWebURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/adminweb"
        endpointInfo += fmt.Sprintf("     - AdminWeb: %s\n", adminWebURL)
        restEndPoint := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider"
        endpointInfo += fmt.Sprintf("     - REST API: %s\n", restEndPoint)
        // swaggerURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/swagger/index.html"
        // endpointInfo += fmt.Sprintf("     - Swagger : %s\n", swaggerURL)
        gRPCServer := "grpc://" + cr.ServiceIPorName + cr.GoServicePort
        endpointInfo += fmt.Sprintf("     - Go   API: %s\n", gRPCServer)

        return c.String(http.StatusOK, endpointInfo)
}</span>

func spiderBanner() <span class="cov0" title="0">{
        fmt.Println("\n  &lt;CB-Spider&gt; Multi-Cloud Infrastructure Federation Framework")

        // AdminWeb
        adminWebURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/adminweb"
        fmt.Printf("     - AdminWeb: %s\n", adminWebURL)

        // REST API EndPoint
        restEndPoint := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider"
        fmt.Printf("     - REST API: %s\n", restEndPoint)

        // Swagger
        // swaggerURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/swagger/index.html"
        // fmt.Printf("     - Swagger : %s\n", swaggerURL)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Cloud Control Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.04.
// by CB-Spider Team, 2019.10.

package restruntime

import (
        "fmt"

        cm "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cmrt "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        // REST API (echo)
        "net/http"
        "net/url"

        "github.com/labstack/echo/v4"

        "strconv"
        "strings"
)

// define string of resource types
const (
        rsImage string = "image"
        rsVPC   string = "vpc"
        // rsSubnet = cm.SUBNET:{VPC NameID} =&gt; cook in code
        rsSG  string = "sg"
        rsKey string = "keypair"
        rsVM  string = "vm"
)

//================ Image Handler
func CreateImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createImage()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">reqInfo := cres.ImageReqInfo{
                IId: cres.IID{req.ReqInfo.Name, ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateImage(req.ConnectionName, rsImage, reqInfo)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listImage()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListImage(req.ConnectionName, rsImage)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.ImageInfo `json:"image"`
        }

        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getImage()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">encodededImageName := c.Param("Name")
        decodedImageName, err := url.QueryUnescape(encodededImageName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Fatal(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">result, err := cmrt.GetImage(req.ConnectionName, rsImage, decodedImageName)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func DeleteImage(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteImage()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.DeleteImage(req.ConnectionName, rsImage, c.Param("Name"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ VMSpec Handler
func ListVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VMSpecInfo `json:"vmspec"`
        }
        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVMSpec(req.ConnectionName, c.Param("Name"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListOrgVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listOrgVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListOrgVMSpec(req.ConnectionName)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.String(http.StatusOK, result)</span>
}

func GetOrgVMSpec(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getOrgVMSpec()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetOrgVMSpec(req.ConnectionName, c.Param("Name"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.String(http.StatusOK, result)</span>
}

type vpcCreateReq struct {
        ConnectionName string
        ReqInfo        struct {
                Name           string
                IPv4_CIDR      string
                SubnetInfoList []struct {
                        Name      string
                        IPv4_CIDR string
                }
        }
}

// createVPC godoc
// @Summary Create VPC
// @Description Create VPC
// @Tags [CCM] VPC management
// @Accept  json
// @Produce  json
// @Param vpcCreateReq body vpcCreateReq true "Request body to create VPC"
// @Success 200 {object} resources.VPCInfo
// @Failure 404 {object} SimpleMsg
// @Failure 500 {object} SimpleMsg
// @Router /vpc [post]
func CreateVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createVPC()")

        req := vpcCreateReq{}

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // check the input Name to include the SUBNET: Prefix
        <span class="cov8" title="1">if strings.HasPrefix(req.ReqInfo.Name, cm.SUBNET_PREFIX) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, fmt.Errorf(cm.SUBNET_PREFIX+" cannot be used for VPC name prefix!!"))
        }</span>
        // check the input Name to include the SecurityGroup Delimiter
        <span class="cov8" title="1">if strings.HasPrefix(req.ReqInfo.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, fmt.Errorf(cm.SG_DELIMITER+" cannot be used in VPC name!!"))
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        // (1) create SubnetInfo List
        <span class="cov8" title="1">subnetInfoList := []cres.SubnetInfo{}
        for _, info := range req.ReqInfo.SubnetInfoList </span><span class="cov8" title="1">{
                subnetInfo := cres.SubnetInfo{IId: cres.IID{info.Name, ""}, IPv4_CIDR: info.IPv4_CIDR}
                subnetInfoList = append(subnetInfoList, subnetInfo)
        }</span>
        // (2) create VPCReqInfo with SubnetInfo List
        <span class="cov8" title="1">reqInfo := cres.VPCReqInfo{
                IId:            cres.IID{req.ReqInfo.Name, ""},
                IPv4_CIDR:      req.ReqInfo.IPv4_CIDR,
                SubnetInfoList: subnetInfoList,
        }

        // Call common-runtime API
        result, err := cmrt.CreateVPC(req.ConnectionName, rsVPC, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVPC(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VPCInfo `json:"vpc"`
        }
        jsonResult.Result = result

        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all VPCs for management
// (1) get args from REST Call
// (2) get all VPC List by common-runtime API
// (3) return REST Json Format
func ListAllVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVPC)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVPC(req.ConnectionName, rsVPC, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, rsVPC, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteCSPVPC(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVPC, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get subnet info from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func AddSubnet(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call addSubnet()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name      string
                        IPv4_CIDR string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        <span class="cov8" title="1">reqSubnetInfo := cres.SubnetInfo{IId: cres.IID{req.ReqInfo.Name, ""}, IPv4_CIDR: req.ReqInfo.IPv4_CIDR}

        // Call common-runtime API
        result, err := cmrt.AddSubnet(req.ConnectionName, cm.SUBNET_PREFIX+c.Param("VPCName"), c.Param("VPCName"), reqSubnetInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func RemoveSubnet(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call removeSubnet()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, cm.SUBNET_PREFIX+c.Param("VPCName"), c.Param("SubnetName"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func RemoveCSPSubnet(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPVPC()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, cm.SUBNET_PREFIX+c.Param("VPCName"), c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

type securityGroupCreateReq struct {
        ConnectionName string
        ReqInfo        struct {
                Name          string
                VPCName       string
                Direction     string
                SecurityRules *[]cres.SecurityRuleInfo
        }
}

/* // createSecurity godoc
// @Summary Create Security Group
// @Description Create Security Group
// @Tags [CCM] Security Group management
// @Accept  json
// @Produce  json
// @Param securityGroupCreateReq body securityGroupCreateReq true "Request body to create Security Group"
// @Success 200 {object} resources.SecurityInfo
// @Failure 404 {object} SimpleMsg
// @Failure 500 {object} SimpleMsg
// @Router /securitygroup [post] */
func CreateSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createSecurity()")

        req := securityGroupCreateReq{}

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // check the input Name to include the SecurityGroup Delimiter
        <span class="cov8" title="1">if strings.Contains(req.ReqInfo.Name, cm.SG_DELIMITER) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, fmt.Errorf(cm.SG_DELIMITER+" cannot be used in Security Group name!!"))
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        <span class="cov8" title="1">reqInfo := cres.SecurityReqInfo{
                // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                // transform: SG NameID =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                //IId:           cres.IID{req.ReqInfo.VPCName + cm.SG_DELIMITER + req.ReqInfo.Name, ""},
                IId:           cres.IID{req.ReqInfo.VPCName + cm.SG_DELIMITER + req.ReqInfo.Name, req.ReqInfo.Name}, // for NCP: fixed NameID =&gt; SystemID, Driver: (1)search systemID with fixed NameID (2)replace fixed NameID into SysemID
                VpcIID:        cres.IID{req.ReqInfo.VPCName, ""},
                Direction:     req.ReqInfo.Direction,
                SecurityRules: req.ReqInfo.SecurityRules,
        }

        // Call common-runtime API
        result, err := cmrt.CreateSecurity(req.ConnectionName, rsSG, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListSecurity(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.SecurityInfo `json:"securitygroup"`
        }
        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all SGs for management
// (1) get args from REST Call
// (2) get all SG List by common-runtime API
// (3) return REST Json Format
func ListAllSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsSG)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetSecurity(req.ConnectionName, rsSG, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, rsSG, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteCSPSecurity(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPSecurity()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsSG, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// type keyPairCreateReq struct {
//         ConnectionName string
//         ReqInfo        struct {
//                 Name string
//         }
// }

// JSONResult's data field will be overridden by the specific type
type JSONResult struct {
        //Code    int          `json:"code" `
        //Message string       `json:"message"`
        //Data    interface{}  `json:"data"`
}

// createKey godoc
// @Summary Create SSH Key
// @Description Create SSH Key
// @Tags [CCM] Access key management
// @Accept  json
// @Produce  json
// @Param keyPairCreateReq body JSONResult{ConnectionName=string,ReqInfo=JSONResult{Name=string}} true "Request body to create key"
// @Success 200 {object} resources.KeyPairInfo
// @Failure 404 {object} SimpleMsg
// @Failure 500 {object} SimpleMsg
// @Router /keypair [post]
func CreateKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call createKey()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        <span class="cov8" title="1">reqInfo := cres.KeyPairReqInfo{
                IId: cres.IID{req.ReqInfo.Name, ""},
        }

        // Call common-runtime API
        result, err := cmrt.CreateKey(req.ConnectionName, rsKey, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListKey(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.KeyPairInfo `json:"keypair"`
        }
        jsonResult.Result = result
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all KeyPairs for management
// (1) get args from REST Call
// (2) get all KeyPair List by common-runtime API
// (3) return REST Json Format
func ListAllKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsKey)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetKey(req.ConnectionName, rsKey, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteResource(req.ConnectionName, rsKey, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func DeleteCSPKey(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteCSPKey()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, _, err := cmrt.DeleteCSPResource(req.ConnectionName, rsKey, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

/****************************
//================ VNic Handler
func createVNic(c echo.Context) error {
        cblog.Info("call createVNic()")

        var req struct {
                ConnectionName string
                ReqInfo cres.VNicReqInfo
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.CreateVNic(req.ReqInfo)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func listVNic(c echo.Context) error {
        cblog.Info("call listVNic()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        infoList, err := handler.ListVNic()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        var jsonResult struct {
                Result []*cres.VNicInfo `json:"vnic"`
        }
        if infoList == nil {
                infoList = []*cres.VNicInfo{}
        }
        jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)
}

func getVNic(c echo.Context) error {
        cblog.Info("call getVNic()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.GetVNic(c.Param("VNicId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func deleteVNic(c echo.Context) error {
        cblog.Info("call deleteVNic()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreateVNicHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        result, err := handler.DeleteVNic(c.Param("VNicId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)
}

//================ PublicIP Handler
func createPublicIP(c echo.Context) error {
        cblog.Info("call createPublicIP()")

        var req struct {
                ConnectionName string
                ReqInfo cres.PublicIPReqInfo
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.CreatePublicIP(req.ReqInfo)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func listPublicIP(c echo.Context) error {
        cblog.Info("call listPublicIP()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        infoList, err := handler.ListPublicIP()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        var jsonResult struct {
                Result []*cres.PublicIPInfo `json:"publicip"`
        }
        if infoList == nil {
                infoList = []*cres.PublicIPInfo{}
        }
        jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)
}

func getPublicIP(c echo.Context) error {
        cblog.Info("call getPublicIP()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        info, err := handler.GetPublicIP(c.Param("PublicIPId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        return c.JSON(http.StatusOK, &amp;info)
}

func deletePublicIP(c echo.Context) error {
        cblog.Info("call deletePublicIP()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        cldConn, err := ccm.GetCloudConnection(req.ConnectionName)
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        handler, err := cldConn.CreatePublicIPHandler()
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        result, err := handler.DeletePublicIP(c.Param("PublicIPId"))
        if err != nil {
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }

        resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)
}
****************************/

//================ VM Handler
// (1) check exist(NameID)
// (2) create Resource
// (3) insert IID
func StartVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call startVM()")

        var req struct {
                ConnectionName string
                ReqInfo        struct {
                        Name               string
                        ImageName          string
                        VPCName            string
                        SubnetName         string
                        SecurityGroupNames []string
                        VMSpecName         string
                        KeyPairName        string

                        VMUserId     string
                        VMUserPasswd string
                }
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Rest RegInfo =&gt; Driver ReqInfo
        // (1) create SecurityGroup IID List
        <span class="cov8" title="1">sgIIDList := []cres.IID{}
        for _, sgName := range req.ReqInfo.SecurityGroupNames </span><span class="cov8" title="1">{
                // SG NameID format =&gt; {VPC NameID} + cm.SG_DELIMITER + {SG NameID}
                // transform: SG NameID =&gt; {VPC NameID}-{SG NameID}
                sgIID := cres.IID{req.ReqInfo.VPCName + cm.SG_DELIMITER + sgName, ""}
                sgIIDList = append(sgIIDList, sgIID)
        }</span>
        // (2) create VMReqInfo with SecurityGroup IID List
        <span class="cov8" title="1">reqInfo := cres.VMReqInfo{
                IId:               cres.IID{req.ReqInfo.Name, ""},
                ImageIID:          cres.IID{req.ReqInfo.ImageName, ""},
                VpcIID:            cres.IID{req.ReqInfo.VPCName, ""},
                SubnetIID:         cres.IID{req.ReqInfo.SubnetName, ""},
                SecurityGroupIIDs: sgIIDList,

                VMSpecName: req.ReqInfo.VMSpecName,
                KeyPairIID: cres.IID{req.ReqInfo.KeyPairName, ""},

                VMUserId:     req.ReqInfo.VMUserId,
                VMUserPasswd: req.ReqInfo.VMUserPasswd,
        }

        // Call common-runtime API
        result, err := cmrt.StartVM(req.ConnectionName, rsVM, reqInfo)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

func ListVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVM(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VMInfo `json:"vm"`
        }
        jsonResult.Result = result

        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

// list all VMs for management
// (1) get args from REST Call
// (2) get all VM List by common-runtime API
// (3) return REST Json Format
func ListAllVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listAllVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">allResourceList, err := cmrt.ListAllResource(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;allResourceList)</span>
}

func GetVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVM(req.ConnectionName, rsVM, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func TerminateVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call terminateVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">_, result, err := cmrt.DeleteResource(req.ConnectionName, rsVM, c.Param("Name"), c.QueryParam("force"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

// (1) get args from REST Call
// (2) call common-runtime API
// (3) return REST Json Format
func TerminateCSPVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call terminateCSPVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">_, result, err := cmrt.DeleteCSPResource(req.ConnectionName, rsVM, c.Param("Id"))
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

func ListVMStatus(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listVMStatus()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ListVMStatus(req.ConnectionName, rsVM)
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cres.VMStatusInfo `json:"vmstatus"`
        }
        jsonResult.Result = result

        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetVMStatus(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getVMStatus()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.GetVMStatus(req.ConnectionName, rsVM, c.Param("Name"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

func ControlVM(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call controlVM()")

        var req struct {
                ConnectionName string
        }

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        // Call common-runtime API
        <span class="cov8" title="1">result, err := cmrt.ControlVM(req.ConnectionName, rsVM, c.Param("Name"), c.QueryParam("action"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := StatusInfo{
                Status: string(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package restruntime

import (
        "strconv"

        im "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager"
        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"

        // REST API (echo)
        "net/http"

        "github.com/labstack/echo/v4"
)

//================ List of support CloudOS
func ListCloudOS(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listCloudOS()")

        infoList := im.ListCloudOS()

        var jsonResult struct {
                Result []string `json:"cloudos"`
        }
        jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)
}</span>

//================ CloudDriver Handler
func RegisterCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerCloudDriver()")
        req := &amp;dim.CloudDriverInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">cldinfoList, err := dim.RegisterCloudDriverInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;cldinfoList)</span>
}

func ListCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listCloudDriver()")

        infoList, err := dim.ListCloudDriver()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*dim.CloudDriverInfo `json:"driver"`
        }
        if infoList == nil </span><span class="cov0" title="0">{
                infoList = []*dim.CloudDriverInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>

}

func GetCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getCloudDriver()")

        cldinfo, err := dim.GetCloudDriver(c.Param("DriverName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;cldinfo)</span>
}

func UnRegisterCloudDriver(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call unRegisterCloudDriver()")

        result, err := dim.UnRegisterCloudDriver(c.Param("DriverName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ Credential Handler
func RegisterCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerCredential()")

        req := &amp;cim.CredentialInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">crdinfoList, err := cim.RegisterCredentialInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfoList)</span>
}

func ListCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listCredential()")

        infoList, err := cim.ListCredential()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*cim.CredentialInfo `json:"credential"`
        }
        if infoList == nil </span><span class="cov8" title="1">{
                infoList = []*cim.CredentialInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getCredential()")

        crdinfo, err := cim.GetCredential(c.Param("CredentialName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfo)</span>
}

func UnRegisterCredential(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call unRegisterCredential()")

        result, err := cim.UnRegisterCredential(c.Param("CredentialName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ Region Handler
func RegisterRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerRegion()")

        req := &amp;rim.RegionInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">crdinfoList, err := rim.RegisterRegionInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfoList)</span>
}

func ListRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listRegion()")

        infoList, err := rim.ListRegion()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*rim.RegionInfo `json:"region"`
        }
        if infoList == nil </span><span class="cov8" title="1">{
                infoList = []*rim.RegionInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getRegion()")

        crdinfo, err := rim.GetRegion(c.Param("RegionName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfo)</span>
}

func UnRegisterRegion(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call unRegisterRegion()")

        result, err := rim.UnRegisterRegion(c.Param("RegionName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}

//================ ConnectionConfig Handler
func CreateConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call registerConnectionConfig()")

        req := &amp;ccim.ConnectionConfigInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">crdinfoList, err := ccim.CreateConnectionConfigInfo(*req)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfoList)</span>
}

func ListConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call listConnectionConfig()")

        infoList, err := ccim.ListConnectionConfig()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">var jsonResult struct {
                Result []*ccim.ConnectionConfigInfo `json:"connectionconfig"`
        }
        if infoList == nil </span><span class="cov0" title="0">{
                infoList = []*ccim.ConnectionConfigInfo{}
        }</span>
        <span class="cov8" title="1">jsonResult.Result = infoList
        return c.JSON(http.StatusOK, &amp;jsonResult)</span>
}

func GetConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call getConnectionConfig()")

        crdinfo, err := ccim.GetConnectionConfig(c.Param("ConfigName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, &amp;crdinfo)</span>
}

func DeleteConnectionConfig(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call deleteConnectionConfig()")

        result, err := ccim.DeleteConnectionConfig(c.Param("ConfigName"))
        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">resultInfo := BooleanInfo{
                Result: strconv.FormatBool(result),
        }

        return c.JSON(http.StatusOK, &amp;resultInfo)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Rest Runtime Server for VM's SSH and SCP of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.

package restruntime

import (
        sshrun "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/vm-ssh"

        "strings"
        // REST API (echo)
        "net/http"

        "github.com/labstack/echo/v4"
)

type SSHRUNReqInfo struct {
        UserName   string   // ex) "root"
        PrivateKey []string // ex)   ["-----BEGIN RSA PRIVATE KEY-----",
        //          "MIIEoQIBAAKCAQEArVNOLwMIp5VmZ4VPZotcoCHdEzimKalAsz+ccLfvAA1Y2ELH",
        //          "..."]
        ServerPort string // ex) "node12:22"
        Command    string // ex) "hostname"
}

//================ SSH RUN
func SSHRun(c echo.Context) error <span class="cov8" title="1">{
        cblog.Info("call sshRun()")

        req := &amp;SSHRUNReqInfo{}
        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov8" title="1">strPrivateKey := strings.Join(req.PrivateKey[:], "\n")

        sshInfo := sshrun.SSHInfo{
                UserName:   req.UserName,
                PrivateKey: []byte(strPrivateKey),
                ServerPort: req.ServerPort,
        }
        var result string
        var err error
        if result, err = sshrun.SSHRun(sshInfo, req.Command); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, "Error while running cmd: "+req.Command+"]"+err.Error())
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"

        "strconv"
        "net/http"
        "strings"
        "github.com/labstack/echo/v4"
        "encoding/json"
)

// number, Spider's NameId, CSP's SystemId, checkbox
func makeMgmtTRList_html(bgcolor string, height string, fontSize string, infoList cr.AllResourceList) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td $$NAMEIDSTYLE$$&gt;
                            &lt;font size=%s&gt;$$NAMEID$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td $$SYTEMIDSTYLE$$&gt;
                            &lt;font size=%s&gt;$$SYTEMID$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$ID$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList.AllList.MappedList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$NAMEID$$", one.NameId)
                str = strings.ReplaceAll(str, "$$SYTEMID$$", one.SystemId)
                str = strings.ReplaceAll(str, "$$ID$$", "::NAMEID::" + one.NameId) // MappedList: contain "::NAMEID::"
                str = strings.ReplaceAll(str, "$$NAMEIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                str = strings.ReplaceAll(str, "$$SYTEMIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                strData += str
        }</span>
        <span class="cov0" title="0">for i, one := range infoList.AllList.OnlySpiderList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$NAMEID$$", one.NameId)
                str = strings.ReplaceAll(str, "$$SYTEMID$$", "( " + one.SystemId + " )")
                str = strings.ReplaceAll(str, "$$ID$$", "::NAMEID::" + one.NameId) // OnlySpiderList: contain "::NAMEID::"

                str = strings.ReplaceAll(str, "$$NAMEIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                str = strings.ReplaceAll(str, "$$SYTEMIDSTYLE$$", ``)
                strData += str
        }</span>
        <span class="cov0" title="0">for i, one := range infoList.AllList.OnlyCSPList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$NAMEID$$", "( " + one.NameId + " )")
                str = strings.ReplaceAll(str, "$$SYTEMID$$", one.SystemId)
                str = strings.ReplaceAll(str, "$$ID$$", one.SystemId) // OnlyCSPList: not contain "::NAMEID::"

                str = strings.ReplaceAll(str, "$$NAMEIDSTYLE$$", ``)
                str = strings.ReplaceAll(str, "$$SYTEMIDSTYLE$$", `style="background-color:#F0F3FF;"`)
                strData += str
        }</span>        

        <span class="cov0" title="0">return strData</span>
}

//====================================== VPC

// make the string of javascript function
func makeDeleteVPCMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/vpc/vpc-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspvpc/vpc-0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteVPCMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vpc/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspvpc/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VPCMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VPCMgmt()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr :=  `
                        &lt;html&gt;
                        &lt;head&gt;
                            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                            &lt;script type="text/javascript"&gt;
                                alert(connConfig)
                            &lt;/script&gt;
                        &lt;/head&gt;
                        &lt;body&gt;
                                &lt;br&gt;
                                &lt;br&gt;
                                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;        
                        &lt;/body&gt;
                `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>
        
        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()                
                htmlStr += makeDeleteVPCMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "vpc", "deleteVPCMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteVPCMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},                    
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list 
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "vpc")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                
                <span class="cov0" title="0">var info cr.AllResourceList
                
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== Security Group

// make the string of javascript function
func makeDeleteSecurityGroupMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/securitygroup/sg-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspsecuritygroup/sg-0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteSecurityGroupMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // if MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/securitygroup/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspsecuritygroup/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func SecurityGroupMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call SecurityGroupMgmt()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr :=  `
                        &lt;html&gt;
                        &lt;head&gt;
                            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                            &lt;script type="text/javascript"&gt;
                                alert(connConfig)
                            &lt;/script&gt;
                        &lt;/head&gt;
                        &lt;body&gt;
                                &lt;br&gt;
                                &lt;br&gt;
                                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;
                        &lt;/body&gt;
                `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makeDeleteSecurityGroupMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "vpc", "deleteSecurityGroupMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteSecurityGroupMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "securitygroup")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">var info cr.AllResourceList

                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== KeyPair

// make the string of javascript function
func makeDeleteKeyPairMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/keypair/keypair-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspkeypair/0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteKeyPairMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/keypair/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspkeypair/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func KeyPairMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call KeyPairMgmt()")

    connConfig := c.Param("ConnectConfig")
    if connConfig == "region not set" </span><span class="cov0" title="0">{
        htmlStr :=  `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

        return c.HTML(http.StatusOK, htmlStr)
    }</span>
    
        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()                
                htmlStr += makeDeleteKeyPairMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "keypair", "deleteKeyPairMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteKeyPairMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},                    
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list 
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "keypair")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                
                <span class="cov0" title="0">var info cr.AllResourceList
                
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VM

// make the string of javascript function
func makeDeleteVMMgmtFunc_js() string <span class="cov0" title="0">{
// delete for MappedList &amp; OnlySpiderList
// curl -sX DELETE http://localhost:1024/spider/vm/vm-01?force=true -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}
// delete for OnlyCSPList
// curl -sX DELETE http://localhost:1024/spider/cspvm/0b0d0d30794eab379 -H 'Content-Type: application/json' -d '{ "ConnectionName": "aws-ohio-config"}' |json_pp

        strFunc := `
                function deleteVMMgmt() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        if(checkboxes[i].value.includes("::NAMEID::")) { // MappedList &amp; OnlySpiderList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vm/" + checkboxes[i].value.replace("::NAMEID::", "") + "?force=true", false);
                                        }else { // OnlyCSPList
                                            xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/cspvm/" + checkboxes[i].value, false);
                                        }

                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VMMgmt(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VMMgmt()")

    connConfig := c.Param("ConnectConfig")
    if connConfig == "region not set" </span><span class="cov0" title="0">{
        htmlStr :=  `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;
            &lt;/body&gt;
        `

        return c.HTML(http.StatusOK, htmlStr)
    }</span>

        // make page header
        <span class="cov0" title="0">htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makeDeleteVMMgmtFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                //htmlStr += makeActionTR_html("4", "vm", "deleteVMMgmt()", "2")
                htmlStr += makeActionTR_html("4", "", "deleteVMMgmt()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Spider's NameId", "300"},
                    {"CSP's SystemId", "300"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list
                resBody, err := getAllResourceList_with_Connection_JsonByte(connConfig, "vm")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">var info cr.AllResourceList

                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeMgmtTRList_html("", "", "", info)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

</pre>
		
		<pre class="file" id="file33" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"

        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        "strconv"

        "encoding/json"
        "net/http"
        "strings"

        "github.com/labstack/echo/v4"
)

//====================================== VPC

// number, VPC Name, VPC CIDR, SUBNET Info, Additional Info, checkbox
func makeVPCTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.VPCInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPCNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPCCIDR$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SUBNETINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$VPCNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strRemoveSubnet := fmt.Sprintf(`
                &lt;a href="javascript:$$REMOVESUBNET$$;"&gt;
                        &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;X&lt;/b&gt;&lt;/font&gt;
                &lt;/a&gt;
                `, fontSize)

        strAddSubnet := fmt.Sprintf(`
                &lt;textarea style="font-size:12px;text-align:center;" name="subnet_text_box" id="subnet_text_box" cols=40&gt;{ "Name": "subnet-xx", "IPv4_CIDR": "192.168.xx.xx/24"}&lt;/textarea&gt;
                &lt;a href="javascript:$$ADDSUBNET$$;"&gt;
                        &lt;font size=%s&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                &lt;/a&gt;
                                                                `, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VPCNAME$$", one.IId.NameId)
                str = strings.ReplaceAll(str, "$$VPCCIDR$$", one.IPv4_CIDR)

                var vpcName = one.IId.NameId

                // for subnet
                strSubnetList := ""
                for _, one := range one.SubnetInfoList </span><span class="cov0" title="0">{
                        strSubnetList += one.IId.NameId + ", "
                        strSubnetList += "CIDR:" + one.IPv4_CIDR + ", {"
                        for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                                strSubnetList += kv.Key + ":" + kv.Value + ", "
                        }</span>
                        <span class="cov0" title="0">strSubnetList += "}"

                        var subnetName = one.IId.NameId
                        strSubnetList += strings.ReplaceAll(strRemoveSubnet, "$$REMOVESUBNET$$", "deleteSubnet('"+vpcName+"', '"+subnetName+"')")

                        strSubnetList += "&lt;br&gt;"</span>
                }
                <span class="cov0" title="0">strSubnetList += strings.ReplaceAll(strAddSubnet, "$$ADDSUBNET$$", "postSubnet('"+vpcName+"')")
                str = strings.ReplaceAll(str, "$$SUBNETINFO$$", strSubnetList)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostVPCFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/vpc -H 'Content-Type: application/json'
        //      -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "vpc-01", "IPv4_CIDR": "192.168.0.0/16",
        //              "SubnetInfoList": [ { "Name": "subnet-01", "IPv4_CIDR": "192.168.1.0/24"} ] } }'

        strFunc := `
                function postVPC() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$VPCNAME$$", "IPv4_CIDR" : "$$VPCCIDR$$", "SubnetInfoList" : $$SUBNETINFOLIST$$ }}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$VPCNAME$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$VPCCIDR$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$SUBNETINFOLIST$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/vpc", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makePostSubnetFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/vpc/vpc-01/subnet -H 'Content-Type: application/json'
        //      -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "subnet-02", "IPv4_CIDR": "192.168.2.0/24" } }'

        strFunc := `
                function postSubnet(vpcName) {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textbox = document.getElementById('subnet_text_box');
                        sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" :  $$SUBNETINFO$$ }'

                        sendJson = sendJson.replace("$$SUBNETINFO$$", textbox.value);

                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/vpc/" + vpcName + "/subnet", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteVPCFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/vpc/vpc-01 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteVPC() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vpc/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteSubnetFunc_js() string <span class="cov0" title="0">{
        //curl -sX DELETE http://localhost:1024/spider/vpc/vpc-01/subnet/subnet-02 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteSubnet(vpcName, subnetName) {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var xhr = new XMLHttpRequest();
                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vpc/" + vpcName + "/subnet/" + subnetName, false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                        xhr.send(sendJson);

                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VPC(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VPC()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
                        &lt;html&gt;
                        &lt;head&gt;
                            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                            &lt;script type="text/javascript"&gt;
                                alert(connConfig)
                            &lt;/script&gt;
                        &lt;/head&gt;
                        &lt;body&gt;
                                &lt;br&gt;
                                &lt;br&gt;
                                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;        
                        &lt;/body&gt;
                `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostVPCFunc_js()
        htmlStr += makeDeleteVPCFunc_js()
        htmlStr += makePostSubnetFunc_js()
        htmlStr += makeDeleteSubnetFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        //htmlStr += makeActionTR_html("6", "vpc", "deleteVPC()", "2")
        htmlStr += makeActionTR_html("6", "", "deleteVPC()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VPC Name", "200"},
                {"VPC CIDR", "200"},
                {"Subnet Info", "300"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vpc")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.VPCInfo `json:"vpc"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVPCTRList_html("", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="vpc-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" value="192.168.0.0/16"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="3" cols=50&gt;[ { "Name": "subnet-01", "IPv4_CIDR": "192.168.1.0/24"} ]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" disabled value="N/A"&gt;
                            &lt;/td&gt;                            
                            &lt;td&gt;
                                &lt;a href="javascript:postVPC()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== Security Group

// number, VPC Name, SecurityGroup Name, Security Rules, Additional Info, checkbox
func makeSecurityGroupTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.SecurityInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPCNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SGNAME$$&lt;/font&gt;
                    &lt;/td&gt;                    
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SECURITYRULES$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$SGNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VPCNAME$$", one.VpcIID.NameId)
                str = strings.ReplaceAll(str, "$$SGNAME$$", one.IId.NameId)

                // for security rules info
                strSRList := ""
                for _, one := range *one.SecurityRules </span><span class="cov0" title="0">{
                        strSRList += "FromPort:" + one.FromPort + ", "
                        strSRList += "ToPort:" + one.ToPort + ", "
                        strSRList += "IPProtocol:" + one.IPProtocol + ", "
                        strSRList += "Direction:" + one.Direction + ", "
                        strSRList += "CIDR:" + one.CIDR + ", "
                        strSRList += "}&lt;br&gt;"
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$SECURITYRULES$$", strSRList)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostSecurityGroupFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/securitygroup -H 'Content-Type: application/json'
        //  -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "sg-01", "VPCName": "vpc-01",
        //      "SecurityRules": [ {"FromPort": "1", "ToPort" : "65535", "IPProtocol" : "tcp", "Direction" : "inbound", "CIDR" : "0.0.0.0/0" } ] } }'

        strFunc := `
                function postSecurityGroup() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$SGNAME$$", "VPCName" : "$$VPCNAME$$", "SecurityRules" : $$SECURITYRULES$$ }}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$VPCNAME$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$SGNAME$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$SECURITYRULES$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/securitygroup", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteSecurityGroupFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/securitygroup/sg-01 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteSecurityGroup() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/securitygroup/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func SecurityGroup(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call SecurityGroup()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostSecurityGroupFunc_js()
        htmlStr += makeDeleteSecurityGroupFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        //htmlStr += makeActionTR_html("6", "securitygroup", "deleteSecurityGroup()", "2")
        htmlStr += makeActionTR_html("6", "", "deleteSecurityGroup()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VPC Name", "200"},
                {"SecurityGroup Name", "200"},
                {"Security Rules", "300"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "securitygroup")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.SecurityInfo `json:"securitygroup"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeSecurityGroupTRList_html("", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        nameList := vpcList(connConfig)

        htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                `
        // Select format of CloudOS  name=text_box, id=1
        htmlStr += makeSelect_html("onchangeVPC", nameList, "1")

        htmlStr += `
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" value="sg-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="3" cols=50 rows=3&gt;[ {"FromPort": "1", "ToPort" : "65535", "IPProtocol" : "tcp", "Direction" : "inbound", "CIDR" : "0.0.0.0/0" } ]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" disabled value="N/A"&gt;                            
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postSecurityGroup()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== KeyPair

// number, KeyPair Name, KeyPair Info, Key User, Additional Info, checkbox
func makeKeyPairTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.KeyPairInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$KEYPAIRNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$KEYINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$KEYUSER$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$KEYPAIRNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$KEYPAIRNAME$$", one.IId.NameId)
                // KeyPair Info: Fingerprint, PrivateKey, PublicKey
                runes := []rune(one.Fingerprint)
                fingerPrint := string(runes[0:12]) + "XXXXXXXXXXX"
                runes = []rune(one.PrivateKey)
                privateKey := string(runes[0:12]) + "XXXXXXXXXXX"
                runes = []rune(one.PublicKey)
                publicKey := string(runes[0:12]) + "XXXXXXXXXXX"
                keyInfo := "&amp;nbsp;* Fingerprint: " + fingerPrint + "&lt;br&gt;"
                keyInfo += "&amp;nbsp;* PrivateKey: " + privateKey + "&lt;br&gt;"
                keyInfo += "&amp;nbsp;* PublicKey: " + publicKey
                str = strings.ReplaceAll(str, "$$KEYINFO$$", keyInfo)
                str = strings.ReplaceAll(str, "$$KEYUSER$$", one.VMUserID)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostKeyPairFunc_js() string <span class="cov0" title="0">{

        //curl -sX POST http://localhost:1024/spider/keypair -H 'Content-Type: application/json'
        //      -d '{ "ConnectionName": "'${CONN_CONFIG}'", "ReqInfo": { "Name": "keypair-01" } }'

        strFunc := `
                function postKeyPair() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;

                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$KEYPAIRNAME$$"}}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$KEYPAIRNAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/keypair", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteKeyPairFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/keypair/keypair-01 -H 'Content-Type: application/json'
        //           -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteKeyPair() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/keypair/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func KeyPair(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call KeyPair()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostKeyPairFunc_js()
        htmlStr += makeDeleteKeyPairFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        //htmlStr += makeActionTR_html("6", "keypair", "deleteKeyPair()", "2")
        htmlStr += makeActionTR_html("6", "", "deleteKeyPair()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"KeyPair Name", "200"},
                {"KeyPair Info", "300"},
                {"Key User", "200"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "keypair")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.KeyPairInfo `json:"keypair"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeKeyPairTRList_html("", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="keypair-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postKeyPair()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VM

// number, VM Name/Control, VMStatus/Last Start Time, VMImage/VMSpec, VPC/Subnet/Security Group,
//         Network Interface/IP, DNS, Boot Disk/Block Disk, SSH AccessPoint/Access Key/Access User Name, Additional Info, checkbox
func makeVMTRList_html(connConfig string, bgcolor string, height string, fontSize string, infoList []*cres.VMInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMSTATUS$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$LASTSTARTTIME$$&lt;/font&gt;
                    &lt;/td&gt;                    
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$IMAGE$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$SPEC$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VPC$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$SUBNET$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$SECURITYGROUP$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NETWORKINTERFACE$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$PUBLICIP$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$PRIVATEIP$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$PUBLICDNS$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$PRIVATEDNS$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$BOOTDISK$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$BLOCKDISK$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$SSHACCESSPOINT$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$ACCESSKEY$$&lt;/font&gt;
                            &lt;br&gt;
                            &lt;font size=%s&gt;$$ACCESSUSER$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$VMNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize,
                fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VMNAME$$", one.IId.NameId)
                status := vmStatus(connConfig, one.IId.NameId)
                str = strings.ReplaceAll(str, "$$VMSTATUS$$", status)
                str = strings.ReplaceAll(str, "$$LASTSTARTTIME$$", one.StartTime.Format("2006.01.02 15:04:05 Mon"))

                // for Image &amp; Spec
                str = strings.ReplaceAll(str, "$$IMAGE$$", one.ImageIId.NameId)
                str = strings.ReplaceAll(str, "$$SPEC$$", one.VMSpecName)

                // for VPC &amp; Subnet
                str = strings.ReplaceAll(str, "$$VPC$$", one.VpcIID.NameId)
                str = strings.ReplaceAll(str, "$$SUBNET$$", one.SubnetIID.NameId)

                // for security rules info
                strSRList := ""
                for _, one := range one.SecurityGroupIIds </span><span class="cov0" title="0">{
                        resBody, err := getResource_with_Connection_JsonByte(connConfig, "securitygroup", one.NameId)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                break</span>
                        }
                        <span class="cov0" title="0">var secInfo cres.SecurityInfo
                        json.Unmarshal(resBody, &amp;secInfo)

                        strSRList += "["
                        for _, secRuleInfo := range *secInfo.SecurityRules </span><span class="cov0" title="0">{
                                strSRList += "{FromPort:" + secRuleInfo.FromPort + ", "
                                strSRList += "ToPort:" + secRuleInfo.ToPort + ", "
                                strSRList += "IPProtocol:" + secRuleInfo.IPProtocol + ", "
                                strSRList += "Direction:" + secRuleInfo.Direction + ", "
                                strSRList += "CIDR:" + secRuleInfo.CIDR
                                strSRList += "},&lt;br&gt;"
                        }</span>
                        <span class="cov0" title="0">strSRList += "]"</span>
                }
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$SECURITYGROUP$$", strSRList)

                // for Network Interface &amp; PublicIP &amp; PrivateIP
                str = strings.ReplaceAll(str, "$$NETWORKINTERFACE$$", one.NetworkInterface)
                str = strings.ReplaceAll(str, "$$PUBLICIP$$", one.PublicIP)
                str = strings.ReplaceAll(str, "$$PRIVATEIP$$", one.PrivateIP)

                // for Public DNS &amp; Private DNS
                str = strings.ReplaceAll(str, "$$PUBLICDNS$$", one.PublicDNS)
                str = strings.ReplaceAll(str, "$$PRIVATEDNS$$", one.PrivateDNS)

                // for Boot Disk &amp; Block Disk
                str = strings.ReplaceAll(str, "$$BOOTDISK$$", one.VMBootDisk)
                str = strings.ReplaceAll(str, "$$BLOCKDISK$$", one.VMBlockDisk)

                // for SSH AccessPoint &amp; Access Key &amp; Access User
                str = strings.ReplaceAll(str, "$$SSHACCESSPOINT$$", one.SSHAccessPoint)
                str = strings.ReplaceAll(str, "$$ACCESSKEY$$", one.KeyPairIId.NameId)
                str = strings.ReplaceAll(str, "$$ACCESSUSER$$", one.VMUserId)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostVMFunc_js() string <span class="cov0" title="0">{

        // curl -sX POST http://localhost:1024/spider/vm -H 'Content-Type: application/json'
        //  -d '{ "ConnectionName": "'${CONN_CONFIG}'",
        //  "ReqInfo": { "Name": "vm-01", "ImageName": "ami-0bbe28eb2173f6167", "VPCName": "vpc-01",
        //  "SubnetName": "subnet-01", "SecurityGroupNames": [ "sg-01" ], "VMSpecName": "t2.micro", "KeyPairName": "keypair-01"} }'

        strFunc := `
                function postVM() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ConnectionName" : "' + connConfig + '", "ReqInfo" : { "Name" : "$$VMNAME$$", \
                                "ImageName" : "$$IMAGE$$", "VMSpecName" : "$$SPEC$$", "VPCName" : "$$VPC$$", "SubnetName" : "$$SUBNET$$", \
                                "SecurityGroupNames" : $$SECURITYGROUP$$, "KeyPairName" : "$$ACCESSKEY$$", "VMUserId" : "$$ACCESSUSER$$", "VMUserPasswd" : "$$ACCESSPASSWD$$" }}'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$VMNAME$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$IMAGE$$", textboxes[i].value);
                                                break;
                                        case "4":
                                                sendJson = sendJson.replace("$$SPEC$$", textboxes[i].value);
                                                break;
                                        case "5":
                                                sendJson = sendJson.replace("$$VPC$$", textboxes[i].value);
                                                break;
                                        case "6":
                                                sendJson = sendJson.replace("$$SUBNET$$", textboxes[i].value);
                                                break;
                                        case "7":
                                                sendJson = sendJson.replace("$$SECURITYGROUP$$", textboxes[i].value);
                                                break;
                                        case "11":
                                                sendJson = sendJson.replace("$$ACCESSKEY$$", textboxes[i].value);
                                                break;
                                        case "12":
                                                sendJson = sendJson.replace("$$ACCESSUSER$$", textboxes[i].value);
                                                break;
                                        case "13":
                                                sendJson = sendJson.replace("$$ACCESSPASSWD$$", textboxes[i].value);
                                                break;

                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/vm", false);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteVMFunc_js() string <span class="cov0" title="0">{
        // curl -sX DELETE http://localhost:1024/spider/vm/vm-01 -H 'Content-Type: application/json' -d '{ "ConnectionName": "'${CONN_CONFIG}'"}'

        strFunc := `
                function deleteVM() {
                        var connConfig = parent.frames["top_frame"].document.getElementById("connConfig").innerHTML;
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/vm/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                    sendJson = '{ "ConnectionName": "' + connConfig + '"}'
                                        xhr.send(sendJson);
                                }
                        }
            location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://"+cr.ServiceIPorName+cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func VM(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VM()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeCheckBoxToggleFunc_js()
        htmlStr += makePostVMFunc_js()
        htmlStr += makeDeleteVMFunc_js()

        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
        // colspan, f5_href, delete_href, fontSize
        htmlStr += makeActionTR_html("11", "", "deleteVM()", "2")

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VM Name / Control", "200"},
                {"VM Status / Last Start Time", "200"},
                {"VM Image / VM Spec", "200"},
                {"VPC / Subnet / Security Group", "400"},
                {"NetworkInterface / PublicIP / PrivateIP", "400"},
                {"PublicDNS / PrivateDNS", "400"},
                {"BootDisk / BlockDisk", "200"},
                {"SSH AccessPoint / Access Key / Access User", "200"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vm")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.VMInfo `json:"vm"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVMTRList_html(connConfig, "", "", "", info.ResultList)

        // (5) make input field and add
        // attach text box for add
        nameList := vpcList(connConfig)
        keyNameList := keyPairList(connConfig)
        providerName, _ := getProviderName(connConfig)

        imageName := ""
        specName := ""
        subnetName := ""
        sgName := ""
        vmUser := "" // AWS:ec2-user, Azure&amp;GCP:cb-user, Alibaba&amp;Cloudit:root, OpenStack: ubuntu
        switch providerName </span>{
        case "AWS":<span class="cov0" title="0">
                imageName = "ami-0bbe28eb2173f6167"
                specName = "t2.micro"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "ec2-user"</span>
        case "AZURE":<span class="cov0" title="0">
                imageName = "Canonical:UbuntuServer:18.04-LTS:latest"
                specName = "Standard_B1ls"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "cb-user"</span>
        case "GCP":<span class="cov0" title="0">
                imageName = "https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/ubuntu-minimal-1804-bionic-v20191024"
                specName = "f1-micro"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "cb-user"</span>
        case "ALIBABA":<span class="cov0" title="0">
                imageName = "ubuntu_18_04_x64_20G_alibase_20200220.vhd"
                specName = "ecs.t5-lc1m2.small"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "root"</span>
        case "CLOUDIT":<span class="cov0" title="0">
                imageName = "CentOS-7"
                specName = "small-2"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "root"</span>
        case "OPENSTACK":<span class="cov0" title="0">
                imageName = "Ubuntu16.04_2"
                specName = "nano.1"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "ubuntu"</span>
        case "DOCKER":<span class="cov0" title="0">
                imageName = "nginx:latest"
                subnetName = ""
                sgName = `[]`
                specName = ""
                vmUser = ""</span>
        case "MOCK":<span class="cov0" title="0">
                imageName = "mock-vmimage-01"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                specName = "mock-vmspec-01"
                vmUser = "cb-user"</span>
        case "CLOUDTWIN":<span class="cov0" title="0">
                imageName = "ubuntu18.04-sshd-systemd"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                specName = "spec-1"
                vmUser = "cb-user"</span>
        default:<span class="cov0" title="0">
                imageName = "ami-0bbe28eb2173f6167"
                specName = "t2.micro"
                subnetName = "subnet-01"
                sgName = `["sg-01"]`
                vmUser = "ec2-user"</span>
        }

        <span class="cov0" title="0">htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="vm-01"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="$$IMAGENAME$$"&gt;
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="4" value="$$SPECNAME$$"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                            `
        // Select format of VPC  name=text_box, id=5
        htmlStr += makeSelect_html("onchangeVPC", nameList, "5")

        htmlStr += `

                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="6" value="$$SUBNETNAME$$"&gt;
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="7" value=$$SGNAME$$&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="8" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="9" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="10" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                            `
        // Select format of KeyPair  name=text_box, id=11
        htmlStr += makeKeyPairSelect_html("onchangeKeyPair", keyNameList, "11")

        htmlStr += `
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="12" value="$$VMUSER$$"&gt;
                                &lt;br&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="password" name="text_box" id="13" value=""&gt;
                            &lt;/td&gt;
                            &lt;td style="vertical-align:top"&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="14" disabled value="N/A"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postVM()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `

        // set imageName &amp; specName &amp; vmUser
        htmlStr = strings.ReplaceAll(htmlStr, "$$IMAGENAME$$", imageName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$SPECNAME$$", specName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$SUBNETNAME$$", subnetName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$SGNAME$$", sgName)
        htmlStr = strings.ReplaceAll(htmlStr, "$$VMUSER$$", vmUser)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VMImage

// number, VMImage Name, GuestOS, VMImage Status, KeyValueList
func makeVMImageTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.ImageInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMIMAGENAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$GUESTOS$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMIMAGESTATUS$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VMIMAGENAME$$", one.IId.NameId)
                str = strings.ReplaceAll(str, "$$GUESTOS$$", one.GuestOS)
                str = strings.ReplaceAll(str, "$$VMIMAGESTATUS$$", one.Status)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

func VMImage(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VMImage()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;/head&gt;

                &lt;body&gt;
        &lt;br&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VMImage Name", "200"},
                {"GuestOS", "300"},
                {"VMImage Status", "200"},
                {"Additional Info", "400"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, false)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vmimage")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.ImageInfo `json:"image"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVMImageTRList_html("", "", "", info.ResultList)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//====================================== VMSpec

// number, VMSpec Name, VCPU, Memory, GPU, KeyValueList
func makeVMSpecTRList_html(bgcolor string, height string, fontSize string, infoList []*cres.VMSpecInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{
                bgcolor = "#FFFFFF"
        }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{
                height = "30"
        }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{
                fontSize = "2"
        }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$VMSPECNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$VCPUINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$MEMINFO$$ MB&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$GPUINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td align="left"&gt;
                            &lt;font size=%s&gt;$$ADDITIONALINFO$$&lt;/font&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList </span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$VMSPECNAME$$", one.Name)
                // VCPU Info: count, GHz
                vcpuInfo := "&amp;nbsp;* Count: " + one.VCpu.Count + "&lt;br&gt;"
                vcpuInfo += "&amp;nbsp;* Clock: " + one.VCpu.Clock + "GHz" + "&lt;br&gt;"
                str = strings.ReplaceAll(str, "$$VCPUINFO$$", vcpuInfo)

                // Mem Info
                str = strings.ReplaceAll(str, "$$MEMINFO$$", one.Mem)

                // GPU Info: Mfr, Model, Mem, Count
                gpuInfo := ""
                for _, gpu := range one.Gpu </span><span class="cov0" title="0">{
                        gpuInfo += "&amp;nbsp;* Mfr: " + gpu.Mfr + "&lt;br&gt;"
                        gpuInfo += "&amp;nbsp;* Model: " + gpu.Model + "&lt;br&gt;"
                        gpuInfo += "&amp;nbsp;* Memory: " + gpu.Mem + " MB" + "&lt;br&gt;"
                        gpuInfo += "&amp;nbsp;* Count: " + gpu.Count + "&lt;br&gt;&lt;br&gt;"
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$GPUINFO$$", gpuInfo)

                // for KeyValueList
                strKeyList := ""
                for _, kv := range one.KeyValueList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$ADDITIONALINFO$$", strKeyList)

                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

func VMSpec(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call VMSpec()")

        connConfig := c.Param("ConnectConfig")
        if connConfig == "region not set" </span><span class="cov0" title="0">{
                htmlStr := `
            &lt;html&gt;
            &lt;head&gt;
                &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;script type="text/javascript"&gt;
                alert(connConfig)
                &lt;/script&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;label style="font-size:24px;color:#606262;"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;Please select a Connection Configuration! (MENU: 2.CONNECTION)&lt;/label&gt;   
            &lt;/body&gt;
        `

                return c.HTML(http.StatusOK, htmlStr)
        }</span>

        // make page header
        <span class="cov0" title="0">htmlStr := `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;/head&gt;

                &lt;body&gt;
        &lt;br&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (3) make Table Header TR
        nameWidthList := []NameWidth{
                {"VMSpec Name", "200"},
                {"VCPU", "300"},
                {"Memory", "200"},
                {"GPU", "300"},
                {"Additional Info", "300"},
        }
        htmlStr += makeTitleTRList_html("#DDDDDD", "2", nameWidthList, false)

        // (4) make TR list with info list
        // (4-1) get info list
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vmspec")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []*cres.VMSpecInfo `json:"vmspec"`
        }
        json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
        htmlStr += makeVMSpecTRList_html("", "", "", info.ResultList)

        // make page tail
        htmlStr += `
                    &lt;/table&gt;
            &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

        //fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"
        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"
        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
        "strconv"

        "net/http"
        "strings"
        "github.com/labstack/echo/v4"
        "encoding/json"
)

// number, Provider Name, Driver File, Driver Name, checkbox
func makeDriverTRList_html(bgcolor string, height string, fontSize string, infoList []*dim.CloudDriverInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S1$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$S3$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                       `, bgcolor, height, fontSize, fontSize, fontSize, fontSize) 

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$S1$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$S2$$", one.DriverLibFileName)
                str = strings.ReplaceAll(str, "$$S3$$", one.DriverName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makeOnchangeDriverProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
                document.getElementById('2').value= providerName.toLowerCase() + "-driver-v1.0.so";
                document.getElementById('3').value= providerName.toLowerCase() + "-driver-01";
              }
        `

        return strFunc
}</span>

// make the string of javascript function
func makeCheckBoxToggleFunc_js() string <span class="cov0" title="0">{

        strFunc := `
              function toggle(source) {
                var checkboxes = document.getElementsByName('check_box');
                for (var i = 0; i &lt; checkboxes.length; i++) {
                  checkboxes[i].checked = source.checked;
                }
              }
        `

        return strFunc
}</span>

// make the string of javascript function
func makePostDriverFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/driver -H 'Content-Type: application/json'  -d '{"DriverName":"aws-driver01","ProviderName":"AWS", "DriverLibFileName":"aws-driver-v1.0.so"}'

        strFunc := `
                function postDriver() {
                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ProviderName" : "$$PROVIDER$$", "DriverLibFileName" : "$$$DRVFILE$$", "DriverName" : "$$NAME$$" }'
                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$$DRVFILE$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/driver", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        //xhr.send(JSON.stringify({ "DriverName": driverName, "ProviderName": providerName, "DriverLibFileName": driverLibFileName}));
                        //xhr.send(JSON.stringify(sendJson));
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteDriverFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/driver/gcp-driver01 -H 'Content-Type: application/json'

        strFunc := `
                function deleteDriver() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/driver/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

//================ Driver Info Management
// create driver page
func Driver(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Driver()")

        // make page header
        htmlStr :=  ` 
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeOnchangeDriverProviderFunc_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostDriverFunc_js()
                htmlStr += makeDeleteDriverFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;      
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("5", "driver", "deleteDriver()", "2")


        // (3) make Table Header TR
                
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Driver Library Name", "300"},
                    {"Driver Name", "200"},
                }        
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("driver")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*dim.CloudDriverInfo `json:"driver"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeDriverTRList_html("", "", "", info.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
                `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")

                htmlStr += `
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="2" value="aws-driver-v1.0.so"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="aws-driver-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postDriver()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

// make the string of javascript function
func makeOnchangeCredentialProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
                // for credential info
                switch(providerName) {
                  case "AWS":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]'
                    break;
                  case "AZURE":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXX-XXXX"}, {"Key":"ClientSecret", "Value":"xxxx-xxxx"}, {"Key":"TenantId", "Value":"xxxx-xxxx"}, {"Key":"SubscriptionId", "Value":"xxxx-xxxx"}]'
                    break;
                  case "GCP":
                        credentialInfo = '[{"Key":"PrivateKey", "Value":"-----BEGIN PRIVATE KEY-----\nXXXX\n-----END PRIVATE KEY-----\n"},{"Key":"ProjectID", "Value":"powerkimhub"}, {"Key":"ClientEmail", "Value":"xxxx@xxxx.iam.gserviceaccount.com"}]'
                    break;
                  case "ALIBABA":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]'
                    break;
                  case "CLOUDIT":
                        credentialInfo = '[{"Key":"IdentityEndpoint", "Value":"http://xxx.xxx.co.kr:9090"}, {"Key":"AuthToken", "Value":"xxxx"}, {"Key":"Username", "Value":"xxxx"}, {"Key":"Password", "Value":"xxxx"}, {"Key":"TenantId", "Value":"tnt0009"}]'
                    break;
                  case "OPENSTACK":
                        credentialInfo = '[{"Key":"IdentityEndpoint", "Value":"http://123.456.789.123:5000/v3"}, {"Key":"Username", "Value":"etri"}, {"Key":"Password", "Value":"xxxx"}, {"Key":"DomainName", "Value":"default"}, {"Key":"ProjectID", "Value":"xxxx"}]'
                    break;
                  case "DOCKER":
                        credentialInfo = '[{"Key":"Host", "Value":"http://123.456.789.123:1004"}, {"Key":"APIVersion", "Value":"v1.38"}]'
                    break;

                  case "NCP":
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXXXXXXXXXXXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXXXXXXXXXXXXXXXXXXXXXXX"}]'
                    break;
                  case "MOCK":
                        credentialInfo = '[{"Key":"MockName", "Value":"mock_name00"}]'
                    break;
                  case "CLOUDTWIN":
                        credentialInfo = '[{"Key":"IdentityEndpoint", "Value":"http://123.456.789.123:8192"}, {"Key":"DomainName", "Value":"cloud-1"}, {"Key":"MockName", "Value":"mock_name01"}]'
                    break;
                  default:
                        credentialInfo = '[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]'
                }
                document.getElementById('2').value= credentialInfo

                // for credential name
                document.getElementById('3').value= providerName.toLowerCase() + "-credential-01";
              }
        `
        return strFunc
}</span>

// number, Provider Name, Credential Info, Credential Name, checkbox
func makeCredentialTRList_html(bgcolor string, height string, fontSize string, infoList []*cim.CredentialInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S1$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$S3$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$S1$$", one.ProviderName)
                strKeyList := ""
                for _, kv := range one.KeyValueInfoList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":xxxx, "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$S2$$", strKeyList)
                str = strings.ReplaceAll(str, "$$S3$$", one.CredentialName)
                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostCredentialFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/credential -H 'Content-Type: application/json' '{"CredentialName":"aws-credential-01","ProviderName":"AWS", "KeyValueInfoList": [{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]}'

        strFunc := `
                function postCredential() {
                        var textboxes = document.getElementsByName('text_box');
                        sendJson = '{ "ProviderName" : "$$PROVIDER$$", "KeyValueInfoList" : $$CREDENTIALINFO$$, "CredentialName" : "$$NAME$$" }'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$CREDENTIALINFO$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/credential", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        //xhr.send(JSON.stringify({ "CredentialName": credentialName, "ProviderName": providerName, "KeyValueInfoList": credentialInfo}));
                        //xhr.send(JSON.stringify(sendJson));
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteCredentialFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/credential/aws-credential-01 -H 'Content-Type: application/json'

        strFunc := `
                function deleteCredential() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/credential/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

//================ Credential Info Management
// create credential page
func Credential(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Credential()")

        // make page header
        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
                htmlStr += makeOnchangeCredentialProviderFunc_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostCredentialFunc_js()
                htmlStr += makeDeleteCredentialFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("5", "credential", "deleteCredential()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Credential Info", "300"},
                    {"Credential Name", "200"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("credential")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*cim.CredentialInfo `json:"credential"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeCredentialTRList_html("", "", "", info.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
                `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")
                        
                htmlStr += `        
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="2" cols=50&gt;[{"Key":"ClientId", "Value":"XXXXXX"}, {"Key":"ClientSecret", "Value":"XXXXXX"}]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="aws-credential-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postCredential()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

// make the string of javascript function
func makeOnchangeRegionProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
        // for region info
        switch(providerName) {
          case "AWS":
            regionInfo = '[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]'
            region = '(ohio)us-east-2'
            zone = ''
            break;
          case "AZURE":
            regionInfo = '[{"Key":"location", "Value":"northeurope"}, {"Key":"ResourceGroup", "Value":"CB-GROUP-POWERKIM"}]'
            region = 'northeurope'
            zone = ''            
            break;
          case "GCP":
            regionInfo = '[{"Key":"Region", "Value":"us-central1"},{"Key":"Zone", "Value":"us-central1-a"}]'
            region = 'us-central1'
            zone = 'us-central1-a'             
            break;
          case "ALIBABA":
            regionInfo = '[{"Key":"Region", "Value":"ap-northeast-1"}, {"Key":"Zone", "Value":"ap-northeast-1a"}]'
            region = 'ap-northeast-1'
            zone = 'ap-northeast-1a'             
            break;
          case "CLOUDIT":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = ''            
            break;
          case "OPENSTACK":
            regionInfo = '[{"Key":"Region", "Value":"RegionOne"}]'
            region = 'RegionOne'
            zone = 'RegionOne'            
            break;
          case "DOCKER":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = ''             
            break;

          case "NCP":
            regionInfo = '[{"Key":"region", "Value":"KR"}]'
            region = 'KR'
            zone = ''             
            break;

          case "MOCK":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = ''             
            break;
          case "CLOUDTWIN":
            regionInfo = '[{"Key":"Region", "Value":"default"}]'
            region = 'default'
            zone = '' 
            break;
          default:
            regionInfo = '[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]'
            region = '(ohio)us-east-2'
            zone = ''
        }
                document.getElementById('2').value= regionInfo

        // for region-zone name
                document.getElementById('3').value= providerName.toLowerCase() + "-" + region + "-" + zone;
              }
        `
        return strFunc
}</span>

// number, Provider Name, Region Info, Region Name, checkbox
func makeRegionTRList_html(bgcolor string, height string, fontSize string, infoList []*rim.RegionInfo) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S1$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$S3$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$S1$$", one.ProviderName)
        strKeyList := ""
                for _, kv := range one.KeyValueInfoList </span><span class="cov0" title="0">{
                        strKeyList += kv.Key + ":" + kv.Value + ", "
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$S2$$", strKeyList)
                str = strings.ReplaceAll(str, "$$S3$$", one.RegionName)
                strData += str</span>
        }

        <span class="cov0" title="0">return strData</span>
}

// make the string of javascript function
func makePostRegionFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/region -H 'Content-Type: application/json' 
//      -d '{"RegionName":"aws-(ohio)us-east-2","ProviderName":"AWS", "KeyValueInfoList": 
//.       '[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]'}'

        strFunc := `
                function postRegion() {
                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ProviderName" : "$$PROVIDER$$", "KeyValueInfoList" : $$REGIONINFO$$, "RegionName" : "$$NAME$$" }'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$REGIONINFO$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/region", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        //xhr.send(JSON.stringify({ "RegionName": regionName, "ProviderName": providerName, "KeyValueInfoList": regionInfo}));
                        //xhr.send(JSON.stringify(sendJson));
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteRegionFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/region/aws-(ohio)us-east-2 -H 'Content-Type: application/json'

        strFunc := `
                function deleteRegion() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/region/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

//================ Region Info Management
// create region page
func Region(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Region()")

        // make page header
        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeOnchangeRegionProviderFunc_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostRegionFunc_js()
                htmlStr += makeDeleteRegionFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("5", "region", "deleteRegion()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Region Info", "300"},
                    {"Region Name", "200"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)


        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("region")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*rim.RegionInfo `json:"region"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                htmlStr += makeRegionTRList_html("", "", "", info.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
        `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")
            
        htmlStr += `    
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;textarea style="font-size:12px;text-align:center;" name="text_box" id="2" cols=50&gt;[{"Key":"Region", "Value":"us-east-2"}, {"Key":"Zone", "Value":"us-east-2a"}]&lt;/textarea&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="3" value="aws-(ohio)us-east-2"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a href="javascript:postRegion()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

// make the string of javascript function
func makeOnInitialInputBoxSetup_js() string <span class="cov0" title="0">{
        strFunc := `
              function onInitialSetup() {
                 cspSelect = document.getElementById('1')
                 onchangeProvider(cspSelect) 
              }
        `
        return strFunc
}</span>

// make the string of javascript function
func makeOnchangeConnectionConfigProviderFunc_js() string <span class="cov0" title="0">{
        strFunc := `
              function onchangeProvider(source) {
                var providerName = source.value
        // for credential info
        var driverNameList = []
        var credentialNameList
        var regionNameList
        switch(providerName) {
          case "AWS":
            driverNameList = document.getElementsByName('driverName-AWS');
            credentialNameList = document.getElementsByName('credentialName-AWS');
            regionNameList = document.getElementsByName('regionName-AWS');
            break;
          case "AZURE":
            driverNameList = document.getElementsByName('driverName-AZURE');
            credentialNameList = document.getElementsByName('credentialName-AZURE');
            regionNameList = document.getElementsByName('regionName-AZURE');
            break;
          case "GCP":
            driverNameList = document.getElementsByName('driverName-GCP');
            credentialNameList = document.getElementsByName('credentialName-GCP');
            regionNameList = document.getElementsByName('regionName-GCP');
            break;
          case "ALIBABA":
            driverNameList = document.getElementsByName('driverName-ALIBABA');
            credentialNameList = document.getElementsByName('credentialName-ALIBABA');
            regionNameList = document.getElementsByName('regionName-ALIBABA');
            break;
          case "CLOUDIT":
            driverNameList = document.getElementsByName('driverName-CLOUDIT');
            credentialNameList = document.getElementsByName('credentialName-CLOUDIT');
            regionNameList = document.getElementsByName('regionName-CLOUDIT');
            break;
          case "OPENSTACK":
            driverNameList = document.getElementsByName('driverName-OPENSTACK');
            credentialNameList = document.getElementsByName('credentialName-OPENSTACK');
            regionNameList = document.getElementsByName('regionName-OPENSTACK');
            break;
          case "DOCKER":
            driverNameList = document.getElementsByName('driverName-DOCKER');
            credentialNameList = document.getElementsByName('credentialName-DOCKER');
            regionNameList = document.getElementsByName('regionName-DOCKER');
            break;
          case "NCP":
            driverNameList = document.getElementsByName('driverName-NCP');
            credentialNameList = document.getElementsByName('credentialName-NCP');
            regionNameList = document.getElementsByName('regionName-NCP');
            break;
          case "MOCK":
            driverNameList = document.getElementsByName('driverName-MOCK');
            credentialNameList = document.getElementsByName('credentialName-MOCK');
            regionNameList = document.getElementsByName('regionName-MOCK');
            break;
          case "CLOUDTWIN":
            driverNameList = document.getElementsByName('driverName-CLOUDTWIN');
            credentialNameList = document.getElementsByName('credentialName-CLOUDTWIN');
            regionNameList = document.getElementsByName('regionName-CLOUDTWIN');
            break;
          default:
            driverNameList = document.getElementsByName('driverName-AWS');
            credentialNameList = document.getElementsByName('credentialName-AWS');
            regionNameList = document.getElementsByName('regionName-AWS');
        }

        // Select Tag for drivers
        //  options remove &amp; create
        var len = document.getElementById('2').options.length
        for (var i=0; i &lt; len; i++) {
                document.getElementById('2').remove(0);
        }
        for (var i=0; i &lt; driverNameList.length; i++) {
                document.getElementById('2').options.add(new Option(driverNameList[i].innerHTML, driverNameList[i].innerHTML));
        }

        // Select Tag for Credentials
        //  options remove &amp; create
        var len = document.getElementById('3').options.length
        for (var i=0; i &lt; len; i++) {
                document.getElementById('3').remove(0);
        }
        for (var i=0; i &lt; credentialNameList.length; i++) {
                document.getElementById('3').options.add(new Option(credentialNameList[i].innerHTML, credentialNameList[i].innerHTML));
        }

        // Select Tag for Regions
        //  options remove &amp; create
        var len = document.getElementById('4').options.length
        for (var i=0; i &lt; len; i++) {
                document.getElementById('4').remove(0);
        }
        for (var i=0; i &lt; regionNameList.length; i++) {
                document.getElementById('4').options.add(new Option(regionNameList[i].innerHTML, regionNameList[i].innerHTML));
        }

        document.getElementById('5').value= providerName.toLowerCase() + "-" +  document.getElementById('4').value + "-connection-config-01";

              }
        `
        return strFunc
}</span>

func getProviderName(connConfig string) (string, error) <span class="cov0" title="0">{
        resBody, err := getResource_JsonByte("connectionconfig", connConfig)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">var configInfo ccim.ConnectionConfigInfo
        json.Unmarshal(resBody, &amp;configInfo)

        return configInfo.ProviderName, nil</span>
}

func getRegionZone(regionName string) (string, string, error) <span class="cov0" title="0">{
        // Region Name List
        resBody, err := getResource_JsonByte("region", regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return "", "", err 
        }</span>
        <span class="cov0" title="0">var regionInfo rim.RegionInfo
        json.Unmarshal(resBody, &amp;regionInfo)

        region := ""
        zone := ""
        // get the region &amp; zone
        for _, one := range regionInfo.KeyValueInfoList </span><span class="cov0" title="0">{
                if one.Key == "Region" || one.Key == "region" </span><span class="cov0" title="0">{
                        region = one.Value
                }</span>
                <span class="cov0" title="0">if one.Key == "location" </span><span class="cov0" title="0">{
                        region = one.Value
                }</span>
                <span class="cov0" title="0">if one.Key == "Zone" || one.Key == "zone" </span><span class="cov0" title="0">{
                        zone = one.Value
                }</span>
                
        }
        <span class="cov0" title="0">return region, zone, nil</span>
}

// make the string of javascript function
func makeSetupConnectionConfigFunc_js() string <span class="cov0" title="0">{

        strFunc := `
                function setupConnectionConfig(configName, providerName, region, zone) {
                        var connConfigLabel = parent.frames["top_frame"].document.getElementById("connConfig");
                        connConfigLabel.innerHTML = configName

                        var cspText = parent.frames["top_frame"].document.getElementById("connDisplay");
                        if (zone) {
                                cspText.value = providerName + ": " + region + " / " + zone
                        } else {
                                cspText.value = providerName + ": " + region
                        }

                        // for vpc
                        var a = parent.frames["top_frame"].document.getElementById("vpcHref");
                        a.href = "vpc/" + configName
                        a = parent.frames["top_frame"].document.getElementById("vpcmgmtHref");
                        a.href = "vpcmgmt/" + configName

                        // for securitygroup
                        a = parent.frames["top_frame"].document.getElementById("securitygroupHref");
                        a.href = "securitygroup/" + configName
                        a = parent.frames["top_frame"].document.getElementById("securitygroupmgmtHref");
                        a.href = "securitygroupmgmt/" + configName

                        // for KeyPair
                        a = parent.frames["top_frame"].document.getElementById("keypairHref");
                        a.href = "keypair/" + configName
                        a = parent.frames["top_frame"].document.getElementById("keypairmgmtHref");
                        a.href = "keypairmgmt/" + configName

                        // for vm
                        a = parent.frames["top_frame"].document.getElementById("vmHref");
                        a.href = "vm/" + configName
                        a = parent.frames["top_frame"].document.getElementById("vmmgmtHref");
                        a.href = "vmmgmt/" + configName


                    // for VMImage
                    a = parent.frames["top_frame"].document.getElementById("vmimageHref");
                    a.href = "vmimage/" + configName

                    // for VMSpec
                    a = parent.frames["top_frame"].document.getElementById("vmspecHref");
                    a.href = "vmspec/" + configName

                }
        `
        return strFunc
}</span>

// number, Provider Name, Driver Name, Credential Name, Region Name, Connection Name, checkbox
func makeConnectionConfigTRList_html(bgcolor string, height string, fontSize string, infoList []*ccim.ConnectionConfigInfo) (string, error) <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#FFFFFF" }</span>
        <span class="cov0" title="0">if height == "" </span><span class="cov0" title="0">{ height = "30" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // make base TR frame for info list
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center" height="%s"&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$NUM$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$PROVIDERNAME$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S2$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S3$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                            &lt;font size=%s&gt;$$S4$$&lt;/font&gt;
                    &lt;/td&gt;
                    &lt;td&gt;                                       &lt;!-- configName, CSP, Region, Zone --&gt;
                        &lt;a href="javascript:setupConnectionConfig('$$CONFIGNAME$$', '$$PROVIDERNAME$$', '$$REGION$$', '$$ZONE$$')"&gt;
                            &lt;font size=%s&gt;$$CONFIGNAME$$&lt;/font&gt;
                        &lt;/a&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;input type="checkbox" name="check_box" value=$$CONFIGNAME$$&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                `, bgcolor, height, fontSize, fontSize, fontSize, fontSize, fontSize, fontSize)

        strData := ""
        // set data and make TR list
        for i, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$NUM$$", strconv.Itoa(i+1))
                str = strings.ReplaceAll(str, "$$PROVIDERNAME$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$S2$$", one.DriverName)
                str = strings.ReplaceAll(str, "$$S3$$", one.CredentialName)
                str = strings.ReplaceAll(str, "$$S4$$", one.RegionName)
                str = strings.ReplaceAll(str, "$$CONFIGNAME$$", one.ConfigName)

                region, zone, err := getRegionZone(one.RegionName)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return "", err
                }</span>
                <span class="cov0" title="0">str = strings.ReplaceAll(str, "$$REGION$$", region)
                str = strings.ReplaceAll(str, "$$ZONE$$", zone)
        
                strData += str</span>
        }

        <span class="cov0" title="0">return strData, nil</span>
}

// make the string of javascript function
func makePostConnectionConfigFunc_js() string <span class="cov0" title="0">{

// curl -X POST http://$RESTSERVER:1024/spider/connectionconfig -H 'Content-Type: application/json' 
//    -d '{"ProviderName":"AWS", "DriverName":"aws-driver01", "CredentialName":"aws-credential-01", "RegionName":"aws-ohio", "ConfigName":"aws-ohio-config",}'

        strFunc := `
                function postConnectionConfig() {
                        var textboxes = document.getElementsByName('text_box');
            sendJson = '{ "ProviderName" : "$$PROVIDER$$", "DriverName" : "$$DRIVERNAME$$", "CredentialName" : "$$CREDENTIALNAME$$", \
                                                "RegionName" : "$$REGIONNAME$$", "ConfigName" : "$$NAME$$" }'

                        for (var i = 0; i &lt; textboxes.length; i++) { // @todo make parallel executions
                                switch (textboxes[i].id) {
                                        case "1":
                                                sendJson = sendJson.replace("$$PROVIDER$$", textboxes[i].value);
                                                break;
                                        case "2":
                                                sendJson = sendJson.replace("$$DRIVERNAME$$", textboxes[i].value);
                                                break;
                                        case "3":
                                                sendJson = sendJson.replace("$$CREDENTIALNAME$$", textboxes[i].value);
                                                break;
                                        case "4":
                                                sendJson = sendJson.replace("$$REGIONNAME$$", textboxes[i].value);
                                                break;                                                
                                        case "5":
                                                sendJson = sendJson.replace("$$NAME$$", textboxes[i].value);
                                                break;
                                        default:
                                                break;
                                }
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "$$SPIDER_SERVER$$/spider/connectionconfig", true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(sendJson);

                        setTimeout(function(){
                                location.reload();
                        }, 400);

                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

// make the string of javascript function
func makeDeleteConnectionConfigFunc_js() string <span class="cov0" title="0">{
// curl -X DELETE http://$RESTSERVER:1024/spider/connectionconfig/aws-connection01 -H 'Content-Type: application/json'

        strFunc := `
                function deleteConnectionConfig() {
                        var checkboxes = document.getElementsByName('check_box');
                        for (var i = 0; i &lt; checkboxes.length; i++) { // @todo make parallel executions
                                if (checkboxes[i].checked) {
                                        var xhr = new XMLHttpRequest();
                                        xhr.open("DELETE", "$$SPIDER_SERVER$$/spider/connectionconfig/" + checkboxes[i].value, false);
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                        xhr.send(null);
                                }
                        }
                        location.reload();
                }
        `
        strFunc = strings.ReplaceAll(strFunc, "$$SPIDER_SERVER$$", "http://" + cr.ServiceIPorName + cr.ServicePort) // cr.ServicePort = ":1024"
        return strFunc
}</span>

func makeDriverNameHiddenTRList_html(infoList []*dim.CloudDriverInfo) string <span class="cov0" title="0">{

        // make base Label frame for info list
        strTR := `&lt;label name="driverName-$$CSP$$" hidden&gt;$$DRIVERNAME$$&lt;/label&gt;`

        strData := ""
        // set data and make TR list
        for _, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$CSP$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$DRIVERNAME$$", one.DriverName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

func makeCredentialNameHiddenTRList_html(infoList []*cim.CredentialInfo) string <span class="cov0" title="0">{

        // make base Label frame for info list
        strTR := `&lt;label name="credentialName-$$CSP$$" hidden&gt;$$CREDENTIALNAME$$&lt;/label&gt;`

        strData := ""
        // set data and make TR list
        for _, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$CSP$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$CREDENTIALNAME$$", one.CredentialName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

func makeRegionNameHiddenTRList_html(infoList []*rim.RegionInfo) string <span class="cov0" title="0">{

        // make base Label frame for info list
        strTR := `&lt;label name="regionName-$$CSP$$" hidden&gt;$$REGIONNAME$$&lt;/label&gt;`

        strData := ""
        // set data and make TR list
        for _, one := range infoList</span><span class="cov0" title="0">{
                str := strings.ReplaceAll(strTR, "$$CSP$$", one.ProviderName)
                str = strings.ReplaceAll(str, "$$REGIONNAME$$", one.RegionName)
                strData += str
        }</span>

        <span class="cov0" title="0">return strData</span>
}

//================ Connection Config Info Management
// create Connection page
func Connectionconfig(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Connectionconfig()")

        // make page header
        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                    &lt;script type="text/javascript"&gt;
                `
        // (1) make Javascript Function
        htmlStr += makeOnchangeConnectionConfigProviderFunc_js()
                htmlStr += makeSetupConnectionConfigFunc_js()
                htmlStr += makeOnInitialInputBoxSetup_js()
                htmlStr += makeCheckBoxToggleFunc_js()
                htmlStr += makePostConnectionConfigFunc_js()
                htmlStr += makeDeleteConnectionConfigFunc_js()


        htmlStr += `
                    &lt;/script&gt;
                &lt;/head&gt;

                &lt;body onload=onInitialSetup()&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                `

        // (2) make Table Action TR
                // colspan, f5_href, delete_href, fontSize
                htmlStr += makeActionTR_html("7", "connectionconfig", "deleteConnectionConfig()", "2")


        // (3) make Table Header TR
                nameWidthList := []NameWidth {
                    {"Provider Name", "200"},
                    {"Driver Name", "200"},
                    {"Credential Name", "200"},
                    {"Region Name", "200"},
                    {"Connection Config Name", "200"},
                }
                htmlStr +=  makeTitleTRList_html("#DDDDDD", "2", nameWidthList, true)

        // (4) make TR list with info list
        // (4-1) get info list @todo if empty list
                resBody, err := getResourceList_JsonByte("connectionconfig")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var info struct {
                        ResultList []*ccim.ConnectionConfigInfo `json:"connectionconfig"`
                }
                json.Unmarshal(resBody, &amp;info)

        // (4-2) make TR list with info list
                trStrList, err :=  makeConnectionConfigTRList_html("", "", "", info.ResultList)
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">htmlStr += trStrList

        // (4-3) make hidden TR list with info list
                // (a) Driver Name Hidden List
                resBody, err = getResourceList_JsonByte("driver")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var driverInfo struct {
                        ResultList []*dim.CloudDriverInfo `json:"driver"`
                }
                json.Unmarshal(resBody, &amp;driverInfo)
                htmlStr += makeDriverNameHiddenTRList_html(driverInfo.ResultList)

                // (b) Credential Name Hidden List
                resBody, err = getResourceList_JsonByte("credential")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var credentialInfo struct {
                        ResultList []*cim.CredentialInfo `json:"credential"`
                }
                json.Unmarshal(resBody, &amp;credentialInfo)
                htmlStr += makeCredentialNameHiddenTRList_html(credentialInfo.ResultList)

                // (c) Region Name Hidden List
                resBody, err = getResourceList_JsonByte("region")
                if err != nil </span><span class="cov0" title="0">{
                        cblog.Error(err)
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">var regionInfo struct {
                        ResultList []*rim.RegionInfo `json:"region"`
                }
                json.Unmarshal(resBody, &amp;regionInfo)
                htmlStr += makeRegionNameHiddenTRList_html(regionInfo.ResultList)


        // (5) make input field and add
        // attach text box for add
                nameList := cloudosList()
                htmlStr += `
                        &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                            &lt;td&gt;
                                    &lt;font size=2&gt;#&lt;/font&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                &lt;!-- &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="1" value="AWS"&gt; --&gt;
        `
                // Select format of CloudOS  name=text_box, id=1
                htmlStr += makeSelect_html("onchangeProvider", nameList, "1")
            
        htmlStr += `    
                            &lt;/td&gt;
                            &lt;!-- value is set up by '&lt;body onload()=onInitialSetup()&gt;' --&gt;
                            &lt;td&gt;
                                &lt;select style="font-size:12px;text-align:center;" name="text_box" id="2" value="aws-driver-v1.0"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;select style="font-size:12px;text-align:center;" name="text_box" id="3" value="aws-credential-01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;select style="font-size:12px;text-align:center;" name="text_box" id="4" value="aws-region01"&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;input style="font-size:12px;text-align:center;" type="text" name="text_box" id="5" value="aws-connection-config01"&gt;
                            &lt;/td&gt;

                            &lt;td&gt;
                                &lt;a href="javascript:postConnectionConfig()"&gt;
                                    &lt;font size=3&gt;&lt;b&gt;+&lt;/b&gt;&lt;/font&gt;
                                &lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                `
        // make page tail
        htmlStr += `
                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `

//fmt.Println(htmlStr)
        return c.HTML(http.StatusOK, htmlStr)</span>
}

//================ This Spider Info
func SpiderInfo(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call SpiderInfo()")


        htmlStr :=  `
                &lt;html&gt;
                &lt;head&gt;
                    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
                &lt;/head&gt;

                &lt;body&gt;

                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                                &lt;tr bgcolor="#DDDDDD" align="center"&gt;
                                    &lt;td width="200"&gt;
                                            &lt;font size=2&gt;Server Start Time&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;Server Version&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;API Version&lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                &lt;tr bgcolor="#FFFFFF" align="center" height="30"&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;$$STARTTIME$$&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;CB-Spider v0.4.0 (CafeMocha)&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="220"&gt;
                                            &lt;font size=2&gt;REST API v0.4.0 (CafeMocha)&lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;

                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;br&gt;
                &lt;br&gt;
                &lt;br&gt;
                    &lt;table border="0" bordercolordark="#F8F8FF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;
                                &lt;tr bgcolor="#DDDDDD" align="center"&gt;
                                    &lt;td width="240"&gt;
                                            &lt;font size=2&gt;API EndPoint&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="420"&gt;
                                            &lt;font size=2&gt;API Docs&lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                &lt;tr bgcolor="#FFFFFF" align="left" height="30"&gt;
                                    &lt;td width="240"&gt;
                                            &lt;font size=2&gt;$$APIENDPOINT$$&lt;/font&gt;
                                    &lt;/td&gt;
                                    &lt;td width="420"&gt;
                                            &lt;font size=2&gt;
                                            &amp;nbsp;&amp;nbsp;&lt;a href='https://github.com/cloud-barista/poc-cicd-spider/wiki/CB-Spider-User-Interface' target='_blank'&gt;
                                                            CB-Spider User Interface
                                                &lt;/a&gt;
                                            &lt;/font&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;

                    &lt;/table&gt;
                    &lt;hr&gt;
                &lt;/body&gt;
                &lt;/html&gt;
                `

        htmlStr = strings.ReplaceAll(htmlStr, "$$STARTTIME$$", cr.StartTime)
        htmlStr = strings.ReplaceAll(htmlStr, "$$APIENDPOINT$$", "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider") // cr.ServicePort = ":1024"

        return c.HTML(http.StatusOK, htmlStr)
}</span>

</pre>
		
		<pre class="file" id="file35" style="display: none">// Cloud Info Manager's Rest Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.06.

package adminweb

import (
        "fmt"
        "bytes"
        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"
        cres "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        cr "github.com/cloud-barista/poc-cicd-spider/api-runtime/common-runtime"

        "net/http"
        "io/ioutil"
        "strings"
        "github.com/labstack/echo/v4"
        "encoding/json"
)

var cblog *logrus.Logger
func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

type NameWidth struct {
        Name string
        Width string
}


func cloudosList() []string <span class="cov0" title="0">{
        resBody, err := getResourceList_JsonByte("cloudos")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []string `json:"cloudos"`
        }
        json.Unmarshal(resBody, &amp;info)

        return info.ResultList</span>
}

func vpcList(connConfig string) []string <span class="cov0" title="0">{
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "vpc")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []cres.VPCInfo `json:"vpc"`
        }
        json.Unmarshal(resBody, &amp;info)

        var nameList []string
        for _, vpc := range info.ResultList </span><span class="cov0" title="0">{
                nameList = append(nameList, vpc.IId.NameId)
        }</span>
        <span class="cov0" title="0">return nameList</span>
}

func vmStatus(connConfig string, vmName string) string <span class="cov0" title="0">{
        resBody, err := getResource_with_Connection_JsonByte(connConfig, "vmstatus", vmName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        //var info cres.VMStatusInfo 
        <span class="cov0" title="0">var info struct {
                Status string
        }
        json.Unmarshal(resBody, &amp;info)
        //return fmt.Sprint(info.Status)
        return info.Status</span>
}

func subnetList(connConfig string, vpcName string) []string <span class="cov0" title="0">{
        resBody, err := getResource_with_Connection_JsonByte(connConfig, "vpc", vpcName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info cres.VPCInfo
        json.Unmarshal(resBody, &amp;info)

        var nameList []string
        for _, subnetInfo := range info.SubnetInfoList </span><span class="cov0" title="0">{
                nameList = append(nameList, subnetInfo.IId.NameId)
        }</span>
        <span class="cov0" title="0">return nameList</span>
}


func keyPairList(connConfig string) []string <span class="cov0" title="0">{
        resBody, err := getResourceList_with_Connection_JsonByte(connConfig, "keypair")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
        }</span>
        <span class="cov0" title="0">var info struct {
                ResultList []cres.VPCInfo `json:"keypair"`
        }
        json.Unmarshal(resBody, &amp;info)

        var nameList []string
        for _, keypair := range info.ResultList </span><span class="cov0" title="0">{
                nameList = append(nameList, keypair.IId.NameId)
        }</span>
        <span class="cov0" title="0">return nameList</span>
}

//================ Frame
func Frame(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Frame()")

        htmlStr :=  `
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;CB-Spider Admin Web Tool ....__^..^__....&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
  &lt;/head&gt;
 &lt;!--   &lt;frameset rows="66,*" frameborder="Yes" border=1"&gt; --&gt;
    &lt;frameset rows="100,*" frameborder="Yes" border=1"&gt;
        &lt;frame src="adminweb/top" name="top_frame" scrolling="auto" noresize marginwidth="0" marginheight="0"/&gt;
        &lt;frameset frameborder="Yes" border=1"&gt;
            &lt;frame src="adminweb/driver" name="main_frame" scrolling="auto" noresize marginwidth="5" marginheight="0"/&gt; 
        &lt;/frameset&gt;
    &lt;/frameset&gt;
    &lt;noframes&gt;
    &lt;body&gt;
    
    
    &lt;/body&gt;
    &lt;/noframes&gt;
&lt;/html&gt;
        `

        return c.HTML(http.StatusOK, htmlStr)
}</span>

//================ Top
func Top(c echo.Context) error <span class="cov0" title="0">{
        cblog.Info("call Top()")

        htmlStr :=  ` 
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- &lt;table border="0" bordercolordark="#FFFFFF" cellpadding="0" cellspacing="2" bgcolor="#FFFFFF" width="320" style="font-size:small;"&gt; --&gt;
    &lt;table border="0" bordercolordark="#FFFFFF" cellpadding="0" cellspacing="1" bgcolor="#FFFFFF"  style="font-size:small;"&gt;      
        &lt;tr bgcolor="#FFFFFF" align="left"&gt;
            &lt;td rowspan="2" width="70" bgcolor="#FFFFFF" align="center"&gt;
                &lt;!-- CB-Spider Logo --&gt;
                &lt;a href="../adminweb" target="_top"&gt;
                  &lt;!-- &lt;img height="45" width="42" src="https://cloud-barista.github.io/assets/img/frameworks/cb-spider.png" border='0' hspace='0' vspace='1' align="middle"&gt; --&gt;
                  &lt;img height="45" width="45" src="./images/logo.png" border='0' hspace='0' vspace='1' align="middle"&gt;
                &lt;/a&gt;
                &lt;font size=1&gt;$$TIME$$&lt;/font&gt;        
            &lt;/td&gt;

            &lt;td width="160"&gt; 
                &lt;!-- Drivers Management --&gt; 
                &lt;a href="driver" target="main_frame"&gt;            
                    &lt;font size=2&gt;1.driver&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="200"&gt;       
                &lt;!-- Credential Management --&gt;
                &lt;a href="credential" target="main_frame"&gt;            
                    &lt;font size=2&gt;1.credential&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- Regions Management --&gt;
                &lt;a href="region" target="main_frame"&gt;            
                    &lt;font size=2&gt;1.region&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- Connection Management --&gt;
                &lt;a href="connectionconfig" target="main_frame"&gt;            
                    &lt;font size=2&gt;2.CONNECTION&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="230"&gt;
                &lt;!-- Display Connection Config --&gt;
                &lt;label id="connConfig" hidden&gt;&lt;/label&gt;
                &lt;input style="font-size:11px;font-weight:bold;text-align:center;background-color:#EDF7F9;" type="text" id="connDisplay" name="connDisplay" size = 24 disabled value="CloudOS: Region / Zone"&gt;

            &lt;/td&gt;
            &lt;td rowspan="2" width="60"&gt;       
                &lt;!-- This CB-Spider Info --&gt;
                &lt;a href="spiderinfo" target="main_frame"&gt;            
                    &lt;font size=2&gt;info&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr bgcolor="#FFFFFF" align="left"&gt;
            &lt;td width="160"&gt;
                &lt;!-- VPC/Subnet Management --&gt;
                &lt;a href="vpc/region not set" target="main_frame" id="vpcHref"&gt;
                    &lt;font size=2&gt;1.vpc/subnet&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="vpcmgmt/region not set" target="main_frame" id="vpcmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;                
            &lt;/td&gt;
            &lt;td width="200"&gt;
                &lt;!-- SecurityGroup Management --&gt;
                &lt;a href="securitygroup/region not set" target="main_frame" id="securitygroupHref"&gt;
                    &lt;font size=2&gt;1.1.security group&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="securitygroupmgmt/region not set" target="main_frame" id="securitygroupmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- KeyPair Management --&gt;
                &lt;a href="keypair/region not set" target="main_frame" id="keypairHref"&gt;
                    &lt;font size=2&gt;1.keypair&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="keypairmgmt/region not set" target="main_frame" id="keypairmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="140"&gt;
                &lt;!-- VM Management --&gt;
                &lt;a href="vm/region not set" target="main_frame" id="vmHref"&gt;
                    &lt;font size=2&gt;2.VM&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;
                &lt;a href="vmmgmt/region not set" target="main_frame" id="vmmgmtHref"&gt;
                    &lt;font size=2&gt;[mgmt]&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
            &lt;td width="230"&gt;
                &lt;!-- Image Management --&gt;
                &lt;a href="vmimage/region not set" target="main_frame" id="vmimageHref"&gt;
                    &lt;font size=2&gt;vmimage&lt;/font&gt;
                &lt;/a&gt;
                &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
                &lt;!-- Spec Management --&gt;
                &lt;a href="vmspec/region not set" target="main_frame" id="vmspecHref"&gt;
                    &lt;font size=2&gt;vmspec&lt;/font&gt;
                &lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;

    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
        `

        
        htmlStr = strings.ReplaceAll(htmlStr, "$$TIME$$", cr.ShortStartTime)
        return c.HTML(http.StatusOK, htmlStr)
}</span>

func makeSelect_html(onchangeFunctionName string, strList []string, id string) string <span class="cov0" title="0">{

        strSelect := `&lt;select name="text_box" id="` + id + `" onchange="` + onchangeFunctionName + `(this)"&gt;`
        for _, one := range strList </span><span class="cov0" title="0">{
                if one == "AWS" </span><span class="cov0" title="0">{
                        strSelect += `&lt;option value="` + one + `" selected&gt;` + one + `&lt;/option&gt;`
                }</span> else<span class="cov0" title="0"> {
                        strSelect += `&lt;option value="` + one + `"&gt;` + one + `&lt;/option&gt;`
                }</span>
        }

        <span class="cov0" title="0">strSelect += `
                &lt;/select&gt;
        `


        return strSelect</span>
}

func makeKeyPairSelect_html(onchangeFunctionName string, strList []string, id string) string <span class="cov0" title="0">{

        strSelect := `&lt;select name="text_box" id="` + id + `" onchange="` + onchangeFunctionName + `(this)"&gt;`
        for _, one := range strList </span><span class="cov0" title="0">{
                strSelect += `&lt;option value="` + one + `"&gt;` + one + `&lt;/option&gt;`
        }</span>
        // add one more not to use Key but to use password
        <span class="cov0" title="0">strSelect += `&lt;option value=""&lt;/option&gt;`

        strSelect += `
                &lt;/select&gt;
        `


        return strSelect</span>
}


func getResourceList_JsonByte(resourceName string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName

        // get object list
        res, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(res.Body)
        res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getResourceList_with_Connection_JsonByte(connConfig string, resourceName string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName
        // get object list
        var reqBody struct {
                Value string `json:"ConnectionName"`
        }        
        reqBody.Value = connConfig

        jsonValue, _ := json.Marshal(reqBody)
        request, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonValue))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")

        client := http.Client{}
        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getAllResourceList_with_Connection_JsonByte(connConfig string, resourceName string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/all" + resourceName
        // get object list
        var reqBody struct {
                Value string `json:"ConnectionName"`
        }
        reqBody.Value = connConfig

        jsonValue, _ := json.Marshal(reqBody)
        request, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonValue))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")

        client := http.Client{}
        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getResource_JsonByte(resourceName string, name string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName + "/" + name

        // get object list
        res, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(res.Body)
        res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

func getResource_with_Connection_JsonByte(connConfig string, resourceName string, name string) ([]byte, error) <span class="cov0" title="0">{
        // cr.ServicePort = ":1024"
        url := "http://" + "localhost" + cr.ServerPort + "/spider/" + resourceName + "/" + name
        // get object list
        var reqBody struct {
                Value string `json:"ConnectionName"`
        }
        reqBody.Value = connConfig

        jsonValue, _ := json.Marshal(reqBody)
        request, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonValue))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")

        client := http.Client{}
        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resBody, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resBody, err</span>
}

// F5, X ("5", "driver", "deleteDriver()", "2")
func makeActionTR_html(colspan string, f5_href string,  delete_href string, fontSize string) string <span class="cov0" title="0">{
        if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="#FFFFFF" align="right"&gt;
                    &lt;td colspan="%s"&gt;
                        &lt;a href="%s"&gt;
                            &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;F5&lt;/b&gt;&lt;/font&gt;
                        &lt;/a&gt;
                        &amp;nbsp;
                        &lt;a href="javascript:%s;"&gt;
                            &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;X&lt;/b&gt;&lt;/font&gt;
                        &lt;/a&gt;
                        &amp;nbsp;
                    &lt;/td&gt;
                &lt;/tr&gt;
                       `, colspan, f5_href, fontSize, delete_href, fontSize) 

        return strTR</span>
}

//         fieldName-width
// number, fieldName0-200, fieldName1-400, ... , checkbox
func makeTitleTRList_html(bgcolor string, fontSize string, nameWidthList []NameWidth, hasCheckBox bool) string <span class="cov0" title="0">{
        if bgcolor == "" </span><span class="cov0" title="0">{ bgcolor = "#DDDDDD" }</span>
        <span class="cov0" title="0">if fontSize == "" </span><span class="cov0" title="0">{ fontSize = "2" }</span>

        // (1) header number field
        <span class="cov0" title="0">strTR := fmt.Sprintf(`
                &lt;tr bgcolor="%s" align="center"&gt;
                    &lt;td width="15"&gt;
                            &lt;font size=%s&gt;&lt;b&gt;&amp;nbsp;#&lt;/b&gt;&lt;/font&gt;
                    &lt;/td&gt;
                `, bgcolor, fontSize)

        // (2) header title field
        for _, one := range nameWidthList </span><span class="cov0" title="0">{
                str := fmt.Sprintf(`
                            &lt;td width="%s"&gt;
                                    &lt;font size=2&gt;%s&lt;/font&gt;
                            &lt;/td&gt;
                        `, one.Width, one.Name)
                strTR += str
        }</span>

        <span class="cov0" title="0">if hasCheckBox </span><span class="cov0" title="0">{        
                // (3) header checkbox field
                strTR += `
                            &lt;td width="15"&gt;
                                    &lt;input type="checkbox" onclick="toggle(this);" /&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                        `
        }</span>
        <span class="cov0" title="0">return strTR</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
// This file was generated by swaggo/swag

package docs

import (
        "bytes"
        "encoding/json"
        "strings"

        "github.com/alecthomas/template"
        "github.com/swaggo/swag"
)

var doc = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{.Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "API Support",
            "url": "http://cloud-barista.github.io",
            "email": "contact-to-cloud-barista@googlegroups.com"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/keypair": {
            "post": {
                "description": "Create SSH Key",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "[CCM] Access key management"
                ],
                "summary": "Create SSH Key",
                "parameters": [
                    {
                        "description": "Request body to create key",
                        "name": "keyPairCreateReq",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/restruntime.JSONResult"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "ConnectionName": {
                                            "type": "string"
                                        },
                                        "ReqInfo": {
                                            "allOf": [
                                                {
                                                    "$ref": "#/definitions/restruntime.JSONResult"
                                                },
                                                {
                                                    "type": "object",
                                                    "properties": {
                                                        "Name": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/resources.KeyPairInfo"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    }
                }
            }
        },
        "/vpc": {
            "post": {
                "description": "Create VPC",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "[CCM] VPC management"
                ],
                "summary": "Create VPC",
                "parameters": [
                    {
                        "description": "Request body to create VPC",
                        "name": "vpcCreateReq",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/restruntime.vpcCreateReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/resources.VPCInfo"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/restruntime.SimpleMsg"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "resources.IID": {
            "type": "object",
            "properties": {
                "nameId": {
                    "description": "NameID by user",
                    "type": "string"
                },
                "systemId": {
                    "description": "SystemID by CloudOS",
                    "type": "string"
                }
            }
        },
        "resources.KeyPairInfo": {
            "type": "object",
            "properties": {
                "fingerprint": {
                    "type": "string"
                },
                "iid": {
                    "description": "{NameId, SystemId}",
                    "$ref": "#/definitions/resources.IID"
                },
                "keyValueList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.KeyValue"
                    }
                },
                "privateKey": {
                    "type": "string"
                },
                "publicKey": {
                    "type": "string"
                },
                "vmuserID": {
                    "type": "string"
                }
            }
        },
        "resources.KeyValue": {
            "type": "object",
            "properties": {
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "resources.SubnetInfo": {
            "type": "object",
            "properties": {
                "iid": {
                    "description": "{NameId, SystemId}",
                    "$ref": "#/definitions/resources.IID"
                },
                "ipv4_CIDR": {
                    "type": "string"
                },
                "keyValueList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.KeyValue"
                    }
                }
            }
        },
        "resources.VPCInfo": {
            "type": "object",
            "properties": {
                "iid": {
                    "description": "{NameId, SystemId}",
                    "$ref": "#/definitions/resources.IID"
                },
                "ipv4_CIDR": {
                    "type": "string"
                },
                "keyValueList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.KeyValue"
                    }
                },
                "subnetInfoList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/resources.SubnetInfo"
                    }
                }
            }
        },
        "restruntime.JSONResult": {
            "type": "object"
        },
        "restruntime.SimpleMsg": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "example": "Any message"
                }
            }
        },
        "restruntime.vpcCreateReq": {
            "type": "object",
            "properties": {
                "connectionName": {
                    "type": "string"
                },
                "reqInfo": {
                    "type": "object",
                    "properties": {
                        "ipv4_CIDR": {
                            "type": "string"
                        },
                        "name": {
                            "type": "string"
                        },
                        "subnetInfoList": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "ipv4_CIDR": {
                                        "type": "string"
                                    },
                                    "name": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "securityDefinitions": {
        "BasicAuth": {
            "type": "basic"
        }
    }
}`

type swaggerInfo struct {
        Version     string
        Host        string
        BasePath    string
        Schemes     []string
        Title       string
        Description string
}

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = swaggerInfo{
        Version:     "latest",
        Host:        "localhost:1024",
        BasePath:    "/spider",
        Schemes:     []string{},
        Title:       "CB-Spider REST API",
        Description: "CB-Spider REST API",
}

type s struct{}

func (s *s) ReadDoc() string <span class="cov0" title="0">{
        sInfo := SwaggerInfo
        sInfo.Description = strings.Replace(sInfo.Description, "\n", "\\n", -1)

        t, err := template.New("swagger_info").Funcs(template.FuncMap{
                "marshal": func(v interface{}) string </span><span class="cov0" title="0">{
                        a, _ := json.Marshal(v)
                        return string(a)
                }</span>,
        }).Parse(doc)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return doc
        }</span>

        <span class="cov0" title="0">var tpl bytes.Buffer
        if err := t.Execute(&amp;tpl, sInfo); err != nil </span><span class="cov0" title="0">{
                return doc
        }</span>

        <span class="cov0" title="0">return tpl.String()</span>
}

func init() <span class="cov8" title="1">{
        swag.Register(swag.Name, &amp;s{})
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// +build !dyna

// Cloud Driver Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.12.

package clouddriverhandler

import (
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        alibabadrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba"
        awsdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws"
        azuredrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure"
        clouditdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit"
        dockerdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker"
        gcpdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp"
        mockdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock"
        openstackdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack"
        tencentdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent"

        // ncpdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/ncp" // NCP
        // ncpvpcdrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/ncpvpc" // NCP-VPC

        icbs "github.com/cloud-barista/cb-store/interfaces"

        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"

        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
        ccim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/connection-config-info-manager"
        cim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/credential-info-manager"
        dim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/driver-info-manager"
        rim "github.com/cloud-barista/poc-cicd-spider/cloud-info-manager/region-info-manager"

        //"encoding/json"
        "fmt"
        //"net/http"
        "os"
        "plugin"
        "strings"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

/*
func ListCloudDriver() []string {
        var cloudDriverList []string
        // @todo get list from storage
        return cloudDriverList
}
*/

// 1. get the ConnectionConfig Info
// 2. get the driver info
// 3. load driver library
// 4. get CloudDriver
func GetCloudDriver(cloudConnectName string) (idrv.CloudDriver, error) <span class="cov0" title="0">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cldDrvInfo, err := dim.GetCloudDriver(cccInfo.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pluginSW := os.Getenv("PLUGIN_SW")
        if strings.ToUpper(pluginSW) == "OFF" </span><span class="cov0" title="0">{
                return getStaticCloudDriver(*cldDrvInfo)
        }</span> else<span class="cov0" title="0"> {
                return getCloudDriver(*cldDrvInfo)
        }</span>
}

// 1. get credential info
// 2. get region info
// 3. get CloudConneciton
func GetCloudConnection(cloudConnectName string) (icon.CloudConnection, error) <span class="cov8" title="1">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cldDrvInfo, err := dim.GetCloudDriver(cccInfo.DriverName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pluginSW := os.Getenv("PLUGIN_SW")
        var cldDriver idrv.CloudDriver
        if strings.ToUpper(pluginSW) == "OFF" </span><span class="cov8" title="1">{
                cldDriver, err = getStaticCloudDriver(*cldDrvInfo)
        }</span> else<span class="cov0" title="0"> {
                cldDriver, err = getCloudDriver(*cldDrvInfo)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">crdInfo, err := cim.GetCredentialDecrypt(cccInfo.CredentialName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rgnInfo, err := rim.GetRegion(cccInfo.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        //cblog.Info(cldDriver)
        //cblog.Info(crdInfo)
        //cblog.Info(rgnInfo)

        <span class="cov8" title="1">regionName, zoneName, err := GetRegionNameByRegionInfo(rgnInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">connectionInfo := idrv.ConnectionInfo{ // @todo powerkim
                CredentialInfo: idrv.CredentialInfo{
                        ClientId:         getValue(crdInfo.KeyValueInfoList, "ClientId"),
                        ClientSecret:     getValue(crdInfo.KeyValueInfoList, "ClientSecret"),
                        TenantId:         getValue(crdInfo.KeyValueInfoList, "TenantId"),
                        SubscriptionId:   getValue(crdInfo.KeyValueInfoList, "SubscriptionId"),
                        IdentityEndpoint: getValue(crdInfo.KeyValueInfoList, "IdentityEndpoint"),
                        Username:         getValue(crdInfo.KeyValueInfoList, "Username"),
                        Password:         getValue(crdInfo.KeyValueInfoList, "Password"),
                        DomainName:       getValue(crdInfo.KeyValueInfoList, "DomainName"),
                        ProjectID:        getValue(crdInfo.KeyValueInfoList, "ProjectID"),
                        AuthToken:        getValue(crdInfo.KeyValueInfoList, "AuthToken"),
                        ClientEmail:      getValue(crdInfo.KeyValueInfoList, "ClientEmail"),
                        PrivateKey:       getValue(crdInfo.KeyValueInfoList, "PrivateKey"),
                        Host:             getValue(crdInfo.KeyValueInfoList, "Host"),
                        APIVersion:       getValue(crdInfo.KeyValueInfoList, "APIVersion"),
                        MockName:         getValue(crdInfo.KeyValueInfoList, "MockName"),
                },
                RegionInfo: idrv.RegionInfo{ // @todo powerkim
                        Region:        regionName,
                        Zone:          zoneName,
                        ResourceGroup: getValue(rgnInfo.KeyValueInfoList, "ResourceGroup"),
                },
        }

        cldConnection, err := cldDriver.ConnectCloud(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cldConnection, nil</span>
}

func getValue(keyValueInfoList []icbs.KeyValue, key string) string <span class="cov8" title="1">{
        for _, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                if kv.Key == key </span><span class="cov8" title="1">{
                        return kv.Value
                }</span>
        }
        <span class="cov8" title="1">return "Not set"</span>
}

func GetProviderNameByConnectionName(cloudConnectName string) (string, error) <span class="cov8" title="1">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">rgnInfo, err := rim.GetRegion(cccInfo.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return rgnInfo.ProviderName, nil</span>
}

func GetRegionNameByConnectionName(cloudConnectName string) (string, string, error) <span class="cov8" title="1">{
        cccInfo, err := ccim.GetConnectionConfig(cloudConnectName)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">rgnInfo, err := rim.GetRegion(cccInfo.RegionName)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return GetRegionNameByRegionInfo(rgnInfo)</span>
}

func GetRegionNameByRegionInfo(rgnInfo *rim.RegionInfo) (string, string, error) <span class="cov8" title="1">{

        // @todo should move KeyValueList into XXXDriver.go, powerkim
        var regionName string
        var zoneName string
        switch strings.ToUpper(rgnInfo.ProviderName) </span>{
        case "AZURE":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "location")</span>
        case "AWS":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        case "ALIBABA":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        case "GCP":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        case "OPENSTACK":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "CLOUDIT":<span class="cov0" title="0">
                // Cloudit do not use Region, But set default @todo 2019.10.28. by powerkim.
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "DOCKER":<span class="cov0" title="0">
                // docker do not use Region, But set default @todo 2020.05.06. by powerkim.
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "NCP":<span class="cov0" title="0"> // NCP
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region") // NCP
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>     // NCP
        case "NCPVPC":<span class="cov0" title="0"> // NCP-VPC
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region") // NCP-VPC
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>     // NCP-VPC
        case "CLOUDTWIN":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "MOCK":<span class="cov8" title="1">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")</span>
        case "TENCENT":<span class="cov0" title="0">
                regionName = getValue(rgnInfo.KeyValueInfoList, "Region")
                zoneName = getValue(rgnInfo.KeyValueInfoList, "Zone")</span>
        default:<span class="cov0" title="0">
                errmsg := rgnInfo.ProviderName + " is not a valid ProviderName!!"
                return "", "", fmt.Errorf(errmsg)</span>
        }

        <span class="cov8" title="1">return regionName, zoneName, nil</span>
}

func getCloudDriver(cldDrvInfo dim.CloudDriverInfo) (idrv.CloudDriver, error) <span class="cov0" title="0">{
        // $CBSPIDER_ROOT/cloud-driver-libs/*
        cbspiderRoot := os.Getenv("CBSPIDER_ROOT")
        if cbspiderRoot == "" </span><span class="cov0" title="0">{
                cblog.Error("$CBSPIDER_ROOT is not set!!")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">driverLibPath := cbspiderRoot + "/cloud-driver-libs/"

        driverFile := cldDrvInfo.DriverLibFileName // ex) "aws-test-driver-v0.5.so"
        if driverFile == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q: driver library file can't nil or empty!!", cldDrvInfo.DriverName)
        }</span>
        <span class="cov0" title="0">driverPath := driverLibPath + driverFile

        cblog.Info(cldDrvInfo.DriverName + ": driver path - " + driverPath)

        /*---------------
                A plugin is only initialized once, and cannot be closed.
                ref) https://golang.org/pkg/plugin/
        -----------------*/

        //var plug *plugin.Plugin
        plug, err := plugin.Open(driverPath)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Errorf("plugin.Open: %v\n", err)
                return nil, err
        }</span>
        //      fmt.Printf("plug: %#v\n\n", plug)

        //driver, err := plug.Lookup(cccInfo.DriverName)
        <span class="cov0" title="0">driver, err := plug.Lookup("CloudDriver")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Errorf("plug.Lookup: %v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">cloudDriver, ok := driver.(idrv.CloudDriver)
        if !ok </span><span class="cov0" title="0">{
                cblog.Error("Not CloudDriver interface!!")
                return nil, err
        }</span>

        <span class="cov0" title="0">return cloudDriver, nil</span>
}

func getStaticCloudDriver(cldDrvInfo dim.CloudDriverInfo) (idrv.CloudDriver, error) <span class="cov8" title="1">{
        cblog.Info("CloudDriverHandler: called getStaticCloudDriver() - " + cldDrvInfo.DriverName)

        var cloudDriver idrv.CloudDriver

        // select driver
        switch cldDrvInfo.ProviderName </span>{
        case "AWS":<span class="cov0" title="0">
                cloudDriver = new(awsdrv.AwsDriver)</span>
        case "AZURE":<span class="cov0" title="0">
                cloudDriver = new(azuredrv.AzureDriver)</span>
        case "GCP":<span class="cov0" title="0">
                cloudDriver = new(gcpdrv.GCPDriver)</span>
        case "ALIBABA":<span class="cov0" title="0">
                cloudDriver = new(alibabadrv.AlibabaDriver)</span>
        case "OPENSTACK":<span class="cov0" title="0">
                cloudDriver = new(openstackdrv.OpenStackDriver)</span>
        case "CLOUDIT":<span class="cov0" title="0">
                cloudDriver = new(clouditdrv.ClouditDriver)</span>
        case "DOCKER":<span class="cov0" title="0">
                cloudDriver = new(dockerdrv.DockerDriver)</span>
        case "TENCENT":<span class="cov0" title="0">
                cloudDriver = new(tencentdrv.TencentDriver)</span>
        // case "NCP": // NCP
        //  cloudDriver = new(ncpdrv.NcpDriver) // NCP
        // case "NCPVPC": // NCP-VPC
        //  cloudDriver = new(ncpvpcdrv.NcpVpcDriver) // NCP-VPC
        case "MOCK":<span class="cov8" title="1">
                cloudDriver = new(mockdrv.MockDriver)</span>

        default:<span class="cov0" title="0">
                errmsg := cldDrvInfo.ProviderName + " is not supported static Cloud Driver!!"
                return cloudDriver, fmt.Errorf(errmsg)</span>
        }

        <span class="cov8" title="1">return cloudDriver, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Call-Log: calling logger of Cloud &amp; VM in CB-Spider
//           Referred to cb-log
//
//      * Cloud-Barista: https://github.com/cloud-barista
//      * CB-Spider: https://github.com/cloud-barista/cb-spider
//      * cb-log: https://github.com/cloud-barista/cb-log
//
// load and set config file
//
// ref) https://github.com/go-yaml/yaml/tree/v3
//      https://godoc.org/gopkg.in/yaml.v3
//
// by CB-Spider Team, 2020.09.

package calllog

import (
        "fmt"
        "os"
        "reflect"
        "strings"
        "time"

        "github.com/chyeh/pubip"
        calllogformatter "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log/formatter"
        "github.com/sirupsen/logrus"
        "github.com/snowzach/rotatefilehook"
)

type CLOUD_OS string
type RES_TYPE string

const (
        //=========== CloudOS (ref: cb-spider/conf/cloudos.yaml)
        AWS       CLOUD_OS = "AWS"
        GCP       CLOUD_OS = "GCP"
        AZURE     CLOUD_OS = "AZURE"
        OPENSTACK CLOUD_OS = "OPENSTACK"
        CLOUDIT   CLOUD_OS = "CLOUDIT"
        ALIBABA   CLOUD_OS = "ALIBABA"
        DOCKER    CLOUD_OS = "DOCKER"
        CLOUDTWIN CLOUD_OS = "CLOUDTWIN"
        NCP       CLOUD_OS = "NCP"
        MOCK      CLOUD_OS = "MOCK"
        TENCENT   CLOUD_OS = "TENCENT"
        IBM       CLOUD_OS = "IBM"

        //=========== ResourceType
        VMIMAGE       RES_TYPE = "VMIMAGE"
        VMSPEC        RES_TYPE = "VMSPEC"
        VPCSUBNET     RES_TYPE = "VPC/SUBNET"
        SECURITYGROUP RES_TYPE = "SECURITYGROUP"
        VMKEYPAIR     RES_TYPE = "VMKEYPAIR"
        VM            RES_TYPE = "VM"
)

type CALLLogger struct {
        loggerName string
        logrus     *logrus.Logger
}

// global var.
var (
        HostIPorName  string
        callLogger    *CALLLogger
        callFormatter *calllogformatter.Formatter
        calllogConfig CALLLOGCONFIG
)

func init() <span class="cov8" title="1">{
        HostIPorName = getHostIPorName()
}</span>

func getHostIPorName() string <span class="cov8" title="1">{
        ip, err := pubip.Get()
        if err != nil </span><span class="cov0" title="0">{
                logrus.Error(err)
                hostName, err := os.Hostname()
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Error(err)
                }</span>
                <span class="cov0" title="0">return hostName</span>
        }

        <span class="cov8" title="1">return ip.String()</span>
}

func GetLogger(loggerName string) *logrus.Logger <span class="cov8" title="1">{
        if callLogger != nil </span><span class="cov0" title="0">{
                return callLogger.logrus
        }</span>
        <span class="cov8" title="1">callLogger = new(CALLLogger)
        callLogger.loggerName = loggerName
        callLogger.logrus = &amp;logrus.Logger{
                Level:     logrus.InfoLevel,
                Out:       os.Stderr,
                Hooks:     make(logrus.LevelHooks),
                Formatter: getFormatter(loggerName),
        }

        // set config.
        setup(loggerName)
        return callLogger.logrus</span>
}

func setup(loggerName string) <span class="cov8" title="1">{
        calllogConfig = GetConfigInfos()
        callLogger.logrus.SetReportCaller(true)

        if calllogConfig.CALLLOG.LOOPCHECK </span><span class="cov0" title="0">{
                SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
                go levelSetupLoop(loggerName)
        }</span> else<span class="cov8" title="1"> {
                SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
        }</span>

        <span class="cov8" title="1">if calllogConfig.CALLLOG.LOGFILE </span><span class="cov0" title="0">{
                setRotateFileHook(loggerName, &amp;calllogConfig)
        }</span>
}

// Now, this method is busy wait.
// @TODO must change this  with file watch&amp;event.
// ref) https://github.com/fsnotify/fsnotify/blob/master/example_test.go
func levelSetupLoop(loggerName string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                calllogConfig = GetConfigInfos()
                SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
                time.Sleep(time.Second * 2)
        }</span>
}

func setRotateFileHook(loggerName string, logConfig *CALLLOGCONFIG) <span class="cov0" title="0">{
        level, _ := logrus.ParseLevel(logConfig.CALLLOG.LOGLEVEL)

        rotateFileHook, err := rotatefilehook.NewRotateFileHook(rotatefilehook.RotateFileConfig{
                Filename:   logConfig.LOGFILEINFO.FILENAME,
                MaxSize:    logConfig.LOGFILEINFO.MAXSIZE, // megabytes
                MaxBackups: logConfig.LOGFILEINFO.MAXBACKUPS,
                MaxAge:     logConfig.LOGFILEINFO.MAXAGE, //days
                Level:      level,
                Formatter:  getFormatter(loggerName),
        })

        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to initialize file rotate hook: %v", err)
        }</span>
        <span class="cov0" title="0">callLogger.logrus.AddHook(rotateFileHook)</span>
}

func SetLevel(strLevel string) <span class="cov8" title="1">{
        err := checkLevel(strLevel)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Errorf("Failed to set log level: %v", err)
        }</span>
        <span class="cov8" title="1">level, _ := logrus.ParseLevel(strLevel)
        callLogger.logrus.SetLevel(level)</span>
}

func checkLevel(lvl string) error <span class="cov8" title="1">{
        switch strings.ToLower(lvl) </span>{
        case "error":<span class="cov8" title="1">
                return nil</span>
        case "info":<span class="cov0" title="0">
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("not a valid calllog Level: %q", lvl)</span>
}

func GetLevel() string <span class="cov0" title="0">{
        return callLogger.logrus.GetLevel().String()
}</span>

func getFormatter(loggerName string) *calllogformatter.Formatter <span class="cov8" title="1">{

        if callFormatter != nil </span><span class="cov0" title="0">{
                return callFormatter
        }</span>
        <span class="cov8" title="1">callFormatter = &amp;calllogformatter.Formatter{
                TimestampFormat: "2006-01-02 15:04:05",
                LogFormat:       "[" + loggerName + "].[" + HostIPorName + "] %time% (%weekday%) %func% - %msg%\n",
        }
        return callFormatter</span>
}

//=========================
type CLOUDLOGSCHEMA struct {
        CloudOS      CLOUD_OS // ex) AWS | AZURE | ALIBABA | GCP | OPENSTACK | CLOUDTWIN | CLOUDIT | DOCKER | NCP | MOCK | IBM
        RegionZone   string   // ex) us-east1/us-east1-c
        ResourceType RES_TYPE // ex) VMIMAGE | VMSPEC | VPCSUBNET | SECURITYGROUP | VMKEYPAIR | VM
        ResourceName string   // ex) vpc-01
        CloudOSAPI   string   // ex) CreateKeyPair()
        ElapsedTime  string   // ex) 2.0201 (sec)
        ErrorMSG     string   // if success, ""
}

/* TBD or Do not support.
type VMLOGSCHEMA struct {
}
*/

func Start() time.Time <span class="cov8" title="1">{
        return time.Now()
}</span>

func Elapsed(start time.Time) string <span class="cov8" title="1">{
        return fmt.Sprintf("%.4f", time.Since(start).Seconds())
}</span>

func String(logInfo interface{}) string <span class="cov8" title="1">{
        t := reflect.TypeOf(logInfo)
        v := reflect.ValueOf(logInfo)

        msg := ""
        for idx := 0; idx &lt; t.NumField(); idx++ </span><span class="cov8" title="1">{
                typeOne := t.Field(idx)
                one := v.Field(idx)
                if idx &lt; (t.NumField() - 1) </span><span class="cov8" title="1">{
                        msg += fmt.Sprintf("\"%s\" : \"%s\", ", typeOne.Name, one)
                }</span> else<span class="cov8" title="1"> {
                        msg += fmt.Sprintf("\"%s\" : \"%s\"", typeOne.Name, one)
                }</span>
        }

        <span class="cov8" title="1">return msg</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Call-Log: calling logger of Cloud &amp; VM in CB-Spider
//           Referred to cb-log
//
//      * Cloud-Barista: https://github.com/cloud-barista
//      * CB-Spider: https://github.com/cloud-barista/cb-spider
//      * cb-log: https://github.com/cloud-barista/cb-log
//
// load and set config file
//
// ref) https://github.com/go-yaml/yaml/tree/v3
//        https://godoc.org/gopkg.in/yaml.v3
//
// by CB-Spider Team, 2020.09.


package calllog

import (
    "os"
    "strings"
    "io/ioutil"
    "log"

    "gopkg.in/yaml.v3"
)

type CALLLOGCONFIG struct {
        CALLLOG struct {
                LOOPCHECK bool
                LOGLEVEL string
                LOGFILE bool
        }

        LOGFILEINFO struct {
                FILENAME string
                MAXSIZE int
                MAXBACKUPS int
                MAXAGE int
        }
}

func load(filePath string) ([]byte, error) <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filePath)
        return data, err
}</span>

func GetConfigInfos() CALLLOGCONFIG <span class="cov8" title="1">{
        calllogRootPath := os.Getenv("CBSPIDER_ROOT")
        if calllogRootPath == "" </span><span class="cov0" title="0">{
                log.Fatalf("$CBSPIDER_ROOT is not set!!")
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">data, err := load(calllogRootPath + "/conf/calllog_conf.yaml")

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: %v", err)
        }</span>

        <span class="cov8" title="1">configInfos := CALLLOGCONFIG{}
        err = yaml.Unmarshal([]byte(data), &amp;configInfos)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: %v", err)
        }</span>

        <span class="cov8" title="1">configInfos.LOGFILEINFO.FILENAME = ReplaceEnvPath(configInfos.LOGFILEINFO.FILENAME)
        return configInfos</span>
}

// $ABC/def ==&gt; /abc/def
func ReplaceEnvPath(str string) string <span class="cov8" title="1">{
        if strings.Index(str, "$") == -1 </span><span class="cov0" title="0">{
                return str
        }</span>

        // ex) input "$CBSTORE_ROOT/meta_db/dat"
        <span class="cov8" title="1">strList := strings.Split(str, "/")
        for n, one := range strList </span><span class="cov8" title="1">{
                if strings.Index(one, "$") != -1 </span><span class="cov8" title="1">{
                        callstoreRootPath := os.Getenv(strings.Trim(one, "$"))
                        if callstoreRootPath == "" </span><span class="cov0" title="0">{
                                log.Fatal(one  +" is not set!")
                        }</span>
                        <span class="cov8" title="1">strList[n] = callstoreRootPath</span>
                }
        }

        <span class="cov8" title="1">var resultStr string
        for _, one := range strList </span><span class="cov8" title="1">{
                resultStr = resultStr + one + "/"
        }</span>
        // ex) "/root/go/src/github.com/cloud-barista/poc-cicd-spider/meta_db/dat/"
        <span class="cov8" title="1">resultStr = strings.TrimRight(resultStr, "/")
        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        return resultStr</span>
}


func GetConfigString(configInfos *CALLLOGCONFIG) string <span class="cov0" title="0">{
        d, err := yaml.Marshal(configInfos)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: %v", err)
        }</span>
        <span class="cov0" title="0">return string(d)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Call-Log: calling logger of Cloud &amp; VM in CB-Spider
//           Referred to cb-log
//
//      * Cloud-Barista: https://github.com/cloud-barista
//      * CB-Spider: https://github.com/cloud-barista/cb-spider
//      * cb-log: https://github.com/cloud-barista/cb-log
//
// load and set config file
//
// ref) https://github.com/go-yaml/yaml/tree/v3
//      https://godoc.org/gopkg.in/yaml.v3
//
// by CB-Spider Team, 2020.09.

package calllogformatter

import (

        "fmt"

        "strconv"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

const (
        // Default log format will output [INFO]: 2006-01-02T15:04:05Z07:00 - Log message
        defaultLogFormat       = " %time% (%weekday%) %func% - %msg%\n"
        defaultTimestampFormat = time.RFC3339
)

// Formatter implements logrus.Formatter interface.
type Formatter struct {
        TimestampFormat string
        LogFormat string
}

// Format building log message.
func (f *Formatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov0" title="0">{
        output := f.LogFormat
        if output == "" </span><span class="cov0" title="0">{
                output = defaultLogFormat
        }</span>

        <span class="cov0" title="0">timestampFormat := f.TimestampFormat
        if timestampFormat == "" </span><span class="cov0" title="0">{
                timestampFormat = defaultTimestampFormat
        }</span>

        <span class="cov0" title="0">output = strings.Replace(output, "%time%", entry.Time.Format(timestampFormat), 1)
        output = strings.Replace(output, "%weekday%", entry.Time.Weekday().String(), 1)


        if entry.HasCaller() </span><span class="cov0" title="0">{
                funcVal := fmt.Sprintf("%s():%d", entry.Caller.Function, entry.Caller.Line)
                
                output = strings.Replace(output, "%func%", funcVal, 1)
        }</span> else<span class="cov0" title="0"> {
                output = strings.Replace(output, "%func%", "", 1)
        }</span>

        <span class="cov0" title="0">output = strings.Replace(output, "%msg%", entry.Message, 1)


        for k, val := range entry.Data </span><span class="cov0" title="0">{
                switch v := val.(type) </span>{
                case string:<span class="cov0" title="0">
                        output = strings.Replace(output, "%"+k+"%", v, 1)</span>
                case int:<span class="cov0" title="0">
                        s := strconv.Itoa(v)
                        output = strings.Replace(output, "%"+k+"%", s, 1)</span>
                case bool:<span class="cov0" title="0">
                        s := strconv.FormatBool(v)
                        output = strings.Replace(output, "%"+k+"%", s, 1)</span>
                }
        }

        <span class="cov0" title="0">return []byte(output), nil</span>
}

func shortFilePathName(filePath string) string <span class="cov0" title="0">{
        strArray := strings.Split(filePath, "/")

        return strArray[len(strArray)-1]
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by zephy@mz.co.kr, 2019.09.

package alibaba

import (
        "C"
        "fmt"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk/auth/credentials"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
        alicon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
        "github.com/davecgh/go-spew/spew"
)
import (
        "time"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk"
)

type AlibabaDriver struct{}

func (AlibabaDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "ALIBABA-CLOUD DRIVER Version 1.0"
}</span>

func (AlibabaDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = false
        drvCapabilityInfo.VPCHandler = false
        drvCapabilityInfo.SecurityHandler = false
        drvCapabilityInfo.KeyPairHandler = false
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = false
        drvCapabilityInfo.VMSpecHandler = false

        return drvCapabilityInfo
}</span>

func (driver *AlibabaDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        ECSClient, err := getECSClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">VPCClient, err := getVPCClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := alicon.AlibabaCloudConnection{
                Region:        connectionInfo.RegionInfo,
                VMClient:      ECSClient,
                KeyPairClient: ECSClient,
                ImageClient:   ECSClient,
                //PublicIPClient:      VPCClient,
                SecurityGroupClient: ECSClient,
                VpcClient:           VPCClient,
                //VNetClient:          VPCClient,
                //VNicClient:          ECSClient,
                //SubnetClient: VPCClient,
                VmSpecClient: ECSClient,
        }
        return &amp;iConn, nil</span>
}

func getECSClient(connectionInfo idrv.ConnectionInfo) (*ecs.Client, error) <span class="cov0" title="0">{

        // Region Info
        fmt.Println("AlibabaDriver : getECSClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")

        /*
                // Customize config
                config := sdk.NewConfig().
                        WithEnableAsync(true).
                        WithGoRoutinePoolSize(5).
                        WithMaxTaskQueueSize(1000)
                        // 600*time.Second

                //fmt.Println(config)
                spew.Dump(config)
        */

        // Create a credential object
        /* BaseCredential deprecated .
        credential := &amp;credentials.BaseCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }
        */

        credential := &amp;credentials.AccessKeyCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }

        config := sdk.NewConfig()
        config.Timeout = time.Duration(15) * time.Second //time.Millisecond
        config.AutoRetry = true
        config.MaxRetryTime = 2
        //sdk.Timeout(1000)

        //escClient, err := ecs.NewClientWithAccessKey(connectionInfo.RegionInfo.Region, credential.AccessKeyId, credential.AccessKeySecret)

        escClient, err := ecs.NewClientWithOptions(connectionInfo.RegionInfo.Region, config, credential)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create alibaba's ecs service client", err)
                spew.Dump(err)
                return nil, err
        }</span>

        //spew.Dump(escClient)

        /*
                escClient, err := sdk.NewClientWithAccessKey("REGION_ID", "ACCESS_KEY_ID", "ACCESS_KEY_SECRET")
                if err != nil {
                        // Handle exceptions
                        panic(err)
                }
        */

        <span class="cov0" title="0">return escClient, nil</span>
}

func getVPCClient(connectionInfo idrv.ConnectionInfo) (*vpc.Client, error) <span class="cov0" title="0">{

        // Region Info
        fmt.Println("AlibabaDriver : getVPCClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")

        /*
                // Customize config
                config := sdk.NewConfig().
                        WithEnableAsync(true).
                        WithGoRoutinePoolSize(5).
                        WithMaxTaskQueueSize(1000)
                // 600*time.Second
                //fmt.Println(config)
        */

        // Create a credential object
        /* BaseCredential deprecated .
        credential := &amp;credentials.BaseCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }
        */

        credential := &amp;credentials.AccessKeyCredential{
                AccessKeyId:     connectionInfo.CredentialInfo.ClientId,
                AccessKeySecret: connectionInfo.CredentialInfo.ClientSecret,
        }

        config := sdk.NewConfig()
        config.Timeout = time.Duration(15) * time.Second //time.Millisecond
        config.AutoRetry = true
        config.MaxRetryTime = 2
        //sdk.Timeout(1000)

        //vpcClient, err := vpc.NewClientWithAccessKey(connectionInfo.RegionInfo.Region, credential.AccessKeyId, credential.AccessKeySecret)
        vpcClient, err := vpc.NewClientWithOptions(connectionInfo.RegionInfo.Region, config, credential)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create alibaba's vpc service client", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return vpcClient, nil</span>
}

var CloudDriver AlibabaDriver
</pre>
		
		<pre class="file" id="file42" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by zephy@mz.co.kr, 2019.09.

package connect

import (
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"

        cblog "github.com/cloud-barista/cb-log"
        alirs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type AlibabaCloudConnection struct {
        Region idrv.RegionInfo

        VMClient      *ecs.Client
        KeyPairClient *ecs.Client
        ImageClient   *ecs.Client
        //PublicIPClient      *vpc.Client
        SecurityGroupClient *ecs.Client
        //VNetClient          *vpc.Client
        VpcClient *vpc.Client
        //VNicClient          *ecs.Client
        SubnetClient *vpc.Client
        VmSpecClient *ecs.Client
}

/*
func (cloudConn *AlibabaCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
        cblogger.Info("Alibaba Cloud Driver: called CreateVNetworkHandler()!")
        vNetHandler := alirs.AlibabaVNetworkHandler{cloudConn.Region, cloudConn.VNetClient}
        return &amp;vNetHandler, nil
}
*/
func (cloudConn *AlibabaCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := alirs.AlibabaVPCHandler{cloudConn.Region, cloudConn.VpcClient}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateImageHandler()!")
        imageHandler := alirs.AlibabaImageHandler{cloudConn.Region, cloudConn.ImageClient}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateSecurityHandler()!")
        sgHandler := alirs.AlibabaSecurityHandler{cloudConn.Region, cloudConn.SecurityGroupClient}
        return &amp;sgHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateKeyPairHandler()!")
        keyPairHandler := alirs.AlibabaKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}
        return &amp;keyPairHandler, nil
}</span>

/*
func (cloudConn *AlibabaCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Alibaba Cloud Driver: called CreateVNicHandler()!")
        //vNicHandler := alirs.AlibabaVNicHandler{cloudConn.Region, cloudConn.VNicClient, cloudConn.SubnetClient}
        vNicHandler := alirs.AlibabaVNicHandler{cloudConn.Region, cloudConn.VNicClient}
        return &amp;vNicHandler, nil
}
*/

/*
func (cloudConn *AlibabaCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Alibaba Cloud Driver: called CreatePublicIPHandler()!")
        publicIPHandler := alirs.AlibabaPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}
        return &amp;publicIPHandler, nil
}
*/

func (cloudConn *AlibabaCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Alibaba Cloud Driver: called CreateVMHandler()!")
        vmHandler := alirs.AlibabaVMHandler{cloudConn.Region, cloudConn.VMClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *AlibabaCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := alirs.AlibabaVmSpecHandler{cloudConn.Region, cloudConn.VmSpecClient}
        return &amp;handler, nil
}</span>

func (AlibabaCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>

func (AlibabaCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Cloud Driver of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr, 2019.09.

package resources

import (
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

const (
        // default Resource GROUP Name
        CBResourceGroupName = "CB-GROUP"
        // default VPC Name
        CBVirutalNetworkName = "CB-VNet"
        // default CIDR Block
        CBVnetDefaultCidr = "130.0.0.0/16"
        // default VM User Name
        CBDefaultVmUserName = "cb-user"

        // default Subnet Name
        CBSubnetName = "CB-VNet-Sub"

        // default Bandwidth is 5 Mbit/s
        CBBandwidth = "5"
        // default InstanceChargeType
        CBInstanceChargeType = "PostPaid"
        // default InternetChargeType
        CBInternetChargeType = "PayByTraffic"

        // default Tag Name
        CBMetaDefaultTagName = "cbCate"
        // default Tag Value
        CBMetaDefaultTagValue = "cbAlibaba"

        CBPageOn = true
        // page number for control pages
        CBPageNumber = 1

        // page size for control pages
        CBPageSize = 100

        CBKeyPairPath       = "/cloud-driver-libs/.ssh-aliyun/"
        CBCloudInitFilePath = "/cloud-driver-libs/.cloud-init-aliyun/cloud-init"
)

type AlibabaCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

func GetCBResourceGroupName() string <span class="cov0" title="0">{
        return CBResourceGroupName
}</span>

//VPC
func GetCBVirutalNetworkName() string <span class="cov0" title="0">{
        return CBVirutalNetworkName
}</span>

//Subnet
func GetCBSubnetName() string <span class="cov0" title="0">{
        return CBSubnetName
}</span>

func GetCBVnetDefaultCidr() string <span class="cov0" title="0">{
        return CBVnetDefaultCidr
}</span>

func SetNameTag(Client *ecs.Client, resourceId string, resourceType string, value string) bool <span class="cov0" title="0">{
        // Tag Name 
        cblogger.Infof("Name Tage  - ResourceId : [%s]  Value : [%s] ", resourceId, value)

        request := ecs.CreateAddTagsRequest()
        request.Scheme = "https"

        request.ResourceType = resourceType // "disk", "instance", "image", "securitygroup", "snapshot"
        request.ResourceId = resourceId     // "i-t4n4qtfwa4w5aavx588v"
        request.Tag = &amp;[]ecs.AddTagsTag{
                {
                        Key:   "Name",
                        Value: value, // "cbVal",
                },
                {
                        Key:   "cbCate",
                        Value: "cbAlibaba",
                },
                {
                        Key:   "cbName",
                        Value: value, // "cbVal",
                },
                // Resources: []*string{&amp;Id},
        }
        _, errtag := Client.AddTags(request)
        if errtag != nil </span><span class="cov0" title="0">{
                cblogger.Error("Name Tag   : ")
                cblogger.Error(errtag)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

//Cloud Object JSON String  
func ConvertJsonString(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON  ")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

//CB-KeyValue   String  
func ConvertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                cblogger.Error("Nil Value")
                return "", errors.New("NIL Value")
        }</span>

        <span class="cov0" title="0">var result string
        t := reflect.ValueOf(value)
        cblogger.Debug("==&gt;ValueOf : ", t)

        switch value.(type) </span>{
        case float32:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 32)</span> // f, fmt, prec, bitSize
        case float64:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 64)</span> // f, fmt, prec, bitSize
                //strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)

        default:<span class="cov0" title="0">
                cblogger.Debug("--&gt; default type:", reflect.ValueOf(value).Type())
                result = fmt.Sprint(value)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

//Cloud Object CB-KeyValue     
func ConvertKeyValueList(v interface{}) ([]irs.KeyValue, error) <span class="cov0" title="0">{
        spew.Dump(v)

        var keyValueList []irs.KeyValue
        var i map[string]interface{}

        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("KeyValue  ")
                cblogger.Error(errJson)
                return nil, errJson
        }</span>

        <span class="cov0" title="0">json.Unmarshal(jsonBytes, &amp;i)

        for k, v := range i </span><span class="cov0" title="0">{
                cblogger.Debugf("K:[%s]====&gt;", k)
                /*
                        cblogger.Infof("v:[%s]====&gt;", reflect.ValueOf(v))

                        vv := reflect.ValueOf(v)
                        cblogger.Infof("value ====&gt;[%s]", vv.String())
                        s := fmt.Sprint(v)
                        cblogger.Infof("value2 ====&gt;[%s]", s)
                */
                //value := fmt.Sprint(v)
                value, errString := ConvertToString(v)
                if errString != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("Key[%s]    - [%s]", k, errString)
                        continue</span>
                }
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, value})</span>
        }
        <span class="cov0" title="0">cblogger.Debug("getKeyValueList : ", keyValueList)
        //keyValueList = append(keyValueList, irs.KeyValue{"test", typeToString([]float32{3.14, 1.53, 2.0000000000000})})

        return keyValueList, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by zephy@mz.co.kr, 2019.09.

package resources

import (
        "errors"
        "strconv"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk/requests"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AlibabaImageHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

func (imageHandler *AlibabaImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateImage : ", imageReqInfo)
        //imageIdArr := strings.Split(imageReqInfo.Id, ":")

        request := ecs.CreateCreateImageRequest()
        request.Scheme = "https"

        //  Req Name
        request.ImageName = imageReqInfo.IId.NameId // ImageName
        request.Tag = &amp;[]ecs.CreateImageTag{        // Default Hidden Tags Info
                {
                        Key:   CBMetaDefaultTagName,  // "cbCat",
                        Value: CBMetaDefaultTagValue, // "cbAlibaba",
                },
        }

        //      InstanceId, DiskDeviceMapping, SnapshotId 

        // Case1 -  ID (InstanceId)     
        //   , for create Case 1 (InstanceId)
        // request.InstanceId = imageReqInfo.InstanceId // "i-t4n98732cvvbbhhbsd4r"

        // &gt;&gt;&gt;&gt; Case2 -      (SnapshotId)       
        // for create Case 2 (SnapshotId)
        //request.SnapshotId = imageReqInfo.Id // SnapshotId

        // Case3 -         DiskDeviceMapping       .
        //   , for create Case 3 (DiskDeviceMapping)
        // request.DiskDeviceMapping = &amp;[]ecs.CreateImageDiskDeviceMapping{
        //         {
        //           Size: imageReqInfo.DiskDevice[0].Size, // "20",
        //           SnapshotId: imageReqInfo.DiskDevice[0].Id, // "s-t4nhjof9caedzwd4929k",
        //           Device: imageReqInfo.DiskDevice[0].Device, // "/dev/xvda",
        //           DiskType: imageReqInfo.DiskDevice[0].DiskType, // "system",
        //         },
        //         {
        //           Size: imageReqInfo.DiskDevice[1].Size, // "20",
        //           SnapshotId: imageReqInfo.DiskDevice[1].Id, // "s-t4nhjof9caedzwd4929l",
        //           Device: imageReqInfo.DiskDevice[1].Device, // "/dev/xvdb",
        //           DiskType: imageReqInfo.DiskDevice[1].DiskType, // "data",
        //         },
        //   }

        //   Req
        // request.Description = imageReqInfo.Description // "cb custom img01"
        // request.Platform = imageReqInfo.Platform // "Ubuntu"
        // request.Architecture = imageReqInfo.Architecture // "x86_64"
        // request.OSType = imageReqInfo.OSType // OSType "linux"

        // Check Image Exists

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageReqInfo.IId.SystemId,
                CloudOSAPI:   "CreateImage()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        // Creates a new custom Image with the given name
        result, err := imageHandler.Client.CreateImage(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to create Image: %s, %v.", imageReqInfo.IId.NameId, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created Image %q %s\n %s\n", result.ImageId, imageReqInfo.IId.NameId, result.RequestId)
        spew.Dump(result)

        /*
                ImageInfo := irs.ImageInfo{
                        Id:          result.ImageId,
                        Name:        *imageReqInfo.ImageName,
                }
        */

        //  Image   , Image  
        imageInfo, err := imageHandler.GetImage(imageReqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>

        <span class="cov0" title="0">return imageInfo, nil</span>
}

func (imageHandler *AlibabaImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        var imageInfoList []*irs.ImageInfo

        request := ecs.CreateDescribeImagesRequest()
        request.Scheme = "https"

        request.Status = "Available"
        request.ActionType = "*"
        if CBPageOn </span><span class="cov0" title="0">{
                request.PageNumber = requests.NewInteger(CBPageNumber)
                request.PageSize = requests.NewInteger(CBPageSize)
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "ListImage()",
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        //spew.Dump(result) //    
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get Images, %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cnt := 0
        for _, cur := range result.Images.Image </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Image  ", cur.ImageId)
                imageInfo := ExtractImageDescribeInfo(&amp;cur)
                imageInfoList = append(imageInfoList, &amp;imageInfo)
        }</span>

        //spew.Dump(imageInfoList)
        <span class="cov0" title="0">return imageInfoList, nil</span>
}

//https://pkg.go.dev/github.com/aliyun/alibaba-cloud-sdk-go/services/ecs?tab=doc#Image
//package ecs v1.61.170 Latest Published: Apr 30, 2020
//Image  
func ExtractImageDescribeInfo(image *ecs.Image) irs.ImageInfo <span class="cov0" title="0">{
        //@TODO : 2020-03-26 Ali API       .
        //func ExtractImageDescribeInfo(image *ecs.ImageInDescribeImages) irs.ImageInfo {
        //@TODO : 2020-04-20 ecs.ImageInDescribeImages    ecs.Image  .
        //func ExtractImageDescribeInfo(image *ecs.Image) irs.ImageInfo {
        //*ecs.DescribeImagesResponse
        cblogger.Infof("=====&gt; ")
        spew.Dump(image)
        imageInfo := irs.ImageInfo{
                IId: irs.IID{NameId: image.ImageId, SystemId: image.ImageId},
                //Name:    image.ImageName,
                Status:  image.Status,
                GuestOS: image.OSNameEn,
        }

        keyValueList := []irs.KeyValue{
                {Key: "CreationTime", Value: image.CreationTime},
                {Key: "Architecture", Value: image.Architecture},

                {Key: "OSNameEn", Value: image.OSNameEn},
                {Key: "ProductCode", Value: image.ProductCode},
                {Key: "OSType", Value: image.OSType},
                {Key: "OSName", Value: image.OSName},
                {Key: "Progress", Value: image.Progress},
                {Key: "IsSupportCloudinit", Value: strconv.FormatBool(image.IsSupportCloudinit)},
                {Key: "Usage", Value: image.Usage},
                {Key: "ImageVersion", Value: image.ImageVersion},
                {Key: "IsSupportIoOptimized", Value: strconv.FormatBool(image.IsSupportIoOptimized)},
                {Key: "IsSelfShared", Value: image.IsSelfShared},
                {Key: "IsCopied", Value: strconv.FormatBool(image.IsCopied)},
                {Key: "IsSubscribed", Value: strconv.FormatBool(image.IsSubscribed)},
                {Key: "Platform", Value: image.Platform},
                {Key: "Size", Value: strconv.Itoa(image.Size)},
        }

        keyValueList = append(keyValueList, irs.KeyValue{Key: "Description", Value: image.Description})
        imageInfo.KeyValueList = keyValueList

        return imageInfo
}</span>

func (imageHandler *AlibabaImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("imageID : ", imageIID.SystemId)

        request := ecs.CreateDescribeImagesRequest()
        request.Scheme = "https"

        // request.Status = "Available"
        // request.ActionType = "*"

        request.ImageId = imageIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //ecs.DescribeImagesResponse.Images.Image
        //spew.Dump(result)
        cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get Images, %v", err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, errors.New("Notfound: '" + imageIID.SystemId + "' Images Not found")
        }</span>

        <span class="cov0" title="0">imageInfo := ExtractImageDescribeInfo(&amp;result.Images.Image[0])

        return imageInfo, nil</span>
}

func (imageHandler *AlibabaImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("DeleteImage : [%s]", imageIID.SystemId)
        // Delete the Image by Id

        request := ecs.CreateDeleteImageRequest()
        request.Scheme = "https"

        //request.ImageId = to.StringPtr(imageID)
        request.ImageId = imageIID.SystemId
        //   Req
        // request.Force = requests.NewBoolean(true)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DeleteImage()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := imageHandler.Client.DeleteImage(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to delete Image: %s, %v.", imageIID.SystemId, err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Successfully deleted %q Image\n", imageIID.SystemId)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr, 2019.09.

package resources

import (
        "bytes"
        "crypto/rsa"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AlibabaKeyPairHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

/*
// @TODO: KeyPairInfo    
type KeyPairInfo struct {
        Name        string
        Fingerprint string
        KeyMaterial string //RSA PRIVATE KEY
}
*/

func (keyPairHandler *AlibabaKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start ListKey()")
        var keyPairList []*irs.KeyPairInfo
        //spew.Dump(keyPairHandler)
        cblogger.Info(keyPairHandler)

        request := ecs.CreateDescribeKeyPairsRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: "ListKey()",
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        //  Returns a list of key pairs
        result, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get key pairs, %v", err)
                return keyPairList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)

        //cblogger.Debugf("Key Pairs:")
        for _, pair := range result.KeyPairs.KeyPair </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(&amp;pair)

                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s] KeyPair Local     Skip.", *&amp;pair.KeyPairName)
                        cblogger.Info(errKeyPair.Error())
                }</span> else<span class="cov0" title="0"> {
                        keyPairList = append(keyPairList, &amp;keyPairInfo)
                }</span>
        }

        <span class="cov0" title="0">cblogger.Info(keyPairList)
        //spew.Dump(keyPairList)
        return keyPairList, nil</span>
}

func (keyPairHandler *AlibabaKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateKey() : ", keyPairReqInfo)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">request := ecs.CreateCreateKeyPairRequest()
        request.Scheme = "https"

        request.KeyPairName = keyPairReqInfo.IId.NameId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        // Creates a new  key pair with the given name
        result, err := keyPairHandler.Client.CreateKeyPair(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to create key pair: %s, %v.", keyPairReqInfo.IId.NameId, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created key pair %q %s\n%s\n", result.KeyPairName, result.KeyPairFingerPrint, result.PrivateKeyBody)
        spew.Dump(result)

        cblogger.Info(" ")
        publicKey, errPub := makePublicKeyFromPrivateKey(result.PrivateKeyBody)
        if errPub != nil </span><span class="cov0" title="0">{
                cblogger.Error(errPub)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">cblogger.Infof("Public Key")
        spew.Dump(publicKey)

        keyPairInfo := irs.KeyPairInfo{
                IId:         irs.IID{NameId: result.KeyPairName, SystemId: result.KeyPairName},
                Fingerprint: result.KeyPairFingerPrint,
                PrivateKey:  result.PrivateKeyBody,
                PublicKey:   publicKey,
                KeyValueList: []irs.KeyValue{
                        {Key: "KeyMaterial", Value: result.PrivateKeyBody},
                },
        }

        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") //       .        .
        savePrivateFileTo := keyPairPath + hashString + ".pem"
        savePublicFileTo := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Infof("savePrivateFileTo : [%s]", savePrivateFileTo)
        cblogger.Infof("savePublicFileTo : [%s]", savePublicFileTo)

        //  private Key 
        err = writeKeyToFile([]byte(keyPairInfo.PrivateKey), savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        //  public Key 
        <span class="cov0" title="0">err = writeKeyToFile([]byte(keyPairInfo.PublicKey), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

//    keyPairID  keyPairName  .
func (keyPairHandler *AlibabaKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        //keyPairID := keyPairName
        cblogger.Infof("GetKey(keyPairName) : [%s]", keyIID.SystemId)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">request := ecs.CreateDescribeKeyPairsRequest()
        request.Scheme = "https"
        request.KeyPairName = keyIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                // if aerr, ok := err.(errors.Error); ok {
                cblogger.Errorf("Unable to get key pair: %s, %v.", keyIID.SystemId, err)
                return irs.KeyPairInfo{}, nil
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("result : ", result)
        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, errors.New("Notfound: '" + keyIID.SystemId + "' KeyPair Not found")
        }</span>

        <span class="cov0" title="0">keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(&amp;result.KeyPairs.KeyPair[0])
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair.Error())
                return irs.KeyPairInfo{}, errKeyPair
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

// KeyPair  
func ExtractKeyPairDescribeInfo(keyPair *ecs.KeyPair) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        spew.Dump(keyPair)

        keyPairInfo := irs.KeyPairInfo{
                IId:         irs.IID{NameId: keyPair.KeyPairName, SystemId: keyPair.KeyPairName},
                Fingerprint: keyPair.KeyPairFingerPrint,
        }

        // Local Keyfile 
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") //       .        .
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, privateKeyPath)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, publicKeyPath)

        // Private Key, Public Key   
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Local Private   ", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Local Public   ", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo.PublicKey = string(publicKeyBytes)
        keyPairInfo.PrivateKey = string(privateKeyBytes)

        keyValueList := []irs.KeyValue{
                //{Key: "ResourceGroupId", Value: keyPair.ResourceGroupId},
                {Key: "CreationTime", Value: keyPair.CreationTime},
        }

        keyPairInfo.KeyValueList = keyValueList

        return keyPairInfo, nil</span>
}

func (keyPairHandler *AlibabaKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("DeleteKey(KeyPairName) : [%s]", keyIID.SystemId)
        // Delete the key pair by name

        //      .
        keyPairInfo, errKey := keyPairHandler.GetKey(keyIID)
        if errKey != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Delete fail", keyIID.SystemId)
                cblogger.Error(errKey)
                return false, errKey
        }</span>

        <span class="cov0" title="0">request := ecs.CreateDeleteKeyPairsRequest()
        request.Scheme = "https"
        request.KeyPairNames = "[" + "\"" + keyIID.SystemId + "\"]"

        spew.Dump(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DeleteKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := keyPairHandler.Client.DeleteKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to delete key pair: %s, %v.", keyIID.SystemId, err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        cblogger.Infof("Successfully deleted %q Alibaba Cloud key pair\n", keyIID.SystemId)

        //====================
        // Local Keyfile 
        //====================
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") //       .        .
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"

        // Private Key, Public Key 
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

//=================================
//          
//=================================
func (keyPairHandler *AlibabaKeyPairHandler) CheckKeyPairFolder(keyPairPath string) error <span class="cov0" title="0">{
        //       .
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Path   .", keyPairPath)

                //errDir := os.MkdirAll(keyPairPath, 0755)
                errDir := os.MkdirAll(keyPairPath, 0700)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path  ", keyPairPath)
                        cblogger.Error(errDir)
                        return errDir
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ParseKey reads the given RSA private key and create a public one for it.
func makePublicKeyFromPrivateKey(pem string) (string, error) <span class="cov0" title="0">{
        key, err := ssh.ParseRawPrivateKey([]byte(pem))
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">rsaKey, ok := key.(*rsa.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q is not a RSA key", pem)
        }</span>
        <span class="cov0" title="0">pub, err := ssh.NewPublicKey(&amp;rsaKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(bytes.TrimRight(ssh.MarshalAuthorizedKey(pub), "\n")), nil</span>
}

//  Key 
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key : %s", saveFileTo)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by zephy@mz.co.kr, 2019.09.

package resources

import (
        "errors"
        "strings"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AlibabaSecurityHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

func (securityHandler *AlibabaSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityReqInfo : ", securityReqInfo)
        //spew.Dump(securityReqInfo)

        //=======================================
        //   
        //=======================================
        request := ecs.CreateCreateSecurityGroupRequest()
        request.Scheme = "https"

        request.Description = securityReqInfo.IId.NameId
        request.SecurityGroupName = securityReqInfo.IId.NameId
        request.VpcId = securityReqInfo.VpcIID.SystemId
        cblogger.Debugf("    ", request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "CreateSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        // Create the security group with the VPC, name and description.
        createRes, err := securityHandler.Client.CreateSecurityGroup(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to create security group %q, %v", securityReqInfo.IId.NameId, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Infof("[%s]   : SecurityGroupId:[%s]", securityReqInfo.IId.NameId, createRes.SecurityGroupId)
        //spew.Dump(createRes)

        //=======================================
        //   
        //=======================================
        cblogger.Infof(" [%s] /   ", createRes.SecurityGroupId)
        createRuleRes, errRule := securityHandler.AuthorizeSecurityRules(createRes.SecurityGroupId, securityReqInfo.VpcIID.SystemId, securityReqInfo.SecurityRules)
        if errRule != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("Unable to create security group rule %q, %v", securityReqInfo.IId.NameId, err)
                return irs.SecurityInfo{}, errRule
        }</span> else<span class="cov0" title="0"> {
                cblogger.Info("Successfully set security group AuthorizeSecurityRules")
        }</span>

        <span class="cov0" title="0">cblogger.Debug("AuthorizeSecurityRules Result")
        // spew.Dump(createRuleRes)
        cblogger.Debug(createRuleRes)

        securityInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: createRes.SecurityGroupId})
        //securityInfo.IId.NameId = securityReqInfo.IId.NameId
        return securityInfo, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) AuthorizeSecurityRules(securityGroupId string, vpcId string, securityRuleInfos *[]irs.SecurityRuleInfo) (*[]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityGroupId : [%s] / vpcId : [%s] / securityRuleInfos : [%v]", securityGroupId, vpcId, securityRuleInfos)
        //cblogger.Info("AuthorizeSecurityRules ", securityRuleInfos)
        spew.Dump(securityRuleInfos)

        /*
                if strings.EqualFold(curRule.Direction, "inbound") {
                } else if strings.EqualFold(curRule.Direction, "outbound") {
                }
        */

        for _, curRule := range *securityRuleInfos </span><span class="cov0" title="0">{
                //if curRule.Direction == "inbound" {
                if strings.EqualFold(curRule.Direction, "inbound") </span><span class="cov0" title="0">{
                        request := ecs.CreateAuthorizeSecurityGroupRequest()
                        request.Scheme = "https"
                        request.IpProtocol = curRule.IPProtocol
                        request.PortRange = curRule.FromPort + "/" + curRule.ToPort
                        request.SecurityGroupId = securityGroupId
                        //request.SourceCidrIp = "0.0.0.0/0"
                        request.SourceCidrIp = curRule.CIDR

                        cblogger.Infof("[%s] [%s] inbound rule Request", request.IpProtocol, request.PortRange)
                        spew.Dump(request)
                        response, err := securityHandler.Client.AuthorizeSecurityGroup(request)
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("Unable to create security group[%s] inbound rule - [%s] [%s] AuthorizeSecurityGroup Request", securityGroupId, request.IpProtocol, request.PortRange)
                                cblogger.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">cblogger.Infof("[%s] [%s] AuthorizeSecurityGroup Request success - RequestId:[%s]", request.IpProtocol, request.PortRange, response)</span>
                        //} else if curRule.Direction == "outbound" {
                } else<span class="cov0" title="0"> if strings.EqualFold(curRule.Direction, "outbound") </span><span class="cov0" title="0">{
                        request := ecs.CreateAuthorizeSecurityGroupEgressRequest()
                        request.Scheme = "https"
                        request.IpProtocol = curRule.IPProtocol
                        request.PortRange = curRule.FromPort + "/" + curRule.ToPort
                        request.SecurityGroupId = securityGroupId
                        //request.DestCidrIp = "0.0.0.0/0"
                        request.DestCidrIp = curRule.CIDR

                        cblogger.Infof("[%s] [%s] outbound rule Request", request.IpProtocol, request.PortRange)
                        spew.Dump(request)
                        response, err := securityHandler.Client.AuthorizeSecurityGroupEgress(request)
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("Unable to create security group[%s] outbound rule - [%s] [%s] AuthorizeSecurityGroup Request", securityGroupId, request.IpProtocol, request.PortRange)
                                cblogger.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">cblogger.Infof("[%s] [%s] AuthorizeSecurityGroup Request success - RequestId:[%s]", request.IpProtocol, request.PortRange, response)</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        //        return nil, nil

        // get SecurityGroup &amp; SecurityGroupAttribute for Alibaba
        request := ecs.CreateDescribeSecurityGroupsRequest()
        request.Scheme = "https"
        spew.Dump(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "ListSecurity()",
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        //spew.Dump(result)
        //ecs.DescribeSecurityGroupsResponse

        var securityInfoList []*irs.SecurityInfo
        for _, curSecurityGroup := range result.SecurityGroups.SecurityGroup </span><span class="cov0" title="0">{
                curSecurityInfo, errSecurityInfo := securityHandler.ExtractSecurityInfo(&amp;curSecurityGroup)
                if errSecurityInfo != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errSecurityInfo)
                        return nil, errSecurityInfo
                }</span>

                <span class="cov0" title="0">securityInfoList = append(securityInfoList, &amp;curSecurityInfo)</span>
        }

        <span class="cov0" title="0">return securityInfoList, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("SecurityGroupId : [%s]", securityIID.SystemId)

        request := ecs.CreateDescribeSecurityGroupsRequest()
        request.Scheme = "https"
        request.SecurityGroupId = securityIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        result, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Debug(result)
        //spew.Dump(result)
        //ecs.DescribeSecurityGroupsResponse

        //ecs.DescribeSecurityGroupsResponse.SecurityGroups
        //ecs.SecurityGroups
        //spew.Dump(result)
        
        //ecs.DescribeSecurityGroupsResponse
        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("Notfound: '" + securityIID.SystemId + "' SecurityGroup Not found")
        }</span>

        <span class="cov0" title="0">securityInfo, errSecurityInfo := securityHandler.ExtractSecurityInfo(&amp;result.SecurityGroups.SecurityGroup[0])
        if errSecurityInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSecurityInfo)
                return irs.SecurityInfo{}, errSecurityInfo
        }</span>

        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) ExtractSecurityInfo(securityGroupResult *ecs.SecurityGroup) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        //securityRules := ExtractIpPermissions(securityGroupResult.SecurityGroups.SecurityGroup)
        var securityRuleInfos []irs.SecurityRuleInfo

        securityRuleInfos, errRuleInfos := securityHandler.ExtractSecurityRuleInfo(securityGroupResult.SecurityGroupId)
        if errRuleInfos != nil </span><span class="cov0" title="0">{
                cblogger.Error(errRuleInfos)
                return irs.SecurityInfo{}, errRuleInfos
        }</span>

        <span class="cov0" title="0">securityInfo := irs.SecurityInfo{
                IId: irs.IID{NameId: securityGroupResult.SecurityGroupName, SystemId: securityGroupResult.SecurityGroupId},
                //SecurityRules: &amp;[]irs.SecurityRuleInfo{},
                //SecurityRules: &amp;securityRules,
                VpcIID:        irs.IID{SystemId: securityGroupResult.VpcId},
                SecurityRules: &amp;securityRuleInfos,

                KeyValueList: []irs.KeyValue{
                        {Key: "SecurityGroupName", Value: securityGroupResult.SecurityGroupName},
                        {Key: "CreationTime", Value: securityGroupResult.CreationTime},
                },
        }

        return securityInfo, nil</span>
}

//   InBound / OutBound  .
func (securityHandler *AlibabaSecurityHandler) ExtractSecurityRuleInfo(securityGroupId string) ([]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        var securityRuleInfos []irs.SecurityRuleInfo

        request := ecs.CreateDescribeSecurityGroupAttributeRequest()
        request.Scheme = "https"
        request.SecurityGroupId = securityGroupId

        response, err := securityHandler.Client.DescribeSecurityGroupAttribute(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">cblogger.Info(response)

        /*
           FromPort    string
           ToPort        string
        */
        var curSecurityRuleInfo irs.SecurityRuleInfo
        for _, curPermission := range response.Permissions.Permission </span><span class="cov0" title="0">{
                curSecurityRuleInfo.Direction = curPermission.Direction

                if strings.EqualFold(curPermission.Direction, "ingress") </span><span class="cov0" title="0">{
                        // curSecurityRuleInfo.Direction = "inbound"
                        curSecurityRuleInfo.CIDR = curPermission.SourceCidrIp
                }</span> else<span class="cov0" title="0"> if strings.EqualFold(curPermission.Direction, "egress") </span><span class="cov0" title="0">{
                        // curSecurityRuleInfo.Direction = "outbound"
                        curSecurityRuleInfo.CIDR = curPermission.DestCidrIp
                }</span>

                <span class="cov0" title="0">curSecurityRuleInfo.IPProtocol = curPermission.IpProtocol

                portRange := strings.Split(curPermission.PortRange, "/")

                curSecurityRuleInfo.FromPort = portRange[0]
                if len(portRange) &gt; 1 </span><span class="cov0" title="0">{
                        curSecurityRuleInfo.ToPort = portRange[1]
                }</span>
                <span class="cov0" title="0">securityRuleInfos = append(securityRuleInfos, curSecurityRuleInfo)</span>
        }

        <span class="cov0" title="0">return securityRuleInfos, nil</span>
}

func (securityHandler *AlibabaSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("securityID : [%s]", securityIID.SystemId)

        request := ecs.CreateDeleteSecurityGroupRequest()
        request.Scheme = "https"
        request.SecurityGroupId = securityIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DeleteSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := securityHandler.Client.DeleteSecurityGroup(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get descriptions for security groups, %v.", err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(response)
        cblogger.Infof("Successfully delete security group %q.", securityIID.SystemId)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Proof of Concepts for the Cloud-Barista Multi-Cloud Project.
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by zephy@mz.co.kr, 2019.09.

package resources

import (
        "encoding/base64"
        "errors"
        "io/ioutil"
        "os"
        "strings"
        "time"

        "github.com/aliyun/alibaba-cloud-sdk-go/sdk/requests"
        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"
        /*
                "github.com/davecgh/go-spew/spew"
        */)

type AlibabaVMHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

//  : VM     KeyPair  ID&amp;PWD     root  -    
//         8-30 , ,  /    .
// @TODO : root            ..      .
// @TODO : PublicIp       
func (vmHandler *AlibabaVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        //cblogger.Info(vmReqInfo)
        spew.Dump(vmReqInfo)

        // 2021-04-28 cbuser   Local KeyPair VM   
        //=============================
        // KeyPair PublicKey  
        //=============================
        cblogger.Infof("[%s] KeyPair  ", vmReqInfo.KeyPairIID.SystemId)
        keypairHandler := AlibabaKeyPairHandler{
                //CredentialInfo:
                Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(keypairHandler)

        keyPairInfo, errKeyPair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair)
                return irs.VMInfo{}, errKeyPair
        }</span>

        //=============================
        // UserData 
        //=============================
        /*
                package_update: true
                packages:
                 - sudo
                users:
                  - default
                  - name: cb-user
                        groups: sudo
                        shell: /bin/bash
                        sudo: ['ALL=(ALL) NOPASSWD:ALL']
                        ssh-authorized-keys:
                          - ssh-rsa AAAAB3NzaC1y
        */
        /*
                //sudo  
                //userData := "#cloud-config\npackage_update: true\npackages:\n  - sudo\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    groups: sudo\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                //sudo  
                //userData := "#cloud-config\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    groups: sudo\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                // 
                userData := "#cloud-config\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                userData = userData + keyPairInfo.PublicKey
                userDataBase64 := base64.StdEncoding.EncodeToString([]byte(userData))
                cblogger.Infof("===== userData ===")
                spew.Dump(userDataBase64)
        */

        //=============================
        // UserData (File)
        //=============================
        //       cloud-init   
        <span class="cov0" title="0">rootPath := os.Getenv("CBSPIDER_ROOT")
        fileDataCloudInit, err := ioutil.ReadFile(rootPath + CBCloudInitFilePath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">userData := string(fileDataCloudInit)
        userData = strings.ReplaceAll(userData, "{{username}}", CBDefaultVmUserName)
        userData = strings.ReplaceAll(userData, "{{public_key}}", keyPairInfo.PublicKey)
        userDataBase64 := base64.StdEncoding.EncodeToString([]byte(userData))
        cblogger.Debugf("cloud-init data : [%s]", userDataBase64)

        //=============================
        //   - SystemId 
        //=============================
        cblogger.Info("SystemId    IID    SystemId     .")
        var newSecurityGroupIds []string
        //var firstSecurityGroupId string

        for _, sgId := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                cblogger.Infof("  : [%s]", sgId)
                newSecurityGroupIds = append(newSecurityGroupIds, sgId.SystemId)
                //firstSecurityGroupId = sgId.SystemId
                //break
        }</span>

        <span class="cov0" title="0">cblogger.Info("  ")
        cblogger.Info(newSecurityGroupIds)

        //request := ecs.CreateCreateInstanceRequest()        // CreateInstance PublicIp   .
        request := ecs.CreateRunInstancesRequest() // RunInstances PublicIp  .
        request.Scheme = "https"

        request.InstanceChargeType = "PostPaid" //    //PrePaid: subscription.  / PostPaid: pay-as-you-go. Default value: PostPaid.
        request.ImageId = vmReqInfo.ImageIID.SystemId
        //request.SecurityGroupIds *[]string
        request.SecurityGroupIds = &amp;newSecurityGroupIds
        //request.SecurityGroupId = firstSecurityGroupId // string     
        //request.SecurityGroupId =  "[\"" + newSecurityGroupIds + "\"]" // string     

        request.InstanceName = vmReqInfo.IId.NameId
        //request.HostName = vmReqInfo.IId.NameId        // OS  
        request.InstanceType = vmReqInfo.VMSpecName
        request.KeyPairName = vmReqInfo.KeyPairIID.SystemId
        request.VSwitchId = vmReqInfo.SubnetIID.SystemId

        request.Password = vmReqInfo.VMUserPasswd // 8-30  , ,  /    .

        request.UserData = userDataBase64 // cbuser 

        //==============
        //PublicIp 
        //==============
        //Public Ip    (1 Mbit/s)  .
        //PayByTraffic() :   (GB ) -   (GB )     
        //PayByBandwidth :     ECS    .
        request.InternetChargeType = "PayByBandwidth"           //Public Ip  1 (PayByBandwidth)   / PayByTraffic() : 1GB    
        request.InternetMaxBandwidthOut = requests.Integer("5") // 0  Public IP   -       : Mbit / s   : 0 ~ 100
        spew.Dump(request)

        //=============================
        // VM 
        //=============================
        cblogger.Info("Create EC2 Instance")
        cblogger.Info(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmReqInfo.IId.NameId,
                CloudOSAPI:   "RunInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        response, err := vmHandler.Client.RunInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        //spew.Dump(response)

        if len(response.InstanceIdSets.InstanceIdSet) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("No errors have occurred, but no VMs have been created.")
        }</span>

        //=========================================
        // VM      
        //=========================================
        <span class="cov0" title="0">newVmIID := irs.IID{SystemId: response.InstanceIdSets.InstanceIdSet[0]}

        //VM     VM      VM     NotExist     .
        //2021-05-11 WaitForRun   GetVM()       . (     WaitForRun  .)
        //curStatus, errStatus := vmHandler.WaitForExist(newVmIID) // 20210511 - NotExist     
        curStatus, errStatus := vmHandler.WaitForRun(newVmIID) // 20210511      WaitForRun  
        if errStatus != nil </span><span class="cov0" title="0">{
                cblogger.Error(errStatus.Error())
                return irs.VMInfo{}, nil
        }</span>
        <span class="cov0" title="0">cblogger.Info("==&gt; VM[%s]  [%s]", newVmIID, curStatus)

        //vmInfo, errVmInfo := vmHandler.GetVM(irs.IID{SystemId: response.InstanceId})
        vmInfo, errVmInfo := vmHandler.GetVM(newVmIID)
        if errVmInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVmInfo.Error())
                return irs.VMInfo{}, errVmInfo
        }</span>
        <span class="cov0" title="0">vmInfo.IId.NameId = vmReqInfo.IId.NameId

        //VM             .
        if vmReqInfo.VMUserPasswd != "" </span><span class="cov0" title="0">{
                vmInfo.VMUserPasswd = vmReqInfo.VMUserPasswd
                vmInfo.VMUserId = "root"
        }</span>
        <span class="cov0" title="0">return vmInfo, nil</span>
}

// VM        ( 30 )
func (vmHandler *AlibabaVMHandler) WaitForExist(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt; VM   VM      NotExist    .")

        waitStatus := "NotExist" //VM  .
        //waitStatus := "Running"
        //waitStatus := "Creating" //     VM     .

        //===================================
        // Suspending  3   .
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 30
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)

                if curStatus != irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM [%s] [%s]   .", curStatus, waitStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM  [%s] 1  .", curStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("(%d )  VM Status  [%s]   .", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("   VM  [" + waitStatus + "]     .")
                }</span>
                //} else {
                //break
                //}
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}

// VM       30 
func (vmHandler *AlibabaVMHandler) WaitForRun(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt; VM       Running   .")

        //waitStatus := "NotExist"        //VM  .
        waitStatus := "Running"
        //waitStatus := "Creating" //     VM     .

        //===================================
        // Suspending  3   .
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)

                if curStatus == irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM  [%s]  .", curStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM  [%s]  1  .", waitStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("(%d )  VM Status  [%s]    .", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("   VM  [" + waitStatus + "]    .")
                }</span>
                //} else {
                //break
                //}
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}

func (vmHandler *AlibabaVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateStartInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StartInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.StartInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(response)
        return irs.VMStatus("Resuming"), nil</span>

}

// @TODO -  :        - StopCharging / KeepCharging
func (vmHandler *AlibabaVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateStopInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId
        request.StoppedMode = "StopCharging"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StopInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.StopInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)
        return irs.VMStatus("Suspending"), nil</span>
}

func (vmHandler *AlibabaVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateRebootInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "RebootInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.RebootInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)
        return irs.VMStatus("Rebooting"), nil</span>
}

func (vmHandler *AlibabaVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        cblogger.Infof("VM   Suspend  .")
        //Terminate VM Running  .
        sus, errSus := vmHandler.SuspendVM(vmIID)
        if errSus != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSus.Error())
                return irs.VMStatus("Failed"), errSus
        }</span>

        <span class="cov0" title="0">if sus != "Suspending" </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VM Suspend   [%s] Suspending .", vmIID.SystemId, sus)
                return irs.VMStatus("Failed"), errors.New(vmIID.SystemId + " VM Suspend     Suspending .")
        }</span>

        //===================================
        // Suspending  3   .
        //===================================
        <span class="cov0" title="0">curRetryCnt := 0
        maxRetryCnt := 60
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)
                if curStatus != irs.VMStatus("Suspended") </span><span class="cov0" title="0">{
                        curRetryCnt++
                        cblogger.Error("VM  Suspended  1  .")
                        time.Sleep(time.Second * 1)
                        if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                                cblogger.Error("  VM Status  Suspended    .")
                        }</span>
                } else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">request := ecs.CreateDeleteInstanceRequest()
        request.Scheme = "https"
        request.InstanceId = vmIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DeleteInstance()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DeleteInstance(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)
        return irs.VMStatus("Terminating"), nil</span>
}

func (vmHandler *AlibabaVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("vmID : [%s]", vmIID.SystemId)

        request := ecs.CreateDescribeInstancesRequest()
        request.Scheme = "https"
        request.InstanceIds = "[\"" + vmIID.SystemId + "\"]"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)

        if response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("Notfound: '" + vmIID.SystemId + "' VM Not found")
        }</span>

        //        vmInfo := vmHandler.ExtractDescribeInstances(response.Instances.Instance[0])
        <span class="cov0" title="0">vmInfo := vmHandler.ExtractDescribeInstances(&amp;response.Instances.Instance[0])
        cblogger.Info("vmInfo", vmInfo)
        return vmInfo, nil</span>
}

//@TODO : 2020-03-26 Ali API       .
//func (vmHandler *AlibabaVMHandler) ExtractDescribeInstances() irs.VMInfo {
func (vmHandler *AlibabaVMHandler) ExtractDescribeInstances(instancInfo *ecs.Instance) irs.VMInfo <span class="cov0" title="0">{
        cblogger.Info(instancInfo)

        //time.Parse(layout, str)
        vmInfo := irs.VMInfo{
                IId:        irs.IID{NameId: instancInfo.InstanceName, SystemId: instancInfo.InstanceId},
                ImageIId:   irs.IID{SystemId: instancInfo.ImageId},
                VMSpecName: instancInfo.InstanceType,
                KeyPairIId: irs.IID{SystemId: instancInfo.KeyPairName},
                //StartTime:  instancInfo.StartTime,

                Region:    irs.RegionInfo{Region: instancInfo.RegionId, Zone: instancInfo.ZoneId}, //  ex) {us-east1, us-east1-c} or {ap-northeast-2}
                VpcIID:    irs.IID{SystemId: instancInfo.VpcAttributes.VpcId},
                SubnetIID: irs.IID{SystemId: instancInfo.VpcAttributes.VSwitchId},
                //SecurityGroupIIds []IID // AWS, ex) sg-0b7452563e1121bb6
                //NetworkInterface string // ex) eth0
                //PublicDNS
                //PrivateIP
                //PrivateIP: instancInfo.VpcAttributes.PrivateIpAddress.IpAddress[0],
                //PrivateDNS

                //VMBootDisk  string // ex) /dev/sda1
                //VMBlockDisk string // ex)

                KeyValueList: []irs.KeyValue{{Key: "", Value: ""}},
        }

        if len(instancInfo.NetworkInterfaces.NetworkInterface) &gt; 0 </span><span class="cov0" title="0">{
                vmInfo.NetworkInterface = instancInfo.NetworkInterfaces.NetworkInterface[0].NetworkInterfaceId
        }</span>

        //vmInfo.VMUserId = "root"
        <span class="cov0" title="0">vmInfo.VMUserId = CBDefaultVmUserName //2021-05-11 VMUserId  cb-user .

        //2021-05-11 VM  WaitForRun()    
        //VM    PrivateIpAddress  .
        if len(instancInfo.VpcAttributes.PrivateIpAddress.IpAddress) &gt; 0 </span><span class="cov0" title="0">{
                vmInfo.PrivateIP = instancInfo.VpcAttributes.PrivateIpAddress.IpAddress[0]
        }</span>

        /*
                if !reflect.ValueOf(reservation.Instances[0].PublicDnsName).IsNil() {
                        vmInfo.PublicDNS = *reservation.Instances[0].PublicDnsName
                }
        */

        //VMUserId
        //VMUserPasswd
        //NetworkInterfaceId

        <span class="cov0" title="0">if len(instancInfo.PublicIpAddress.IpAddress) &gt; 0 </span><span class="cov0" title="0">{
                vmInfo.PublicIP = instancInfo.PublicIpAddress.IpAddress[0]
        }</span>

        <span class="cov0" title="0">for _, security := range instancInfo.SecurityGroupIds.SecurityGroupId </span><span class="cov0" title="0">{
                //vmInfo.SecurityGroupIds = append(vmInfo.SecurityGroupIds, *security.GroupId)
                vmInfo.SecurityGroupIIds = append(vmInfo.SecurityGroupIIds, irs.IID{SystemId: security})
        }</span>

        <span class="cov0" title="0">timeLen := len(instancInfo.CreationTime)
        cblogger.Infof("     ")
        cblogger.Infof("======&gt;   [%s]", timeLen)
        if timeLen &gt; 7 </span><span class="cov0" title="0">{
                cblogger.Infof("======&gt;    [%s]", instancInfo.CreationTime[timeLen-1:])
                var NewStartTime string
                if instancInfo.CreationTime[timeLen-1:] == "Z" &amp;&amp; timeLen == 17 </span><span class="cov0" title="0">{
                        //cblogger.Infof("======&gt;   : [%s]", StartTime[:timeLen-1])
                        NewStartTime = instancInfo.CreationTime[:timeLen-1] + ":00Z"
                        cblogger.Infof("======&gt;    : [%s]", NewStartTime)
                }</span> else<span class="cov0" title="0"> {
                        NewStartTime = instancInfo.CreationTime
                }</span>

                <span class="cov0" title="0">cblogger.Infof("Convert StartTime string [%s] to time.time", NewStartTime)

                //layout := "2020-05-07T01:36Z"
                t, err := time.Parse(time.RFC3339, NewStartTime)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Infof("======&gt; [%v]", t)
                        vmInfo.StartTime = t
                }</span>
        }

        <span class="cov0" title="0">return vmInfo</span>
}

func (vmHandler *AlibabaVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")

        request := ecs.CreateDescribeInstancesRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVM()",
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(response)

        var vmInfoList []*irs.VMInfo
        for _, curInstance := range response.Instances.Instance </span><span class="cov0" title="0">{

                cblogger.Info("[%s] ECS  ", curInstance.InstanceId)
                vmInfo, errVmInfo := vmHandler.GetVM(irs.IID{SystemId: curInstance.InstanceId})
                if errVmInfo != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errVmInfo.Error())
                        return nil, errVmInfo
                }</span>
                //cblogger.Info("=======&gt;VM  ")
                <span class="cov0" title="0">spew.Dump(vmInfo)

                vmInfoList = append(vmInfoList, &amp;vmInfo)</span>
        }

        //cblogger.Info("=======&gt;VM  ")
        <span class="cov0" title="0">spew.Dump(vmInfoList)
        //cblogger.Info("=======&gt;VM  ")
        return vmInfoList, nil</span>
}

//SHUTTING-DOWN / TERMINATED
func (vmHandler *AlibabaVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        request := ecs.CreateDescribeInstanceStatusRequest()
        request.Scheme = "https"
        request.InstanceId = &amp;[]string{vmIID.SystemId}
        cblogger.Infof("request : [%v]", request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstanceStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstanceStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err.Error())
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success", response)
        if response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                //return irs.VMStatus("Failed"), errors.New("Notfound: '" + vmIID.SystemId + "' VM Not found")
                return irs.VMStatus("NotExist"), nil
        }</span>

        <span class="cov0" title="0">for _, vm := range response.InstanceStatuses.InstanceStatus </span><span class="cov0" title="0">{
                //vmStatus := strings.ToUpper(vm.Status)
                cblogger.Infof("Req VM:[%s] / Cur VM:[%s] / ECS Status : [%s]", vmID, vm.InstanceId, vm.Status)
                vmStatus, errStatus := vmHandler.ConvertVMStatusString(vm.Status)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                        return irs.VMStatus("Failed"), errStatus
                }</span>
                <span class="cov0" title="0">return vmStatus, errStatus</span>
        }

        <span class="cov0" title="0">return irs.VMStatus("Failed"), errors.New("No status information found.")</span>
}

//    : https://www.alibabacloud.com/help/doc-detail/25380.htm
/*
const (
        Creating VMStatus = Creating" // from launch to running
        Running VMStatus = Running"

        Suspending VMStatus = Suspending" // from running to suspended
        Suspended  VMStatus = Suspended"
        Resuming VMStatus = Resuming" // from suspended to running

        Rebooting VMStatus = Rebooting" // from running to running

        Terminating VMStatus = Terminating" // from running, suspended to terminated
        Terminated  VMStatus = Terminated
        NotExist  VMStatus = NotExist  // VM does not exist

        Failed  VMStatus = Failed
)

&lt; &gt;
Running( ): MCIS  
Suspended( ): MCIS  
Failed( ): MCIS    
Terminated( ): MCIS  

&lt; &gt;
Creating(  ): MCIS   
Suspending(  ): MCIS     
Resuming(  ): MCIS     
Rebooting(  ): MCIS  
Terminating(  ): MCIS     

*/
func (vmHandler *AlibabaVMHandler) ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "Pending") </span><span class="cov0" title="0">{
                resultStatus = "Creating"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Running") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Stopping") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Stopped") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]      .", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "  CB VM    .")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM   : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

func (vmHandler *AlibabaVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")

        request := ecs.CreateDescribeInstanceStatusRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVMStatus()",
                CloudOSAPI:   "DescribeInstanceStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstanceStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success", response)
        if response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var vmInfoList []*irs.VMStatusInfo
        for _, vm := range response.InstanceStatuses.InstanceStatus </span><span class="cov0" title="0">{
                cblogger.Infof("Cur VM:[%s] / ECS Status : [%s]", vm.InstanceId, vm.Status)
                vmStatus, errStatus := vmHandler.ConvertVMStatusString(vm.Status)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                        return nil, errStatus
                }</span>
                <span class="cov0" title="0">curVmStatusInfo := irs.VMStatusInfo{IId: irs.IID{SystemId: vm.InstanceId}, VmStatus: vmStatus}
                vmInfoList = append(vmInfoList, &amp;curVmStatusInfo)</span>
        }

        <span class="cov0" title="0">return vmInfoList, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package resources

import (
        "errors"
        "reflect"
        "strconv"
        "strings"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

//https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.DescribeInstanceTypes
type AlibabaVmSpecHandler struct {
        Region idrv.RegionInfo
        Client *ecs.Client
}

//   
func ExtractVMSpecInfo(Region string, instanceTypeInfo ecs.InstanceType) irs.VMSpecInfo <span class="cov0" title="0">{
        //@TODO : 2020-03-26 Ali API       .
        // ecs.InstanceType  Mac  API ecs.InstanceType  ecs.InstanceTypeInDescribeInstanceTypes .
        //func ExtractVMSpecInfo(Region string, instanceTypeInfo ecs.InstanceTypeInDescribeInstanceTypes) irs.VMSpecInfo {
        //@todo : 2020-04-20 ecs.InstanceTypeInDescribeInstanceTypes    ecs.InstanceType .
        //func ExtractVMSpecInfo(Region string, instanceTypeInfo ecs.InstanceType) irs.VMSpecInfo {
        //ecs.InstanceType
        cblogger.Infof("ExtractVMSpecInfo : Region:[%s] / SpecName:[%s]", Region, instanceTypeInfo.InstanceTypeFamily)
        //spew.Dump(instanceTypeInfo)

        vCpuInfo := irs.VCpuInfo{
                Clock: "N/A",
        }
        gpuInfoList := []irs.GpuInfo{
                {
                        Count: strconv.Itoa(instanceTypeInfo.GPUAmount),
                        Model: instanceTypeInfo.GPUSpec,
                },
        }

        if !reflect.ValueOf(&amp;instanceTypeInfo.GPUSpec).IsNil() </span><span class="cov0" title="0">{
                gpu := strings.Split(instanceTypeInfo.GPUSpec, " ") //"Nvidia Tesla P4"
                cblogger.Infof("   : [%s] / [%s]", instanceTypeInfo.GPUSpec, gpu[0])
                gpuInfoList[0].Mfr = gpu[0]
        }</span>

        //          .
        <span class="cov0" title="0">vmSpecInfo := irs.VMSpecInfo{
                Region: Region,
        }

        //VCPU   - Count
        //if !reflect.ValueOf(&amp;instanceTypeInfo.CpuCoreCount).IsNil() {
        vCpuInfo.Count = strconv.Itoa(instanceTypeInfo.CpuCoreCount)
        //}

        vmSpecInfo.VCpu = vCpuInfo

        vmSpecInfo.Gpu = gpuInfoList

        //if !reflect.ValueOf(&amp;instanceTypeInfo.InstanceTypeId).IsNil() {
        vmSpecInfo.Name = instanceTypeInfo.InstanceTypeId
        //}

        //if !reflect.ValueOf(&amp;instanceTypeInfo.MemorySize).IsNil() {
        //vmSpecInfo.Mem = strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)
        vmSpecInfo.Mem = strconv.FormatFloat(instanceTypeInfo.MemorySize*1024, 'f', 0, 64) // GB-&gt;MB 
        //}

        //KeyValue  
        keyValueList, errKeyValue := ConvertKeyValueList(instanceTypeInfo)
        cblogger.Errorf("[%] KeyValue  ", instanceTypeInfo.InstanceTypeId)
        cblogger.Error(errKeyValue)
        vmSpecInfo.KeyValueList = keyValueList

        return vmSpecInfo</span>
}

func (vmSpecHandler *AlibabaVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListVMSpec(Region:[%s])", Region)
        var vMSpecInfoList []*irs.VMSpecInfo

        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get ListVMSpec - %v", err)
                return vMSpecInfoList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //spew.Dump(resp)
        cblogger.Info("    : ", len(resp.InstanceTypes.InstanceType))
        for _, curInstance := range resp.InstanceTypes.InstanceType </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VM   ", curInstance.InstanceTypeFamily)
                vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)
        }</span>
        //spew.Dump(vMSpecInfoList)
        <span class="cov0" title="0">return vMSpecInfoList, nil</span>
}

func (vmSpecHandler *AlibabaVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetVMSpec(Region:[%s], Name:[%s])", Region, Name)

        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region
        //request.InstanceTypeFamily = Name

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "Region:" + Region + "/ Name:" + Name,
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("    : ", len(resp.InstanceTypes.InstanceType))
        //        spew.Dump(resp)

        if len(resp.InstanceTypes.InstanceType) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMSpecInfo{}, errors.New("Notfound: '" + Name + "'  Spec    .")
        }</span>

        <span class="cov0" title="0">var vMSpecInfo irs.VMSpecInfo
        //      .
        //       InstanceTypeFamily      .
        for _, curInstance := range resp.InstanceTypes.InstanceType </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s]", curInstance.InstanceTypeId)
                if Name == curInstance.InstanceTypeId </span><span class="cov0" title="0">{
                        cblogger.Debugf("===&gt; [%s]", curInstance.InstanceTypeId)
                        cblogger.Infof("[%s] VM   ", curInstance.InstanceTypeId)
                        vMSpecInfo = ExtractVMSpecInfo(Region, curInstance)
                        break</span>
                }
        }

        <span class="cov0" title="0">return vMSpecInfo, nil</span>
}

// Alibaba Cloud     JSON  .
func (vmSpecHandler *AlibabaVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListOrgVMSpec(Region:[%s])", Region)

        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListOrgVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get ListOrgVMSpec - %v", err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //jsonString, errJson := ConvertJsonString(resp.InstanceTypes.InstanceType)
        jsonString, errJson := ConvertJsonString(resp.InstanceTypes)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}

// AWS     JSON  .
func (vmSpecHandler *AlibabaVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetOrgVMSpec(Region:[%s], Name:[%s])", Region, Name)
        request := ecs.CreateDescribeInstanceTypesRequest()
        request.Scheme = "https"
        request.RegionId = Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "Region:" + Region + "/ Name:" + Name,
                CloudOSAPI:   "DescribeInstanceTypes()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.DescribeInstanceTypes(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(resp)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("    : ", len(resp.InstanceTypes.InstanceType))
        //        spew.Dump(resp)

        if len(resp.InstanceTypes.InstanceType) &lt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(Name + "  Spec    .")
        }</span>

        <span class="cov0" title="0">var jsonString string
        var errJson error
        //      .
        //       InstanceTypeFamily      .
        for _, curInstance := range resp.InstanceTypes.InstanceType </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s]", curInstance.InstanceTypeId)
                if Name == curInstance.InstanceTypeId </span><span class="cov0" title="0">{
                        cblogger.Debugf("===&gt; [%s]", curInstance.InstanceTypeId)
                        cblogger.Infof("[%s] VM   ", curInstance.InstanceTypeId)

                        jsonString, errJson = ConvertJsonString(curInstance)
                        if errJson != nil </span><span class="cov0" title="0">{
                                cblogger.Error(errJson)
                                return "", errJson
                        }</span>

                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">return jsonString, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by zephy@mz.co.kr, 2019.09.
// by devunet@mz.co.kr, 2020.04.

//VPC &amp; Subnet  (AlibabaCloud's Subnet --&gt; VSwitch )
package resources

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
        "github.com/davecgh/go-spew/spew"

        //"github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        /*
                "github.com/aliyun/alibaba-cloud-sdk-go/sdk/errors"
                "github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
                idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
                irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
                "github.com/davecgh/go-spew/spew"
        */)

type AlibabaVPCHandler struct {
        Region idrv.RegionInfo
        Client *vpc.Client
}

func (VPCHandler *AlibabaVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        request := vpc.CreateCreateVpcRequest()
        request.Scheme = "https"
        request.VpcName = vpcReqInfo.IId.NameId
        request.CidrBlock = vpcReqInfo.IPv4_CIDR

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        response, err := VPCHandler.Client.CreateVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //VPC  Pending  Subnet     Available   .
        err = VPCHandler.WaitForRun(response.VpcId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>

        //==========================
        // Subnet 
        //==========================
        <span class="cov0" title="0">cblogger.Info("Subnet  ")
        //var resSubnetList []irs.SubnetInfo
        for _, curSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet ", curSubnet.IId.NameId)
                resSubnet, errSubnet := VPCHandler.CreateSubnet(response.VpcId, curSubnet)

                cblogger.Info(resSubnet)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        return irs.VPCInfo{}, errSubnet
                }</span>
        }

        // Subnet  VPC   .
        <span class="cov0" title="0">retVpcInfo, errVpc := VPCHandler.GetVPC(irs.IID{SystemId: response.VpcId})
        if errVpc != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpc)
                return irs.VPCInfo{}, errVpc
        }</span>
        <span class="cov0" title="0">retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId // NameId     .

        return retVpcInfo, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Info(reqSubnetInfo)

        /*
                vpcInfo, errVpcInfo := VPCHandler.GetSubnet(reqSubnetInfo.IId.SystemId)
                if errVpcInfo == nil {
                        cblogger.Errorf(" [%S] Subnet         .", reqSubnetInfo.IId.SystemId)
                        cblogger.Info(vpcInfo)
                        return vpcInfo, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + reqSubnetInfo.IId.SystemId + "' already exists.")
                }
        */

        // 
        request := vpc.CreateCreateVSwitchRequest()
        request.Scheme = "https"
        request.VpcId = vpcId
        request.CidrBlock = reqSubnetInfo.IPv4_CIDR
        request.VSwitchName = reqSubnetInfo.IId.NameId
        fmt.Printf("\n\n======= %#v\n\n", VPCHandler.Region.Zone) // by powerkim.
        request.ZoneId = VPCHandler.Region.Zone                   //"ap-northeast-1a" // @TOTO : ZoneId   .
        cblogger.Info(request)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateVSwitch()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        response, err := VPCHandler.Client.CreateVSwitch(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err.Error())
                return irs.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        spew.Dump(response)

        subnetInfo, errSunetInfo := VPCHandler.GetSubnet(response.VSwitchId)
        if errSunetInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(subnetInfo)
                return irs.SubnetInfo{}, errSunetInfo
        }</span>

        <span class="cov0" title="0">return subnetInfo, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start")

        request := vpc.CreateDescribeVpcsRequest()
        request.Scheme = "https"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "List()",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(result)
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vpcInfoList []*irs.VPCInfo
        for _, curVpc := range result.Vpcs.Vpc </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VPC  ", curVpc.VpcId)
                //vpcInfo := ExtractVpcDescribeInfo(&amp;curVpc)
                vpcInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: curVpc.VpcId})
                if vpcErr != nil </span><span class="cov0" title="0">{
                        return nil, vpcErr
                }</span>
                <span class="cov0" title="0">vpcInfoList = append(vpcInfoList, &amp;vpcInfo)</span>
        }

        <span class="cov0" title="0">cblogger.Debug(result)
        //spew.Dump(vpcInfoList)
        return vpcInfoList, nil</span>
}

//VPC  
func ExtractVpcDescribeInfo(vpcInfo *vpc.Vpc) irs.VPCInfo <span class="cov0" title="0">{
        aliVpcInfo := irs.VPCInfo{
                IId:       irs.IID{NameId: vpcInfo.VpcName, SystemId: vpcInfo.VpcId},
                IPv4_CIDR: vpcInfo.CidrBlock,
        }

        keyValueList := []irs.KeyValue{
                {Key: "IsDefault", Value: strconv.FormatBool(vpcInfo.IsDefault)},
                {Key: "Status", Value: vpcInfo.Status},
                {Key: "VRouterId", Value: vpcInfo.VRouterId},
                {Key: "RegionId", Value: vpcInfo.RegionId},
        }
        aliVpcInfo.KeyValueList = keyValueList

        return aliVpcInfo
}</span>

//Pending , Available
func (VPCHandler *AlibabaVPCHandler) WaitForRun(vpcId string) error <span class="cov0" title="0">{
        cblogger.Info("======&gt; VPC Running   .")

        maxRetryCnt := 20
        curRetryCnt := 0
        status := ""
        request := vpc.CreateDescribeVpcsRequest()
        request.Scheme = "https"
        request.VpcId = vpcId

        for </span><span class="cov0" title="0">{
                result, err := VPCHandler.Client.DescribeVpcs(request)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if len(result.Vpcs.Vpc) &lt; 1 </span><span class="cov0" title="0">{
                        return errors.New("Not found")
                }</span>

                <span class="cov0" title="0">status = result.Vpcs.Vpc[0].Status
                cblogger.Info("===&gt;VPC Status : ", status)
                if strings.EqualFold(status, "Pending") </span><span class="cov0" title="0">{
                        curRetryCnt++
                        cblogger.Error("VPC  Available  1  .")
                        time.Sleep(time.Second * 1)
                        if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                                cblogger.Error(" VPC Status  Available    .")
                        }</span>
                } else<span class="cov0" title="0"> {
                        if strings.EqualFold(status, "Available") </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> {
                                return errors.New("Unknown VPC Status value.")
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (VPCHandler *AlibabaVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        request := vpc.CreateDescribeVpcsRequest()
        request.Scheme = "https"
        request.VpcId = vpcIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("VPC  : ", len(result.Vpcs.Vpc))
        //if result.TotalCount &lt; 1 {
        if len(result.Vpcs.Vpc) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New("Notfound: '" + vpcIID.SystemId + "' VPC Not found")
        }</span>

        <span class="cov0" title="0">vpcInfo := ExtractVpcDescribeInfo(&amp;result.Vpcs.Vpc[0])
        spew.Dump(vpcInfo)

        //==========================
        // VPC  
        //==========================
        var subnetInfoList []irs.SubnetInfo
        for _, curSubnet := range result.Vpcs.Vpc[0].VSwitchIds.VSwitchId </span><span class="cov0" title="0">{
                //cblogger.Infof("\n\n\n\n")
                //cblogger.Infof("---------------------------------------------------------------------")
                cblogger.Infof("[%s] VSwitch  ", curSubnet)
                subnetInfo, errSubnet := VPCHandler.GetSubnet(curSubnet)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] VSwitch   ", curSubnet)
                        cblogger.Error(errSubnet)
                        return irs.VPCInfo{}, errSubnet
                }</span>
                //cblogger.Infof("    =====&gt; [%s]  ", curSubnet)
                //spew.Dump(subnetInfo)
                <span class="cov0" title="0">subnetInfoList = append(subnetInfoList, subnetInfo)</span>
        }
        //cblogger.Info("===========&gt;  ")
        //spew.Dump(subnetInfoList)

        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetInfoList
        return vpcInfo, nil</span>
}

//@TODO :     VPC               Route     4   VPC   .
//@TODO : VPCHandler   VPC               .
/*
  -  
          Route    .
        ErrorCode: Forbbiden
        Recommend:
        RequestId: 8871BF19-330B-4F00-93ED-D886F2CE066F
        Message: Active custom route in vpc.)
*/
func (VPCHandler *AlibabaVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        //Subnet      VPC  .
        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                return false, errVpcInfo
        }</span>

        //=================
        // Subnet
        //=================
        <span class="cov0" title="0">for _, curSubnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VSwitch  ", curSubnet.IId.SystemId)
                _, errSubnet := VPCHandler.DeleteSubnet(curSubnet.IId)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        return false, errSubnet
                }</span>
        }

        //=====================
        //     .
        //=================
        //        3   .
        <span class="cov0" title="0">time.Sleep(time.Second * 3)

        cblogger.Infof("[%s] VPC  .", vpcInfo.IId.SystemId)
        //cblogger.Info("VPC    IGW / Route  ")

        request := vpc.CreateDeleteVpcRequest()
        request.Scheme = "https"
        request.VpcId = vpcIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        response, err := VPCHandler.Client.DeleteVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Infof("[%s] VPC Delete fail", vpcIID.SystemId)
                cblogger.Error(err.Error())
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return true, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) DeleteSubnet(subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VSwitch : [%s]", subnetIID.SystemId)

        request := vpc.CreateDeleteVSwitchRequest()
        request.Scheme = "https"
        request.VSwitchId = subnetIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "DeleteVSwitch()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        response, err := VPCHandler.Client.DeleteVSwitch(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Infof("[%s] VSwitch Delete fail", subnetIID.SystemId)
                cblogger.Error(err.Error())
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return true, nil</span>
}

func (VPCHandler *AlibabaVPCHandler) GetSubnet(reqSubnetId string) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("SubnetId : [%s]", reqSubnetId)

        request := vpc.CreateDescribeVSwitchesRequest()
        request.Scheme = "https"
        request.VSwitchId = reqSubnetId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetId,
                CloudOSAPI:   "DescribeVSwitches()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVSwitches(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        //cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if result.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.SubnetInfo{}, errors.New("Notfound: '" + reqSubnetId + "' Subnet Not found")
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(result.VSwitches.VSwitch).IsNil() </span><span class="cov0" title="0">{
                retSubnetInfo := ExtractSubnetDescribeInfo(result.VSwitches.VSwitch[0])
                return retSubnetInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.SubnetInfo{}, errors.New("InvalidVSwitch.NotFound: The '" + reqSubnetId + "' does not exist")
        }</span>
}

//Subnet(VSwitch)  
func ExtractSubnetDescribeInfo(subnetInfo vpc.VSwitch) irs.SubnetInfo <span class="cov0" title="0">{
        vNetworkInfo := irs.SubnetInfo{
                IId:       irs.IID{NameId: subnetInfo.VSwitchName, SystemId: subnetInfo.VSwitchId},
                IPv4_CIDR: subnetInfo.CidrBlock,
        }

        keyValueList := []irs.KeyValue{
                {Key: "Status", Value: subnetInfo.Status},
                {Key: "IsDefault", Value: strconv.FormatBool(subnetInfo.IsDefault)},
                {Key: "ZoneId", Value: subnetInfo.ZoneId},
        }
        vNetworkInfo.KeyValueList = keyValueList

        return vNetworkInfo
}</span>

func (VPCHandler *AlibabaVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet  - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.ALIBABA,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if errSubnet != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = errSubnet.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(resSubnet)

        //#330 
        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, errVpcInfo
        }</span>

        <span class="cov0" title="0">findSubnet := false
        cblogger.Debug("==============   =========")
        for posSubnet, curSubnetInfo := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Debugf("%d - [%s] Subnet  ", posSubnet, curSubnetInfo.IId.SystemId)
                if resSubnet.IId.SystemId == curSubnetInfo.IId.SystemId </span><span class="cov0" title="0">{
                        cblogger.Infof("   [%s] Subnet  . - SystemID:[%s]", subnetInfo.IId.NameId, curSubnetInfo.IId.SystemId)
                        //for ~ range     . for loop    vpcInfo    .
                        cblogger.Infof("  : %d", posSubnet)
                        //vpcInfo.SubnetInfoList[posSubnet].IId.NameId = "~"
                        vpcInfo.SubnetInfoList[posSubnet].IId.NameId = subnetInfo.IId.NameId
                        findSubnet = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !findSubnet </span><span class="cov0" title="0">{
                cblogger.Errorf("   VPC     [%s] [%s]  .", subnetInfo.IId.NameId, resSubnet.IId.SystemId)
                return irs.VPCInfo{}, errors.New("MismatchSubnet.NotFound: No SysmteId[" + resSubnet.IId.SystemId + "] found for newly created Subnet[" + subnetInfo.IId.NameId + "].")
        }</span>

        <span class="cov0" title="0">return vpcInfo, nil</span>

        //return irs.VPCInfo{}, nil
}

func (VPCHandler *AlibabaVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC [%s] Subnet ", vpcIID.SystemId, subnetIID.SystemId)

        return VPCHandler.DeleteSubnet(subnetIID)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by CB-Spider Team, 2019.06.

//package main

package aws

import (
        "C"

        acon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
        //icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect/AwsNewIfCloudConnect"
        //icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect/connect"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/ec2"
)
import (
        "fmt"

        "github.com/aws/aws-sdk-go/aws/credentials"
)

type AwsDriver struct {
}

func (AwsDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "TEST AWS DRIVER Version 1.0"
}</span>

func (AwsDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

//func getVMClient(regionInfo idrv.RegionInfo) (*ec2.EC2, error) {
func getVMClient(connectionInfo idrv.ConnectionInfo) (*ec2.EC2, error) <span class="cov0" title="0">{

        // setup Region
        fmt.Println("AwsDriver : getVMClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")
        fmt.Println("AwsDriver : getVMClient() - Zone : [" + connectionInfo.RegionInfo.Zone + "]")
        //fmt.Println("   ")
        //spew.Dump(connectionInfo)

        sess, err := session.NewSession(&amp;aws.Config{
                Region: aws.String(connectionInfo.RegionInfo.Region),
                //Region:      aws.String("ap-northeast-2"),
                Credentials: credentials.NewStaticCredentials(connectionInfo.CredentialInfo.ClientId, connectionInfo.CredentialInfo.ClientSecret, "")},
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create aws New Session", err)
                return nil, err
        }</span>

        // Create EC2 service client
        <span class="cov0" title="0">svc := ec2.New(sess)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create EC2 service client", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return svc, nil</span>
}

func (driver *AwsDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        //fmt.Println("ConnectCloud   idrv.ConnectionInfo ")
        //spew.Dump(connectionInfo)

        // sample code, do not user like this^^
        //var iConn icon.CloudConnection
        vmClient, err := getVMClient(connectionInfo)
        //vmClient, err := getVMClient(connectionInfo.RegionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        //iConn = acon.AwsCloudConnection{}
        <span class="cov0" title="0">iConn := acon.AwsCloudConnection{
                CredentialInfo: connectionInfo.CredentialInfo,
                Region:         connectionInfo.RegionInfo,
                VMClient:       vmClient,
                KeyPairClient:  vmClient,

                VNetworkClient: vmClient,
                //VNicClient:     vmClient,
                ImageClient: vmClient,
                //PublicIPClient: vmClient,
                SecurityClient: vmClient,
                VmSpecClient:   vmClient,
        }

        return &amp;iConn, nil</span> // return type: (icon.CloudConnection, error)
}

/*
func (AwsDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) {
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.
        // sample code, do not user like this^^
        var iConn icon.CloudConnection
        iConn = acon.AwsCloudConnection{}
        return iConn, nil // return type: (icon.CloudConnection, error)
}
*/
var CloudDriver AwsDriver
</pre>
		
		<pre class="file" id="file51" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by powerkim@etri.re.kr, 2019.06.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        //irs2 "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/new-resources"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"

        ars "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/aws/resources"

        //ec2drv "github.com/aws/aws-sdk-go/service/ec2"
        "github.com/aws/aws-sdk-go/service/ec2"
)

//type AwsCloudConnection struct{}
type AwsCloudConnection struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
        KeyPairClient  *ec2.EC2
        VMClient       *ec2.EC2

        VNetworkClient *ec2.EC2
        //VNicClient     *ec2.EC2
        ImageClient *ec2.EC2
        //PublicIPClient *ec2.EC2
        SecurityClient *ec2.EC2
        VmSpecClient   *ec2.EC2
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

func (cloudConn *AwsCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateKeyPairHandler()")

        keyPairHandler := ars.AwsKeyPairHandler{cloudConn.CredentialInfo, cloudConn.Region, cloudConn.KeyPairClient}
        //keyPairHandler := ars.AwsKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}

        return &amp;keyPairHandler, nil
}</span>

func (cloudConn *AwsCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateVMHandler()")

        vmHandler := ars.AwsVMHandler{cloudConn.Region, cloudConn.VMClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *AwsCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (cloudConn *AwsCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (cloudConn *AwsCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsVPCHandler{cloudConn.Region, cloudConn.VNetworkClient}

        return &amp;handler, nil
}</span>

//func (cloudConn *AwsCloudConnection) CreateImageHandler() (irs2.ImageHandler, error) {
func (cloudConn *AwsCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsImageHandler{cloudConn.Region, cloudConn.ImageClient}

        return &amp;handler, nil
}</span>

func (cloudConn *AwsCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsSecurityHandler{cloudConn.Region, cloudConn.SecurityClient}

        return &amp;handler, nil
}</span>

/*
func (cloudConn *AwsCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Start")
        handler := ars.AwsVNicHandler{cloudConn.Region, cloudConn.VNicClient}

        return &amp;handler, nil
}

func (cloudConn *AwsCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Start")
        handler := ars.AwsPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}

        return &amp;handler, nil
}
*/

func (cloudConn *AwsCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := ars.AwsVmSpecHandler{cloudConn.Region, cloudConn.VmSpecClient}
        return &amp;handler, nil
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/ec2"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const CBDefaultVNetName string = "CB-VNet"          // CB Default Virtual Network Name
const CBDefaultSubnetName string = "CB-VNet-Subnet" // CB Default Subnet Name
const CBDefaultCidrBlock string = "192.168.0.0/16"  // CB Default CidrBlock
const CBKeyPairPath string = "/cloud-driver-libs/.ssh-aws/"
const CBCloudInitFilePath string = "/cloud-driver-libs/.cloud-init-aws/cloud-init"

const CBDefaultVmUserName string = "cb-user" // default VM User Name

const CUSTOM_ERR_CODE_TOOMANY string = "600"  //awserr.New("600", "n  xxxx  .", nil)
const CUSTOM_ERR_CODE_NOTFOUND string = "404" //awserr.New("404", "XXX   .", nil)

type AwsCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

//VPC
func GetCBDefaultVNetName() string <span class="cov0" title="0">{
        return CBDefaultVNetName
}</span>

//Subnet
func GetCBDefaultSubnetName() string <span class="cov0" title="0">{
        return CBDefaultSubnetName
}</span>

func GetCBDefaultCidrBlock() string <span class="cov0" title="0">{
        return CBDefaultCidrBlock
}</span>

/*
//  VPC &amp; Subnet   .
//VPC &amp; Subnet       Default VPC &amp; Subnet     .
func (VPCHandler *AwsVPCHandler) GetAutoCBNetworkInfo() (AwsCBNetworkInfo, error) {
        return AwsCBNetworkInfo{}, errors.New("  !!!!")
                var awsCBNetworkInfo AwsCBNetworkInfo

                subNetId := VPCHandler.GetMcloudBaristaDefaultSubnetId()
                if subNetId == "" {
                        // VPC   Subnet .
                        _, err := VPCHandler.CreateVNetwork(irs.VNetworkReqInfo{})
                        if err != nil {
                                cblogger.Error("Default VNetwork(VPC &amp; Subnet)   ")
                                cblogger.Error(err)
                                return AwsCBNetworkInfo{}, err
                        }
                }

                //VPC &amp; Subnet     .
                awsVpcInfo, _ := VPCHandler.GetVpc(GetCBDefaultVNetName())
                spew.Dump(awsVpcInfo)
                awsCBNetworkInfo.VpcId = awsVpcInfo.Id
                awsCBNetworkInfo.VpcName = awsVpcInfo.Name

                awsSubnetInfo, _ := VPCHandler.GetVNetwork(irs.IID{})
                spew.Dump(awsSubnetInfo)
                //awsCBNetworkInfo.SubnetId = awsSubnetInfo.Id
                //awsCBNetworkInfo.SubnetName = awsSubnetInfo.Name
                awsCBNetworkInfo.SubnetId = awsSubnetInfo.IId.SystemId
                awsCBNetworkInfo.SubnetName = awsSubnetInfo.IId.NameId

                spew.Dump(awsCBNetworkInfo)

                return awsCBNetworkInfo, nil
}
*/

/*

func (VPCHandler *AwsVPCHandler) GetMcloudBaristaDefaultVpcId() string {
        return ""
                awsVpcInfo, err := VPCHandler.GetVpc(GetCBDefaultVNetName())
                if err != nil {
                        if aerr, ok := err.(awserr.Error); ok {
                                switch aerr.Code() {
                                default:
                                        cblogger.Error(aerr.Error())
                                }
                        } else {
                                cblogger.Error(err.Error())
                        }
                        return ""
                }

                //  ...
                if awsVpcInfo.Id != "" {
                        return awsVpcInfo.Id
                } else {
                        return ""
                }
}
*/

/*

//@TODO : awsSubnetInfo.IId.SystemId   NameId    . -&gt;       .
func (VPCHandler *AwsVPCHandler) GetMcloudBaristaDefaultSubnetId() string {
        awsSubnetInfo, err := VPCHandler.GetVNetwork(irs.IID{})
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        cblogger.Error(err.Error())
                }
                return ""
        }

        //  ...
        //if awsSubnetInfo.Id != "" {
        //        return awsSubnetInfo.Id
        if awsSubnetInfo.IId.SystemId != "" {
                return awsSubnetInfo.IId.SystemId
        } else {
                return ""
        }
}

//@TODO : ListVNetwork()      VPC   Func .(    )
//CB Default Virtual Network   ,   Vpc ID  .
func (VPCHandler *AwsVPCHandler) FindOrCreateMcloudBaristaDefaultVPC(vNetworkReqInfo irs.VNetworkReqInfo) (string, error) {
        cblogger.Info(vNetworkReqInfo)

        awsVpcInfo, err := VPCHandler.GetVpc(GetCBDefaultVNetName())
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return "", err
        }

        //  ...
        if awsVpcInfo.Id != "" {
                return awsVpcInfo.Id, nil
        } else {
                //@TODO : Subnet VPC CSP       CB          -       
                / *
                        cblogger.Infof(" VPC[%s]  Subnet    /16  VPC .", GetCBDefaultVNetName())
                        cblogger.Info("Subnet CIDR   : ", vNetworkReqInfo.CidrBlock)
                        if vNetworkReqInfo.CidrBlock == "" {
                                //VPC    List()         nil .
                                cblogger.Infof("  CIDR   Default VPC[%s]  ", GetCBDefaultVNetName())
                                return "", nil
                        }

                        reqCidr := strings.Split(vNetworkReqInfo.CidrBlock, ".")
                        //cblogger.Info("CIDR   : ", reqCidr[0])
                        VpcCidrBlock := reqCidr[0] + "." + reqCidr[1] + ".0.0/16"
                        cblogger.Info(" VPC  CIDR  : ", VpcCidrBlock)
                * /

                cblogger.Infof(" VPC[%s]  CIDR[%s]  VPC  .", GetCBDefaultVNetName(), GetCBDefaultCidrBlock())
                awsVpcReqInfo := AwsVpcReqInfo{
                        Name: GetCBDefaultVNetName(),
                        //CidrBlock: VpcCidrBlock,
                        CidrBlock: GetCBDefaultCidrBlock(),
                }

                result, errVpc := VPCHandler.CreateVpc(awsVpcReqInfo)
                if errVpc != nil {
                        cblogger.Error(errVpc)
                        return "", errVpc
                }
                cblogger.Infof("CB Default VPC[%s]   - CIDR : [%s]", GetCBDefaultVNetName(), result.CidrBlock)
                cblogger.Info(result)
                spew.Dump(result)

                return result.Id, nil
        }
}

//  VPC &amp; Subnet  ?
// Subnet       vNic   .
func (VPCHandler *AwsVPCHandler) IsAvailableAutoCBNet() bool {
        return false
}
*/

//Name Tag 
func SetNameTag(Client *ec2.EC2, Id string, value string) bool <span class="cov0" title="0">{
        // Tag Name 
        cblogger.Infof("Name Tage  - ResourceId : [%s]  Value : [%s] ", Id, value)
        _, errtag := Client.CreateTags(&amp;ec2.CreateTagsInput{
                Resources: []*string{&amp;Id},
                Tags: []*ec2.Tag{
                        {
                                Key:   aws.String("Name"),
                                Value: aws.String(value),
                        },
                },
        })
        if errtag != nil </span><span class="cov0" title="0">{
                cblogger.Error("Name Tag   : ")
                cblogger.Error(errtag)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func JSONMarshal(t interface{}) ([]byte, error) <span class="cov0" title="0">{
        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err := encoder.Encode(t)
        return buffer.Bytes(), err
}</span>

//Cloud Object JSON String  
func ConvertJsonStringNoEscape(v interface{}) (string, error) <span class="cov0" title="0">{
        //jsonBytes, errJson := json.Marshal(v)

        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        errJson := encoder.Encode(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON  ")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        //fmt.Println("After marshal", string(buffer.Bytes()))
        //spew.Dump(string(buffer.Bytes()))
        //spew.Dump("\"TEST")

        <span class="cov0" title="0">jsonString := string(buffer.Bytes())
        //jsonString = strings.Replace(jsonString, "\n", "", -1)
        jsonString = strings.Replace(jsonString, "\"", "", -1)

        return jsonString, nil</span>
}

//Cloud Object JSON String  
func ConvertJsonString(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonBytes, errJson := json.Marshal(v)

        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON  ")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

//CB-KeyValue   String  
func ConvertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                cblogger.Debugf("Nil Value")
                return "", errors.New("Nil. Value")
        }</span>

        <span class="cov0" title="0">var result string
        t := reflect.ValueOf(value)
        cblogger.Debug("==&gt;ValueOf : ", t)

        switch value.(type) </span>{
        case float32:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 32)</span> // f, fmt, prec, bitSize
        case float64:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 64)</span> // f, fmt, prec, bitSize
                //strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)

        default:<span class="cov0" title="0">
                cblogger.Debug("--&gt; default type:", reflect.ValueOf(value).Type())
                result = fmt.Sprint(value)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

//Cloud Object CB-KeyValue     
func ConvertKeyValueList(v interface{}) ([]irs.KeyValue, error) <span class="cov0" title="0">{
        //spew.Dump(v)
        var keyValueList []irs.KeyValue
        var i map[string]interface{}

        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("KeyValue  ")
                cblogger.Error(errJson)
                return nil, errJson
        }</span>

        <span class="cov0" title="0">json.Unmarshal(jsonBytes, &amp;i)

        for k, v := range i </span><span class="cov0" title="0">{
                cblogger.Debugf("K:[%s]====&gt;", k)
                /*
                        cblogger.Infof("v:[%s]====&gt;", reflect.ValueOf(v))

                        vv := reflect.ValueOf(v)
                        cblogger.Infof("value ====&gt;[%s]", vv.String())
                        s := fmt.Sprint(v)
                        cblogger.Infof("value2 ====&gt;[%s]", s)
                */
                //value := fmt.Sprint(v)
                value, errString := ConvertToString(v)
                if errString != nil </span><span class="cov0" title="0">{
                        //cblogger.Errorf("Key[%s]    - [%s]", k, errString)
                        cblogger.Debugf("Key[%s]    - [%s]", k, errString) //  Error Warn 
                        continue</span>
                }
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, value})</span>

                /*
                        _, ok := v.(string)
                        if !ok {
                                cblogger.Errorf("Key[%s]   ", k)
                                continue
                        }
                        keyValueList = append(keyValueList, irs.KeyValue{k, v.(string)})
                */
        }
        <span class="cov0" title="0">cblogger.Debug("getKeyValueList : ", keyValueList)
        //keyValueList = append(keyValueList, irs.KeyValue{"test", typeToString([]float32{3.14, 1.53, 2.0000000000000})})

        return keyValueList, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Cloud Driver Interface of CB-Spider.  // The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "reflect"
        "strconv"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        //irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/new-resources"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
)

type AwsImageHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

//@TODO :  .
func (imageHandler *AwsImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageReqInfo.IId.NameId,
                CloudOSAPI:   "-",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        imageReqInfo.IId.SystemId = imageReqInfo.IId.NameId

        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        return irs.ImageInfo{imageReqInfo.IId, "", "", nil}, nil
}</span>

//@TODO :     amazon     AMI  .
//20210607 - Tumblebug    state    ,     AWS    .
func (imageHandler *AwsImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        var imageInfoList []*irs.ImageInfo
        input := &amp;ec2.DescribeImagesInput{
                //ImageIds: []*string{aws.String("ami-0d097db2fb6e0f05e")},
                Owners: []*string{
                        aws.String("amazon"), //        .
                },
                Filters: []*ec2.Filter{
                        {
                                Name:   aws.String("image-type"),
                                Values: aws.StringSlice([]string{"machine"}),
                        },
                        {
                                Name:   aws.String("is-public"),
                                Values: aws.StringSlice([]string{"true"}),
                        },
                        /*
                                {
                                        Name:   aws.String("state"),
                                        Values: aws.StringSlice([]string{"available"}),
                                },
                        */
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "ListImage()",
                CloudOSAPI:   "DescribeImages",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := imageHandler.Client.DescribeImages(input)
        //spew.Dump(result)        //    

        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cnt := 0
        for _, cur := range result.Images </span><span class="cov0" title="0">{
                //spew.Dump(cur)
                if reflect.ValueOf(cur.State).IsNil() </span><span class="cov0" title="0">{
                        cblogger.Errorf("===&gt;[%s] AMI State   Skip.", *cur.ImageId)
                        continue</span>
                }

                <span class="cov0" title="0">if reflect.ValueOf(cur.Name).IsNil() </span><span class="cov0" title="0">{
                        cblogger.Infof("===&gt;[%s] AMI Name   Skip.", *cur.ImageId)
                        continue</span>
                }

                <span class="cov0" title="0">cblogger.Debugf("[%s] - [%s] - [%s] AMI  ", *cur.ImageId, *cur.State, *cur.Name)
                //cblogger.Infof("[%s] - [%s] - [%s] - [%s] AMI  ", *cur.ImageId, *cur.State, *cur.Name, *cur.UsageOperation)

                imageInfo := ExtractImageDescribeInfo(cur)
                imageInfoList = append(imageInfoList, &amp;imageInfo)
                cnt++</span>
                /*
                        if cnt &gt; 20 {
                                break
                        }
                */
        }

        <span class="cov0" title="0">cblogger.Info("%d  .", cnt)
        //spew.Dump(imageInfoList)

        return imageInfoList, nil</span>
}

//Image  
//@TODO : GuestOS  
func ExtractImageDescribeInfo(image *ec2.Image) irs.ImageInfo <span class="cov0" title="0">{
        //spew.Dump(image)
        imageInfo := irs.ImageInfo{
                //IId: irs.IID{*image.Name, *image.ImageId},
                IId: irs.IID{*image.ImageId, *image.ImageId},
                //Id:     *image.ImageId,
                //Name:   *image.Name,
                Status: *image.State,
        }

        keyValueList := []irs.KeyValue{
                //{Key: "Name", Value: *image.Name}, //20200723-Name    - )ami-0008a301
                {Key: "CreationDate", Value: *image.CreationDate},
                {Key: "Architecture", Value: *image.Architecture}, //x86_64
                {Key: "OwnerId", Value: *image.OwnerId},
                {Key: "ImageType", Value: *image.ImageType},
                {Key: "ImageLocation", Value: *image.ImageLocation},
                {Key: "VirtualizationType", Value: *image.VirtualizationType},
                {Key: "Public", Value: strconv.FormatBool(*image.Public)},
        }

        //  Platform     PlatformDetails  . - "Linux/UNIX"
        //  PlatformDetails "Windows with SQL Server Standard" SQL .
        if !reflect.ValueOf(image.Platform).IsNil() </span><span class="cov0" title="0">{
                imageInfo.GuestOS = *image.Platform //Linux/UNIX
                keyValueList = append(keyValueList, irs.KeyValue{Key: "Platform", Value: *image.Platform})
        }</span> else<span class="cov0" title="0"> {
                // Platform    PlatformDetails   PlatformDetails  .
                if !reflect.ValueOf(image.PlatformDetails).IsNil() </span><span class="cov0" title="0">{
                        imageInfo.GuestOS = *image.PlatformDetails //Linux/UNIX
                }</span>
        }

        //        .
        <span class="cov0" title="0">if !reflect.ValueOf(image.PlatformDetails).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "PlatformDetails", Value: *image.PlatformDetails})
        }</span>

        //        .
        <span class="cov0" title="0">if !reflect.ValueOf(image.Name).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "Name", Value: *image.Name})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.Description).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "Description", Value: *image.Description})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.ImageOwnerAlias).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "ImageOwnerAlias", Value: *image.ImageOwnerAlias})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.RootDeviceName).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "RootDeviceName", Value: *image.RootDeviceName})
                keyValueList = append(keyValueList, irs.KeyValue{Key: "RootDeviceType", Value: *image.RootDeviceType})
        }</span>
        <span class="cov0" title="0">if !reflect.ValueOf(image.EnaSupport).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "EnaSupport", Value: strconv.FormatBool(*image.EnaSupport)})
        }</span>

        <span class="cov0" title="0">imageInfo.KeyValueList = keyValueList

        return imageInfo</span>
}

//func (imageHandler *AwsImageHandler) GetImage(imageID string) (irs.ImageInfo, error) {
func (imageHandler *AwsImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{

        cblogger.Infof("imageID : [%s]", imageIID.SystemId)

        input := &amp;ec2.DescribeImagesInput{
                ImageIds: []*string{
                        aws.String(imageIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DescribeImages",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := imageHandler.Client.DescribeImages(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        //spew.Dump(result)
        cblogger.Info(result)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return irs.ImageInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(result.Images) &gt; 0 </span><span class="cov0" title="0">{
                imageInfo := ExtractImageDescribeInfo(result.Images[0])
                return imageInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.ImageInfo{}, errors.New(" Image  .")
        }</span>

}

//@TODO :  API  .
func (imageHandler *AwsImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "-",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        return false, nil
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package resources

import (
        "bytes"
        "crypto/md5"
        "crypto/rsa"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        _ "github.com/davecgh/go-spew/spew"
        "golang.org/x/crypto/ssh"
)

type AwsKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
        Client         *ec2.EC2
}

/*
// @TODO: KeyPairInfo    
type KeyPairInfo struct {
        Name        string
        Fingerprint string
        KeyMaterial string //RSA PRIVATE KEY
}
*/

func (keyPairHandler *AwsKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start ListKey()")
        var keyPairList []*irs.KeyPairInfo
        //spew.Dump(keyPairHandler)
        cblogger.Debug(keyPairHandler)

        input := &amp;ec2.DescribeKeyPairsInput{
                KeyNames: []*string{
                        nil,
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "ListKey()",
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //  Returns a list of key pairs
        result, err := keyPairHandler.Client.DescribeKeyPairs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Debug(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Errorf("Unable to get key pairs, %v", err)
                return keyPairList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Debugf("Key Pairs:")
        for _, pair := range result.KeyPairs </span><span class="cov0" title="0">{
                /*
                        cblogger.Debugf("%s: %s\n", *pair.KeyName, *pair.KeyFingerprint)
                        keyPairInfo := new(irs.KeyPairInfo)
                        keyPairInfo.Name = *pair.KeyName
                        keyPairInfo.Fingerprint = *pair.KeyFingerprint
                */
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(pair)
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s] KeyPair Local     Skip.", *pair.KeyName)
                        cblogger.Info(errKeyPair.Error())
                        //return nil, errKeyPair
                }</span> else<span class="cov0" title="0"> {
                        keyPairList = append(keyPairList, &amp;keyPairInfo)
                }</span>
        }

        <span class="cov0" title="0">cblogger.Debug(keyPairList)
        //spew.Dump(keyPairList)
        return keyPairList, nil</span>
}

func (keyPairHandler *AwsKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Info(keyPairReqInfo)
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        // Creates a new  key pair with the given name
        result, err := keyPairHandler.Client.CreateKeyPair(&amp;ec2.CreateKeyPairInput{
                //KeyName: aws.String(keyPairReqInfo.Name),
                KeyName: aws.String(keyPairReqInfo.IId.NameId),
        })
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "InvalidKeyPair.Duplicate" </span><span class="cov0" title="0">{
                        cblogger.Errorf("Keypair %q already exists.", keyPairReqInfo.IId.NameId)
                        return irs.KeyPairInfo{}, err
                }</span>
                <span class="cov0" title="0">cblogger.Errorf("Unable to create key pair: %s, %v.", keyPairReqInfo.IId.NameId, err)
                return irs.KeyPairInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created key pair %q %s\n%s\n", *result.KeyName, *result.KeyFingerprint, *result.KeyMaterial)

        cblogger.Info(" ")
        publicKey, errPub := makePublicKeyFromPrivateKey(*result.KeyMaterial)
        if errPub != nil </span><span class="cov0" title="0">{
                cblogger.Error(errPub)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">cblogger.Infof("Public Key")
        //spew.Dump(publicKey)
        keyPairInfo := irs.KeyPairInfo{
                //Name:        *result.KeyName,
                IId:         irs.IID{keyPairReqInfo.IId.NameId, *result.KeyName},
                Fingerprint: *result.KeyFingerprint,
                PrivateKey:  *result.KeyMaterial, // AWS(PEM-RSA PRIVATE KEY)
                PublicKey:   publicKey,
                //KeyMaterial: *result.KeyMaterial,
                KeyValueList: []irs.KeyValue{
                        {Key: "KeyMaterial", Value: *result.KeyMaterial},
                },
        }

        //spew.Dump(keyPairInfo)

        //        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        //@TODO : File     PK      . (     IAM            Uniqueue     .)     .
        /*
                hashString, err := CreateHashString(keyPairHandler.CredentialInfo, keyPairHandler.Region)
                if err != nil {
                        cblogger.Error(err)
                        return irs.KeyPairInfo{}, err
                }
                savePrivateFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pem"
                savePublicFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pub"
        */
        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") //       .        .
        savePrivateFileTo := keyPairPath + hashString + ".pem"
        savePublicFileTo := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Infof("savePrivateFileTo : [%s]", savePrivateFileTo)
        cblogger.Infof("savePublicFileTo : [%s]", savePublicFileTo)

        //  private Key 
        err = writeKeyToFile([]byte(keyPairInfo.PrivateKey), savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        //  public Key 
        <span class="cov0" title="0">err = writeKeyToFile([]byte(keyPairInfo.PublicKey), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

//   keyPairID  keyName  .
func (keyPairHandler *AwsKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        //keyPairID := keyName
        <span class="cov0" title="0">cblogger.Infof("keyName : [%s]", keyIID.SystemId)
        input := &amp;ec2.DescribeKeyPairsInput{
                KeyNames: []*string{
                        aws.String(keyIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: keyIID.SystemId,
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := keyPairHandler.Client.DescribeKeyPairs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result : ", result)
        cblogger.Info("err : ", err)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        cblogger.Info("aerr : ", aerr)
                        cblogger.Info("aerr.Code()  : ", aerr.Code())
                        cblogger.Info("ok : ", ok)
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                //fmt.Println(aerr.Error())
                                cblogger.Error(aerr.Error())
                                return irs.KeyPairInfo{}, aerr</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        return irs.KeyPairInfo{}, err
                }</span>
                <span class="cov0" title="0">return irs.KeyPairInfo{}, nil</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(result.KeyPairs) &gt; 0 </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(result.KeyPairs[0])
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errKeyPair.Error())
                        return irs.KeyPairInfo{}, errKeyPair
                }</span>

                <span class="cov0" title="0">spew.Dump(keyPairInfo)
                return keyPairInfo, nil</span>
        } else<span class="cov0" title="0"> {
                return irs.KeyPairInfo{}, errors.New("   .")
        }</span>
}

//KeyPair  
func ExtractKeyPairDescribeInfo(keyPair *ec2.KeyPairInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        //spew.Dump(keyPair)
        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{*keyPair.KeyName, *keyPair.KeyName},
                //Name:        *keyPair.KeyName,
                Fingerprint: *keyPair.KeyFingerprint,
        }

        // Local Keyfile 
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") //       .        .
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, privateKeyPath)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, publicKeyPath)

        // Private Key, Public Key   
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Local Private   ", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Local Public   ", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo.PublicKey = string(publicKeyBytes)
        keyPairInfo.PrivateKey = string(privateKeyBytes)

        keyValueList := []irs.KeyValue{
                //{Key: "KeyMaterial", Value: *keyPair.KeyMaterial},
        }

        keyPairInfo.KeyValueList = keyValueList

        return keyPairInfo, nil</span>
}

func (keyPairHandler *AwsKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("   : [%s]", keyIID.SystemId)

        keyPairInfo, errGet := keyPairHandler.GetKey(keyIID)
        if errGet != nil </span><span class="cov0" title="0">{
                return false, errGet
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: keyIID.SystemId,
                CloudOSAPI:   "DeleteKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Delete the key pair by name
        //by powerkim, result, err := keyPairHandler.Client.DeleteKeyPair(&amp;ec2.DeleteKeyPairInput{
        _, err := keyPairHandler.Client.DeleteKeyPair(&amp;ec2.DeleteKeyPairInput{
                KeyName: aws.String(keyIID.SystemId),
        })
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok &amp;&amp; aerr.Code() == "InvalidKeyPair.Duplicate" </span><span class="cov0" title="0">{
                        cblogger.Error("Key pair %q does not exist.", keyIID.SystemId)
                        return false, err
                }</span>
                <span class="cov0" title="0">cblogger.Errorf("Unable to delete key pair: %s, %v.", keyIID.SystemId, err)
                return false, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Infof("Successfully deleted %q AWS key pair\n", keyIID.SystemId)

        //====================
        // Local Keyfile 
        //====================
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString := strings.ReplaceAll(keyPairInfo.Fingerprint, ":", "") //       .        .
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"

        // Private Key, Public Key 
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

//=================================
//          
//=================================
func (keyPairHandler *AwsKeyPairHandler) CheckKeyPairFolder(keyPairPath string) error <span class="cov0" title="0">{
        //       .
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Path   .", keyPairPath)

                //errDir := os.MkdirAll(keyPairPath, 0755)
                errDir := os.MkdirAll(keyPairPath, 0700)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path  ", keyPairPath)
                        cblogger.Error(errDir)
                        return errDir
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ParseKey reads the given RSA private key and create a public one for it.
func makePublicKeyFromPrivateKey(pem string) (string, error) <span class="cov0" title="0">{
        key, err := ssh.ParseRawPrivateKey([]byte(pem))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">rsaKey, ok := key.(*rsa.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q is not a RSA key", pem)
        }</span>
        <span class="cov0" title="0">pub, err := ssh.NewPublicKey(&amp;rsaKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(bytes.TrimRight(ssh.MarshalAuthorizedKey(pub), "\n")), nil</span>
}

//  Key 
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key : %s", saveFileTo)
        return nil</span>
}

// @TODO - PK   . (A User / B User / User  IAM        .)
//       -  AWS  KeyPair FingerPrint   -       .
// KeyPair    (PK    )
func CreateHashString(credentialInfo idrv.CredentialInfo, Region idrv.RegionInfo) (string, error) <span class="cov0" title="0">{
        log.Println("credentialInfo.ClientId : " + credentialInfo.ClientId)
        log.Println("Region.Region : " + Region.Region)
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + Region.Region
        //keyString := credentialInfo
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "reflect"
        "strconv"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

type AwsSecurityHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

//2019-11-16 CB-Driver   NameId  . (      Name   )
//@TODO :       
//VPC      VPC  .
func (securityHandler *AwsSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityReqInfo : ", securityReqInfo)
        //spew.Dump(securityReqInfo)

        /*
                //VPC &amp; Subnet   
                VPCHandler := AwsVPCHandler{Client: securityHandler.Client}
                awsCBNetworkInfo, errAutoCBNetInfo := VPCHandler.GetAutoCBNetworkInfo()
                if errAutoCBNetInfo != nil || awsCBNetworkInfo.VpcId == "" {
                        cblogger.Error("VPC   ")
                        return irs.SecurityInfo{}, errors.New("mcloud-barista      .")
                }

                cblogger.Infof("==&gt; [%s] CB Default VPC  ", awsCBNetworkInfo.VpcId)
                vpcId := awsCBNetworkInfo.VpcId
        */
        vpcId := securityReqInfo.VpcIID.SystemId

        // Create the security group with the VPC, name and description.
        //createRes, err := securityHandler.Client.CreateSecurityGroup(&amp;ec2.CreateSecurityGroupInput{
        input := ec2.CreateSecurityGroupInput{
                //GroupName:   aws.String(securityReqInfo.Name),
                GroupName: aws.String(securityReqInfo.IId.NameId),
                //Description: aws.String(securityReqInfo.Name),
                Description: aws.String(securityReqInfo.IId.NameId),
                //                VpcId:       aws.String(securityReqInfo.VpcId),awsCBNetworkInfo
                VpcId: aws.String(vpcId),
        }
        cblogger.Debugf("    ", input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "CreateSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        createRes, err := securityHandler.Client.CreateSecurityGroup(&amp;input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        case "InvalidVpcID.NotFound":<span class="cov0" title="0">
                                cblogger.Errorf("Unable to find VPC with ID %q.", vpcId)
                                return irs.SecurityInfo{}, err</span>
                        case "InvalidGroup.Duplicate":<span class="cov0" title="0">
                                cblogger.Errorf("Security group %q already exists.", securityReqInfo.IId.NameId)
                                return irs.SecurityInfo{}, err</span>
                        }
                }
                <span class="cov0" title="0">cblogger.Errorf("Unable to create security group %q, %v", securityReqInfo.IId.NameId, err)
                return irs.SecurityInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Infof("[%s]   ", aws.StringValue(createRes.GroupId))
        cblogger.Debug(createRes)
        //spew.Dump(createRes)

        //newGroupId = *createRes.GroupId

        cblogger.Debug("   ")
        //Ingress 
        var ipPermissions []*ec2.IpPermission
        for _, ip := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                //for _, ip := range securityReqInfo.IPPermissions {
                if ip.Direction != "inbound" </span><span class="cov0" title="0">{
                        cblogger.Debug("==&gt; inbound    Skip : ", ip.Direction)
                        continue</span>
                }

                // cblogger.Debug("===&gt;")
                // spew.Dump(ip)
                <span class="cov0" title="0">ipPermission := new(ec2.IpPermission)
                ipPermission.SetIpProtocol(ip.IPProtocol)

                if ip.FromPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.FromPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetFromPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.FromPort, "  !!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetFromPort(0)
                }</span>

                <span class="cov0" title="0">if ip.ToPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.ToPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetToPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.ToPort, "  !!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetToPort(0)
                }</span>

                <span class="cov0" title="0">ipPermission.SetIpRanges([]*ec2.IpRange{
                        (&amp;ec2.IpRange{}).
                                SetCidrIp(ip.CIDR),
                        //SetCidrIp("0.0.0.0/0"),
                })
                // cblogger.Debug("===&gt;")
                // spew.Dump(ipPermission)

                ipPermissions = append(ipPermissions, ipPermission)</span>
        }

        //    
        <span class="cov0" title="0">if len(ipPermissions) &gt; 0 </span><span class="cov0" title="0">{
                cblogger.Debug("===&gt;   ")
                cblogger.Debug(ipPermissions)
                // spew.Dump(ipPermissions)

                // Add permissions to the security group
                _, err = securityHandler.Client.AuthorizeSecurityGroupIngress(&amp;ec2.AuthorizeSecurityGroupIngressInput{
                        //GroupName:     aws.String(securityReqInfo.Name),
                        GroupId:       createRes.GroupId,
                        IpPermissions: ipPermissions,
                })
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("Unable to set security group %q ingress, %v", securityReqInfo.IId.NameId, err)
                        return irs.SecurityInfo{}, err
                }</span>

                <span class="cov0" title="0">cblogger.Info("Successfully set security group ingress")</span>
        }

        <span class="cov0" title="0">cblogger.Debug("   ")
        //Egress 
        var ipPermissionsEgress []*ec2.IpPermission
        //for _, ip := range securityReqInfo.IPPermissionsEgress {
        for _, ip := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                if ip.Direction != "outbound" </span><span class="cov0" title="0">{
                        cblogger.Debug("==&gt; outbound    Skip : ", ip.Direction)
                        continue</span>
                }

                <span class="cov0" title="0">ipPermission := new(ec2.IpPermission)
                ipPermission.SetIpProtocol(ip.IPProtocol)
                //ipPermission.SetFromPort(ip.FromPort)
                //ipPermission.SetToPort(ip.ToPort)
                if ip.FromPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.FromPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetFromPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.FromPort, "  !!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetFromPort(0)
                }</span>

                <span class="cov0" title="0">if ip.ToPort != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseInt(ip.ToPort, 10, 64); err == nil </span><span class="cov0" title="0">{
                                ipPermission.SetToPort(n)
                        }</span> else<span class="cov0" title="0"> {
                                cblogger.Error(ip.ToPort, "  !!")
                                return irs.SecurityInfo{}, err
                        }</span>
                } else <span class="cov0" title="0">{
                        //ipPermission.SetToPort(0)
                }</span>

                <span class="cov0" title="0">ipPermission.SetIpRanges([]*ec2.IpRange{
                        (&amp;ec2.IpRange{}).
                                SetCidrIp(ip.CIDR),
                        //SetCidrIp("0.0.0.0/0"),
                })
                //ipPermissions = append(ipPermissions, ipPermission)
                ipPermissionsEgress = append(ipPermissionsEgress, ipPermission)</span>
        }

        //    
        <span class="cov0" title="0">if len(ipPermissionsEgress) &gt; 0 </span><span class="cov0" title="0">{
                cblogger.Debug("===&gt;   ")
                cblogger.Debug(ipPermissionsEgress)

                // Add permissions to the security group
                _, err = securityHandler.Client.AuthorizeSecurityGroupEgress(&amp;ec2.AuthorizeSecurityGroupEgressInput{
                        GroupId:       createRes.GroupId,
                        IpPermissions: ipPermissionsEgress,
                })
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("Unable to set security group %q egress, %v", securityReqInfo.IId.NameId, err)
                        return irs.SecurityInfo{}, err
                }</span>

                <span class="cov0" title="0">cblogger.Info("Successfully set security group egress")</span>
        }

        <span class="cov0" title="0">cblogger.Debug("Name Tag ")
        //======================
        // Name  
        //======================
        //VPC Name 
        tagInput := &amp;ec2.CreateTagsInput{
                Resources: []*string{
                        aws.String(*createRes.GroupId),
                },
                Tags: []*ec2.Tag{
                        {
                                Key:   aws.String("Name"),
                                Value: aws.String(securityReqInfo.IId.NameId),
                        },
                },
        }
        //spew.Dump(tagInput)

        _, errTag := securityHandler.Client.CreateTags(tagInput)
        //Tag         .
        if errTag != nil </span><span class="cov0" title="0">{
                cblogger.Error(errTag)
        }</span>

        //securityInfo, _ := securityHandler.GetSecurity(*createRes.GroupId)
        //securityInfo, _ := securityHandler.GetSecurity(securityReqInfo.IId) //2019-11-16 NameId  
        <span class="cov0" title="0">securityInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: *createRes.GroupId}) //2020-04-09 SystemId 
        securityInfo.IId.NameId = securityReqInfo.IId.NameId                                  // Name       NameId  .
        securityInfo.VpcIID.NameId = securityReqInfo.VpcIID.NameId                            // Name            NameId    .
        return securityInfo, nil</span>
}

func (securityHandler *AwsSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        //VPC ID 
        /* 2020-04-13 :    
        VPCHandler := AwsVPCHandler{Client: securityHandler.Client}
        vpcId := VPCHandler.GetMcloudBaristaDefaultVpcId()
        if vpcId == "" {
                return nil, nil
        }
        */

        input := &amp;ec2.DescribeSecurityGroupsInput{
                GroupIds: []*string{
                        nil,
                },
                /*
                        Filters: []*ec2.Filter{
                                {
                                        Name:   aws.String("vpc-id"),
                                        Values: aws.StringSlice([]string{vpcId}),
                                },
                        },
                */
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "List()",
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := securityHandler.Client.DescribeSecurityGroups(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result : ", result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                cblogger.Info("err : ", err)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var results []*irs.SecurityInfo
        for _, securityGroup := range result.SecurityGroups </span><span class="cov0" title="0">{
                securityInfo := ExtractSecurityInfo(securityGroup)
                results = append(results, &amp;securityInfo)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

//2019-11-16 CB-Driver   NameId  .
//func (securityHandler *AwsSecurityHandler) GetSecurity(securityNameId string) (irs.SecurityInfo, error) {
func (securityHandler *AwsSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityNameId : [%s]", securityIID.SystemId)

        //2020-04-09 Filter  SystemId  
        input := &amp;ec2.DescribeSecurityGroupsInput{
                GroupIds: []*string{
                        aws.String(securityIID.SystemId),
                },
        }
        /* 2020-04-09 Name     
        input.Filters = ([]*ec2.Filter{
                &amp;ec2.Filter{
                        //Name: aws.String("tag:Name"), // subnet-id
                        Name: aws.String("group-name"), // subnet-id
                        Values: []*string{
                                aws.String(securityIID.SystemId),
                        },
                },
        })
        */
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := securityHandler.Client.DescribeSecurityGroups(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result : ", result)
        cblogger.Info("err : ", err)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return irs.SecurityInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(result.SecurityGroups) &gt; 0 </span><span class="cov0" title="0">{
                securityInfo := ExtractSecurityInfo(result.SecurityGroups[0])
                return securityInfo, nil
        }</span> else<span class="cov0" title="0"> {
                //return irs.SecurityInfo{}, errors.New("[" + securityNameId + "]    .")
                return irs.SecurityInfo{}, errors.New("InvalidSecurityGroup.NotFound: The security group '" + securityIID.SystemId + "' does not exist")
        }</span>
}

func ExtractSecurityInfo(securityGroupResult *ec2.SecurityGroup) irs.SecurityInfo <span class="cov0" title="0">{
        var ipPermissions []irs.SecurityRuleInfo
        var ipPermissionsEgress []irs.SecurityRuleInfo
        var securityRules []irs.SecurityRuleInfo

        cblogger.Debugf("===[:%s]===", *securityGroupResult.GroupId)
        ipPermissions = ExtractIpPermissions(securityGroupResult.IpPermissions, "inbound")
        cblogger.Debug("InBouds : ", ipPermissions)
        ipPermissionsEgress = ExtractIpPermissions(securityGroupResult.IpPermissionsEgress, "outbound")
        cblogger.Debug("OutBounds : ", ipPermissionsEgress)
        //spew.Dump(ipPermissionsEgress)
        securityRules = append(ipPermissions, ipPermissionsEgress...)

        securityInfo := irs.SecurityInfo{
                //Id: *securityGroupResult.GroupId,
                IId: irs.IID{"", *securityGroupResult.GroupId},
                //SecurityRules: &amp;[]irs.SecurityRuleInfo{},
                SecurityRules: &amp;securityRules,
                VpcIID:        irs.IID{"", *securityGroupResult.VpcId},

                KeyValueList: []irs.KeyValue{
                        {Key: "GroupName", Value: *securityGroupResult.GroupName},
                        {Key: "VpcID", Value: *securityGroupResult.VpcId},
                        {Key: "OwnerID", Value: *securityGroupResult.OwnerId},
                        {Key: "Description", Value: *securityGroupResult.Description},
                },
        }

        //Name Tag "Name"  
        cblogger.Debug("Name Tag ")
        for _, t := range securityGroupResult.Tags </span><span class="cov0" title="0">{
                if *t.Key == "Name" </span><span class="cov0" title="0">{
                        //securityInfo.Name = *t.Value
                        securityInfo.IId.NameId = *t.Value
                        cblogger.Debug("Name : ", securityInfo.IId.NameId)
                        break</span>
                }
        }

        <span class="cov0" title="0">return securityInfo</span>
}

// IpPermission  
func ExtractIpPermissionCommon(ip *ec2.IpPermission, securityRuleInfo *irs.SecurityRuleInfo) <span class="cov0" title="0">{
        // 
        if !reflect.ValueOf(ip.FromPort).IsNil() </span><span class="cov0" title="0">{
                //securityRuleInfo.FromPort = *ip.FromPort
                securityRuleInfo.FromPort = strconv.FormatInt(*ip.FromPort, 10)
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(ip.ToPort).IsNil() </span><span class="cov0" title="0">{
                //securityRuleInfo.ToPort = *ip.ToPort
                securityRuleInfo.ToPort = strconv.FormatInt(*ip.ToPort, 10)
        }</span>

        <span class="cov0" title="0">securityRuleInfo.IPProtocol = *ip.IpProtocol</span>
}

func ExtractIpPermissions(ipPermissions []*ec2.IpPermission, direction string) []irs.SecurityRuleInfo <span class="cov0" title="0">{
        var results []irs.SecurityRuleInfo

        for _, ip := range ipPermissions </span><span class="cov0" title="0">{

                //ipv4 
                for _, ipv4 := range ip.IpRanges </span><span class="cov0" title="0">{
                        cblogger.Debug("Inbound/Outbound   : ", *ip.IpProtocol)
                        securityRuleInfo := irs.SecurityRuleInfo{
                                Direction: direction, // "inbound | outbound"
                                CIDR:      *ipv4.CidrIp,
                        }
                        cblogger.Debug(*ipv4.CidrIp)

                        ExtractIpPermissionCommon(ip, &amp;securityRuleInfo) //IP &amp; Port &amp; Protocol 
                        results = append(results, securityRuleInfo)
                }</span>

                //ipv6 
                <span class="cov0" title="0">for _, ipv6 := range ip.Ipv6Ranges </span><span class="cov0" title="0">{
                        securityRuleInfo := irs.SecurityRuleInfo{
                                Direction: direction, // "inbound | outbound"
                                CIDR:      *ipv6.CidrIpv6,
                        }
                        cblogger.Debug(*ipv6.CidrIpv6)

                        ExtractIpPermissionCommon(ip, &amp;securityRuleInfo) //IP &amp; Port &amp; Protocol 
                        results = append(results, securityRuleInfo)
                }</span>

                //ELB    
                <span class="cov0" title="0">for _, userIdGroup := range ip.UserIdGroupPairs </span><span class="cov0" title="0">{
                        securityRuleInfo := irs.SecurityRuleInfo{
                                Direction: direction, // "inbound | outbound"
                                CIDR:      *userIdGroup.GroupId,
                        }
                        cblogger.Debug(*userIdGroup.UserId)

                        ExtractIpPermissionCommon(ip, &amp;securityRuleInfo) //IP &amp; Port &amp; Protocol 
                        results = append(results, securityRuleInfo)
                }</span>

                /*  @TODO :        .
                if !reflect.ValueOf(ip.IpRanges).IsNil() {
                        securityRuleInfo.Cidr = *ip.IpRanges[0].CidrIp
                } else {
                        //ELB    IpRanges  UserIdGroupPairs   
                        //https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/classic/elb-security-groups.html
                        if !reflect.ValueOf(ip.UserIdGroupPairs).IsNil() {
                                securityRuleInfo.Cidr = *ip.UserIdGroupPairs[0].GroupId
                        } else {
                                cblogger.Error("     -    ", ip)
                        }
                }
                */
        }

        <span class="cov0" title="0">return results</span>
}

//2019-11-16 CB-Driver   NameId  .
//func (securityHandler *AwsSecurityHandler) DeleteSecurity(securityNameId string) (bool, error) {
func (securityHandler *AwsSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("securityNameId : [%s]", securityIID.SystemId)

        /* //2020-04-09 SystemId    .
        securityInfo, errsecurityInfo := securityHandler.GetSecurity(securityIID)
        if errsecurityInfo != nil {
                return false, errsecurityInfo
        }
        cblogger.Info(securityInfo)
        */

        //securityID := securityInfo.Id
        //securityID := securityInfo.IId.SystemId
        securityID := securityIID.SystemId

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DeleteSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Delete the security group.
        _, err := securityHandler.Client.DeleteSecurityGroup(&amp;ec2.DeleteSecurityGroupInput{
                GroupId: aws.String(securityID),
        })
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))

                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        case "InvalidGroupId.Malformed":<span class="cov0" title="0">
                                fallthrough</span>
                        case "InvalidGroup.NotFound":<span class="cov0" title="0">
                                cblogger.Errorf("%s.", aerr.Message())
                                return false, err</span>
                        }
                }
                <span class="cov0" title="0">cblogger.Errorf("Unable to get descriptions for security groups, %v.", err)
                return false, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Successfully delete security group %q.", securityID)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Proof of Concepts for the Cloud-Barista Multi-Cloud Project.
//      * Cloud-Barista: https://github.com/cloud-barista
//
// EC2 Hander (AWS SDK GO Version 1.16.26, Thanks AWS.)
//
// by CB-Spider Team, 2019.03.
package resources

import (
        "encoding/base64"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "reflect"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/ec2"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"

        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

type AwsVMHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

func Connect(region string) *ec2.EC2 <span class="cov0" title="0">{
        // setup Region
        sess, err := session.NewSession(&amp;aws.Config{
                Region: aws.String(region)},
        )

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Could not create instance", err)
                return nil
        }</span>

        // Create EC2 service client
        <span class="cov0" title="0">svc := ec2.New(sess)

        return svc</span>
}

// 1 VM   (MinCount / MaxCount   )
// (:mcloud-barista)  URL    " "   .
//https://ap-northeast-2.console.aws.amazon.com/ec2/v2/home?region=ap-northeast-2#KeyPairs:sort=keyName
func (vmHandler *AwsVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vmReqInfo)
        spew.Dump(vmReqInfo)

        imageID := vmReqInfo.ImageIID.SystemId
        instanceType := vmReqInfo.VMSpecName // "t2.micro"
        minCount := aws.Int64(1)
        maxCount := aws.Int64(1)
        keyName := vmReqInfo.KeyPairIID.SystemId
        baseName := vmReqInfo.IId.NameId //"mcloud-barista-VMHandlerTest"
        subnetID := vmReqInfo.SubnetIID.SystemId

        // 2021-04-28 cbuser   Local KeyPair VM   
        //=============================
        // KeyPair PublicKey  
        //=============================
        cblogger.Infof("[%s] KeyPair  ", keyName)
        keypairHandler := AwsKeyPairHandler{
                //CredentialInfo:
                Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(keypairHandler)

        keyPairInfo, errKeyPair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair)
                return irs.VMInfo{}, errKeyPair
        }</span>

        //=============================
        //   - SystemId 
        //=============================
        <span class="cov0" title="0">cblogger.Info("SystemId    IID    SystemId     .")
        var newSecurityGroupIds []string

        for _, sgName := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                cblogger.Infof("  : [%s]", sgName)
                newSecurityGroupIds = append(newSecurityGroupIds, sgName.SystemId)
        }</span>

        <span class="cov0" title="0">cblogger.Info("  ")
        cblogger.Info(newSecurityGroupIds)

        /* 2020-04-08 EIP  
        //=============================
        // PublicIp  - NameId 
        //=============================
        cblogger.Info("NameId    PublicIp  .")
        publicIPHandler := AwsPublicIPHandler{
                //Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(publicIPHandler)

        publicIPInfo, errPublicIPInfo := publicIPHandler.GetPublicIP(vmReqInfo.PublicIPId)
        cblogger.Info(publicIPInfo)
        if errPublicIPInfo != nil {
                cblogger.Error(errPublicIPInfo)
                return irs.VMInfo{}, errPublicIPInfo
        }
        publicIpId := publicIPInfo.Id
        cblogger.Infof("PublicIP ID [%s] [%s] .", publicIPInfo.Id, publicIpId)
        */

        /*
                //=============================
                // UserData 
                //=============================
                userData := "#cloud-config\nusers:\n  - default\n  - name: " + CBDefaultVmUserName + "\n    groups: sudo\n    shell: /bin/bash\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n    ssh-authorized-keys:\n      - "
                //userData = userData + "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0wqohybvHvljVsUW7vmyicVNVDcPdzh6ZRkm1H9SyMuUEK0zOB3Kj+1MxMQPnRXgL9fI518ymUxavrkrHr0LwZtG8pfMOwZkZ7WD4WnT6Ho14N14U1JIM/+005cBBYyF+OWYyxD/q5p/y8R19NXLpEbnpTNL0mKjQ1q8a6/LVCsaKxy9OJ9o/ChN2FDXhCdVLPHL/jrUPqzjSLkm/GIt+v9RWJ0BFAk+rZY7abMNfGSorTqWZEYYd8gqofeTPh2mhYr21NVLBiAyzQqs6fgL+FgsnJFBnuIZ2peuCGxcOxZ7h8iEzJG2r+tGn+ivfMpla12oHxwihJhiodN1KxeZ7"
                userData = userData + keyPairInfo.PublicKey
                userDataBase64 := aws.String(base64.StdEncoding.EncodeToString([]byte(userData)))
                cblogger.Infof("===== userData ===")
                spew.Dump(userDataBase64)
        */

        //=============================
        // UserData (File)
        //=============================
        //       cloud-init   
        rootPath := os.Getenv("CBSPIDER_ROOT")
        fileDataCloudInit, err := ioutil.ReadFile(rootPath + CBCloudInitFilePath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">userData := string(fileDataCloudInit)
        userData = strings.ReplaceAll(userData, "{{username}}", CBDefaultVmUserName)
        userData = strings.ReplaceAll(userData, "{{public_key}}", keyPairInfo.PublicKey)
        userDataBase64 := aws.String(base64.StdEncoding.EncodeToString([]byte(userData)))
        cblogger.Debugf("cloud-init data : [%s]", userDataBase64)

        //=============================
        // VM 
        //=============================
        cblogger.Info("Create EC2 Instance")
        input := &amp;ec2.RunInstancesInput{
                ImageId:      aws.String(imageID),
                InstanceType: aws.String(instanceType),
                MinCount:     minCount,
                MaxCount:     maxCount,
                KeyName:      aws.String(keyName),

                /*SecurityGroupIds: []*string{
                        aws.String(securityGroupID), // "sg-0df1c209ea1915e4b" -    "default"    .
                },*/

                /* PrivateSubnet PublicIp  AssociatePublicIpAddress   Subnet PublicIp   True  .
                //  PublicIp   False   NetworkInterfaces     . - 2020-04-19
                SecurityGroupIds: aws.StringSlice(newSecurityGroupIds),
                SubnetId:         aws.String(subnetID), // "subnet-cf9ccf83" -   VPC     PublicIP  .
                */

                //AdditionalInfo: aws.String("--associate-public-ip-address"),
                //AdditionalInfo: aws.String("AssociatePublicIpAddress=true"),
                //NetworkInterfaces: []*ec2.InstanceNetworkInterfaceSpecification{{AssociatePublicIpAddress: aws.Bool(true)}},

                NetworkInterfaces: []*ec2.InstanceNetworkInterfaceSpecification{ // PublicIp   SubnetId      .
                        {AssociatePublicIpAddress: aws.Bool(true),
                                DeviceIndex: aws.Int64(0),
                                Groups:      aws.StringSlice(newSecurityGroupIds),
                                SubnetId:    aws.String(subnetID),
                        },
                },

                //ec2.InstanceNetworkInterfaceSpecification
                UserData: userDataBase64,
        }
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmReqInfo.IId.NameId,
                CloudOSAPI:   "RunInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        // Specify the details of the instance that you want to create.
        runResult, err := vmHandler.Client.RunInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(runResult)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Errorf("EC2    : ", err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(runResult.Instances) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("AWS   VM  .")
        }</span>

        //=============================
        // Name Tag  - NameId 
        //=============================
        <span class="cov0" title="0">newVmId := *runResult.Instances[0].InstanceId
        cblogger.Infof("[%s] VM .", newVmId)

        if baseName != "" </span><span class="cov0" title="0">{
                // Tag VM Name 
                _, errtag := vmHandler.Client.CreateTags(&amp;ec2.CreateTagsInput{
                        Resources: []*string{runResult.Instances[0].InstanceId},
                        Tags: []*ec2.Tag{
                                {
                                        Key:   aws.String("Name"),
                                        Value: aws.String(baseName),
                                },
                        },
                })
                if errtag != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] VM Name Tag  ", newVmId)
                        cblogger.Error(errtag)
                        //return irs.VMInfo{}, errtag
                }</span>
        } else<span class="cov0" title="0"> {
                cblogger.Error("vmReqInfo.IId.NameId   Name Tag .")
        }</span>
        //Public IP            .
        //cblogger.Info("Public IP   VM     EC2 Running   ")

        //2021-05-11 EIP       Running    .
        //2021-05-11 WaitForRun   GetVM()       . (     WaitForRun  .)
        <span class="cov0" title="0">cblogger.Info("VM     EC2 Running   ")
        WaitForRun(vmHandler.Client, newVmId)
        cblogger.Info("EC2 Running   : ", runResult.Instances[0].State.Name)

        /* 2020-04-08 EIP  
        //EC2 EIP  (  EIP  )
        cblogger.Infof("[%s] EC2 [%s] IP  ", newVmId, publicIpId)
        assocRes, errIp := vmHandler.AssociatePublicIP(publicIpId, newVmId)
        if errIp != nil {
                cblogger.Errorf("EC2[%s] Public IP Id[%s]     - %v", newVmId, publicIpId, err)
                return irs.VMInfo{}, errIp
        }

        cblogger.Infof("[%s] EC2 Public IP   : ", newVmId, assocRes)
        */

        /* 2020-04-08 vNic  
        //
        //vNic       vNic VM  .
        //
        if vmReqInfo.NetworkInterfaceId != "" {
                _, errvNic := vmHandler.AttachNetworkInterface(vmReqInfo.NetworkInterfaceId, newVmId)
                if errvNic != nil {
                        cblogger.Errorf("vNic [%s]  !", vmReqInfo.NetworkInterfaceId)
                        cblogger.Error(errvNic)
                        return irs.VMInfo{}, errvNic
                } else {
                        cblogger.Infof("vNic [%s]  ", vmReqInfo.NetworkInterfaceId)
                }
        }
        */

        //  
        //newVmInfo, _ := vmHandler.GetVM(newVmId)
        newVmInfo, _ := vmHandler.GetVM(irs.IID{SystemId: newVmId})
        newVmInfo.IId.NameId = vmReqInfo.IId.NameId // Tag        NameId  .

        /*
                //   Running       .
                //Running    Public Ip    GetVM()      .
                //vmInfo :=GetVM(runResult.Instances[0].InstanceId)

                //cblogger.Info("EC2 Running  ")
                //WaitForRun(vmHandler.Client, *runResult.Instances[0].InstanceId)
                //cblogger.Info("EC2 Running   : ", runResult.Instances[0].State.Name)

                vmInfo := ExtractDescribeInstances(runResult)
                // VM      Tag   Name    .
                if vmInfo.Name == "" {
                        vmInfo.Name = baseName
                }
        */

        return newVmInfo, nil</span>
}

//VM Running   .
func WaitForRun(svc *ec2.EC2, instanceID string) <span class="cov0" title="0">{
        cblogger.Infof("EC2 ID : [%s]", instanceID)

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        aws.String(instanceID),
                },
        }
        err := svc.WaitUntilInstanceRunning(input)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("failed to wait until instances exist: %v", err)
        }</span>
        <span class="cov0" title="0">cblogger.Info("=========WaitForRun() ")</span>
}

//func (vmHandler *AwsVMHandler) ResumeVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
                vmID := vmInfo.IId.SystemId
        */
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.StartInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
                DryRun: aws.Bool(true),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StartInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.StartInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        awsErr, ok := err.(awserr.Error)

        if ok &amp;&amp; awsErr.Code() == "DryRunOperation" </span><span class="cov0" title="0">{
                // Let's now set dry run to be false. This will allow us to start the instances
                input.DryRun = aws.Bool(false)
                result, err = vmHandler.Client.StartInstances(input)
                spew.Dump(result)
                if err != nil </span><span class="cov0" title="0">{
                        //fmt.Println("Error", err)
                        cblogger.Error(err)
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        return irs.VMStatus("Failed"), err
                }</span> else<span class="cov0" title="0"> {
                        //fmt.Println("Success", result.StartingInstances)
                        cblogger.Info("Success", result.StartingInstances)
                }</span>
        } else<span class="cov0" title="0"> { // This could be due to a lack of permissions
                //fmt.Println("Error", err)
                cblogger.Error(err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return irs.VMStatus("Resuming"), nil</span>
}

//func (vmHandler *AwsVMHandler) SuspendVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
        */
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.StopInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
                DryRun: aws.Bool(true),
        }
        cblogger.Info(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StopInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := vmHandler.Client.StopInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        awsErr, ok := err.(awserr.Error)
        if ok &amp;&amp; awsErr.Code() == "DryRunOperation" </span><span class="cov0" title="0">{
                input.DryRun = aws.Bool(false)
                result, err = vmHandler.Client.StopInstances(input)
                spew.Dump(result)
                if err != nil </span><span class="cov0" title="0">{
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        cblogger.Error(err)
                        return irs.VMStatus("Failed"), err
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Info("Success", result.StoppingInstances)
                }</span>
        } else<span class="cov0" title="0"> {
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error("Error", err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return irs.VMStatus("Suspending"), nil</span>
}

//func (vmHandler *AwsVMHandler) RebootVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
                vmID := vmInfo.IId.SystemId
        */
        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.RebootInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
                DryRun: aws.Bool(true),
        }
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "RebootInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := vmHandler.Client.RebootInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("result  : ", result)
        cblogger.Info("err  : ", err)

        awsErr, ok := err.(awserr.Error)
        cblogger.Info("ok  : ", ok)
        cblogger.Info("awsErr  : ", awsErr)
        if ok &amp;&amp; awsErr.Code() == "DryRunOperation" </span><span class="cov0" title="0">{
                cblogger.Info("Reboot   - awsErr.Code() : ", awsErr.Code())

                //DryRun      .
                cblogger.Info("DryRun      .")
                input.DryRun = aws.Bool(false)
                result, err = vmHandler.Client.RebootInstances(input)
                spew.Dump(result)
                cblogger.Info("result  : ", result)
                cblogger.Info("err  : ", err)
                if err != nil </span><span class="cov0" title="0">{
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        cblogger.Error("Error", err)
                        return irs.VMStatus("Failed"), err
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Info("Success", result)
                }</span>
        } else<span class="cov0" title="0"> { // This could be due to a lack of permissions
                cblogger.Info("   .")
                cblogger.Error("Error", err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return irs.VMStatus("Rebooting"), nil</span>
}

//func (vmHandler *AwsVMHandler) TerminateVM(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        input := &amp;ec2.TerminateInstancesInput{
                //InstanceIds: instanceIds,
                InstanceIds: []*string{
                        aws.String(vmID),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "TerminateInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.TerminateInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error("Could not termiate instances", err)
                return irs.VMStatus("Failed"), err
        }</span> else<span class="cov0" title="0"> {
                cblogger.Info("Success")
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return irs.VMStatus("Terminating"), nil</span>
}

//2019-11-16 CB-Driver   NameId  .
//func (vmHandler *AwsVMHandler) GetVM(vmNameId string) (irs.VMInfo, error) {
func (vmHandler *AwsVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)
        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmIID.SystemId),
                },
        }
        /*
                input.Filters = ([]*ec2.Filter{
                        &amp;ec2.Filter{
                                Name: aws.String("tag:Name"),
                                Values: []*string{
                                        aws.String(vmIID.NameId),
                                },
                        },
                })
        */
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Info(result)
        cblogger.Infof(" VM   : [%d]", len(result.Reservations))
        if len(result.Reservations) &gt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, awserr.New("600", "1  VM ["+vmIID.NameId+"]  .", nil)
        }</span> else<span class="cov0" title="0"> if len(result.Reservations) == 0 </span><span class="cov0" title="0">{
                cblogger.Errorf("VM [%s]   .", vmIID.NameId)
                return irs.VMInfo{}, awserr.New("404", "VM ["+vmIID.NameId+"]   .", nil)
        }</span>

        <span class="cov0" title="0">vmInfo := irs.VMInfo{}
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                //vmInfo := ExtractDescribeInstances(result.Reservations[0])
                vmInfo = vmHandler.ExtractDescribeInstances(i)
        }</span>

        //if len(vmInfo.Region.Zone) &gt; 0 {
        //vmInfo.Region.Region = vmHandler.Region.Region
        //}

        <span class="cov0" title="0">cblogger.Info("vmInfo", vmInfo)
        return vmInfo, nil</span>
}

// DescribeInstances EC2   
// VM   Running     
//       GetVM   .
func (vmHandler *AwsVMHandler) ExtractDescribeInstances(reservation *ec2.Reservation) irs.VMInfo <span class="cov0" title="0">{
        //cblogger.Info("ExtractDescribeInstances", reservation)
        cblogger.Info("Instances[0]", reservation.Instances[0])
        //spew.Dump(reservation.Instances[0])

        //"stopped" / "terminated" / "running" ...
        var state string
        state = *reservation.Instances[0].State.Name
        cblogger.Infof("EC2  : [%s]", state)

        //VM      
        vmInfo := irs.VMInfo{
                IId:        irs.IID{"", *reservation.Instances[0].InstanceId},
                ImageIId:   irs.IID{*reservation.Instances[0].ImageId, *reservation.Instances[0].ImageId},
                VMSpecName: *reservation.Instances[0].InstanceType,
                KeyPairIId: irs.IID{*reservation.Instances[0].KeyName, *reservation.Instances[0].KeyName},
                //GuestUserID:    "",
                //AdditionalInfo: "State:" + *reservation.Instances[0].State.Name,
        }

        keyValueList := []irs.KeyValue{
                {Key: "State", Value: *reservation.Instances[0].State.Name},
                {Key: "Architecture", Value: *reservation.Instances[0].Architecture},
        }

        //if *reservation.Instances[0].LaunchTime != "" {
        vmInfo.StartTime = *reservation.Instances[0].LaunchTime
        //}

        //cblogger.Info("=======&gt; : ", reflect.TypeOf(*reservation.Instances[0]))
        //cblogger.Info("===&gt; PublicIpAddress TypeOf : ", reflect.TypeOf(reservation.Instances[0].PublicIpAddress))
        //cblogger.Info("===&gt; PublicIpAddress ValueOf : ", reflect.ValueOf(reservation.Instances[0].PublicIpAddress))

        //vmInfo.PublicIP = *reservation.Instances[0].NetworkInterfaces[0].Association.PublicIp
        //vmInfo.PublicDNS = *reservation.Instances[0].NetworkInterfaces[0].Association.PublicDnsName

        //  (:EIP) VM    VM   Nil    .
        if !reflect.ValueOf(reservation.Instances[0].PublicIpAddress).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PublicIP = *reservation.Instances[0].PublicIpAddress
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].PublicDnsName).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PublicDNS = *reservation.Instances[0].PublicDnsName
        }</span>

        <span class="cov0" title="0">cblogger.Info("===&gt; BlockDeviceMappings ValueOf : ", reflect.ValueOf(reservation.Instances[0].BlockDeviceMappings))
        if !reflect.ValueOf(reservation.Instances[0].BlockDeviceMappings).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(reservation.Instances[0].BlockDeviceMappings[0].DeviceName).IsNil() </span><span class="cov0" title="0">{
                        vmInfo.VMBlockDisk = *reservation.Instances[0].BlockDeviceMappings[0].DeviceName
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].Placement.AvailabilityZone).IsNil() </span><span class="cov0" title="0">{
                vmInfo.Region = irs.RegionInfo{
                        Region: vmHandler.Region.Region, //  
                        Zone:   *reservation.Instances[0].Placement.AvailabilityZone,
                }
        }</span>

        //NetworkInterfaces  
        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].VpcId).IsNil() </span><span class="cov0" title="0">{
                        //vmInfo.VirtualNetworkId = *reservation.Instances[0].NetworkInterfaces[0].VpcId
                        vmInfo.VpcIID = irs.IID{"", *reservation.Instances[0].NetworkInterfaces[0].VpcId}
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "VpcId", Value: *reservation.Instances[0].NetworkInterfaces[0].VpcId})
                }</span>

                <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].SubnetId).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SubnetId", Value: *reservation.Instances[0].NetworkInterfaces[0].SubnetId})
                        vmInfo.SubnetIID = irs.IID{SystemId: *reservation.Instances[0].NetworkInterfaces[0].SubnetId}
                }</span>

                <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].Attachment).IsNil() </span><span class="cov0" title="0">{
                        vmInfo.NetworkInterface = *reservation.Instances[0].NetworkInterfaces[0].Attachment.AttachmentId
                }</span>

                <span class="cov0" title="0">for _, security := range reservation.Instances[0].NetworkInterfaces[0].Groups </span><span class="cov0" title="0">{
                        //vmInfo.SecurityGroupIds = append(vmInfo.SecurityGroupIds, *security.GroupId)
                        vmInfo.SecurityGroupIIds = append(vmInfo.SecurityGroupIIds, irs.IID{*security.GroupName, *security.GroupId})
                }</span>

                /*
                        if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].Groups).IsNil() {
                                vmInfo.SecurityGroupIds = *reservation.Instances[0].NetworkInterfaces[0].Groups[0]
                                if !reflect.ValueOf(reservation.Instances[0].NetworkInterfaces[0].Groups[0].GroupId).IsNil() {
                                        vmInfo.SecurityID = *reservation.Instances[0].NetworkInterfaces[0].Groups[0].GroupId
                                }
                        }
                */
        }

        //SecurityName: *reservation.Instances[0].NetworkInterfaces[0].Groups[0].GroupName,
        //vmInfo.VNIC = "eth0 -    "

        //vmInfo.PrivateIP = *reservation.Instances[0].NetworkInterfaces[0].PrivateIpAddress        //   Instances[0].PrivateIpAddress  - i-0b75cac73c4575386
        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].PrivateIpAddress).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PrivateIP = *reservation.Instances[0].PrivateIpAddress
        }</span>

        //vmInfo.PrivateDNS = *reservation.Instances[0].NetworkInterfaces[0].PrivateDnsName                //   Instances[0].PrivateDnsName  - i-0b75cac73c4575386
        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].PrivateDnsName).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PrivateDNS = *reservation.Instances[0].PrivateDnsName
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].RootDeviceName).IsNil() </span><span class="cov0" title="0">{
                vmInfo.VMBootDisk = *reservation.Instances[0].RootDeviceName
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(reservation.Instances[0].KeyName).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "KeyName", Value: *reservation.Instances[0].KeyName})
        }</span>

        //Name Tag "Name"  
        <span class="cov0" title="0">cblogger.Debug("Name Tag ")
        for _, t := range reservation.Instances[0].Tags </span><span class="cov0" title="0">{
                if *t.Key == "Name" </span><span class="cov0" title="0">{
                        vmInfo.IId.NameId = *t.Value
                        cblogger.Debug("EC2  : ", vmInfo.IId.NameId)
                        break</span>
                }
        }

        <span class="cov0" title="0">vmInfo.KeyValueList = keyValueList
        return vmInfo</span>
}

func ExtractVmName(Tags []*ec2.Tag) string <span class="cov0" title="0">{
        for _, t := range Tags </span><span class="cov0" title="0">{
                if *t.Key == "Name" </span><span class="cov0" title="0">{
                        cblogger.Info("  --&gt; EC2  : ", *t.Key)
                        return *t.Value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (vmHandler *AwsVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")
        var vmInfoList []*irs.VMInfo

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        nil,
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "",
                CloudOSAPI:   "ListVM()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success")

        //tmpVmName := ""
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                for _, vm := range i.Instances </span><span class="cov0" title="0">{
                        cblogger.Info("[%s] EC2  ", *vm.InstanceId)
                        /*
                                tmpVmName = ExtractVmName(vm.Tags)
                                if tmpVmName == "" {
                                        cblogger.Errorf("VM Id[%s]  VM    !!!", *vm.InstanceId)
                                        continue
                                }
                        */
                        //vmInfo, _ := vmHandler.GetVM(irs.IID{NameId: tmpVmName})
                        vmInfo, _ := vmHandler.GetVM(irs.IID{SystemId: *vm.InstanceId})
                        vmInfoList = append(vmInfoList, &amp;vmInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmInfoList, nil</span>
}

func ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "pending") </span><span class="cov0" title="0">{
                //resultStatus = "Creating"        // VM   Pending CB      .
                resultStatus = "Resuming" // Resume     Pending   Pending Resuming .
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "running") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopping") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopped") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
                //} else if strings.EqualFold(vmStatus, "pending") {
                //        resultStatus = "Resuming"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Rebooting") </span><span class="cov0" title="0">{
                resultStatus = "Rebooting"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "shutting-down") </span><span class="cov0" title="0">{
                resultStatus = "Terminating"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Terminated") </span><span class="cov0" title="0">{
                resultStatus = "Terminated"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]      .", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "  CB VM    .")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM   : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

//SHUTTING-DOWN / TERMINATED
//func (vmHandler *AwsVMHandler) GetVMStatus(vmNameId string) (irs.VMStatus, error) {
func (vmHandler *AwsVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        /*
                vmInfo, errVmInfo := vmHandler.GetVM(vmIID)
                if errVmInfo != nil {
                        return irs.VMStatus("Failed"), errVmInfo
                }
                cblogger.Info(vmInfo)
                vmID := vmInfo.IId.SystemId
        */

        vmID := vmIID.SystemId
        cblogger.Infof("vmID : [%s]", vmID)

        //vmStatus := "pending"
        //return irs.VMStatus(vmStatus)

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        aws.String(vmID),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success", result)
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                for _, vm := range i.Instances </span><span class="cov0" title="0">{
                        //vmStatus := strings.ToUpper(*vm.State.Name)
                        cblogger.Info(vmID, " EC2 Status : ", *vm.State.Name)
                        vmStatus, errStatus := ConvertVMStatusString(*vm.State.Name)
                        return vmStatus, errStatus
                        //return irs.VMStatus(vmStatus), nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VMStatus("Failed"), errors.New("    .")</span>
}

func (vmHandler *AwsVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")
        var vmStatusList []*irs.VMStatusInfo

        input := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []*string{
                        nil,
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVMStatus()",
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := vmHandler.Client.DescribeInstances(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("Success")

        tmpVmName := ""
        for _, i := range result.Reservations </span><span class="cov0" title="0">{
                for _, vm := range i.Instances </span><span class="cov0" title="0">{
                        //*vm.State.Name
                        //*vm.InstanceId

                        vmStatus, _ := ConvertVMStatusString(*vm.State.Name)
                        tmpVmName = ExtractVmName(vm.Tags)
                        /*
                                if tmpVmName == "" {
                                        cblogger.Errorf("VM Id[%s]  VM    !!!", *vm.InstanceId)
                                        //continue //2020-04-10 Name      .
                                }
                        */

                        vmStatusInfo := irs.VMStatusInfo{
                                //VmId:   *vm.InstanceId,
                                //VmName: tmpVmName,
                                IId: irs.IID{tmpVmName, *vm.InstanceId},
                                //VmStatus: vmHandler.GetVMStatus(*vm.InstanceId),
                                //VmStatus: irs.VMStatus(strings.ToUpper(*vm.State.Name)),
                                VmStatus: vmStatus,
                        }
                        cblogger.Info(vmStatusInfo.IId.SystemId, " EC2 Status : ", vmStatusInfo.VmStatus)
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

// AssociationId  PublicIP  .
func (vmHandler *AwsVMHandler) AssociatePublicIP(allocationId string, instanceId string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("EC2  IP - AllocationId : [%s], InstanceId : [%s]", allocationId, instanceId)

        // EC2 .
        // Associate the new Elastic IP address with an existing EC2 instance.
        assocRes, err := vmHandler.Client.AssociateAddress(&amp;ec2.AssociateAddressInput{
                AllocationId: aws.String(allocationId),
                InstanceId:   aws.String(instanceId),
        })

        spew.Dump(assocRes)
        //cblogger.Infof("[%s] EC2 EIP(AllocationId : [%s])   - AssociationId Id : [%s]", instanceId, allocationId, *assocRes.AssociationId)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("Unable to associate IP address with %s, %v", instanceId, err)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Errorf(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Errorf(err.Error())
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">cblogger.Info(assocRes)
        return true, nil</span>
}

//   vNic VM .
func (vmHandler *AwsVMHandler) AttachNetworkInterface(vNicId string, instanceId string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("EC2[%s] VM vNic[%s]  ", vNicId, instanceId)

        input := &amp;ec2.AttachNetworkInterfaceInput{
                DeviceIndex:        aws.Int64(1),
                InstanceId:         aws.String(instanceId),
                NetworkInterfaceId: aws.String(vNicId),
        }

        result, err := vmHandler.Client.AttachNetworkInterface(input)
        cblogger.Info(result)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("EC2[%s] VM vNic[%s]  ", vNicId, instanceId)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Errorf(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Errorf(err.Error())
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package resources

import (
        "errors"
        "reflect"
        "strconv"

        //sdk2 "github.com/aws/aws-sdk-go-v2"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

//https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.DescribeInstanceTypes
type AwsVmSpecHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

func ExtractGpuInfo(gpuDeviceInfo *ec2.GpuDeviceInfo) irs.GpuInfo <span class="cov0" title="0">{
        cblogger.Debug(gpuDeviceInfo)
        //cblogger.Info("================")
        //spew.Dump(gpuDeviceInfo)

        gpuInfo := irs.GpuInfo{
                Count: strconv.FormatInt(*gpuDeviceInfo.Count, 10),
                Mfr:   *gpuDeviceInfo.Manufacturer,
                Model: *gpuDeviceInfo.Name,
                Mem:   strconv.FormatInt(*gpuDeviceInfo.MemoryInfo.SizeInMiB, 10),
        }

        return gpuInfo
}</span>

//   
func ExtractVMSpecInfo(Region string, instanceTypeInfo *ec2.InstanceTypeInfo) irs.VMSpecInfo <span class="cov0" title="0">{
        cblogger.Debugf("ExtractVMSpecInfo : Region:[%s] / SpecName:[%s]", Region, *instanceTypeInfo.InstanceType)
        //spew.Dump(instanceTypeInfo)

        vCpuInfo := irs.VCpuInfo{}
        gpuInfoList := []irs.GpuInfo{}

        //         .
        vmSpecInfo := irs.VMSpecInfo{
                Region: Region,
        }

        //VCPU   - Count
        if !reflect.ValueOf(instanceTypeInfo.VCpuInfo.DefaultVCpus).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Count = strconv.FormatInt(*instanceTypeInfo.VCpuInfo.DefaultVCpus, 10)
        }</span>

        //VCPU   - Clock
        <span class="cov0" title="0">if !reflect.ValueOf(instanceTypeInfo.ProcessorInfo.SustainedClockSpeedInGhz).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Clock = strconv.FormatFloat(*instanceTypeInfo.ProcessorInfo.SustainedClockSpeedInGhz, 'f', 1, 64)
        }</span>
        <span class="cov0" title="0">vmSpecInfo.VCpu = vCpuInfo

        //GPU    GPU 
        if !reflect.ValueOf(instanceTypeInfo.GpuInfo).IsNil() </span><span class="cov0" title="0">{
                for _, curGpu := range instanceTypeInfo.GpuInfo.Gpus </span><span class="cov0" title="0">{
                        cblogger.Debugf("[%s] Gpu   ", *curGpu.Name)
                        gpuInfo := ExtractGpuInfo(curGpu)
                        gpuInfoList = append(gpuInfoList, gpuInfo)
                }</span>
                //spew.Dump(gpuInfoList)
        }
        <span class="cov0" title="0">vmSpecInfo.Gpu = gpuInfoList

        if !reflect.ValueOf(instanceTypeInfo.InstanceType).IsNil() </span><span class="cov0" title="0">{
                vmSpecInfo.Name = *instanceTypeInfo.InstanceType
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(instanceTypeInfo.MemoryInfo.SizeInMiB).IsNil() </span><span class="cov0" title="0">{
                vmSpecInfo.Mem = strconv.FormatInt(*instanceTypeInfo.MemoryInfo.SizeInMiB, 10)
        }</span>

        //KeyValue  
        <span class="cov0" title="0">keyValueList, errKeyValue := ConvertKeyValueList(instanceTypeInfo)
        if errKeyValue != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%] KeyValue  ", *instanceTypeInfo.InstanceType)
                cblogger.Error(errKeyValue)
        }</span>
        /*
                if errKeyValue != nil {
                        return irs.VMSpecInfo{}, errKeyValue
                }
        */
        <span class="cov0" title="0">vmSpecInfo.KeyValueList = keyValueList

        return vmSpecInfo</span>
}

// Zone  ID  .
func (vmSpecHandler *AwsVmSpecHandler) ListVMSpecAZ(ZoneName string) (map[string]string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListVMSpecAZ(ZoneName:[%s])", ZoneName)
        if ZoneName == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return nil, errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">var mapVmSpecIds map[string]string
        mapVmSpecIds = make(map[string]string)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstanceTypeOfferings.html
        input := &amp;ec2.DescribeInstanceTypeOfferingsInput{
                //[]*string
                LocationType: aws.String("availability-zone"),
                Filters: []*ec2.Filter{
                        {
                                Name:   aws.String("location"),
                                Values: aws.StringSlice([]string{ZoneName}),
                        },
                },
                MaxResults: aws.Int64(1000), //5~1000
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "ListVMSpecAZ()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        pageNum := 0
        totCnt := 0
        err := vmSpecHandler.Client.DescribeInstanceTypeOfferingsPages(input,
                func(page *ec2.DescribeInstanceTypeOfferingsOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        pageNum++
                        //fmt.Println(page)
                        cblogger.Infof("PageNum : [%d] / Count : [%d] / lastPage : [%v]", pageNum, len(page.InstanceTypeOfferings), lastPage)
                        //totCnt = totCnt + len(page.InstanceTypeOfferings)

                        for _, specInfo := range page.InstanceTypeOfferings </span><span class="cov0" title="0">{
                                totCnt++
                                //cblogger.Infof("===&gt; [%s]", *specInfo.InstanceType)
                                mapVmSpecIds[*specInfo.InstanceType] = ""
                        }</span>
                        <span class="cov0" title="0">return !lastPage</span>
                })
        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("===&gt; Total Check AZ Spec Count : [%d]", totCnt)
        //spew.Dump(mapVmSpecIds)

        return mapVmSpecIds, nil</span>
}

func (vmSpecHandler *AwsVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListVMSpec(Region:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        cblogger.Infof("Request Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return nil, errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">mapVmSpecIds, errListVMSpecAZ := vmSpecHandler.ListVMSpecAZ(zoneId)
        if errListVMSpecAZ != nil </span><span class="cov0" title="0">{
                cblogger.Error(errListVMSpecAZ)
                return nil, errListVMSpecAZ
        }</span>

        <span class="cov0" title="0">var vMSpecInfoList []*irs.VMSpecInfo
        input := &amp;ec2.DescribeInstanceTypesInput{
                //MaxResults: aws.Int64(5),
        }

        /*
                req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
                err := req.Send()
                if err != nil { // resp is now filled
                        cblogger.Errorf("Unable to get ListVMSpec - %v", err)
                        return vMSpecInfoList, err
                }
        */

        //cblogger.Info(resp)
        //fmt.Println(resp)

        //ExtractVMSpecInfo(Region, resp.InstanceTypes[0])
        //var vMSpecInfoList []*irs.VMSpecInfo
        /*
                for _, curInstance := range resp.InstanceTypes {
                        cblogger.Infof("[%s] VM   ", *curInstance.InstanceType)

                        _, exists := mapVmSpecIds[*curInstance.InstanceType]
                        if !exists {
                                cblogger.Infof("[%s]  [%s] Zone   .", *curInstance.InstanceType, zoneId)
                                continue
                        }

                        //vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                        //vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)
                }
        */

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "ListVMSpec()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        pageNum := 0
        totCnt := 0
        err := vmSpecHandler.Client.DescribeInstanceTypesPages(input,
                func(page *ec2.DescribeInstanceTypesOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        pageNum++
                        //fmt.Println(page)
                        cblogger.Infof("PageNum : [%d] / Count : [%d] / isLastPage : [%v]", pageNum, len(page.InstanceTypes), lastPage)
                        //totCnt = totCnt + len(page.InstanceTypes)

                        for _, curInstance := range page.InstanceTypes </span><span class="cov0" title="0">{
                                totCnt++
                                //cblogger.Infof("[%d] [%s] VM   ", totCnt, *curInstance.InstanceType)

                                _, exists := mapVmSpecIds[*curInstance.InstanceType]
                                if !exists </span><span class="cov0" title="0">{
                                        cblogger.Debugf("[%s]  [%s] Zone  .", *curInstance.InstanceType, zoneId)
                                        continue</span>
                                }

                                <span class="cov0" title="0">vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                                vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)</span>
                        }

                        <span class="cov0" title="0">return !lastPage</span>
                })

        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return vMSpecInfoList, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        //spew.Dump(vMSpecInfoList)

        //cblogger.Infof("===&gt; Total Check Spec Count : [%d]", totCnt)
        cblogger.Infof("==&gt;[%s] AZ [%s] [%d]   [%d]    .", zoneId, Region, totCnt, len(vMSpecInfoList))

        return vMSpecInfoList, nil</span>
}

func (vmSpecHandler *AwsVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetVMSpec(Region:[%s], Name:[%s])", Region, Name)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstanceTypes.html
        input := &amp;ec2.DescribeInstanceTypesInput{
                //[]*string
                InstanceTypes: []*string{
                        aws.String(Name),
                },
        }

        //svc := ec2.New(&amp;sess)
        //svc := ec2.New(&amp;vmSpecHandler.Client, aws.NewConfig().WithRegion("us-west-2"))
        //req, resp := svc.DescribeInstanceTypesRequest(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypesRequest()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Example sending a request using the DescribeInstanceTypesRequest method.
        req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
        err := req.Send()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Info(resp)
        //fmt.Println(resp)
        if len(resp.InstanceTypes) &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMSpecInfo{}, errors.New(Name + "  Spec    .")
        }</span>

        <span class="cov0" title="0">vMSpecInfo := ExtractVMSpecInfo(Region, resp.InstanceTypes[0])

        /*
                //KeyValue  
                keyValueList, errKeyValue := ConvertKeyValueList(resp.InstanceTypes[0])
                if errKeyValue != nil {
                        return irs.VMSpecInfo{}, errKeyValue
                }
                vMSpecInfo.KeyValueList = keyValueList
        */

        return vMSpecInfo, nil</span>
}

// AWS     JSON  .
func (vmSpecHandler *AwsVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListOrgVMSpec(Region:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return "", errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">mapVmSpecIds, errListVMSpecAZ := vmSpecHandler.ListVMSpecAZ(zoneId)
        if errListVMSpecAZ != nil </span><span class="cov0" title="0">{
                cblogger.Error(errListVMSpecAZ)
                return "", errListVMSpecAZ
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.DescribeInstanceTypesInput{
                //MaxResults: aws.Int64(5),
        }

        /*
                req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
                err := req.Send()
                if err != nil { // resp is now filled
                        cblogger.Errorf("Unable to get ListOrgVMSpec - %v", err)
                        return "", err
                }
        */

        //cblogger.Info(resp)
        //fmt.Println(resp)

        //var resp *ec2.DescribeInstanceTypesOutput

        /*
                resp := *ec2.DescribeInstanceTypesOutput{
                        InstanceTypes: &amp;[]ec2.InstanceTypeInfo{{}},
                }
        */

        resp := new(ec2.DescribeInstanceTypesOutput)

        pageNum := 0
        totCnt := 0
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "ListOrgVMSpec()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        err := vmSpecHandler.Client.DescribeInstanceTypesPages(input,
                func(page *ec2.DescribeInstanceTypesOutput, lastPage bool) bool </span><span class="cov0" title="0">{
                        pageNum++
                        //fmt.Println(page)
                        cblogger.Infof("PageNum : [%d] / Count : [%d] / isLastPage : [%v]", pageNum, len(page.InstanceTypes), lastPage)
                        //totCnt = totCnt + len(page.InstanceTypes)

                        for _, curInstance := range page.InstanceTypes </span><span class="cov0" title="0">{
                                totCnt++
                                //cblogger.Infof("[%d] [%s] VM   ", totCnt, *curInstance.InstanceType)

                                _, exists := mapVmSpecIds[*curInstance.InstanceType]
                                if !exists </span><span class="cov0" title="0">{
                                        cblogger.Debugf("[%s]  [%s] Zone  .", *curInstance.InstanceType, zoneId)
                                        continue</span>
                                }

                                //vMSpecInfo := ExtractVMSpecInfo(Region, curInstance)
                                //vMSpecInfoList = append(vMSpecInfoList, &amp;vMSpecInfo)
                                <span class="cov0" title="0">resp.InstanceTypes = append(resp.InstanceTypes, curInstance)</span>
                        }

                        <span class="cov0" title="0">return !lastPage</span>
                })

        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        //spew.Dump(vMSpecInfoList)

        cblogger.Infof("==&gt;[%s] AZ [%s] [%d]   [%d]    .", zoneId, Region, totCnt, len(resp.InstanceTypes))

        //jsonString, errJson := ConvertJsonString(resp.InstanceTypes[0])
        jsonString, errJson := ConvertJsonString(resp)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}

// AWS     JSON  .
func (vmSpecHandler *AwsVmSpecHandler) ListOrgVMSpecOld(Region string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start ListOrgVMSpec(Region:[%s])", Region)

        input := &amp;ec2.DescribeInstanceTypesInput{
                //MaxResults: aws.Int64(5),
        }

        req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
        err := req.Send()
        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                cblogger.Errorf("Unable to get ListOrgVMSpec - %v", err)
                return "", err
        }</span>

        //cblogger.Info(resp)
        //fmt.Println(resp)

        //00, errJson := ConvertJsonString(resp.InstanceTypes[0])
        <span class="cov0" title="0">jsonString, errJson := ConvertJsonString(resp)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}

// AWS     JSON  .
func (vmSpecHandler *AwsVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Start GetOrgVMSpec(Region:[%s], Name:[%s])", Region, Name)

        input := &amp;ec2.DescribeInstanceTypesInput{
                InstanceTypes: []*string{
                        aws.String(Name),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypesRequest()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        req, resp := vmSpecHandler.Client.DescribeInstanceTypesRequest(input)
        err := req.Send()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{ // resp is now filled
                cblogger.Errorf("Unable to get GetVMSpec - %v", err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cblogger.Info(resp)
        //fmt.Println(resp)
        if len(resp.InstanceTypes) &lt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(Name + "  Spec    .")
        }</span>

        <span class="cov0" title="0">jsonString, errJson := ConvertJsonString(resp.InstanceTypes[0])
        //jsonString, errJson := ConvertJsonStringNoEscape(resp.InstanceTypes[0])

        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
        }</span>
        <span class="cov0" title="0">return jsonString, errJson</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr

package resources

import (
        "errors"
        "reflect"
        "strconv"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/service/ec2"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type AwsVPCHandler struct {
        Region idrv.RegionInfo
        Client *ec2.EC2
}

func (VPCHandler *AwsVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return irs.VPCInfo{}, errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.CreateVpcInput{
                CidrBlock: aws.String(vpcReqInfo.IPv4_CIDR),
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        retVpcInfo := ExtractVpcDescribeInfo(result.Vpc)
        retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId // NameId     .

        //IGW Name Tag 
        if SetNameTag(VPCHandler.Client, *result.Vpc.VpcId, vpcReqInfo.IId.NameId) </span><span class="cov0" title="0">{
                cblogger.Infof("VPC %s Name  ", vpcReqInfo.IId.NameId)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Errorf("VPC %s Name  ", vpcReqInfo.IId.NameId)
        }</span>

        //====================================
        // PublicIP   IGW  
        //====================================
        //IGW 
        <span class="cov0" title="0">resultIGW, errIGW := VPCHandler.Client.CreateInternetGateway(&amp;ec2.CreateInternetGatewayInput{})
        if errIGW != nil </span><span class="cov0" title="0">{
                if aerr, ok := errIGW.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGW.Error())
                }</span>
                <span class="cov0" title="0">return retVpcInfo, errIGW</span>
        }

        <span class="cov0" title="0">cblogger.Info(resultIGW)

        //IGW Name Tag 
        if SetNameTag(VPCHandler.Client, *resultIGW.InternetGateway.InternetGatewayId, vpcReqInfo.IId.NameId) </span><span class="cov0" title="0">{
                cblogger.Infof("IGW %s Name  ", vpcReqInfo.IId.NameId)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Errorf("IGW %s Name  ", vpcReqInfo.IId.NameId)
        }</span>

        // VPC IGW
        <span class="cov0" title="0">inputIGW := &amp;ec2.AttachInternetGatewayInput{
                InternetGatewayId: aws.String(*resultIGW.InternetGateway.InternetGatewayId),
                VpcId:             aws.String(retVpcInfo.IId.SystemId),
        }

        resultIGWAttach, errIGWAttach := VPCHandler.Client.AttachInternetGateway(inputIGW)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := errIGWAttach.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGWAttach.Error())
                }</span>
                <span class="cov0" title="0">return retVpcInfo, errIGWAttach</span>
        }

        <span class="cov0" title="0">cblogger.Info(resultIGWAttach)

        //  VPC    IGW   
        errRoute := VPCHandler.CreateRouteIGW(retVpcInfo.IId.SystemId, *resultIGW.InternetGateway.InternetGatewayId)
        if errRoute != nil </span><span class="cov0" title="0">{
                return retVpcInfo, errRoute
        }</span>

        //==========================
        // Subnet 
        //==========================
        //VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, vpcReqInfo.SubnetInfoList[0])
        <span class="cov0" title="0">var resSubnetList []irs.SubnetInfo
        for _, curSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet ", curSubnet.IId.NameId)
                cblogger.Infof("Reqt Subnet Info [%v]", curSubnet)
                resSubnet, errSubnet := VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, curSubnet)

                if errSubnet != nil </span><span class="cov0" title="0">{
                        return retVpcInfo, errSubnet
                }</span>
                <span class="cov0" title="0">resSubnetList = append(resSubnetList, resSubnet)</span>
        }
        <span class="cov0" title="0">retVpcInfo.SubnetInfoList = resSubnetList
        return retVpcInfo, nil</span>
}

//  VPC   IGW(Internet Gateway)    (AWS    [] Tab )
func (VPCHandler *AwsVPCHandler) CreateRouteIGW(vpcId string, igwId string) error <span class="cov0" title="0">{
        cblogger.Infof("VPC ID : [%s] / IGW ID : [%s]", vpcId, igwId)
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil </span><span class="cov0" title="0">{
                return errRoute
        }</span>

        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s] IGW[%s]  (0.0.0.0/0)   .", routeTableId, igwId)
        input := &amp;ec2.CreateRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                GatewayId:            aws.String(igwId),
                RouteTableId:         aws.String(routeTableId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: igwId,
                CloudOSAPI:   "CreateRoute()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateRoute(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("RouteTable[%s] IGW[%s]  (0.0.0.0/0)   ", routeTableId, igwId)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return err</span>
        }
        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s] IGW[%s]  (0.0.0.0/0)   ", routeTableId, igwId)
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return nil</span>
}

//https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Route_Tables.html
//https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html
//   VPC     
func (VPCHandler *AwsVPCHandler) GetDefaultRouteTable(vpcId string) (string, error) <span class="cov0" title="0">{
        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &gt; 0 </span><span class="cov0" title="0">{
                routeTableId := *result.RouteTables[0].RouteTableId
                cblogger.Infof("  ID  : [%s]", routeTableId)
                return routeTableId, nil
        }</span> else<span class="cov0" title="0"> {
                return "", errors.New("VPC    ID   .")
        }</span>
}

func (VPCHandler *AwsVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Info(reqSubnetInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return irs.SubnetInfo{}, errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">if reqSubnetInfo.IId.SystemId != "" </span><span class="cov0" title="0">{
                vpcInfo, errVpcInfo := VPCHandler.GetSubnet(reqSubnetInfo.IId.SystemId)
                if errVpcInfo == nil </span><span class="cov0" title="0">{
                        cblogger.Errorf(" [%S] Subnet         .", reqSubnetInfo.IId.SystemId)
                        cblogger.Info(vpcInfo)
                        return vpcInfo, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + reqSubnetInfo.IId.SystemId + "' already exists.")
                }</span>
        }

        // 
        <span class="cov0" title="0">input := &amp;ec2.CreateSubnetInput{
                CidrBlock: aws.String(reqSubnetInfo.IPv4_CIDR),
                VpcId:     aws.String(vpcId),
                //AvailabilityZoneId: aws.String(zoneId),        //use1-az1, use1-az2, use1-az3, use1-az4, use1-az5, use1-az6
                AvailabilityZone: aws.String(zoneId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        cblogger.Info(input)
        result, err := VPCHandler.Client.CreateSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)

        //vNetworkInfo := irs.VNetworkInfo{}
        vNetworkInfo := ExtractSubnetDescribeInfo(result.Subnet)

        //Subnet Name 
        if SetNameTag(VPCHandler.Client, *result.Subnet.SubnetId, reqSubnetInfo.IId.NameId) </span><span class="cov0" title="0">{
                cblogger.Infof("Subnet %s Name  ", reqSubnetInfo.IId.NameId)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Errorf("Subnet %s Name  ", reqSubnetInfo.IId.NameId)
        }</span>

        <span class="cov0" title="0">vNetworkInfo.IId.NameId = reqSubnetInfo.IId.NameId

        // VPC    Subnet   .
        errSubnetRoute := VPCHandler.AssociateRouteTable(vpcId, vNetworkInfo.IId.SystemId)
        if errSubnetRoute != nil </span>{<span class="cov0" title="0">
        }</span> else<span class="cov0" title="0"> {
                return vNetworkInfo, errSubnetRoute
        }</span>

        <span class="cov0" title="0">return vNetworkInfo, nil</span>
}

// VPC    Subnet  .
func (VPCHandler *AwsVPCHandler) AssociateRouteTable(vpcId string, subnetId string) error <span class="cov0" title="0">{
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil </span><span class="cov0" title="0">{
                return errRoute
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.AssociateRouteTableInput{
                RouteTableId: aws.String(routeTableId),
                SubnetId:     aws.String(subnetId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetId,
                CloudOSAPI:   "AssociateRouteTable()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.AssociateRouteTable(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return err</span>
        }

        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)
        return nil</span>
}

func (VPCHandler *AwsVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(&amp;ec2.DescribeVpcsInput{})
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vNetworkInfoList []*irs.VPCInfo
        for _, curVpc := range result.Vpcs </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] VPC  ", *curVpc.VpcId)
                vNetworkInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: *curVpc.VpcId})
                if vpcErr != nil </span><span class="cov0" title="0">{
                        return nil, vpcErr
                }</span>
                <span class="cov0" title="0">vNetworkInfoList = append(vNetworkInfoList, &amp;vNetworkInfo)</span>
        }

        <span class="cov0" title="0">spew.Dump(vNetworkInfoList)
        return vNetworkInfoList, nil</span>
}

func (VPCHandler *AwsVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        input := &amp;ec2.DescribeVpcsInput{
                VpcIds: []*string{
                        aws.String(vpcIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        //spew.Dump(result)

        if reflect.ValueOf(result.Vpcs).IsNil() </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, nil
        }</span>

        <span class="cov0" title="0">var errSubnet error
        awsVpcInfo := ExtractVpcDescribeInfo(result.Vpcs[0])
        awsVpcInfo.SubnetInfoList, errSubnet = VPCHandler.ListSubnet(vpcIID.SystemId)
        if errSubnet != nil </span><span class="cov0" title="0">{
                return awsVpcInfo, errSubnet
        }</span>

        <span class="cov0" title="0">return awsVpcInfo, nil</span>
}

/*
type VPCInfo struct {
        IId   IID       // {NameId, SystemId}
        IPv4_CIDR string
        SubnetInfoList []SubnetInfo

        KeyValueList []KeyValue
}
*/
//VPC  
func ExtractVpcDescribeInfo(vpcInfo *ec2.Vpc) irs.VPCInfo <span class="cov0" title="0">{
        awsVpcInfo := irs.VPCInfo{
                IId:       irs.IID{SystemId: *vpcInfo.VpcId},
                IPv4_CIDR: *vpcInfo.CidrBlock,
                //IsDefault: *vpcInfo.IsDefault,
                //State:     *vpcInfo.State,
        }

        //Name Tag "Name"  
        //NameId   .
        /*
                cblogger.Debug("Name Tag ")
                for _, t := range vpcInfo.Tags {
                        if *t.Key == "Name" {
                                awsVpcInfo.IId.NameId = *t.Value
                                cblogger.Debug("VPC Name : ", awsVpcInfo.IId.NameId)
                                break
                        }
                }
        */
        return awsVpcInfo
}</span>

func (VPCHandler *AwsVPCHandler) DeleteSubnet(subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        input := &amp;ec2.DeleteSubnetInput{
                SubnetId: aws.String(subnetIID.SystemId),
        }
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "DeleteSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        _, err := VPCHandler.Client.DeleteSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        cblogger.Info(err)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return false, err</span>
        }

        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        return true, nil</span>
}

func (VPCHandler *AwsVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                return false, errVpcInfo
        }</span>

        //=================
        // Subnet
        //=================
        <span class="cov0" title="0">for _, curSubnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet ", curSubnet.IId.SystemId)
                delSubnet, errSubnet := VPCHandler.DeleteSubnet(curSubnet.IId)
                if errSubnet != nil </span><span class="cov0" title="0">{
                        return false, errSubnet
                }</span>

                <span class="cov0" title="0">if delSubnet </span><span class="cov0" title="0">{
                        cblogger.Infof("  ==&gt; [%s] Subnet ", curSubnet.IId.SystemId)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Errorf("  ==&gt; [%s] Subnet ", curSubnet.IId.SystemId)
                        return false, errors.New("Subnet   VPC   .") //    
                }</span>
        }

        <span class="cov0" title="0">cblogger.Infof("[%s] VPC  .", vpcInfo.IId.SystemId)
        cblogger.Info("VPC    IGW / Route  ")

        //    IGW   .
        errRoute := VPCHandler.DeleteRouteIGW(vpcInfo.IId.SystemId)
        if errRoute != nil </span><span class="cov0" title="0">{
                cblogger.Error("   0.0.0.0/0 IGW   ")
                cblogger.Error(errRoute)
                if "InvalidRoute.NotFound" == errRoute.Error() </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s] #255      .", errRoute)
                }</span> else<span class="cov0" title="0"> {
                        return false, errRoute
                }</span>
                //} else {
                //        cblogger.Info("   0.0.0.0/0 IGW   ")
        }

        //VPC   IGW . (VPC   IGW )
        <span class="cov0" title="0">errIgw := VPCHandler.DeleteAllIGW(vpcInfo.IId.SystemId)
        if errIgw != nil </span><span class="cov0" title="0">{
                cblogger.Error(" IGW   : ", errIgw)
        }</span> else<span class="cov0" title="0"> {
                cblogger.Info(" IGW  ")
        }</span>

        <span class="cov0" title="0">input := &amp;ec2.DeleteVpcInput{
                VpcId: aws.String(vpcInfo.IId.SystemId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcInfo.IId.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DeleteVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return false, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return true, nil</span>
}

/*
// VPC  0.0.0.0/0   .
func (VPCHandler *AwsVPCHandler) DeleteRouteIGWOld(vpcId string) error {
        cblogger.Infof("VPC ID : [%s]", vpcId)
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil {
                return errRoute
        }

        cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)  .", routeTableId)
        input := &amp;ec2.DeleteRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                RouteTableId:         aws.String(routeTableId),
        }
        cblogger.Info(input)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteRoute.html
        result, err := VPCHandler.Client.DeleteRoute(input)
        if err != nil {
                cblogger.Errorf("RouteTable[%s]  (0.0.0.0/0)   ", routeTableId)
                if aerr, ok := err.(awserr.Error); ok {
                        //InvalidRoute.NotFound
                        cblogger.Errorf("Error Code : [%s] - Error:[%s] - Message:[%s]", aerr.Code(), aerr.Error(), aerr.Message())
                        switch aerr.Code() {
                        case "InvalidRoute.NotFound": //NotFound   (#255)
                                return errors.New(aerr.Code())
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }
        cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)   ", routeTableId)

        cblogger.Info(result)
        spew.Dump(result)
        cblogger.Info("   0.0.0.0/0 IGW   ")
        return nil
}
*/

// VPC  0.0.0.0/0   .
// #255       0.0.0.0    
func (VPCHandler *AwsVPCHandler) DeleteRouteIGW(vpcId string) error <span class="cov0" title="0">{
        cblogger.Infof("VPC ID : [%s]", vpcId)
        routeTableId := ""

        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &lt; 1 </span><span class="cov0" title="0">{
                return errors.New("VPC       .")
        }</span>

        <span class="cov0" title="0">routeTableId = *result.RouteTables[0].RouteTableId
        cblogger.Infof("  ID  : [%s]", routeTableId)

        cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)  .", routeTableId)

        //ec2.Route
        findIgw := false
        for _, curRoute := range result.RouteTables[0].Routes </span><span class="cov0" title="0">{
                cblogger.Infof("DestinationCidrBlock[%s] Check", *curRoute.DestinationCidrBlock)

                if "0.0.0.0/0" == *curRoute.DestinationCidrBlock </span><span class="cov0" title="0">{
                        cblogger.Infof("===&gt;RouteTable[%s]  (0.0.0.0/0)  !!", routeTableId)
                        findIgw = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !findIgw </span><span class="cov0" title="0">{
                cblogger.Infof("RouteTable[%s]  IGW (0.0.0.0/0)     . ", routeTableId)
                return nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)  .", routeTableId)
        inputDel := &amp;ec2.DeleteRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                RouteTableId:         aws.String(routeTableId),
        }
        cblogger.Info(inputDel)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteRoute.html
        resultDel, err := VPCHandler.Client.DeleteRoute(inputDel)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("RouteTable[%s]  (0.0.0.0/0)   ", routeTableId)
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        //InvalidRoute.NotFound
                        cblogger.Errorf("Error Code : [%s] - Error:[%s] - Message:[%s]", aerr.Code(), aerr.Error(), aerr.Message())
                        switch aerr.Code() </span>{
                        case "InvalidRoute.NotFound":<span class="cov0" title="0"> //NotFound   (#255)
                                return errors.New(aerr.Code())</span>
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)   ", routeTableId)

        cblogger.Info(resultDel)
        spew.Dump(resultDel)
        cblogger.Info("   0.0.0.0/0 IGW   ")
        return nil</span>
}

//VPC   IGW .
func (VPCHandler *AwsVPCHandler) DeleteAllIGW(vpcId string) error <span class="cov0" title="0">{
        input := &amp;ec2.DescribeInternetGatewaysInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("attachment.vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeInternetGateways(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)

        // VPC     IGW 
        // ,  .
        for _, curIgw := range result.InternetGateways </span><span class="cov0" title="0">{
                //IGW   IGW  .
                VPCHandler.DetachInternetGateway(vpcId, *curIgw.InternetGatewayId)
                //IGW 
                VPCHandler.DeleteIGW(*curIgw.InternetGatewayId)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// VPC  IGW  .
func (VPCHandler *AwsVPCHandler) DetachInternetGateway(vpcId string, igwId string) error <span class="cov0" title="0">{
        cblogger.Infof("VPC[%s]  IGW[%s]  .", vpcId, igwId)

        input := &amp;ec2.DetachInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
                VpcId:             aws.String(vpcId),
        }

        result, err := VPCHandler.Client.DetachInternetGateway(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)
        return nil</span>
}

// IGW  .
func (VPCHandler *AwsVPCHandler) DeleteIGW(igwId string) error <span class="cov0" title="0">{
        input := &amp;ec2.DeleteInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
        }

        result, err := VPCHandler.Client.DeleteInternetGateway(input)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">cblogger.Info(result)
        spew.Dump(result)
        return nil</span>
}

//VPC    .
func (VPCHandler *AwsVPCHandler) ListSubnet(vpcId string) ([]irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")
        var arrSubnetInfoList []irs.SubnetInfo

        input := &amp;ec2.DescribeSubnetsInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListSubnet",
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //spew.Dump(input)
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return nil, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        spew.Dump(result)
        for _, curSubnet := range result.Subnets </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet  ", *curSubnet.SubnetId)
                arrSubnetInfo := ExtractSubnetDescribeInfo(curSubnet)
                //arrSubnetInfo, errSubnet := VPCHandler.GetSubnet(*curSubnet.SubnetId)
                /*
                        if errSubnet != nil {
                                return nil, errSubnet
                        }
                */
                //arrSubnetInfoList = append(arrSubnetInfoList, arrSubnetInfo)
                arrSubnetInfoList = append(arrSubnetInfoList, arrSubnetInfo)
        }</span>

        <span class="cov0" title="0">spew.Dump(arrSubnetInfoList)
        return arrSubnetInfoList, nil</span>
}

func (VPCHandler *AwsVPCHandler) GetSubnet(reqSubnetId string) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("SubnetId : [%s]", reqSubnetId)

        input := &amp;ec2.DescribeSubnetsInput{
                SubnetIds: []*string{
                        aws.String(reqSubnetId),
                },
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetId,
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        default:<span class="cov0" title="0">
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }</span>
                <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err</span>
        }
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if !reflect.ValueOf(result.Subnets).IsNil() </span><span class="cov0" title="0">{
                retSubnetInfo := ExtractSubnetDescribeInfo(result.Subnets[0])
                return retSubnetInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.SubnetInfo{}, errors.New("InvalidSubnet.NotFound: The CBVnetwork '" + reqSubnetId + "' does not exist")
        }</span>
}

/*
    IId        IID
    IPv4_CIDR    string
        KeyValueList    []KeyValue
*/

//Subnet  
func ExtractSubnetDescribeInfo(subnetInfo *ec2.Subnet) irs.SubnetInfo <span class="cov0" title="0">{
        vNetworkInfo := irs.SubnetInfo{
                IId:       irs.IID{SystemId: *subnetInfo.SubnetId},
                IPv4_CIDR: *subnetInfo.CidrBlock,
                //Status:    *subnetInfo.State,
        }

        /*
                cblogger.Debug("Name Tag ")
                for _, t := range subnetInfo.Tags {
                        if *t.Key == "Name" {
                                vNetworkInfo.IId.NameId = *t.Value
                                cblogger.Debug("Subnet Name : ", vNetworkInfo.IId.NameId)
                                break
                        }
                }
        */

        keyValueList := []irs.KeyValue{
                {Key: "VpcId", Value: *subnetInfo.VpcId},
                {Key: "MapPublicIpOnLaunch", Value: strconv.FormatBool(*subnetInfo.MapPublicIpOnLaunch)},
                {Key: "AvailableIpAddressCount", Value: strconv.FormatInt(*subnetInfo.AvailableIpAddressCount, 10)},
                {Key: "AvailabilityZone", Value: *subnetInfo.AvailabilityZone},
                {Key: "Status", Value: *subnetInfo.State},
        }
        vNetworkInfo.KeyValueList = keyValueList

        return vNetworkInfo
}</span>

func (VPCHandler *AwsVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet  - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>
        <span class="cov0" title="0">cblogger.Info(resSubnet)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, errVpcInfo
        }</span>

        <span class="cov0" title="0">findSubnet := false
        cblogger.Debug("==============   =========")
        for posSubnet, curSubnetInfo := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Debugf("%d - [%s] Subnet  ", posSubnet, curSubnetInfo.IId.SystemId)
                if resSubnet.IId.SystemId == curSubnetInfo.IId.SystemId </span><span class="cov0" title="0">{
                        cblogger.Infof("   [%s] Subnet  . - SystemID:[%s]", subnetInfo.IId.NameId, curSubnetInfo.IId.SystemId)
                        //for ~ range     . for loop    vpcInfo    .
                        cblogger.Infof("  : %d", posSubnet)
                        //vpcInfo.SubnetInfoList[posSubnet].IId.NameId = "~"
                        vpcInfo.SubnetInfoList[posSubnet].IId.NameId = subnetInfo.IId.NameId
                        findSubnet = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !findSubnet </span><span class="cov0" title="0">{
                cblogger.Errorf("   VPC     [%s] [%s]  .", subnetInfo.IId.NameId, resSubnet.IId.SystemId)
                return irs.VPCInfo{}, errors.New("MismatchSubnet.NotFound: No SysmteId[" + resSubnet.IId.SystemId + "] found for newly created Subnet[" + subnetInfo.IId.NameId + "].")
        }</span>
        //spew.Dump(vpcInfo)

        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (VPCHandler *AwsVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC [%s] Subnet ", vpcIID.SystemId, subnetIID.SystemId)

        return VPCHandler.DeleteSubnet(subnetIID)
        //return false, nil
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package azure

import (
        "context"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2020-10-01/resources"
        "github.com/Azure/go-autorest/autorest/azure/auth"
        "github.com/Azure/go-autorest/autorest/to"

        azcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/connect"
        azrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type AzureDriver struct{}

func (AzureDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "AZURE DRIVER Version 1.0"
}</span>

const (
        cspTimeout time.Duration = 6000
)

func (AzureDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

func (driver *AzureDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        // Initialize Logger
        azrs.InitLog()

        // Credentail  ResourceGroup     
        err := checkResourceGroup(connectionInfo.CredentialInfo, connectionInfo.RegionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">Ctx, VMClient, err := getVMClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, imageClient, err := getImageClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, publicIPClient, err := getPublicIPClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, sgClient, err := getSecurityGroupClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, vNicClient, err := getVNicClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, SubnetClient, err := getSubnetClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, VNetClient, err := getVNetworkClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, IPConfigClient, err := getIPConfigClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, VMImageClient, err := getVMImageClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, DiskClient, err := getDiskClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Ctx, VmSpecClient, err := getVmSpecClient(connectionInfo.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := azcon.AzureCloudConnection{
                CredentialInfo:      connectionInfo.CredentialInfo,
                Region:              connectionInfo.RegionInfo,
                Ctx:                 Ctx,
                VMClient:            VMClient,
                ImageClient:         imageClient,
                PublicIPClient:      publicIPClient,
                SecurityGroupClient: sgClient,
                VNetClient:          VNetClient,
                VNicClient:          vNicClient,
                IPConfigClient:      IPConfigClient,
                SubnetClient:        SubnetClient,
                VMImageClient:       VMImageClient,
                DiskClient:          DiskClient,
                VmSpecClient:        VmSpecClient,
        }
        return &amp;iConn, nil</span>
}

func checkResourceGroup(credential idrv.CredentialInfo, region idrv.RegionInfo) error <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">resourceClient := resources.NewGroupsClient(credential.SubscriptionId)
        resourceClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        rg, err := resourceClient.Get(ctx, region.ResourceGroup)

        //      
        if rg.ID == nil </span><span class="cov0" title="0">{
                rg, err = resourceClient.CreateOrUpdate(ctx, region.ResourceGroup,
                        resources.Group{
                                Name:     to.StringPtr(region.ResourceGroup),
                                Location: to.StringPtr(region.Region),
                        })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getVMClient(credential idrv.CredentialInfo) (context.Context, *compute.VirtualMachinesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vmClient := compute.NewVirtualMachinesClient(credential.SubscriptionId)
        vmClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vmClient, nil</span>
}

func getImageClient(credential idrv.CredentialInfo) (context.Context, *compute.ImagesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">imageClient := compute.NewImagesClient(credential.SubscriptionId)
        imageClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;imageClient, nil</span>
}

func getPublicIPClient(credential idrv.CredentialInfo) (context.Context, *network.PublicIPAddressesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">publicIPClient := network.NewPublicIPAddressesClient(credential.SubscriptionId)
        publicIPClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;publicIPClient, nil</span>
}

func getSecurityGroupClient(credential idrv.CredentialInfo) (context.Context, *network.SecurityGroupsClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">sgClient := network.NewSecurityGroupsClient(credential.SubscriptionId)
        sgClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;sgClient, nil</span>
}

func getVNetworkClient(credential idrv.CredentialInfo) (context.Context, *network.VirtualNetworksClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vNetClient := network.NewVirtualNetworksClient(credential.SubscriptionId)
        vNetClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vNetClient, nil</span>
}

func getVNicClient(credential idrv.CredentialInfo) (context.Context, *network.InterfacesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vNicClient := network.NewInterfacesClient(credential.SubscriptionId)
        vNicClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vNicClient, nil</span>
}

func getIPConfigClient(credential idrv.CredentialInfo) (context.Context, *network.InterfaceIPConfigurationsClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ipConfigClient := network.NewInterfaceIPConfigurationsClient(credential.SubscriptionId)
        ipConfigClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;ipConfigClient, nil</span>
}

func getSubnetClient(credential idrv.CredentialInfo) (context.Context, *network.SubnetsClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">subnetClient := network.NewSubnetsClient(credential.SubscriptionId)
        subnetClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;subnetClient, nil</span>
}

func getVMImageClient(credential idrv.CredentialInfo) (context.Context, *compute.VirtualMachineImagesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vmImageClient := compute.NewVirtualMachineImagesClient(credential.SubscriptionId)
        vmImageClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vmImageClient, nil</span>
}

func getDiskClient(credential idrv.CredentialInfo) (context.Context, *compute.DisksClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">diskClient := compute.NewDisksClient(credential.SubscriptionId)
        diskClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;diskClient, nil</span>
}

func getVmSpecClient(credential idrv.CredentialInfo) (context.Context, *compute.VirtualMachineSizesClient, error) <span class="cov0" title="0">{
        config := auth.NewClientCredentialsConfig(credential.ClientId, credential.ClientSecret, credential.TenantId)
        authorizer, err := config.Authorizer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">vmSpecClient := compute.NewVirtualMachineSizesClient(credential.SubscriptionId)
        vmSpecClient.Authorizer = authorizer
        ctx, _ := context.WithTimeout(context.Background(), cspTimeout*time.Second)

        return ctx, &amp;vmSpecClient, nil</span>
}

var CloudDriver AzureDriver
</pre>
		
		<pre class="file" id="file60" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package connect

import (
        "context"
        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        cblog "github.com/cloud-barista/cb-log"
        azrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/azure/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type AzureCloudConnection struct {
        CredentialInfo      idrv.CredentialInfo
        Region              idrv.RegionInfo
        Ctx                 context.Context
        VMClient            *compute.VirtualMachinesClient
        ImageClient         *compute.ImagesClient
        VMImageClient       *compute.VirtualMachineImagesClient
        PublicIPClient      *network.PublicIPAddressesClient
        SecurityGroupClient *network.SecurityGroupsClient
        VNetClient          *network.VirtualNetworksClient
        VNicClient          *network.InterfacesClient
        IPConfigClient      *network.InterfaceIPConfigurationsClient
        SubnetClient        *network.SubnetsClient
        DiskClient          *compute.DisksClient
        VmSpecClient        *compute.VirtualMachineSizesClient
}

func (cloudConn *AzureCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateImageHandler()!")
        imageHandler := azrs.AzureImageHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.ImageClient, cloudConn.VMImageClient}
        return &amp;imageHandler, nil
}</span>

/*func (cloudConn *AzureCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
        cblogger.Info("Azure Cloud Driver: called CreateVNetworkHandler()!")
        vNetHandler := azrs.AzureVPCHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNetClient, cloudConn.SubnetClient}
        return &amp;vNetHandler, nil
}*/

func (cloudConn *AzureCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := azrs.AzureVPCHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNetClient, cloudConn.SubnetClient}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateSecurityHandler()!")
        sgHandler := azrs.AzureSecurityHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.SecurityGroupClient}
        return &amp;sgHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := azrs.AzureKeyPairHandler{cloudConn.CredentialInfo, cloudConn.Region}
        return &amp;keypairHandler, nil
}</span>

/*func (cloudConn *AzureCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Azure Cloud Driver: called CreateVNicHandler()!")
        vNicHandler := azrs.AzureVNicHandler{cloudConn.CredentialInfo, cloudConn.Region, cloudConn.Ctx, cloudConn.VNicClient, cloudConn.SubnetClient}
        return &amp;vNicHandler, nil
}*/

/*func (cloudConn *AzureCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Azure Cloud Driver: called CreatePublicIPHandler()!")
        publicIPHandler := azrs.AzurePublicIPHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.PublicIPClient, cloudConn.IPConfigClient}
        return &amp;publicIPHandler, nil
}*/

func (cloudConn *AzureCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateVMHandler()!")
        vmHandler := azrs.AzureVMHandler{
                CredentialInfo: cloudConn.CredentialInfo,
                Region:         cloudConn.Region,
                Ctx:            cloudConn.Ctx,
                Client:         cloudConn.VMClient,
                SubnetClient:   cloudConn.SubnetClient,
                NicClient:      cloudConn.VNicClient,
                PublicIPClient: cloudConn.PublicIPClient,
                DiskClient:     cloudConn.DiskClient,
        }
        return &amp;vmHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Azure Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := azrs.AzureVmSpecHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VmSpecClient}
        return &amp;vmSpecHandler, nil
}</span>

func (cloudConn *AzureCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>

func (cloudConn *AzureCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package resources

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "sync"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
)

const (
        CBResourceGroupName  = "CB-GROUP"
        CBVirutalNetworkName = "CB-VNet"
        CBVnetDefaultCidr    = "130.0.0.0/16"
        CBVMUser             = "cb-user"
        // by powerkim, 2019.10.30
        CBKeyPairPath = "/cloud-driver-libs/.ssh-azure/"
)

var once sync.Once
var cblogger *logrus.Logger
var calllogger *logrus.Logger

func InitLog() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                // cblog is a global variable.
                cblogger = cblog.GetLogger("CB-SPIDER")
                calllogger = call.GetLogger("HISCALL")
        }</span>)
}

func LoggingError(hiscallInfo call.CLOUDLOGSCHEMA, err error) <span class="cov0" title="0">{
        cblogger.Error(err.Error())
        hiscallInfo.ErrorMSG = err.Error()
        calllogger.Info(call.String(hiscallInfo))
}</span>

func LoggingInfo(hiscallInfo call.CLOUDLOGSCHEMA, start time.Time) <span class="cov0" title="0">{
        hiscallInfo.ElapsedTime = call.Elapsed(start)
        calllogger.Info(call.String(hiscallInfo))
}</span>

func GetCallLogScheme(region idrv.RegionInfo, resourceType call.RES_TYPE, resourceName string, apiName string) call.CLOUDLOGSCHEMA <span class="cov0" title="0">{
        cblogger.Info(fmt.Sprintf("Call %s %s", call.AZURE, apiName))
        return call.CLOUDLOGSCHEMA{
                CloudOS:      call.AZURE,
                RegionZone:   region.Region,
                ResourceType: resourceType,
                ResourceName: resourceName,
                CloudOSAPI:   apiName,
        }
}</span>

//  CIDR  (CIDR C class  )
/*func CreateSubnetCIDR(subnetList []*irs.VPCHandler) (*string, error) {

        addressPrefix := "0.0.0.0/24"

        // CIDR C class  
        maxClassNum := 0
        for _, subnet := range subnetList {
                //addressArr := strings.Split(subnet.AddressPrefix, ".")
                addressArr := strings.Split(addressPrefix, ".")
                if curClassNum, err := strconv.Atoi(addressArr[2]); err != nil {
                        return nil, err
                } else {
                        if curClassNum &gt; maxClassNum {
                                maxClassNum = curClassNum
                        }
                }
        }

        if len(subnetList) == 0 {
                maxClassNum = 0
        } else {
                maxClassNum = maxClassNum + 1
        }

        //  CIDR 
        vNetIP := strings.Split(CBVnetDefaultCidr, "/")
        vNetIPClass := strings.Split(vNetIP[0], ".")
        subnetCIDR := fmt.Sprintf("%s.%s.%d.0/24", vNetIPClass[0], vNetIPClass[1], maxClassNum)
        return &amp;subnetCIDR, nil
}*/

// KeyPair   
func CreateHashString(credentialInfo idrv.CredentialInfo) (string, error) <span class="cov0" title="0">{
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + credentialInfo.TenantId + credentialInfo.SubscriptionId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}

// Public KeyPair  
func GetPublicKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"
        publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(publicKeyBytes), nil</span>
}

// Private KeyPair  
/*func GetPrivateKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) {
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil {
                return "", err
        }

        privateKeyPath := keyPairPath + hashString + "--" + keyPairName + ".ppk"
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil {
                return "", err
        }
        return string(privateKeyBytes), nil
}*/

func GetVNicIdByName(credentialInfo idrv.CredentialInfo, regionInfo idrv.RegionInfo, vNicName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/networkInterfaces/%s", credentialInfo.SubscriptionId, regionInfo.ResourceGroup, vNicName)
}</span>

func GetPublicIPIdByName(credentialInfo idrv.CredentialInfo, regionInfo idrv.RegionInfo, publicIPName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/publicIPAddresses/%s", credentialInfo.SubscriptionId, regionInfo.ResourceGroup, publicIPName)
}</span>

func GetSecGroupIdByName(credentialInfo idrv.CredentialInfo, regionInfo idrv.RegionInfo, secGroupName string) string <span class="cov0" title="0">{
        //   "SecurityGroupIds": ["/subscriptions/cb592624-b77b-4a8f-bb13-0e5a48cae40f/resourceGroups/CB-GROUP/providers/Microsoft.Network/networkSecurityGroups/CB-SecGroup"],
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/networkSecurityGroups/%s", credentialInfo.SubscriptionId, regionInfo.ResourceGroup, secGroupName)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package resources

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Image = "IMAGE"
)

type AzureImageHandler struct {
        Region        idrv.RegionInfo
        Ctx           context.Context
        Client        *compute.ImagesClient
        VMImageClient *compute.VirtualMachineImagesClient
}

func (imageHandler *AzureImageHandler) setterImage(image compute.Image) *irs.ImageInfo <span class="cov0" title="0">{
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   *image.Name,
                        SystemId: *image.Name,
                },
                GuestOS:      fmt.Sprint(image.ImageProperties.StorageProfile.OsDisk.OsType),
                Status:       *image.ProvisioningState,
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: imageHandler.Region.ResourceGroup}},
        }

        return imageInfo
}</span>

func (imageHandler *AzureImageHandler) setterVMImage(image compute.VirtualMachineImage) *irs.ImageInfo <span class="cov0" title="0">{
        imageIdArr := strings.Split(*image.ID, "/")
        imageName := fmt.Sprintf("%s:%s:%s:%s", imageIdArr[8], imageIdArr[12], imageIdArr[14], imageIdArr[16])
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   imageName,
                        SystemId: imageName,
                },
                GuestOS:      fmt.Sprint(image.OsDiskImage.OperatingSystem),
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: imageHandler.Region.ResourceGroup}},
        }

        return imageInfo
}</span>

func (imageHandler *AzureImageHandler) setterVMImageforList(image compute.VirtualMachineImageResource) *irs.ImageInfo <span class="cov0" title="0">{
        imageIdArr := strings.Split(*image.ID, "/")
        imageName := fmt.Sprintf("%s:%s:%s:%s", imageIdArr[8], imageIdArr[12], imageIdArr[14], imageIdArr[16])
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   imageName,
                        SystemId: imageName,
                },
                //GuestOS:      fmt.Sprint(image.OsDiskImage.OperatingSystem),
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: imageHandler.Region.ResourceGroup}},
        }

        return imageInfo
}</span>

func (imageHandler *AzureImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{

        // @TODO: PublicIP     
        type ImageReqInfo struct {
                OSType string
                DiskId string
        }

        reqInfo := ImageReqInfo{
                //BlobUrl: "https://md-ds50xp550wh2.blob.core.windows.net/kt0lhznvgx2h/abcd?sv=2017-04-17&amp;sr=b&amp;si=b9674241-fb8e-4cb2-89c7-614d336dc3a7&amp;sig=uvbqvAZQITSpxas%2BWosG%2FGOf6e%2BIBmWNxlUmvARnxiM%3D",
                OSType: "Linux",
                DiskId: "/subscriptions/cb592624-b77b-4a8f-bb13-0e5a48cae40f/resourceGroups/INNO-PLATFORM1-RSRC-GRUP/providers/Microsoft.Compute/disks/inno-test-vm_OsDisk_1_61bf675b990f4aa381d7ee3d766974aa",
                // edited by powerkim for test, 2019.08.13
                //DiskId: "/subscriptions/f1548292-2be3-4acd-84a4-6df079160846/resourceGroups/CB-RESOURCE-GROUP/providers/Microsoft.Compute/disks/vm_name_OsDisk_1_2d63d9cd754c4094b1b1fb6a98c36b71",
        }

        // Check Image Exists
        image, err := imageHandler.Client.Get(imageHandler.Ctx, imageHandler.Region.ResourceGroup, imageReqInfo.IId.NameId, "")
        if image.ID != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("Image with name %s already exist", imageReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                return irs.ImageInfo{}, createErr
        }</span>

        <span class="cov0" title="0">createOpts := compute.Image{
                ImageProperties: &amp;compute.ImageProperties{
                        StorageProfile: &amp;compute.ImageStorageProfile{
                                OsDisk: &amp;compute.ImageOSDisk{
                                        //BlobURI: to.StringPtr(reqInfo.BlobUrl),
                                        ManagedDisk: &amp;compute.SubResource{
                                                ID: to.StringPtr(reqInfo.DiskId),
                                        },
                                        OsType: compute.OperatingSystemTypes(reqInfo.OSType),
                                },
                        },
                },
                Location: &amp;imageHandler.Region.Region,
        }

        future, err := imageHandler.Client.CreateOrUpdate(imageHandler.Ctx, imageHandler.Region.ResourceGroup, imageReqInfo.IId.NameId, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(imageHandler.Ctx, imageHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>

        //  Image  
        <span class="cov0" title="0">imageInfo, err := imageHandler.GetImage(imageReqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">return imageInfo, nil</span>
}

func (imageHandler *AzureImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Region, call.VMIMAGE, Image, "ListImage()")

        var imageList []*irs.ImageInfo

        publishers, err := imageHandler.VMImageClient.ListPublishers(context.TODO(), imageHandler.Region.Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">start := call.Start()

        var publisherWg sync.WaitGroup
        publisherWg.Add(len(*publishers.Value))

        for _, p := range *publishers.Value </span><span class="cov0" title="0">{
                go func(publisher compute.VirtualMachineImageResource) </span><span class="cov0" title="0">{
                        defer publisherWg.Done()
                        offers, err := imageHandler.VMImageClient.ListOffers(context.TODO(), imageHandler.Region.Region, *publisher.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">for _, offer := range *offers.Value </span><span class="cov0" title="0">{
                                skus, err := imageHandler.VMImageClient.ListSkus(context.TODO(), imageHandler.Region.Region, *publisher.Name, *offer.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">for _, sku := range *skus.Value </span><span class="cov0" title="0">{
                                        imageVersionList, err := imageHandler.VMImageClient.List(context.TODO(), imageHandler.Region.Region, *publisher.Name, *offer.Name, *sku.Name, "", nil, "")
                                        if err != nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if len(*imageVersionList.Value) == 0 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">for _, version := range *imageVersionList.Value </span><span class="cov0" title="0">{
                                                imageIdArr := strings.Split(*version.ID, "/")
                                                imageVersion := imageIdArr[len(imageIdArr)-1]
                                                vmImage, err := imageHandler.VMImageClient.Get(context.TODO(), imageHandler.Region.Region, *publisher.Name, *offer.Name, *sku.Name, imageVersion)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">vmImageInfo := imageHandler.setterVMImage(vmImage)
                                                imageList = append(imageList, vmImageInfo)</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">return</span>
                }(p)
        }

        <span class="cov0" title="0">publisherWg.Wait()
        LoggingInfo(hiscallInfo, start)
        return imageList, nil</span>
}

func (imageHandler *AzureImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Region, call.VMIMAGE, imageIID.NameId, "GetImage()")

        imageArr := strings.Split(imageIID.NameId, ":")

        //  URN  
        if len(imageArr) != 4 </span><span class="cov0" title="0">{
                formatErr := errors.New("invalid format for image ID, imageId=" + imageIID.NameId)
                LoggingError(hiscallInfo, formatErr)
                return irs.ImageInfo{}, formatErr
        }</span>

        //   publisher, offer, skus  version   (latest    )
        /*
                imageVersion := imageArr[3]
                if strings.EqualFold(imageVersion, "latest") {
                        vmImageList, err := imageHandler.VMImageClient.List(imageHandler.Ctx, imageHandler.Region.Region, imageArr[0], imageArr[1], imageArr[2], "", to.Int32Ptr(1), "name desc")
                        if err != nil {
                                LoggingError(hiscallInfo, err)
                                return irs.ImageInfo{}, err
                        }
                        if &amp;vmImageList == nil {
                                getErr := errors.New(fmt.Sprintf("could not found image with imageId %s", imageIID.NameId))
                                LoggingError(hiscallInfo, getErr)
                                return irs.ImageInfo{}, getErr
                        }
                        if vmImageList.Value == nil {
                                getErr := errors.New(fmt.Sprintf("could not found image with imageId %s", imageIID.NameId))
                                LoggingError(hiscallInfo, getErr)
                                return irs.ImageInfo{}, getErr
                        }
                        if len(*vmImageList.Value) == 0 {
                                getErr := errors.New(fmt.Sprintf("could not found image with imageId %s", imageIID.NameId))
                                LoggingError(hiscallInfo, getErr)
                                return irs.ImageInfo{}, getErr
                        } else {
                                latestVmImage := (*vmImageList.Value)[0]
                                imageIdArr := strings.Split(*latestVmImage.ID, "/")
                                imageVersion = imageIdArr[len(imageIdArr)-1]
                        }
                }
        */

        // 1      
        <span class="cov0" title="0">start := call.Start()
        vmImage, err := imageHandler.VMImageClient.Get(imageHandler.Ctx, imageHandler.Region.Region, imageArr[0], imageArr[1], imageArr[2], imageArr[3])
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageInfo := imageHandler.setterVMImage(vmImage)
        return *imageInfo, nil</span>
}

func (imageHandler *AzureImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Region, call.VMIMAGE, imageIID.NameId, "DeleteImage()")

        start := call.Start()
        future, err := imageHandler.Client.Delete(imageHandler.Ctx, imageHandler.Region.ResourceGroup, imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(imageHandler.Ctx, imageHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package resources

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        KeyPair = "KEYPAIR"
)

type AzureKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
}

func (keyPairHandler *AzureKeyPairHandler) CheckKeyPairFolder(folderPath string) error <span class="cov0" title="0">{
        // Check KeyPair Folder Exists
        if _, err := os.Stat(folderPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.MkdirAll(folderPath, 0700); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, keyPairReqInfo.IId.NameId, "CreateKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">savePrivateFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId
        savePublicFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pub"
        bitSize := 4096

        // Check KeyPair Exists
        if _, err := os.Stat(savePrivateFileTo); err == nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("KeyPair with name %s already exist", keyPairReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                cblogger.Error(createErr.Error())
                hiscallInfo.ErrorMSG = createErr.Error()
                calllogger.Info(call.String(hiscallInfo))
                return irs.KeyPairInfo{}, createErr
        }</span>

        <span class="cov0" title="0">start := call.Start()

        //   RSA  () 
        privateKey, err := generatePrivateKey(bitSize)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  RSA PEM  
        <span class="cov0" title="0">privateKeyBytes := encodePrivateKeyToPEM(privateKey)

        // rsa.PublicKey  .pub     
        // "ssh-rsa ..." 
        publicKeyBytes, err := generatePublicKey(&amp;privateKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  private Key 
        <span class="cov0" title="0">err = writeKeyToFile(privateKeyBytes, savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  public Key 
        <span class="cov0" title="0">err = writeKeyToFile([]byte(publicKeyBytes), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairReqInfo.IId.NameId,
                        SystemId: keyPairReqInfo.IId.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keyPairInfo, nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, KeyPair, "ListKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var keyPairInfoList []*irs.KeyPairInfo

        start := call.Start()

        files, err := ioutil.ReadDir(keyPairPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), ".pub") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.Contains(f.Name(), hashString) </span><span class="cov0" title="0">{
                        fileNameArr := strings.Split(f.Name(), "--")
                        keypairInfo, err := keyPairHandler.GetKey(irs.IID{NameId: fileNameArr[1]})
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keyPairInfoList = append(keyPairInfoList, &amp;keypairInfo)</span>
                }
        }

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return keyPairInfoList, nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, keyIID.NameId, "GetKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)

        privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key   
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keypairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyIID.NameId,
                        SystemId: keyIID.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keypairInfo, nil</span>
}

func (keyPairHandler *AzureKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Region, call.VMKEYPAIR, keyIID.NameId, "DeleteKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key 
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

//   RSA  () 
func generatePrivateKey(bitSize int) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        // Private Key 
        privateKey, err := rsa.GenerateKey(rand.Reader, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Private Key 
        <span class="cov0" title="0">err = privateKey.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Private Key generated()")
        //fmt.Println(privateKey)
        return privateKey, nil</span>
}

//  RSA PEM  
func encodePrivateKeyToPEM(privateKey *rsa.PrivateKey) []byte <span class="cov0" title="0">{
        // Get ASN.1 DER format
        privDER := x509.MarshalPKCS1PrivateKey(privateKey)

        // pem.Block
        privBlock := pem.Block{
                Type:    "RSA PRIVATE KEY",
                Headers: nil,
                Bytes:   privDER,
        }

        // Private key in PEM format
        privatePEM := pem.EncodeToMemory(&amp;privBlock)
        fmt.Println("privateKey Rsa -&gt; Pem  ")
        //fmt.Println(privatePEM)
        return privatePEM
}</span>

// rsa.PublicKey  .pub     
// "ssh-rsa ..." 
func generatePublicKey(privatekey *rsa.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        publicRsaKey, err := ssh.NewPublicKey(privatekey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pubKeyBytes := ssh.MarshalAuthorizedKey(publicRsaKey)

        log.Println("Public key ")
        //fmt.Println(pubKeyBytes)
        return pubKeyBytes, nil</span>
}

//  Key 
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key : %s", saveFileTo)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package resources

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        ICMP          = "icmp"
        SecurityGroup = "SECURITYGROUP"
)

type AzureSecurityHandler struct {
        Region idrv.RegionInfo
        Ctx    context.Context
        Client *network.SecurityGroupsClient
}

func (securityHandler *AzureSecurityHandler) setterSec(securityGroup network.SecurityGroup) *irs.SecurityInfo <span class="cov0" title="0">{
        security := &amp;irs.SecurityInfo{
                IId: irs.IID{
                        NameId:   *securityGroup.Name,
                        SystemId: *securityGroup.ID,
                },
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: securityHandler.Region.ResourceGroup}},
        }

        var securityRuleArr []irs.SecurityRuleInfo
        for _, sgRule := range *securityGroup.SecurityRules </span><span class="cov0" title="0">{

                var fromPort string
                var toPort string

                if strings.Contains(*sgRule.SourcePortRange, "-") </span><span class="cov0" title="0">{
                        sourcePortArr := strings.Split(*sgRule.SourcePortRange, "-")
                        fromPort = sourcePortArr[0]
                        toPort = sourcePortArr[1]
                }</span> else<span class="cov0" title="0"> {
                        fromPort = *sgRule.SourcePortRange
                        toPort = *sgRule.DestinationPortRange
                }</span>

                <span class="cov0" title="0">ruleInfo := irs.SecurityRuleInfo{
                        IPProtocol: strings.ToLower(fmt.Sprint(sgRule.Protocol)),
                        Direction:  fmt.Sprint(sgRule.Direction),
                        CIDR:       *sgRule.SourceAddressPrefix,
                }

                if strings.ToLower(fmt.Sprint(sgRule.Protocol)) == ICMP </span><span class="cov0" title="0">{
                        ruleInfo.FromPort = "-1"
                        ruleInfo.ToPort = "-1"
                }</span> else<span class="cov0" title="0"> {
                        ruleInfo.FromPort = fromPort
                        ruleInfo.ToPort = toPort
                }</span>

                <span class="cov0" title="0">securityRuleArr = append(securityRuleArr, ruleInfo)</span>
        }
        <span class="cov0" title="0">security.SecurityRules = &amp;securityRuleArr

        return security</span>
}

func (securityHandler *AzureSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, securityReqInfo.IId.NameId, "CreateSecurity()")

        // Check SecurityGroup Exists
        security, _ := securityHandler.Client.Get(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityReqInfo.IId.NameId, "")
        if security.ID != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Security Group with name %s already exist", securityReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.SecurityInfo{}, createErr
        }</span>

        <span class="cov0" title="0">var sgRuleList []network.SecurityRule
        var priorityNum int32
        for idx, rule := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                priorityNum = int32(300 + idx*100)
                sgRuleInfo := network.SecurityRule{
                        Name: to.StringPtr(fmt.Sprintf("%s-rules-%d", securityReqInfo.IId.NameId, idx+1)),
                        SecurityRulePropertiesFormat: &amp;network.SecurityRulePropertiesFormat{
                                SourceAddressPrefix:      &amp;rule.CIDR,
                                DestinationAddressPrefix: to.StringPtr("*"),
                                DestinationPortRange:     to.StringPtr("*"),
                                Protocol:                 network.SecurityRuleProtocol(strings.ToUpper(rule.IPProtocol)),
                                Access:                   network.SecurityRuleAccess("Allow"),
                                Priority:                 to.Int32Ptr(priorityNum),
                                Direction:                network.SecurityRuleDirection(rule.Direction),
                        },
                }

                if strings.ToLower(rule.IPProtocol) == ICMP || (rule.FromPort == "*" &amp;&amp; rule.ToPort == "*") </span><span class="cov0" title="0">{
                        sgRuleInfo.SourcePortRange = to.StringPtr("*")
                }</span> else<span class="cov0" title="0"> if rule.FromPort == rule.ToPort </span><span class="cov0" title="0">{
                        sgRuleInfo.SourcePortRange = to.StringPtr(rule.FromPort)
                }</span> else<span class="cov0" title="0"> {
                        sgRuleInfo.SourcePortRange = to.StringPtr(rule.FromPort + "-" + rule.ToPort)
                }</span>

                <span class="cov0" title="0">sgRuleList = append(sgRuleList, sgRuleInfo)</span>
        }

        <span class="cov0" title="0">createOpts := network.SecurityGroup{
                SecurityGroupPropertiesFormat: &amp;network.SecurityGroupPropertiesFormat{
                        SecurityRules: &amp;sgRuleList,
                },
                Location: &amp;securityHandler.Region.Region,
        }

        start := call.Start()
        future, err := securityHandler.Client.CreateOrUpdate(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityReqInfo.IId.NameId, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(securityHandler.Ctx, securityHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>

        //  SecurityGroup  
        <span class="cov0" title="0">securityInfo, err := securityHandler.GetSecurity(securityReqInfo.IId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>

        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *AzureSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, SecurityGroup, "ListSecurity()")

        start := call.Start()
        result, err := securityHandler.Client.List(securityHandler.Ctx, securityHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var securityList []*irs.SecurityInfo
        for _, security := range result.Values() </span><span class="cov0" title="0">{
                securityInfo := securityHandler.setterSec(security)
                securityList = append(securityList, securityInfo)
        }</span>
        <span class="cov0" title="0">return securityList, nil</span>
}

func (securityHandler *AzureSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, securityIID.NameId, "GetSecurity()")

        start := call.Start()
        security, err := securityHandler.Client.Get(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityIID.NameId, "")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        securityInfo := securityHandler.setterSec(security)
        return *securityInfo, nil</span>
}

func (securityHandler *AzureSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Region, call.SECURITYGROUP, securityIID.NameId, "DeleteSecurity()")

        start := call.Start()
        future, err := securityHandler.Client.Delete(securityHandler.Ctx, securityHandler.Region.ResourceGroup, securityIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(securityHandler.Ctx, securityHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package resources

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        ProvisioningStateCode string = "ProvisioningState/succeeded"
        VM                           = "VM"
)

type AzureVMHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
        Ctx            context.Context
        Client         *compute.VirtualMachinesClient
        SubnetClient   *network.SubnetsClient
        NicClient      *network.InterfacesClient
        PublicIPClient *network.PublicIPAddressesClient
        DiskClient     *compute.DisksClient
}

func (vmHandler *AzureVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmReqInfo.IId.NameId, "StartVM()")

        // Check VM Exists
        vm, err := vmHandler.Client.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.IId.NameId, compute.InstanceViewTypesInstanceView)
        if vm.ID != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("virtualMachine with name %s already exist", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // Check login method (keypair, password)
        <span class="cov0" title="0">if vmReqInfo.VMUserPasswd != "" &amp;&amp; vmReqInfo.KeyPairIID.NameId != "" </span><span class="cov0" title="0">{
                createErr := errors.New("specify one login method, Password or Keypair")
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // TODO: nested flow 
        // PublicIP 
        <span class="cov0" title="0">publicIPIId, err := CreatePublicIP(vmHandler, vmReqInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        // TODO: nested flow 
        // VNic 
        <span class="cov0" title="0">vNicIId, err := CreateVNic(vmHandler, vmReqInfo, publicIPIId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">vmOpts := compute.VirtualMachine{
                Location: &amp;vmHandler.Region.Region,
                VirtualMachineProperties: &amp;compute.VirtualMachineProperties{
                        HardwareProfile: &amp;compute.HardwareProfile{
                                VMSize: compute.VirtualMachineSizeTypes(vmReqInfo.VMSpecName),
                        },
                        OsProfile: &amp;compute.OSProfile{
                                ComputerName:  &amp;vmReqInfo.IId.NameId,
                                AdminUsername: to.StringPtr(CBVMUser),
                        },
                        NetworkProfile: &amp;compute.NetworkProfile{
                                NetworkInterfaces: &amp;[]compute.NetworkInterfaceReference{
                                        {
                                                //ID: &amp;vmReqInfo.NetworkInterfaceId,
                                                ID: &amp;vNicIId.SystemId,
                                                NetworkInterfaceReferenceProperties: &amp;compute.NetworkInterfaceReferenceProperties{
                                                        Primary: to.BoolPtr(true),
                                                },
                                        },
                                },
                        },
                },
        }

        // Image 
        if strings.Contains(vmReqInfo.ImageIID.SystemId, ":") </span><span class="cov0" title="0">{
                imageArr := strings.Split(vmReqInfo.ImageIID.SystemId, ":")
                // URN    
                vmOpts.StorageProfile = &amp;compute.StorageProfile{
                        ImageReference: &amp;compute.ImageReference{
                                Publisher: &amp;imageArr[0],
                                Offer:     &amp;imageArr[1],
                                Sku:       &amp;imageArr[2],
                                Version:   &amp;imageArr[3],
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                //    
                vmOpts.StorageProfile = &amp;compute.StorageProfile{
                        ImageReference: &amp;compute.ImageReference{
                                ID: &amp;vmReqInfo.ImageIID.NameId,
                        },
                }
        }</span>

        // KeyPair 
        <span class="cov0" title="0">if vmReqInfo.KeyPairIID.NameId != "" </span><span class="cov0" title="0">{
                publicKey, err := GetPublicKey(vmHandler.CredentialInfo, vmReqInfo.KeyPairIID.NameId)
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VMInfo{}, err
                }</span>
                <span class="cov0" title="0">vmOpts.OsProfile.LinuxConfiguration = &amp;compute.LinuxConfiguration{
                        SSH: &amp;compute.SSHConfiguration{
                                PublicKeys: &amp;[]compute.SSHPublicKey{
                                        {
                                                Path:    to.StringPtr(fmt.Sprintf("/home/%s/.ssh/authorized_keys", CBVMUser)),
                                                KeyData: to.StringPtr(publicKey),
                                        },
                                },
                        },
                }</span>
        } else<span class="cov0" title="0"> {
                vmOpts.OsProfile.AdminPassword = to.StringPtr(vmReqInfo.VMUserPasswd)
        }</span>

        // VM   
        <span class="cov0" title="0">if vmReqInfo.KeyPairIID.NameId != "" </span><span class="cov0" title="0">{
                vmOpts.Tags = map[string]*string{
                        "keypair":  to.StringPtr(vmReqInfo.KeyPairIID.NameId),
                        "publicip": to.StringPtr(publicIPIId.NameId),
                }
        }</span>

        <span class="cov0" title="0">start := call.Start()
        future, err := vmHandler.Client.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.IId.NameId, vmOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">vm, err = vmHandler.Client.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.IId.NameId, compute.InstanceViewTypesInstanceView)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
        }</span>

        <span class="cov0" title="0">vmInfo := vmHandler.mappingServerInfo(vm)
        return vmInfo, nil</span>
}

func (vmHandler *AzureVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "SuspendVM()")

        start := call.Start()
        future, err := vmHandler.Client.PowerOff(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId, to.BoolPtr(false))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // Get VM Status
        <span class="cov0" title="0">vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return vmStatus, nil</span>
}

func (vmHandler *AzureVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "ResumeVM()")

        start := call.Start()
        future, err := vmHandler.Client.Start(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        //  
        return irs.Resuming, nil</span>
}

func (vmHandler *AzureVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "RebootVM()")

        start := call.Start()
        future, err := vmHandler.Client.Restart(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        //  
        return irs.Rebooting, nil</span>
}

func (vmHandler *AzureVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "TerminateVM()")

        // VM   OS Disk   
        // VM OSDisk  
        vmInfo, err := vmHandler.GetVM(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">osDiskName := vmInfo.VMBootDisk
        /* Detach may not be required for dynamic public IP mode. by powerkim. 2021.04.30.
        // TODO: nested flow 
        // VNic PublicIP 
        vNicDetachStatus, err := DetachVNic(vmHandler, vmInfo)
        if err != nil {
                LoggingError(hiscallInfo, err)
                return vNicDetachStatus, err
        }
        */

        // VM 
        start := call.Start()
        future, err := vmHandler.Client.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId, to.BoolPtr(false))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // TODO: nested flow 
        // VNic 
        <span class="cov0" title="0">vNicStatus, err := DeleteVNic(vmHandler, vmInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return vNicStatus, err
        }</span>

        // TODO: nested flow 
        // PublicIP 
        <span class="cov0" title="0">publicIPStatus, err := DeletePublicIP(vmHandler, vmInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return publicIPStatus, err
        }</span>

        // TODO: nested flow 
        // OS Disk 
        <span class="cov0" title="0">diskStatus, err := DeleteVMDisk(vmHandler, osDiskName)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return diskStatus, err
        }</span>

        //  
        <span class="cov0" title="0">return irs.NotExist, nil</span>
}

func (vmHandler *AzureVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, VM, "ListVMStatus()")

        start := call.Start()
        serverList, err := vmHandler.Client.List(vmHandler.Ctx, vmHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMStatusInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var vmStatusList []*irs.VMStatusInfo
        for _, s := range serverList.Values() </span><span class="cov0" title="0">{
                if s.InstanceView != nil </span><span class="cov0" title="0">{
                        statusStr := getVmStatus(*s.InstanceView)
                        status := irs.VMStatus(statusStr)
                        vmStatusInfo := irs.VMStatusInfo{
                                IId: irs.IID{
                                        NameId:   *s.Name,
                                        SystemId: *s.ID,
                                },
                                VmStatus: status,
                        }
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span> else<span class="cov0" title="0"> {
                        vmIdArr := strings.Split(*s.ID, "/")
                        vmName := vmIdArr[8]
                        status, _ := vmHandler.GetVMStatus(irs.IID{NameId: vmName, SystemId: *s.ID})
                        vmStatusInfo := irs.VMStatusInfo{
                                IId: irs.IID{
                                        NameId:   *s.Name,
                                        SystemId: *s.ID,
                                },
                                VmStatus: status,
                        }
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func (vmHandler *AzureVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "GetVMStatus()")

        start := call.Start()
        instanceView, err := vmHandler.Client.InstanceView(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Get powerState, provisioningState
        vmStatus := getVmStatus(instanceView)
        return irs.VMStatus(vmStatus), nil</span>
}

func (vmHandler *AzureVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, VM, "ListVM()")

        start := call.Start()
        serverList, err := vmHandler.Client.List(vmHandler.Ctx, vmHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var vmList []*irs.VMInfo
        for _, server := range serverList.Values() </span><span class="cov0" title="0">{
                vmInfo := vmHandler.mappingServerInfo(server)
                vmList = append(vmList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmList, nil</span>
}

func (vmHandler *AzureVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Region, call.VM, vmIID.NameId, "GetVM()")

        start := call.Start()
        vm, err := vmHandler.Client.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmIID.NameId, compute.InstanceViewTypesInstanceView)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfo := vmHandler.mappingServerInfo(vm)
        return vmInfo, nil</span>
}

func getVmStatus(instanceView compute.VirtualMachineInstanceView) irs.VMStatus <span class="cov0" title="0">{
        var powerState, provisioningState string

        for _, stat := range *instanceView.Statuses </span><span class="cov0" title="0">{
                statArr := strings.Split(*stat.Code, "/")

                if statArr[0] == "PowerState" </span><span class="cov0" title="0">{
                        powerState = strings.ToLower(statArr[1])
                }</span> else<span class="cov0" title="0"> if statArr[0] == "ProvisioningState" </span><span class="cov0" title="0">{
                        provisioningState = strings.ToLower(statArr[1])
                }</span>
        }

        <span class="cov0" title="0">if strings.EqualFold(provisioningState, "failed") </span><span class="cov0" title="0">{
                return irs.Failed
        }</span>

        // Set VM Status Info
        <span class="cov0" title="0">var resultStatus string
        switch powerState </span>{
        case "starting":<span class="cov0" title="0">
                resultStatus = "Creating"</span>
        case "running":<span class="cov0" title="0">
                resultStatus = "Running"</span>
        case "stopping":<span class="cov0" title="0">
                resultStatus = "Suspending"</span>
        case "stopped":<span class="cov0" title="0">
                resultStatus = "Suspended"</span>
        case "deleting":<span class="cov0" title="0">
                resultStatus = "Terminating"</span>
        default:<span class="cov0" title="0">
                resultStatus = "Failed"</span>
        }
        <span class="cov0" title="0">return irs.VMStatus(resultStatus)</span>
}

func (vmHandler *AzureVMHandler) mappingServerInfo(server compute.VirtualMachine) irs.VMInfo <span class="cov0" title="0">{

        // Get Default VM Info
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId:   *server.Name,
                        SystemId: *server.ID,
                },
                Region: irs.RegionInfo{
                        Region: *server.Location,
                },
                VMSpecName: string(server.VirtualMachineProperties.HardwareProfile.VMSize),
        }

        // Set VM Zone
        if server.Zones != nil </span><span class="cov0" title="0">{
                vmInfo.Region.Zone = (*server.Zones)[0]
        }</span>

        // Set VM Image Info
        <span class="cov0" title="0">if reflect.ValueOf(server.StorageProfile.ImageReference.ID).IsNil() </span><span class="cov0" title="0">{
                imageRef := server.VirtualMachineProperties.StorageProfile.ImageReference
                vmInfo.ImageIId.SystemId = *imageRef.Publisher + ":" + *imageRef.Offer + ":" + *imageRef.Sku + ":" + *imageRef.Version
                //vmInfo.ImageIId.SystemId = vmInfo.ImageIId.NameId
        }</span> else<span class="cov0" title="0"> {
                vmInfo.ImageIId.SystemId = *server.VirtualMachineProperties.StorageProfile.ImageReference.ID
                //vmInfo.ImageIId.SystemId = vmInfo.ImageIId.NameId
        }</span>

        // Get VNic ID
        <span class="cov0" title="0">niList := *server.NetworkProfile.NetworkInterfaces
        var VNicId string
        for _, ni := range niList </span><span class="cov0" title="0">{
                if ni.ID != nil </span><span class="cov0" title="0">{
                        VNicId = *ni.ID
                }</span>
        }

        // Get VNic
        <span class="cov0" title="0">nicIdArr := strings.Split(VNicId, "/")
        nicName := nicIdArr[len(nicIdArr)-1]
        vNic, _ := vmHandler.NicClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, nicName, "")
        vmInfo.NetworkInterface = nicName

        // Get SecurityGroup
        sgGroupIdArr := strings.Split(*vNic.NetworkSecurityGroup.ID, "/")
        sgGroupName := sgGroupIdArr[len(sgGroupIdArr)-1]
        vmInfo.SecurityGroupIIds = []irs.IID{
                {
                        NameId:   sgGroupName,
                        SystemId: *vNic.NetworkSecurityGroup.ID,
                },
        }

        // Get PrivateIP, PublicIpId
        for _, ip := range *vNic.IPConfigurations </span><span class="cov0" title="0">{
                if *ip.Primary </span><span class="cov0" title="0">{
                        // PrivateIP  
                        vmInfo.PrivateIP = *ip.PrivateIPAddress

                        // PublicIP    
                        if ip.PublicIPAddress != nil </span><span class="cov0" title="0">{
                                publicIPId := *ip.PublicIPAddress.ID
                                publicIPIdArr := strings.Split(publicIPId, "/")
                                publicIPName := publicIPIdArr[len(publicIPIdArr)-1]

                                publicIP, _ := vmHandler.PublicIPClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPName, "")
                                vmInfo.PublicIP = *publicIP.IPAddress
                        }</span>

                        // Get Subnet
                        <span class="cov0" title="0">subnetIdArr := strings.Split(*ip.InterfaceIPConfigurationPropertiesFormat.Subnet.ID, "/")
                        subnetName := subnetIdArr[len(subnetIdArr)-1]
                        vmInfo.SubnetIID = irs.IID{NameId: subnetName, SystemId: *ip.InterfaceIPConfigurationPropertiesFormat.Subnet.ID}

                        // Get VPC
                        vpcIdArr := subnetIdArr[:len(subnetIdArr)-2]
                        vpcName := vpcIdArr[len(vpcIdArr)-1]
                        vmInfo.VpcIID = irs.IID{NameId: vpcName, SystemId: strings.Join(vpcIdArr, "/")}</span>
                }
        }

        // Set GuestUser Id/Pwd
        <span class="cov0" title="0">if server.VirtualMachineProperties.OsProfile.AdminUsername != nil </span><span class="cov0" title="0">{
                vmInfo.VMUserId = *server.VirtualMachineProperties.OsProfile.AdminUsername
        }</span>
        <span class="cov0" title="0">if server.VirtualMachineProperties.OsProfile.AdminPassword != nil </span><span class="cov0" title="0">{
                vmInfo.VMUserPasswd = *server.VirtualMachineProperties.OsProfile.AdminPassword
        }</span>

        // Set BootDisk
        <span class="cov0" title="0">if server.VirtualMachineProperties.StorageProfile.OsDisk.Name != nil </span><span class="cov0" title="0">{
                vmInfo.VMBootDisk = *server.VirtualMachineProperties.StorageProfile.OsDisk.Name
        }</span>

        // Get StartTime
        <span class="cov0" title="0">if server.VirtualMachineProperties.InstanceView != nil </span><span class="cov0" title="0">{
                for _, status := range *server.VirtualMachineProperties.InstanceView.Statuses </span><span class="cov0" title="0">{
                        if strings.EqualFold(*status.Code, ProvisioningStateCode) </span><span class="cov0" title="0">{
                                vmInfo.StartTime = status.Time.Local()
                                break</span>
                        }
                }
        }

        // Get Keypair
        <span class="cov0" title="0">tagList := server.Tags
        for key, val := range tagList </span><span class="cov0" title="0">{
                if key == "keypair" </span><span class="cov0" title="0">{
                        vmInfo.KeyPairIId = irs.IID{NameId: *val, SystemId: *val}
                }</span>
                <span class="cov0" title="0">if key == "publicip" </span><span class="cov0" title="0">{
                        vmInfo.KeyValueList = []irs.KeyValue{
                                {Key: "publicip", Value: *val},
                        }
                }</span>
        }

        <span class="cov0" title="0">return vmInfo</span>
}

// VM   Public IP   (nested flow )
func CreatePublicIP(vmHandler *AzureVMHandler, vmReqInfo irs.VMReqInfo) (irs.IID, error) <span class="cov0" title="0">{

        // PublicIP  
        /*var publicIPName string
        uuid, err := uuid.NewUUID()
        if err != nil {
                createErr := errors.New(fmt.Sprintf("Failed to generate UUID, error=%s", err))
                return irs.IID{}, createErr
        }*/
        //publicIPName = fmt.Sprintf("%s-%s-PublicIP", vmReqInfo.IId.NameId, uuid)
        publicIPName := fmt.Sprintf("%s-PublicIP", vmReqInfo.IId.NameId)

        createOpts := network.PublicIPAddress{
                Name: to.StringPtr(publicIPName),
                Sku: &amp;network.PublicIPAddressSku{
                        Name: network.PublicIPAddressSkuName("Basic"),
                },
                PublicIPAddressPropertiesFormat: &amp;network.PublicIPAddressPropertiesFormat{
                        PublicIPAddressVersion: network.IPVersion("IPv4"),
                        //PublicIPAllocationMethod: network.IPAllocationMethod("Static"),
                        PublicIPAllocationMethod: network.IPAllocationMethod("Dynamic"),
                        IdleTimeoutInMinutes:     to.Int32Ptr(4),
                },
                Location: &amp;vmHandler.Region.Region,
        }

        future, err := vmHandler.PublicIPClient.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPName, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to create PublicIP, error=%s", err))
                return irs.IID{}, createErr
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.PublicIPClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to create PublicIP, error=%s", err))
                return irs.IID{}, createErr
        }</span>

        //  PublicIP  
        <span class="cov0" title="0">publicIPInfo, err := vmHandler.PublicIPClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPName, "")
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get PublicIP, error=%s", err))
                return irs.IID{}, getErr
        }</span>
        <span class="cov0" title="0">publicIPIId := irs.IID{NameId: *publicIPInfo.Name, SystemId: *publicIPInfo.ID}
        return publicIPIId, nil</span>
}

// VM   Public IP   (nested flow )
func DeletePublicIP(vmHandler *AzureVMHandler, vmInfo irs.VMInfo) (irs.VMStatus, error) <span class="cov0" title="0">{
        var publicIPId string
        for _, keyInfo := range vmInfo.KeyValueList </span><span class="cov0" title="0">{
                if keyInfo.Key == "publicip" </span><span class="cov0" title="0">{
                        publicIPId = keyInfo.Value
                        break</span>
                }
        }

        <span class="cov0" title="0">publicIPFuture, err := vmHandler.PublicIPClient.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, publicIPId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = publicIPFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.PublicIPClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">return irs.Terminating, nil</span>
}

// VM   VNic   (nested flow )
func CreateVNic(vmHandler *AzureVMHandler, vmReqInfo irs.VMReqInfo, publicIPIId irs.IID) (irs.IID, error) <span class="cov0" title="0">{

        // VNic  
        /*var VNicName string
        uuid, err := uuid.NewUUID()
        if err != nil {
                createErr := errors.New(fmt.Sprintf("Failed to generate UUID, error=%s", err))
                return irs.IID{}, createErr
        }*/
        //VNicName = fmt.Sprintf("%s-%s-VNic", vmReqInfo.IId.NameId, uuid)
        VNicName := fmt.Sprintf("%s-VNic", vmReqInfo.IId.NameId)

        //  Id  
        // Azure  VNic 1   
        secGroupId := GetSecGroupIdByName(vmHandler.CredentialInfo, vmHandler.Region, vmReqInfo.SecurityGroupIIDs[0].NameId)
        subnet, err := vmHandler.SubnetClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmReqInfo.VpcIID.NameId, vmReqInfo.SubnetIID.NameId, "")

        var ipConfigArr []network.InterfaceIPConfiguration
        ipConfig := network.InterfaceIPConfiguration{
                Name: to.StringPtr("ipConfig1"),
                InterfaceIPConfigurationPropertiesFormat: &amp;network.InterfaceIPConfigurationPropertiesFormat{
                        Subnet:                    &amp;subnet,
                        PrivateIPAllocationMethod: "Dynamic",
                        PublicIPAddress: &amp;network.PublicIPAddress{
                                ID: to.StringPtr(publicIPIId.SystemId),
                        },
                },
        }
        ipConfigArr = append(ipConfigArr, ipConfig)

        /*
         test VM is interfacingProperties
        */

        createOpts := network.Interface{
                InterfacePropertiesFormat: &amp;network.InterfacePropertiesFormat{
                        IPConfigurations: &amp;ipConfigArr,
                        NetworkSecurityGroup: &amp;network.SecurityGroup{
                                ID: to.StringPtr(secGroupId),
                        },
                },
                Location: &amp;vmHandler.Region.Region,
        }

        future, err := vmHandler.NicClient.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, VNicName, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                return irs.IID{}, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vmHandler.Ctx, vmHandler.NicClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                return irs.IID{}, err
        }</span>

        //  VNic  
        <span class="cov0" title="0">VNic, err := vmHandler.NicClient.Get(vmHandler.Ctx, vmHandler.Region.ResourceGroup, VNicName, "")
        if err != nil </span><span class="cov0" title="0">{
                return irs.IID{}, err
        }</span>
        <span class="cov0" title="0">VNicIId := irs.IID{NameId: *VNic.Name, SystemId: *VNic.ID}
        return VNicIId, nil</span>
}

// VNic   PublicIP  
func DetachVNic(vmHandler *AzureVMHandler, vmInfo irs.VMInfo) (irs.VMStatus, error) <span class="cov0" title="0">{
        var ipConfigArr []network.InterfaceIPConfiguration
        ipConfig := network.InterfaceIPConfiguration{
                Name: to.StringPtr("ipConfig1"),
                InterfaceIPConfigurationPropertiesFormat: &amp;network.InterfaceIPConfigurationPropertiesFormat{
                        Subnet: &amp;network.Subnet{
                                Name: to.StringPtr(vmInfo.SubnetIID.NameId),
                                ID:   to.StringPtr(vmInfo.SubnetIID.SystemId),
                        },
                        PrivateIPAllocationMethod: "Dynamic",
                        PublicIPAddress:           nil,
                },
        }
        ipConfigArr = append(ipConfigArr, ipConfig)

        detachOpts := network.Interface{
                InterfacePropertiesFormat: &amp;network.InterfacePropertiesFormat{
                        IPConfigurations: &amp;ipConfigArr,
                },
                Location: &amp;vmHandler.Region.Region,
        }

        nicDetachFuture, err := vmHandler.NicClient.CreateOrUpdate(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmInfo.NetworkInterface, detachOpts)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = nicDetachFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.NicClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return irs.Terminating, nil</span>
}

// VM   VNic   (nested flow )
func DeleteVNic(vmHandler *AzureVMHandler, vmInfo irs.VMInfo) (irs.VMStatus, error) <span class="cov0" title="0">{
        nicDeleteFuture, err := vmHandler.NicClient.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, vmInfo.NetworkInterface)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = nicDeleteFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.NicClient.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">return irs.Terminating, nil</span>
}

// VM   VM Disk   (nested flow )
func DeleteVMDisk(vmHandler *AzureVMHandler, osDiskName string) (irs.VMStatus, error) <span class="cov0" title="0">{
        diskFuture, err := vmHandler.DiskClient.Delete(vmHandler.Ctx, vmHandler.Region.ResourceGroup, osDiskName)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">err = diskFuture.WaitForCompletionRef(vmHandler.Ctx, vmHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">return irs.Terminating, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package resources

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-03-01/compute"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMSpec = "VMSPEC"
)

type AzureVmSpecHandler struct {
        Region idrv.RegionInfo
        Ctx    context.Context
        Client *compute.VirtualMachineSizesClient
}

func setterVmSpec(region string, vmSpec compute.VirtualMachineSize) *irs.VMSpecInfo <span class="cov0" title="0">{
        vmSpecInfo := &amp;irs.VMSpecInfo{
                Region:       region,
                Name:         *vmSpec.Name,
                VCpu:         irs.VCpuInfo{Count: strconv.FormatInt(int64(*vmSpec.NumberOfCores), 10)},
                Mem:          strconv.FormatInt(int64(*vmSpec.MemoryInMB), 10),
                Gpu:          nil,
                KeyValueList: nil,
        }
        return vmSpecInfo
}</span>

func (vmSpecHandler *AzureVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, VMSpec, "ListVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmSpecList := make([]*irs.VMSpecInfo, len(*result.Value))
        for i, spec := range *result.Value </span><span class="cov0" title="0">{
                vmSpecList[i] = setterVmSpec(Region, spec)
        }</span>
        <span class="cov0" title="0">return vmSpecList, nil</span>
}

func (vmSpecHandler *AzureVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, Name, "GetVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMSpecInfo{}, err
        }</span>

        <span class="cov0" title="0">for _, spec := range *result.Value </span><span class="cov0" title="0">{
                if Name == *spec.Name </span><span class="cov0" title="0">{
                        LoggingInfo(hiscallInfo, start)
                        vmSpecInfo := setterVmSpec(Region, spec)
                        return *vmSpecInfo, nil
                }</span>
        }

        <span class="cov0" title="0">getErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err))
        LoggingError(hiscallInfo, getErr)
        return irs.VMSpecInfo{}, getErr</span>
}

func (vmSpecHandler *AzureVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, VMSpec, "ListOrgVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var jsonResult struct {
                Result []compute.VirtualMachineSize `json:"list"`
        }
        jsonResult.Result = *result.Value
        jsonBytes, err := json.Marshal(jsonResult)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)
        return jsonString, nil</span>
}

func (vmSpecHandler *AzureVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Region, call.VMSPEC, Name, "GetOrgVMSpec()")

        start := call.Start()
        result, err := vmSpecHandler.Client.List(vmSpecHandler.Ctx, Region)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        for _, spec := range *result.Value </span><span class="cov0" title="0">{
                if Name == *spec.Name </span><span class="cov0" title="0">{
                        jsonBytes, err := json.Marshal(spec)
                        if err != nil </span><span class="cov0" title="0">{
                                getErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err))
                                LoggingError(hiscallInfo, getErr)
                                return "", err
                        }</span>

                        <span class="cov0" title="0">jsonString := string(jsonBytes)
                        return jsonString, nil</span>
                }
        }

        <span class="cov0" title="0">notFoundErr := errors.New("failed to get VM spec")
        LoggingError(hiscallInfo, notFoundErr)
        return "", notFoundErr</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package resources

import (
        "context"
        "errors"
        "fmt"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-02-01/network"
        "github.com/Azure/go-autorest/autorest/to"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VPC = "VPC"
)

type AzureVPCHandler struct {
        Region       idrv.RegionInfo
        Ctx          context.Context
        Client       *network.VirtualNetworksClient
        SubnetClient *network.SubnetsClient
}

func (vpcHandler *AzureVPCHandler) setterVPC(network network.VirtualNetwork) *irs.VPCInfo <span class="cov0" title="0">{
        vpcInfo := &amp;irs.VPCInfo{
                IId: irs.IID{
                        NameId:   *network.Name,
                        SystemId: *network.ID,
                },
                IPv4_CIDR:    (*network.AddressSpace.AddressPrefixes)[0],
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: vpcHandler.Region.ResourceGroup}},
        }

        subnetArr := make([]irs.SubnetInfo, len(*network.Subnets))
        for i, subnet := range *network.Subnets </span><span class="cov0" title="0">{
                subnetArr[i] = *vpcHandler.setterSubnet(subnet)
        }</span>
        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetArr

        return vpcInfo</span>
}

func (vpcHandler *AzureVPCHandler) setterSubnet(subnet network.Subnet) *irs.SubnetInfo <span class="cov0" title="0">{
        subnetInfo := &amp;irs.SubnetInfo{
                IId: irs.IID{
                        NameId:   *subnet.Name,
                        SystemId: *subnet.ID,
                },
                IPv4_CIDR:    *subnet.AddressPrefix,
                KeyValueList: []irs.KeyValue{{Key: "ResourceGroup", Value: vpcHandler.Region.ResourceGroup}},
        }
        return subnetInfo
}</span>

func (vpcHandler *AzureVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, VPC, "CreateVPC()")

        // Check VPC Exists
        vpc, _ := vpcHandler.Client.Get(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcReqInfo.IId.NameId, "")
        if vpc.ID != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("vpc with name %s already exist", vpcReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // Create VPC
        <span class="cov0" title="0">createOpts := network.VirtualNetwork{
                Name: to.StringPtr(vpcReqInfo.IId.NameId),
                VirtualNetworkPropertiesFormat: &amp;network.VirtualNetworkPropertiesFormat{
                        AddressSpace: &amp;network.AddressSpace{
                                AddressPrefixes: &amp;[]string{vpcReqInfo.IPv4_CIDR},
                        },
                },
                Location: &amp;vpcHandler.Region.Region,
        }

        start := call.Start()
        future, err := vpcHandler.Client.CreateOrUpdate(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcReqInfo.IId.NameId, createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Create Subnet
        var subnetCreateOpts network.Subnet
        for _, subnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                subnetCreateOpts = network.Subnet{
                        Name: to.StringPtr(subnet.IId.NameId),
                        SubnetPropertiesFormat: &amp;network.SubnetPropertiesFormat{
                                AddressPrefix: to.StringPtr(subnet.IPv4_CIDR),
                        },
                }
                future, err := vpcHandler.SubnetClient.CreateOrUpdate(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcReqInfo.IId.NameId, subnet.IId.NameId, subnetCreateOpts)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(fmt.Sprintf("failed to create subnet with name %s", subnet.IId.NameId))
                        continue</span>
                }
                <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(fmt.Sprintf("failed to create subnet with name %s", subnet.IId.NameId))
                        continue</span>
                }
        }

        //  VNetwork  
        <span class="cov0" title="0">vpcInfo, err := vpcHandler.GetVPC(irs.IID{NameId: vpcReqInfo.IId.NameId})
        if err != nil </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (vpcHandler *AzureVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, VPC, "ListVPC()")

        start := call.Start()
        vpcList, err := vpcHandler.Client.List(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfoList := make([]*irs.VPCInfo, len(vpcList.Values()))
        for i, vpc := range vpcList.Values() </span><span class="cov0" title="0">{
                vpcInfoList[i] = vpcHandler.setterVPC(vpc)
        }</span>
        <span class="cov0" title="0">return vpcInfoList, nil</span>
}

func (vpcHandler *AzureVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, vpcIID.NameId, "GetVPC()")

        start := call.Start()
        vpc, err := vpcHandler.Client.Get(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId, "")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(vpc)
        return *vpcInfo, nil</span>
}

func (vpcHandler *AzureVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, vpcIID.NameId, "DeleteVPC()")

        start := call.Start()
        future, err := vpcHandler.Client.Delete(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (vpcHandler *AzureVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Region, call.VPCSUBNET, subnetInfo.IId.NameId, "AddSubnet()")

        vpc, _ := vpcHandler.Client.Get(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId, "")
        if vpc.ID == nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("vpc with name %s not exist", vpcIID.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">subnetCreateOpts := network.Subnet{
                Name: to.StringPtr(subnetInfo.IId.NameId),
                SubnetPropertiesFormat: &amp;network.SubnetPropertiesFormat{
                        AddressPrefix: to.StringPtr(subnetInfo.IPv4_CIDR),
                },
        }
        future, err := vpcHandler.SubnetClient.CreateOrUpdate(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, *vpc.Name, subnetInfo.IId.NameId, subnetCreateOpts)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to create subnet with name %s", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to create subnet with name %s", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">result, err := vpcHandler.GetVPC(irs.IID{NameId: vpcIID.NameId})
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to create subnet with name %s", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (vpcHandler *AzureVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        future, err := vpcHandler.SubnetClient.Delete(vpcHandler.Ctx, vpcHandler.Region.ResourceGroup, vpcIID.NameId, subnetIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(vpcHandler.Ctx, vpcHandler.Client.Client)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package cloudit

import (
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        cicon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/connect"
        cirs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type ClouditDriver struct{}

func (ClouditDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "CLOUDIT DRIVER Version 1.0"
}</span>

func (ClouditDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = false
        drvCapabilityInfo.VPCHandler = false
        drvCapabilityInfo.SecurityHandler = false
        drvCapabilityInfo.KeyPairHandler = false
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true

        return drvCapabilityInfo
}</span>

func (driver *ClouditDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        // Initialize Logger
        cirs.InitLog()

        Client, err := getServiceClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := cicon.ClouditCloudConnection{
                CredentialInfo: connectionInfo.CredentialInfo,
                Client:         *Client,
        }

        return &amp;iConn, nil</span>
}

func getServiceClient(connInfo idrv.ConnectionInfo) (*client.RestClient, error) <span class="cov0" title="0">{
        restClient := client.RestClient{
                IdentityBase:   connInfo.CredentialInfo.IdentityEndpoint,
                ClouditVersion: "v4.0",
                TenantID:       connInfo.CredentialInfo.TenantId,
        }
        return &amp;restClient, nil
}</span>

var CloudDriver ClouditDriver
</pre>
		
		<pre class="file" id="file69" style="display: none">package client

import (
        "bytes"
        "encoding/json"
        "fmt"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
        "io"
        "io/ioutil"
        "net/http"
        "strings"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

// DefaultUserAgent is the default User-Agent string set in the request header.
const (
        DefaultUserAgent = "cloudit/1.0.0"
)

// ClouditEngine is type of cloud service in cloudit
type ClouditEngine string

const (
        IAM ClouditEngine = "iam"
        ACE ClouditEngine = "ace"
        DNA ClouditEngine = "dna"
)

// UserAgent represents a User-Agent header.
type UserAgent struct {
        // prepend is the slice of User-Agent strings to prepend to DefaultUserAgent.
        // All the strings to prepend are accumulated and prepended in the Join method.
        prepend []string
}

// Prepend prepends a user-defined string to the default User-Agent string. Users
// may pass in one or more strings to prepend.
func (ua *UserAgent) Prepend(s ...string) <span class="cov0" title="0">{
        ua.prepend = append(s, ua.prepend...)
}</span>

// Join concatenates all the user-defined User-Agend strings with the default
func (ua *UserAgent) Join() string <span class="cov0" title="0">{
        uaSlice := append(ua.prepend, DefaultUserAgent)
        return strings.Join(uaSlice, " ")
}</span>

type RestClient struct {
        // IdentityBase is the base URL used for a particular provider's identity
        // service - it will be used when issuing authenticatation requests. It
        // should point to the root resource of the identity service, not a specific
        // identity version.
        IdentityBase string

        // IdentityEndpoint is the identity endpoint. This may be a specific version
        // of the identity service. If this is the case, this endpoint is used rather
        // than querying versions first.
        IdentityEndpoint string

        // ClouditVersion
        ClouditVersion string

        // TenantId for Cloudit User
        TenantID string

        // TokenID is the ID of the most recently issued valid token.
        TokenID string

        // HTTPClient allows users to interject arbitrary http, https, or other transit behaviors.
        HTTPClient http.Client

        // UserAgent represents the User-Agent header in the HTTP request.
        UserAgent UserAgent

        // ReauthFunc is the function used to re-authenticate the user if the request
        // fails with a 401 HTTP response code. This a needed because there may be multiple
        // authentication functions for different Identity service versions.
        ReauthFunc func() error
}

// AuthenticatedHeaders returns a map of HTTP headers that are common for all
// authenticated service requests.
func (client *RestClient) AuthenticatedHeaders() map[string]string <span class="cov0" title="0">{
        if client.TokenID == "" </span><span class="cov0" title="0">{
                return map[string]string{}
        }</span>
        <span class="cov0" title="0">return map[string]string{"X-Auth-Token": client.TokenID}</span>
}

// RequestOpts customizes the behavior of the provider.Request() method.
type RequestOpts struct {
        // JSONBody, if provided, will be encoded as JSON and used as the body of the HTTP request. The
        // content type of the request will default to "application/json" unless overridden by MoreHeaders.
        // It's an error to specify both a JSONBody and a RawBody.
        JSONBody interface{}
        // RawBody contains an io.ReadSeeker that will be consumed by the request directly. No content-type
        // will be set unless one is provided explicitly by MoreHeaders.
        RawBody io.ReadSeeker

        // JSONResponse, if provided, will be populated with the contents of the response body parsed as
        // JSON.
        JSONResponse interface{}
        // OkCodes contains a list of numeric HTTP status codes that should be interpreted as success. If
        // the response has a different code, an error will be returned.
        OkCodes []int

        // MoreHeaders specifies additional HTTP headers to be provide on the request. If a header is
        // provided with a blank value (""), that header will be *omitted* instead: use this to suppress
        // the default Accept header or an inferred Content-Type, for example.
        MoreHeaders map[string]string
}

type Result struct {
        // Body is the payload of the HTTP response from the server. In most cases,
        // this will be the deserialized JSON structure.
        Body interface{}

        // Header contains the HTTP header structure from the original response.
        Header http.Header

        // Err is an error that occurred during the operation. It's deferred until
        // extraction to make it easier to chain the Extract call.
        Err error
}

func (opts *RequestOpts) setBody(body interface{}) <span class="cov0" title="0">{
        if v, ok := (body).(io.ReadSeeker); ok </span><span class="cov0" title="0">{
                opts.RawBody = v
        }</span> else<span class="cov0" title="0"> if body != nil </span><span class="cov0" title="0">{
                opts.JSONBody = body
        }</span>
}

// UnexpectedResponseCodeError is returned by the Request method when a response code other than
// those listed in OkCodes is encountered.
type UnexpectedResponseCodeError struct {
        URL      string
        Method   string
        Expected []int
        Actual   int
        Body     []byte
}

func (err *UnexpectedResponseCodeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Expected HTTP response code %v when accessing [%s %s], but got %d instead\n%s",
                err.Expected, err.Method, err.URL, err.Actual, err.Body,
        )
}</span>

var applicationJSON = "application/json"

// Request performs an HTTP request using the RestClient's current HTTPClient. An authentication
// header will automatically be provided.
func (client *RestClient) Request(method, url string, options RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        var body io.ReadSeeker
        var contentType *string

        // Derive the content body by either encoding an arbitrary object as JSON, or by taking a provided
        // io.ReadSeeker as-is. Default the content-type to application/json.
        if options.JSONBody != nil </span><span class="cov0" title="0">{
                if options.RawBody != nil </span><span class="cov0" title="0">{
                        cblogger.Error("Please provide only one of JSONBody or RawBody to cloudit.Request().")
                }</span>

                <span class="cov0" title="0">rendered, err := json.Marshal(options.JSONBody)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">body = bytes.NewReader(rendered)
                contentType = &amp;applicationJSON</span>
        }

        <span class="cov0" title="0">if options.RawBody != nil </span><span class="cov0" title="0">{
                body = options.RawBody
        }</span>

        // Construct the http.Request.
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Populate the request headers. Apply options.MoreHeaders last, to give the caller the chance to
        // modify or omit any header.
        <span class="cov0" title="0">if contentType != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", *contentType)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", applicationJSON)

        for k, v := range client.AuthenticatedHeaders() </span><span class="cov0" title="0">{
                req.Header.Add(k, v)
        }</span>

        // Set the User-Agent header
        <span class="cov0" title="0">req.Header.Set("User-Agent", client.UserAgent.Join())

        if options.MoreHeaders != nil </span><span class="cov0" title="0">{
                for k, v := range options.MoreHeaders </span><span class="cov0" title="0">{
                        if v != "" </span><span class="cov0" title="0">{
                                req.Header.Set(k, v)
                        }</span> else<span class="cov0" title="0"> {
                                req.Header.Del(k)
                        }</span>
                }
        }

        // Set connection parameter to close the connection immediately when we've got the response
        <span class="cov0" title="0">req.Close = true

        // Issue the request.
        resp, err := client.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                if client.ReauthFunc != nil </span><span class="cov0" title="0">{
                        err = client.ReauthFunc()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error trying to re-authenticate: %s", err)
                        }</span>
                        <span class="cov0" title="0">if options.RawBody != nil </span><span class="cov0" title="0">{
                                options.RawBody.Seek(0, 0)
                        }</span>
                        <span class="cov0" title="0">resp.Body.Close()
                        resp, err = client.Request(method, url, options)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Successfully re-authenticated, but got error executing request: %s", err)
                        }</span>

                        <span class="cov0" title="0">return resp, nil</span>
                }
        }

        // Allow default OkCodes if none explicitly set
        <span class="cov0" title="0">if options.OkCodes == nil </span><span class="cov0" title="0">{
                options.OkCodes = defaultOkCodes(method)
        }</span>

        // Validate the HTTP response status.
        <span class="cov0" title="0">var ok bool
        for _, code := range options.OkCodes </span><span class="cov0" title="0">{
                if resp.StatusCode == code </span><span class="cov0" title="0">{
                        ok = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                body, _ := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                return resp, &amp;UnexpectedResponseCodeError{
                        URL:      url,
                        Method:   method,
                        Expected: options.OkCodes,
                        Actual:   resp.StatusCode,
                        Body:     body,
                }
        }</span>

        // Parse the response body as JSON, if requested to do so.
        <span class="cov0" title="0">if options.JSONResponse != nil </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                if err := json.NewDecoder(resp.Body).Decode(options.JSONResponse); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

func defaultOkCodes(method string) []int <span class="cov0" title="0">{
        switch </span>{
        case method == "GET":<span class="cov0" title="0">
                return []int{200}</span>
        case method == "POST":<span class="cov0" title="0">
                return []int{201, 202}</span>
        case method == "PUT":<span class="cov0" title="0">
                return []int{201, 202}</span>
        case method == "PATCH":<span class="cov0" title="0">
                return []int{200, 204}</span>
        case method == "DELETE":<span class="cov0" title="0">
                return []int{202, 204}</span>
        }

        <span class="cov0" title="0">return []int{}</span>
}

func (client *RestClient) Get(url string, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>
        <span class="cov0" title="0">if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>
        <span class="cov0" title="0">return client.Request("GET", url, *opts)</span>
}

func (client *RestClient) Post(url string, body interface{}, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">opts.setBody(body)

        if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>

        <span class="cov0" title="0">return client.Request("POST", url, *opts)</span>
}

func (client *RestClient) Put(url string, body interface{}, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">opts.setBody(body)

        if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>

        <span class="cov0" title="0">return client.Request("PUT", url, *opts)</span>
}

func (client *RestClient) Patch(url string, JSONBody interface{}, JSONResponse *interface{}, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">if v, ok := (JSONBody).(io.ReadSeeker); ok </span><span class="cov0" title="0">{
                opts.RawBody = v
        }</span> else<span class="cov0" title="0"> if JSONBody != nil </span><span class="cov0" title="0">{
                opts.JSONBody = JSONBody
        }</span>

        <span class="cov0" title="0">if JSONResponse != nil </span><span class="cov0" title="0">{
                opts.JSONResponse = JSONResponse
        }</span>

        <span class="cov0" title="0">return client.Request("PATCH", url, *opts)</span>
}

func (client *RestClient) Delete(url string, opts *RequestOpts) (*http.Response, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RequestOpts{}
        }</span>

        <span class="cov0" title="0">return client.Request("DELETE", url, *opts)</span>
}

func (r Result) ExtractInto(to interface{}) error <span class="cov0" title="0">{
        if reader, ok := r.Body.(io.Reader); ok </span><span class="cov0" title="0">{
                if readCloser, ok := reader.(io.Closer); ok </span><span class="cov0" title="0">{
                        defer readCloser.Close()
                }</span>
                <span class="cov0" title="0">return json.NewDecoder(reader).Decode(to)</span>
        }

        <span class="cov0" title="0">b, err := json.Marshal(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(b, to)

        return err</span>
}

func (client *RestClient) CreateRequestBaseURL(engine ClouditEngine, parts ...string) string <span class="cov0" title="0">{
        engineName := fmt.Sprint(engine)
        baseURL := strings.Join([]string{client.IdentityBase, "cloudit", client.ClouditVersion, engineName, "v1.0", client.TenantID}, "/")
        customURI := strings.Join(parts, "/")
        return baseURL + "/" + customURI
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package image

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type ImageReqInfo struct {
        Name         string `json:"name" required:"true"`
        VolumeId     string `json:"volumeId" required:"true"`   //       
        SnapshotId   string `json:"snapshotId" required:"true"` //      
        Ownership    string `json:"ownership" required:"true"`  // TENANT, PRIVATE
        Format       string `json:"format" required:"true"`     // raw, vdi, vmdk, vpc, qcow2
        SourceType   string `json:"sourceType" required:"true"` // server, snapshot
        TemplateType string `json:"templateType" required:"true"`
        Size         int    `json:"size" required:"false"`
        PoolId       string `json:"poolId" required:"false"`
        Protection   int    `json:"protection" required:"false"`
}

type ImageInfo struct {
        ID            string
        TenantID      string
        ClusterID     string
        ClusterName   string
        Size          int
        RealSize      int
        RefCount      int
        Name          string
        CreatedAt     string
        Ownership     string //  ,  
        TemplateType  string
        State         string
        Protection    int
        OS            string
        Arch          string // Architecture
        Format        string
        Enabled       int
        Description   string
        PoolID        string
        PoolName      string
        SnapshotID    string
        Creator       string
        VolumeID      string
        Url           string
        Pause         int
        SourceType    string
        MinKvmVersion int
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]ImageInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var image []ImageInfo
        if err := result.ExtractInto(&amp;image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;image, nil</span>
}

func Get(restClient *client.RestClient, templateId string, requestOpts *client.RequestOpts) (*ImageInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates", templateId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var image ImageInfo
        if err := result.ExtractInto(&amp;image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;image, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*ImageInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var image ImageInfo
        if err := result.ExtractInto(&amp;image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;image, nil</span>
}

func Delete(restClient *client.RestClient, templateId string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "templates", templateId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package nic

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type VNicReqInfo struct {
        SubnetAddr string                             `json:"subnetAddr" required:"true"`
        VmId       string                             `json:"vmId" required:"true"`
        Type       string                             `json:"type" required:"true"`
        Secgroups  []securitygroup.SecurityGroupRules `json:"secgroups" required:"true"`
        IP         string                             `json:"ip" required:"true"`
}

type VmNicInfo struct {
        TenantId        string
        VmId            string
        Type            string
        Mac             string
        Dev             string
        Ip              string
        SubnetAddr      string
        Creator         string
        CreatedAt       string
        VmName          string
        NetworkName     string
        AdaptiveIp      string
        State           string
        Template        string
        SpecName        string
        CpuNum          string
        MemSize         string
        VolumeSize      string
        Qos             int
        SecGroups       []SecurityGroupInfo `json:"secgroupMapInfo"`
        AdaptiveMapInfo interface{}
}

type SecurityGroupInfo struct {
        Id         string `json:"secgroup_id"`
        Name       string
        TenantId   string `json:"tenant_id"`
        State      string
        Mac        string
        Protection int
}

func List(restClient *client.RestClient, serverId string, requestOpts *client.RequestOpts) (*[]VmNicInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var nic []VmNicInfo
        if err := result.ExtractInto(&amp;nic); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;nic, nil</span>
}

func Get(restClient *client.RestClient, serverId string, macAddr string, requestOpts *client.RequestOpts) (*VmNicInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics", macAddr)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var nic VmNicInfo
        if err := result.ExtractInto(&amp;nic); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;nic, nil</span>
}

func Create(restClient *client.RestClient, serverId string, requestOpts *client.RequestOpts) (*VmNicInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics")

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var nicInfo VmNicInfo
        if err := result.ExtractInto(&amp;nicInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov0" title="0"> {
                return &amp;nicInfo, nil
        }</span>

}
func Delete(restClient *client.RestClient, serverId string, macAddr string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nics", macAddr)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// updateNIC
func Put(restClient *client.RestClient, serverId string, requestOpts *client.RequestOpts, nicMac string) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", serverId, "nic", nicMac, "securitygroup")
        cblogger.Info(requestURL)

        var result client.Result
        _, _ = restClient.Put(requestURL, nil, &amp;result.Body, requestOpts)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package server

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type SecGroupInfo struct {
        Id string `json:"id" required:"true"`
}

type VMReqInfo struct {
        TemplateId   string         `json:"templateId" required:"true"`
        SpecId       string         `json:"specId" required:"true"`
        Name         string         `json:"name" required:"true"`
        HostName     string         `json:"hostName" required:"true"`
        RootPassword string         `json:"rootPassword" required:"true"`
        SubnetAddr   string         `json:"subnetAddr" required:"true"`
        Secgroups    []SecGroupInfo `json:"secgroups" required:"true"`
        Description  int            `json:"description" required:"false"`
        Protection   int            `json:"protection" required:"false"`
}

type ServerInfo struct {
        VolumeInfoList interface{}
        VmNicInfoList  interface{}
        NicMapInfo     []struct {
                Name    string
                Count   int
                Address string `json:"addr"`
        }
        PoolMapInfo []struct {
                Name       string
                Count      int
                PoolID     string `json:"pool_id"`
                FileSystem string
        }
        AdaptiveIpMapInfo []struct {
                IP        string
                Count     int
                PrivateIP string `json:"private_ip"`
        }
        ID                string
        TenantID          string
        CpuNum            float32
        MemSize           float32
        VncPort           int
        RepeaterPort      int
        State             string
        NodeIp            string
        NodeHostName      string
        Name              string
        Protection        int
        CreatedAt         string
        IsoId             string
        IsoPath           string
        Iso               string
        Template          string
        TemplateID        string
        OsType            string
        RootPassword      string
        HostName          string
        Creator           string
        VolumeId          string
        VolumeSize        int
        VolumeMode        string
        MacAddr           string
        Spec              string
        SpecId            string
        Pool              string
        PoolId            string
        Cycle             int
        Metric            int
        MigrationPort     int
        MigrationIp       string
        Cloudinit         bool
        DeleteVolume      bool
        ServerCount       int
        PrivateIp         string
        AdaptiveIp        string
        InitCloud         int
        ClusterId         string
        ClusterName       string
        NicType           string
        Secgroups         []securitygroup.SecurityGroupInfo
        Ip                string
        SubnetAddr        string
        DeviceId          string
        Gpu               string
        GpuCount          int
        GpuId             string
        Description       string
        DiskSize          int
        DiskCount         int
        IsoInsertedAt     string
        Puppet            int
        SshKeyName        string
        SshPublicKey      string
        TemplateOwnership string
        TemplateType      string
        VmStatInfo        string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]ServerInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var server []ServerInfo
        if err := result.ExtractInto(&amp;server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;server, nil</span>
}

func Get(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) (*ServerInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id)
        cblogger.Info(requestURL)

        var result client.Result
        _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts)

        var server ServerInfo
        if err := result.ExtractInto(&amp;server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;server, nil</span>
}

// create
func Start(restClient *client.RestClient, requestOpts *client.RequestOpts) (*ServerInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var server ServerInfo
        if err := result.ExtractInto(&amp;server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;server, nil</span>
}

//shutdown
func Suspend(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id, "shutdown")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, nil, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//start
func Resume(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id, "start")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, nil, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//reboot
func Reboot(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id, "reboot")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, nil, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//delete
func Terminate(restClient *client.RestClient, id string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "servers", id)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package specs

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type VMSpecInfo struct {
        Id      string `json:"id" required:"true"`
        Name    string `json:"name" required:"true"`
        Cpu     int    `json:"cpu" required:"true"`
        Mem     int    `json:"mem" required:"true"`
        Disk    int    `json:"disk" required:"true"`
        GPU     int    `json:"gpu" required:"true"`
        Enabled int    `json:"enabled" required:"true"`
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]VMSpecInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.ACE, "specs")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var spec []VMSpecInfo
        if err := result.ExtractInto(&amp;spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;spec, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package adaptiveip

import (
        //"fmt"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type PublicIPReqInfo struct {
        IP         string `json:"ip" required:"true"`
        Name       string `json:"name" required:"true"`
        PrivateIP  string `json:"privateIp" required:"true"` // PublicIP  VM Private IP
        Protection int    `json:"protection" required:"false"`
}

type IPInfo struct {
        IP      string `json:"addr"`
        gateway string
        prefix  string
        state   string
        netmask string
}

type AdaptiveIPInfo struct {
        ID          string
        IP          string
        Name        string
        Rules       interface{}
        TenantId    string
        Creator     string
        State       string
        CreatedAt   string
        PrivateIp   string
        Protection  int
        RuleCount   int
        VmName      string
        Description string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]AdaptiveIPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var adaptiveIP []AdaptiveIPInfo
        if err := result.ExtractInto(&amp;adaptiveIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;adaptiveIP, nil</span>
}

func ListAvailableIP(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]IPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "ips")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var availableIP []IPInfo
        if err := result.ExtractInto(&amp;availableIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;availableIP, nil</span>
}

func Get(restClient *client.RestClient, adaptiveIPId string, requestOpts *client.RequestOpts) (*AdaptiveIPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips", adaptiveIPId, "detail")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var adaptiveIP AdaptiveIPInfo
        if err := result.ExtractInto(&amp;adaptiveIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;adaptiveIP, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*AdaptiveIPInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips")
        cblogger.Info(requestURL)

        var result client.Result

        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var adaptiveIP AdaptiveIPInfo
        if err := result.ExtractInto(&amp;adaptiveIP); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;adaptiveIP, nil</span>
}

func Delete(restClient *client.RestClient, adaptiveIP string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "adaptive-ips", adaptiveIP)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package subnet

import (
        //"fmt"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type VNetworkReqInfo struct {
        Name       string `json:"name" required:"true"`
        Addr       string `json:"addr" required:"true"`
        Prefix     string `json:"prefix" required:"true"`
        Gateway    string `json:"gateway" required:"false"`
        Protection int    `json:"protection" required:"false"`
}

type SubnetInfo struct {
        ID          string
        TenantId    string
        Addr        string
        Prefix      string
        Gateway     string
        Creator     string
        Protection  int
        Name        string
        State       string
        Vlan        int
        CreatedAt   string
        NicCount    int
        Description string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet []SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func ListCreatableSubnet(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets", "creatable")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet []SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func Get(restClient *client.RestClient, subnetId string, requestOpts *client.RequestOpts) (*SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, subnetId, "detail")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*SubnetInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets")
        cblogger.Info(requestURL)

        var result client.Result

        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var subnet SubnetInfo
        if err := result.ExtractInto(&amp;subnet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subnet, nil</span>
}

func Delete(restClient *client.RestClient, addr string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.DNA, "subnets", addr)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package securitygroup

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type SecurityReqInfo struct {
        Name       string               `json:"name" required:"true"`
        Rules      []SecurityGroupRules `json:"rules" required:"false"`
        Protection int                  `json:"protection" required:"false"`
}

type SecurityGroupRules struct {
        ID         string `json:"id"`
        SecGroupID string `json:"secgroupId"`
        Name       string `json:"name"`
        Type       string `json:"type"`
        Port       string `json:"port"`
        Target     string `json:"target"`
        Protocol   string `json:"protocol"`
        Creator    string `json:"creator"`
        CreatedAt  string `json:"createdAt"`
}

type SecurityGroupInfo struct {
        ID          string
        Name        string
        TenantID    string
        Creator     string
        State       string
        CreatedAt   string
        Protection  int
        Rules       []SecurityGroupRules
        RulesCount  int
        Description string
        AsID        string
}

func List(restClient *client.RestClient, requestOpts *client.RequestOpts) (*[]SecurityGroupInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup []SecurityGroupInfo
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func ListRule(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) (*[]SecurityGroupRules, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var sgRules []SecurityGroupRules
        if err := result.ExtractInto(&amp;sgRules); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sgRules, nil</span>
}

func Get(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) (*SecurityGroupInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId, "detail")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup SecurityGroupInfo
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func Create(restClient *client.RestClient, requestOpts *client.RequestOpts) (*SecurityGroupInfo, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups")
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup SecurityGroupInfo
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func Delete(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ListRulesinSG(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts) (*[]SecurityGroupRules, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Get(requestURL, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup []SecurityGroupRules
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func AddRule(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts, rule string) (*SecurityGroupRules, error) <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId, rule)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Post(requestURL, nil, &amp;result.Body, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return nil, result.Err
        }</span>

        <span class="cov0" title="0">var securityGroup SecurityGroupRules
        if err := result.ExtractInto(&amp;securityGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;securityGroup, nil</span>
}

func DeleteRule(restClient *client.RestClient, securitygroupId string, requestOpts *client.RequestOpts, ruleID string) error <span class="cov0" title="0">{
        requestURL := restClient.CreateRequestBaseURL(client.IAM, "securitygroups", securitygroupId, ruleID)
        cblogger.Info(requestURL)

        var result client.Result
        if _, result.Err = restClient.Delete(requestURL, requestOpts); result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.com, 2019.08.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        cirs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type ClouditCloudConnection struct {
        CredentialInfo idrv.CredentialInfo
        Client         client.RestClient
}

func (cloudConn *ClouditCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateImageHandler()!")
        imageHandler := cirs.ClouditImageHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *ClouditCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateVNetworkHandler()!")
        vNetHandler := cirs.ClouditVPCHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;vNetHandler, nil
}</span>

func (cloudConn ClouditCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateSecurityHandler()!")
        securityHandler := cirs.ClouditSecurityHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;securityHandler, nil
}</span>

func (cloudConn *ClouditCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := cirs.ClouditKeyPairHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;keypairHandler, nil
}</span>

/*func (cloudConn ClouditCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Cloudit Cloud Driver: called CreateVNicHandler()!")
        vNicHandler := cirs.ClouditNicHandler{cloudConn.CredentialInfo, &amp;cloudConn.Client}
        return &amp;vNicHandler, nil
}*/

/*func (cloudConn ClouditCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Cloudit Cloud Driver: called CreatePublicIPHandler()!")
        publicIPHandler := cirs.ClouditPublicIPHandler{cloudConn.CredentialInfo, &amp;cloudConn.Client}
        return &amp;publicIPHandler, nil
}*/

func (cloudConn *ClouditCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateVMHandler()!")
        vmHandler := cirs.ClouditVMHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *ClouditCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Cloudit Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := cirs.ClouditVMSpecHandler{CredentialInfo: cloudConn.CredentialInfo, Client: &amp;cloudConn.Client}
        return &amp;vmSpecHandler, nil
}</span>

func (ClouditCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (ClouditCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package resources

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/bramvdbogaerde/go-scp"
        "github.com/bramvdbogaerde/go-scp/auth"
        cblog "github.com/cloud-barista/cb-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        "github.com/sirupsen/logrus"
        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/nic"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/specs"
)

const (
        CBVMUser      = "cb-user"
        CBKeyPairPath = "/cloud-driver-libs/.ssh-cloudit/"
)

var once sync.Once
var cblogger *logrus.Logger
var calllogger *logrus.Logger

func InitLog() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                // cblog is a global variable.
                cblogger = cblog.GetLogger("CB-SPIDER")
                calllogger = call.GetLogger("HISCALL")
        }</span>)
}

func LoggingError(hiscallInfo call.CLOUDLOGSCHEMA, err error) <span class="cov0" title="0">{
        cblogger.Error(err.Error())
        hiscallInfo.ErrorMSG = err.Error()
        calllogger.Info(call.String(hiscallInfo))
}</span>

func LoggingInfo(hiscallInfo call.CLOUDLOGSCHEMA, start time.Time) <span class="cov0" title="0">{
        hiscallInfo.ElapsedTime = call.Elapsed(start)
        calllogger.Info(call.String(hiscallInfo))
}</span>

func GetCallLogScheme(endpoint string, resourceType call.RES_TYPE, resourceName string, apiName string) call.CLOUDLOGSCHEMA <span class="cov0" title="0">{
        cblogger.Info(fmt.Sprintf("Call %s %s", call.CLOUDIT, apiName))
        return call.CLOUDLOGSCHEMA{
                CloudOS:      call.CLOUDIT,
                RegionZone:   endpoint,
                ResourceType: resourceType,
                ResourceName: resourceName,
                CloudOSAPI:   apiName,
        }
}</span>

// VM Spec  
func GetVMSpecByName(authHeader map[string]string, reqClient *client.RestClient, specName string) (*string, error) <span class="cov0" title="0">{
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        specList, err := specs.List(reqClient, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(fmt.Sprintf("failed to get security group list, err : %s", err))
                return nil, err
        }</span>

        <span class="cov0" title="0">specInfo := specs.VMSpecInfo{}
        for _, s := range *specList </span><span class="cov0" title="0">{
                if strings.EqualFold(specName, s.Name) </span><span class="cov0" title="0">{
                        specInfo = s
                        break</span>
                }
        }

        // VM Spec     
        <span class="cov0" title="0">if specInfo.Id == "" </span><span class="cov0" title="0">{
                cblogger.Error(fmt.Sprintf("failed to get image, err : %s", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;specInfo.Id, nil</span>
}

// VNic  
func ListVNic(authHeader map[string]string, reqClient *client.RestClient, vmId string) (*[]nic.VmNicInfo, error) <span class="cov0" title="0">{
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        vNicList, err := nic.List(reqClient, vmId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return vNicList, nil</span>
}

// KeyPair   
func CreateHashString(credentialInfo idrv.CredentialInfo) (string, error) <span class="cov0" title="0">{
        keyString := credentialInfo.IdentityEndpoint + credentialInfo.AuthToken + credentialInfo.TenantId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}

// Public KeyPair  
func GetPublicKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"
        publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(publicKeyBytes), nil</span>
}

func GetSSHClient(serverIp string, serverPort int, username string, password string) (scp.Client, error) <span class="cov0" title="0">{
        clientConfig, err := auth.PasswordKey(username, password, ssh.InsecureIgnoreHostKey())
        if err != nil </span><span class="cov0" title="0">{
                return scp.Client{}, err
        }</span>
        <span class="cov0" title="0">sshClient := scp.NewClient(fmt.Sprintf("%s:%d", serverIp, serverPort), &amp;clientConfig)
        err = sshClient.Connect()
        return sshClient, err</span>
}

func RunCommand(serverIp string, serverPort int, username string, password string, command string) (string, error) <span class="cov0" title="0">{
        clientConfig, err := auth.PasswordKey(username, password, ssh.InsecureIgnoreHostKey())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">sshClient := scp.NewClient(fmt.Sprintf("%s:%d", serverIp, serverPort), &amp;clientConfig)
        err = sshClient.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer sshClient.Close()

        session := sshClient.Session
        sshOut, err := session.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">session.Stderr = os.Stderr

        err = session.Run(command)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return "", err
        }</span>
        <span class="cov0" title="0">defer session.Close()
        return stdoutToString(sshOut), err</span>
}

func stdoutToString(sshOut io.Reader) string <span class="cov0" title="0">{
        buf := make([]byte, 1000)
        num, err := sshOut.Read(buf)
        outStr := ""
        if err == nil </span><span class="cov0" title="0">{
                outStr = string(buf[:num])
        }</span>
        <span class="cov0" title="0">for err == nil </span><span class="cov0" title="0">{
                num, err = sshOut.Read(buf)
                outStr += string(buf[:num])
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span>{<span class="cov0" title="0">
                                //cblog.Error(err)
                        }</span>
                }

        }
        <span class="cov0" title="0">return strings.Trim(outStr, "\n")</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/image"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Image = "IMAGE"
)

type ClouditImageHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func setterImage(image image.ImageInfo) *irs.ImageInfo <span class="cov0" title="0">{
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   image.Name,
                        SystemId: image.ID,
                },
                GuestOS: image.OS,
                Status:  image.State,
        }
        return imageInfo
}</span>

func (imageHandler *ClouditImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageReqInfo.IId.NameId, "CreateImage()")

        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        reqInfo := image.ImageReqInfo{
                Name:         imageReqInfo.IId.NameId,
                VolumeId:     "fa4bb8d7-bf09-4fd7-b123-d08677ac0691",
                SnapshotId:   "dbc61213-b37e-4cc2-94ca-47991337e36f",
                Ownership:    "TENANT",
                Format:       "qcow2",
                SourceType:   "server",
                TemplateType: "DEFAULT",
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        // Create Image
        start := call.Start()
        image, err := image.Create(imageHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageInfo := setterImage(*image)
        return *imageInfo, nil</span>
}

func (imageHandler *ClouditImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, Image, "ListImage()")

        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        imageList, err := image.List(imageHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        resultList := make([]*irs.ImageInfo, len(*imageList))
        for i, vmImage := range *imageList </span><span class="cov0" title="0">{
                imageInfo := setterImage(vmImage)
                resultList[i] = imageInfo
        }</span>
        <span class="cov0" title="0">return resultList, nil</span>
}

func (imageHandler *ClouditImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "GetImage()")

        start := call.Start()
        imageInfo, err := imageHandler.getImageByName(imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return *imageInfo, nil</span>
}

func (imageHandler *ClouditImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "DeleteImage()")

        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := image.Delete(imageHandler.Client, imageIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (imageHandler *ClouditImageHandler) getImageByName(imageName string) (*irs.ImageInfo, error) <span class="cov0" title="0">{
        imageHandler.Client.TokenID = imageHandler.CredentialInfo.AuthToken
        authHeader := imageHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        imageList, err := image.List(imageHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var imageInfo *irs.ImageInfo
        for _, image := range *imageList </span><span class="cov0" title="0">{
                if strings.EqualFold(image.Name, imageName) </span><span class="cov0" title="0">{
                        imageInfo = setterImage(image)
                        break</span>
                }
        }

        <span class="cov0" title="0">if imageInfo == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find image with name %s", imageName))
                return nil, err
        }</span>
        <span class="cov0" title="0">return imageInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package resources

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "golang.org/x/crypto/ssh"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        KeyPair = "KEYPAIR"
)

type ClouditKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func (keyPairHandler *ClouditKeyPairHandler) CheckKeyPairFolder(folderPath string) error <span class="cov0" title="0">{
        // Check KeyPair Folder Exists
        if _, err := os.Stat(folderPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.MkdirAll(folderPath, 0700); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyPairReqInfo.IId.NameId, "CreateKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">savePrivateFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId
        savePublicFileTo := keyPairPath + hashString + "--" + keyPairReqInfo.IId.NameId + ".pub"
        bitSize := 4096

        // Check KeyPair Exists
        if _, err := os.Stat(savePrivateFileTo); err == nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("KeyPair with name %s already exist", keyPairReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                cblogger.Error(createErr.Error())
                hiscallInfo.ErrorMSG = createErr.Error()
                calllogger.Info(call.String(hiscallInfo))
                return irs.KeyPairInfo{}, createErr
        }</span>

        <span class="cov0" title="0">start := call.Start()

        //   RSA  () 
        privateKey, err := generatePrivateKey(bitSize)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  RSA PEM  
        <span class="cov0" title="0">privateKeyBytes := encodePrivateKeyToPEM(privateKey)

        // rsa.PublicKey  .pub     
        // "ssh-rsa ..." 
        publicKeyBytes, err := generatePublicKey(&amp;privateKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  private Key 
        <span class="cov0" title="0">err = writeKeyToFile(privateKeyBytes, savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  public Key 
        <span class="cov0" title="0">err = writeKeyToFile([]byte(publicKeyBytes), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairReqInfo.IId.NameId,
                        SystemId: keyPairReqInfo.IId.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keyPairInfo, nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, KeyPair, "ListKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var keyPairInfoList []*irs.KeyPairInfo

        start := call.Start()

        files, err := ioutil.ReadDir(keyPairPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), ".pub") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.Contains(f.Name(), hashString) </span><span class="cov0" title="0">{
                        fileNameArr := strings.Split(f.Name(), "--")
                        keypairInfo, err := keyPairHandler.GetKey(irs.IID{NameId: fileNameArr[1]})
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keyPairInfoList = append(keyPairInfoList, &amp;keypairInfo)</span>
                }
        }

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return keyPairInfoList, nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "GetKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)

        privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key   
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keypairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyIID.NameId,
                        SystemId: keyIID.NameId,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keypairInfo, nil</span>
}

func (keyPairHandler *ClouditKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "DeleteKey()")

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyIID.NameId
        publicKeyPath := keyPairPath + hashString + "--" + keyIID.NameId + ".pub"

        start := call.Start()

        // Private Key, Public Key 
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

//   RSA  () 
func generatePrivateKey(bitSize int) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        // Private Key 
        privateKey, err := rsa.GenerateKey(rand.Reader, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Private Key 
        <span class="cov0" title="0">err = privateKey.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Private Key generated()")
        //fmt.Println(privateKey)
        return privateKey, nil</span>
}

//  RSA PEM  
func encodePrivateKeyToPEM(privateKey *rsa.PrivateKey) []byte <span class="cov0" title="0">{
        // Get ASN.1 DER format
        privDER := x509.MarshalPKCS1PrivateKey(privateKey)

        // pem.Block
        privBlock := pem.Block{
                Type:    "RSA PRIVATE KEY",
                Headers: nil,
                Bytes:   privDER,
        }

        // Private key in PEM format
        privatePEM := pem.EncodeToMemory(&amp;privBlock)
        fmt.Println("privateKey Rsa -&gt; Pem  ")
        //fmt.Println(privatePEM)
        return privatePEM
}</span>

// rsa.PublicKey  .pub     
// "ssh-rsa ..." 
func generatePublicKey(privatekey *rsa.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        publicRsaKey, err := ssh.NewPublicKey(privatekey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pubKeyBytes := ssh.MarshalAuthorizedKey(publicRsaKey)

        log.Println("Public key ")
        //fmt.Println(pubKeyBytes)
        return pubKeyBytes, nil</span>
}

//  Key 
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key : %s", saveFileTo)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/iam/securitygroup"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        SecurityGroup = "SECURITYGROUP"
        NULL          = ""
        DefaultCIDR   = "0.0.0.0/0"
        DefaultPort   = "0"
)

type ClouditSecurityHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func setterSecGroup(secGroup securitygroup.SecurityGroupInfo) *irs.SecurityInfo <span class="cov0" title="0">{

        secInfo := &amp;irs.SecurityInfo{
                IId: irs.IID{
                        NameId:   secGroup.Name,
                        SystemId: secGroup.ID,
                },
                VpcIID: irs.IID{
                        NameId:   defaultVPCName,
                        SystemId: defaultVPCName,
                },
                SecurityRules: nil,
        }

        secRuleArr := make([]irs.SecurityRuleInfo, len(secGroup.Rules))
        for i, sgRule := range secGroup.Rules </span><span class="cov0" title="0">{
                secRuleInfo := irs.SecurityRuleInfo{
                        IPProtocol: sgRule.Protocol,
                        Direction:  sgRule.Type,
                        CIDR:       sgRule.Target,
                }
                if strings.Contains(sgRule.Port, "-") </span><span class="cov0" title="0">{
                        portArr := strings.Split(sgRule.Port, "-")
                        secRuleInfo.FromPort = portArr[0]
                        secRuleInfo.ToPort = portArr[1]
                }</span> else<span class="cov0" title="0"> {
                        secRuleInfo.FromPort = sgRule.Port
                        secRuleInfo.ToPort = sgRule.Port
                }</span>
                <span class="cov0" title="0">secRuleArr[i] = secRuleInfo</span>
        }
        <span class="cov0" title="0">secInfo.SecurityRules = &amp;secRuleArr

        return secInfo</span>
}

func (securityHandler *ClouditSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityReqInfo.IId.NameId, "CreateSecurity()")

        //    
        securityInfo, _ := securityHandler.getSecurityByName(securityReqInfo.IId.NameId)
        if securityInfo != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("SecurityGroup with name %s already exist", securityReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.SecurityInfo{}, createErr
        }</span>

        <span class="cov0" title="0">securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        reqInfo := securitygroup.SecurityReqInfo{
                Name: securityReqInfo.IId.NameId,
        }

        // SecurityGroup Rule 
        ruleList := make([]securitygroup.SecurityGroupRules, len(*securityReqInfo.SecurityRules))
        for i, rule := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                var port string
                if rule.CIDR == NULL </span><span class="cov0" title="0">{
                        rule.CIDR = DefaultCIDR
                }</span>
                <span class="cov0" title="0">if rule.FromPort == rule.ToPort </span><span class="cov0" title="0">{
                        port = rule.FromPort
                }</span> else<span class="cov0" title="0"> {
                        port = rule.FromPort + "-" + rule.ToPort
                }</span>
                <span class="cov0" title="0">secRuleInfo := securitygroup.SecurityGroupRules{
                        Name:     fmt.Sprintf("%s-rules-%d", securityReqInfo.IId.NameId, i+1),
                        Type:     rule.Direction,
                        Port:     port,
                        Target:   rule.CIDR,
                        Protocol: strings.ToLower(rule.IPProtocol),
                }
                ruleList[i] = secRuleInfo</span>
        }
        <span class="cov0" title="0">reqInfo.Rules = ruleList

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        start := call.Start()
        securityGroup, err := securitygroup.Create(securityHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        secGroupInfo := setterSecGroup(*securityGroup)
        return *secGroupInfo, nil</span>
}

func (securityHandler *ClouditSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, SecurityGroup, "ListSecurity()")

        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        securityList, err := securitygroup.List(securityHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // SecurityGroup Rule  
        for i, sg := range *securityList </span><span class="cov0" title="0">{
                sgRules, err := securitygroup.ListRule(securityHandler.Client, sg.ID, &amp;requestOpts)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        continue</span>
                }
                <span class="cov0" title="0">(*securityList)[i].Rules = *sgRules
                (*securityList)[i].RulesCount = len(*sgRules)</span>
        }

        <span class="cov0" title="0">resultList := make([]*irs.SecurityInfo, len(*securityList))
        for i, security := range *securityList </span><span class="cov0" title="0">{
                secInfo := setterSecGroup(security)
                resultList[i] = secInfo
        }</span>
        <span class="cov0" title="0">return resultList, nil</span>
}

func (securityHandler *ClouditSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "GetSecurity()")

        //    
        start := call.Start()
        securityInfo, err := securityHandler.getSecurityByName(securityIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        // SecurityGroup Rule  
        sgRules, err := securitygroup.ListRule(securityHandler.Client, securityInfo.ID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>

        <span class="cov0" title="0">(*securityInfo).Rules = *sgRules
        (*securityInfo).RulesCount = len(*sgRules)
        secGroupInfo := setterSecGroup(*securityInfo)

        return *secGroupInfo, nil</span>
}

func (securityHandler *ClouditSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "DeleteSecurity()")

        //    
        securityInfo, err := securityHandler.getSecurityByName(securityIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        //  
        start := call.Start()
        err = securitygroup.Delete(securityHandler.Client, securityInfo.ID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (securityHandler *ClouditSecurityHandler) getSecurityByName(securityName string) (*securitygroup.SecurityGroupInfo, error) <span class="cov0" title="0">{
        var security *securitygroup.SecurityGroupInfo

        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        securityList, err := securitygroup.List(securityHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range *securityList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, securityName) </span><span class="cov0" title="0">{
                        security = &amp;s
                        break</span>
                }
        }

        <span class="cov0" title="0">if security == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find security group with name %s", securityName))
                return nil, err
        }</span>
        <span class="cov0" title="0">return security, nil</span>
}

func (securityHandler *ClouditSecurityHandler) listRulesInSG(securityID string) (*[]securitygroup.SecurityGroupRules, error) <span class="cov0" title="0">{
        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        securityList, err := securitygroup.ListRulesinSG(securityHandler.Client, securityID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return securityList, nil</span>
}

func (securityHandler *ClouditSecurityHandler) addRuleToSG(extraRuleName, securityID, rule string) (*securitygroup.SecurityGroupRules, error) <span class="cov0" title="0">{
        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        reqInfo := securitygroup.SecurityGroupRules{
                Name:     extraRuleName,
                Protocol: strings.ToLower(DefaultSGName),
                Port:     DefaultPort,
                Target:   DefaultCIDR,
                Type:     rule,
        }

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
                JSONBody:    reqInfo,
        }

        createdRule, err := securitygroup.AddRule(securityHandler.Client, securityID, &amp;requestOpts, rule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return createdRule, nil</span>
}

func (securityHandler *ClouditSecurityHandler) deleteRuleInSG(securityGroupID, ruleID string) error <span class="cov0" title="0">{
        securityHandler.Client.TokenID = securityHandler.CredentialInfo.AuthToken
        authHeader := securityHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        err := securitygroup.DeleteRule(securityHandler.Client, securityGroupID, &amp;requestOpts, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.08.

package resources

import (
        "errors"
        "fmt"
        "strings"
        "time"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/nic"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/server"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/adaptiveip"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMDefaultUser         = "root"
        VMDefaultPassword     = "qwe1212!Q"
        SSHDefaultUser        = "cb-user"
        SSHDefaultPort        = 22
        VM                    = "VM"
        DefaultSGName         = "ALL"
        ExtraInboundRuleName  = "extra-inbound"
        ExtraOutboundRuleName = "extra-outbound"
        InboundRule           = "inbound"
        OutboundRule          = "outbound"
)

type ClouditVMHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func (vmHandler *ClouditVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "StartVM()")

        //    
        vmId, _ := vmHandler.getVmIdByName(vmReqInfo.IId.NameId)
        if vmId != "" </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("VirtualMachine with name %s already exist", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        //    (Name)
        <span class="cov0" title="0">imageHandler := ClouditImageHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }
        image, err := imageHandler.GetImage(vmReqInfo.ImageIID)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get image, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        //     (Name)
        <span class="cov0" title="0">vpcHandler := ClouditVPCHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }
        vpc, err := vpcHandler.GetSubnet(vmReqInfo.SubnetIID)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get virtual network, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        //    (Name)
        <span class="cov0" title="0">sgHandler := ClouditSecurityHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }

        // TODO: VNIC Security Group  API 
        //// Default SG 
        //defaultSG, err := sgHandler.getSecurityByName(DefaultSGName)
        //if err != nil {
        //        return irs.VMInfo{}, nil
        //}
        //defaultSecGroups := make([]server.SecGroupInfo, len(vmReqInfo.SecurityGroupIIDs))
        //for i, _ := range vmReqInfo.SecurityGroupIIDs {
        //        defaultSecGroups[i] = server.SecGroupInfo{
        //                Id: defaultSG.ID,
        //        }
        //}

        // VM VNIC User Security Group 
        secGroups := make([]server.SecGroupInfo, len(vmReqInfo.SecurityGroupIIDs))
        for i, s := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                secGroups[i] = server.SecGroupInfo{
                        Id: s.SystemId,
                }
        }</span>

        //  Inbound  
        <span class="cov0" title="0">_, err = sgHandler.addRuleToSG(ExtraInboundRuleName, secGroups[0].Id, InboundRule)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to add extra inbound rule to SG, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>
        //  Outbound  
        <span class="cov0" title="0">_, err = sgHandler.addRuleToSG(ExtraOutboundRuleName, secGroups[0].Id, OutboundRule)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to add extra outbound rule to SG, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        // Spec   (Name)
        <span class="cov0" title="0">vmSpecId, err := GetVMSpecByName(vmHandler.Client.AuthenticatedHeaders(), vmHandler.Client, vmReqInfo.VMSpecName)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get vm spec, err : %s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        <span class="cov0" title="0">vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        reqInfo := server.VMReqInfo{
                TemplateId:   image.IId.SystemId,
                SpecId:       *vmSpecId,
                Name:         vmReqInfo.IId.NameId,
                HostName:     vmReqInfo.IId.NameId,
                RootPassword: VMDefaultPassword,
                SubnetAddr:   vpc.Addr,
                Secgroups:    secGroups,
        }

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
                JSONBody:    reqInfo,
        }

        // VM 
        start := call.Start()
        creatingVm, err := server.Start(vmHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM   wait
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                // Check VM Deploy Status
                vmInfo, err := server.Get(vmHandler.Client, creatingVm.ID, &amp;requestOpts)
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VMInfo{}, err
                }</span>

                <span class="cov0" title="0">if vmInfo.PrivateIp != "" &amp;&amp; getVmStatus(vmInfo.State) == irs.Running </span><span class="cov0" title="0">{
                        ok, err := vmHandler.AssociatePublicIP(creatingVm.Name, vmInfo.PrivateIp)
                        if !ok </span><span class="cov0" title="0">{
                                LoggingError(hiscallInfo, err)
                                return irs.VMInfo{}, err
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                curRetryCnt++
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                        return irs.VMInfo{}, errors.New(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                }</span>
        }

        <span class="cov0" title="0">vm, err := server.Get(vmHandler.Client, creatingVm.ID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">vmInfo := vmHandler.mappingServerInfo(*vm)

        // SSH     
        loginUserId := SSHDefaultUser
        createUserErr := errors.New("Error adding cb-User to new VM")

        // SSH  
        curConnectionCnt := 0
        maxConnectionRetryCnt := 30
        for </span><span class="cov0" title="0">{
                cblogger.Info("Trying to connect via root user ...")
                _, err := RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "echo test")
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                curConnectionCnt++
                if curConnectionCnt &gt; maxConnectionRetryCnt </span><span class="cov0" title="0">{
                        return irs.VMInfo{}, createUserErr
                }</span>
        }

        //    sudoer  
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("useradd -s /bin/bash %s -rm", loginUserId))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("echo \"%s ALL=(root) NOPASSWD:ALL\" &gt;&gt; /etc/sudoers", loginUserId))
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>

        //  
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("mkdir -p /home/%s/.ssh", loginUserId))
        publicKey, err := GetPublicKey(vmHandler.CredentialInfo, vmReqInfo.KeyPairIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, fmt.Sprintf("echo \"%s\" &gt; /home/%s/.ssh/authorized_keys", publicKey, loginUserId))

        // ssh    (sshd_config  )
        _, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "sed -i 's/PasswordAuthentication yes/PasswordAuthentication no/g' /etc/ssh/sshd_config")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "sed -i 's/#PubkeyAuthentication yes/PubkeyAuthentication yes/g' /etc/ssh/sshd_config")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>
        <span class="cov0" title="0">_, err = RunCommand(vmInfo.PublicIP, SSHDefaultPort, VMDefaultUser, VMDefaultPassword, "systemctl restart sshd")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, createUserErr
        }</span>

        // VM VNIC User Security Group Attach
        <span class="cov0" title="0">userSecGroups := make([]server.SecGroupInfo, len(vmReqInfo.SecurityGroupIIDs))
        for i, s := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                userSecGroups[i] = server.SecGroupInfo{
                        Id: s.SystemId,
                }
        }</span>

        // SG     Rule ID 
        <span class="cov0" title="0">extraSG, _ := sgHandler.listRulesInSG(secGroups[0].Id)
        //deleteTargetRuleID := make([]string, 2)
        var deleteTargetRuleID []string

        for _, v := range *extraSG </span><span class="cov0" title="0">{
                if v.Name == ExtraInboundRuleName || v.Name == ExtraOutboundRuleName </span><span class="cov0" title="0">{
                        deleteTargetRuleID = append(deleteTargetRuleID, v.ID)
                }</span>
        }

        // SG   
        <span class="cov0" title="0">for _, v := range deleteTargetRuleID </span><span class="cov0" title="0">{
                err = sgHandler.deleteRuleInSG(secGroups[0].Id, v)
                if err != nil </span><span class="cov0" title="0">{
                        deleteErr := errors.New(fmt.Sprintf("failed to delete extra rules, err : %s", err.Error()))
                        LoggingError(hiscallInfo, deleteErr)
                        return irs.VMInfo{}, deleteErr
                }</span>
        }
        // TODO: VNIC SG  API 
        //err = vmHandler.attachSgToVnic(authHeader, vm.ID, vmHandler.Client, vnicMac, defaultSecGroups, userSecGroups)
        //if err != nil {
        //        return irs.VMInfo{}, err
        //}

        <span class="cov0" title="0">return vmInfo, nil</span>
}

func (vmHandler *ClouditVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "SuspendVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := server.Suspend(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM   
        vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return vmStatus, nil</span>
}

func (vmHandler *ClouditVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "ResumeVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := server.Resume(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM   
        vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return vmStatus, nil</span>
}

func (vmHandler *ClouditVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "RebootVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err := server.Reboot(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM   
        vmStatus, err := vmHandler.GetVMStatus(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">return vmStatus, nil</span>
}

func (vmHandler *ClouditVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "TerminateVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        // VM  
        vmInfo, err := vmHandler.GetVM(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        //  PublicIP 
        <span class="cov0" title="0">if vmInfo.PublicIP != "" </span><span class="cov0" title="0">{
                if ok, err := vmHandler.DisassociatePublicIP(vmInfo.PublicIP); !ok </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.Failed, err
                }</span>
                <span class="cov0" title="0">time.Sleep(5 * time.Second)</span>
        }

        <span class="cov0" title="0">start := call.Start()
        if err := server.Terminate(vmHandler.Client, vmInfo.IId.SystemId, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // VM   
        return irs.Terminating, nil</span>
}

func (vmHandler *ClouditVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVMStatus()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        vmList, err := server.List(vmHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMStatusInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmStatusList := make([]*irs.VMStatusInfo, len(*vmList))
        for i, vm := range *vmList </span><span class="cov0" title="0">{
                vmStatusInfo := irs.VMStatusInfo{
                        IId: irs.IID{
                                NameId:   vm.Name,
                                SystemId: vm.ID,
                        },
                        VmStatus: irs.VMStatus(vm.State),
                }
                vmStatusList[i] = &amp;vmStatusInfo
        }</span>
        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func (vmHandler *ClouditVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVMStatus()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        vmSystemID, err := vmHandler.getVmIdByName(vmIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        vm, err := server.Get(vmHandler.Client, vmSystemID, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Set VM Status Info
        status := getVmStatus(vm.State)
        return status, nil</span>
}

func (vmHandler *ClouditVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        vmList, err := server.List(vmHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return []*irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfoList := make([]*irs.VMInfo, len(*vmList))
        for i, vm := range *vmList </span><span class="cov0" title="0">{
                vmInfo := vmHandler.mappingServerInfo(vm)
                vmInfoList[i] = &amp;vmInfo
        }</span>
        <span class="cov0" title="0">return vmInfoList, nil</span>
}

func (vmHandler *ClouditVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVM()")

        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        vm, err := server.Get(vmHandler.Client, vmIID.SystemId, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfo := vmHandler.mappingServerInfo(*vm)
        return vmInfo, nil</span>
}

// VM PublicIP 
func (vmHandler *ClouditVMHandler) AssociatePublicIP(vmName string, vmIp string) (bool, error) <span class="cov0" title="0">{
        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        var availableIP adaptiveip.IPInfo

        // 1.   PublicIP  
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        if availableIPList, err := adaptiveip.ListAvailableIP(vmHandler.Client, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span> else<span class="cov0" title="0"> {
                if len(*availableIPList) == 0 </span><span class="cov0" title="0">{
                        allocateErr := errors.New(fmt.Sprintf("There is no PublicIPs to allocate"))
                        return false, allocateErr
                }</span> else<span class="cov0" title="0"> {
                        availableIP = (*availableIPList)[0]
                }</span>
        }

        // 2. PublicIP   
        <span class="cov0" title="0">reqInfo := adaptiveip.PublicIPReqInfo{
                IP:        availableIP.IP,
                Name:      vmName + "-PublicIP",
                PrivateIP: vmIp,
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }
        _, err := adaptiveip.Create(vmHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// VM PublicIP 
func (vmHandler *ClouditVMHandler) DisassociatePublicIP(publicIP string) (bool, error) <span class="cov0" title="0">{
        vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        if err := adaptiveip.Delete(vmHandler.Client, publicIP, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span> else<span class="cov0" title="0"> {
                return true, nil
        }</span>
}

func (vmHandler *ClouditVMHandler) mappingServerInfo(server server.ServerInfo) irs.VMInfo <span class="cov0" title="0">{

        // Get Default VM Info
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId:   server.Name,
                        SystemId: server.ID,
                },
                Region: irs.RegionInfo{
                        Region: server.TenantID,
                        Zone:   server.TenantID,
                },
                ImageIId: irs.IID{
                        NameId:   server.Template,
                        SystemId: server.TemplateID,
                },
                VMSpecName: server.Spec,
                VpcIID: irs.IID{
                        NameId:   defaultVPCName,
                        SystemId: defaultVPCName,
                },
                VMUserId:  VMDefaultUser,
                PublicIP:  server.AdaptiveIp,
                PrivateIP: server.PrivateIp,
        }

        if server.CreatedAt != "" </span><span class="cov0" title="0">{
                timeArr := strings.Split(server.CreatedAt, " ")
                timeFormatStr := fmt.Sprintf("%sT%sZ", timeArr[0], timeArr[1])
                if createTime, err := time.Parse(time.RFC3339, timeFormatStr); err == nil </span><span class="cov0" title="0">{
                        vmInfo.StartTime = createTime
                }</span>
        }

        // Get Subnet Info
        <span class="cov0" title="0">VPCHandler := ClouditVPCHandler{
                Client:         vmHandler.Client,
                CredentialInfo: vmHandler.CredentialInfo,
        }
        subnet, err := VPCHandler.GetSubnet(irs.IID{NameId: server.SubnetAddr})
        if err == nil </span><span class="cov0" title="0">{
                vmInfo.SubnetIID = irs.IID{
                        NameId:   subnet.Name,
                        SystemId: subnet.ID,
                }
        }</span>

        // Get SecurityGroup Info
        <span class="cov0" title="0">vmHandler.Client.TokenID = vmHandler.CredentialInfo.AuthToken
        authHeader := vmHandler.Client.AuthenticatedHeaders()
        vnicList, _ := ListVNic(authHeader, vmHandler.Client, server.ID)
        if vnicList != nil </span><span class="cov0" title="0">{
                defaultVnic := (*vnicList)[0]
                segGroupList := make([]irs.IID, len(defaultVnic.SecGroups))
                for i, s := range defaultVnic.SecGroups </span><span class="cov0" title="0">{
                        segGroupList[i] = irs.IID{
                                NameId:   s.Name,
                                SystemId: s.Id,
                        }
                }</span>
                <span class="cov0" title="0">vmInfo.SecurityGroupIIds = segGroupList</span>
        }
        <span class="cov0" title="0">return vmInfo</span>
}

func (vmHandler *ClouditVMHandler) getVmIdByName(vmNameID string) (string, error) <span class="cov0" title="0">{
        var vmId string

        // VM  
        vmList, err := vmHandler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // VM  Name  
        <span class="cov0" title="0">for _, v := range vmList </span><span class="cov0" title="0">{
                if strings.EqualFold(v.IId.NameId, vmNameID) </span><span class="cov0" title="0">{
                        vmId = v.IId.SystemId
                        break</span>
                }
        }

        //  VM     
        <span class="cov0" title="0">if vmId == "" </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find vm with name %s", vmNameID))
                return "", err
        }</span>
        <span class="cov0" title="0">return vmId, nil</span>
}

func getVmStatus(vmStatus string) irs.VMStatus <span class="cov0" title="0">{
        var resultStatus string
        switch strings.ToLower(vmStatus) </span>{
        case "creating":<span class="cov0" title="0">
                resultStatus = "Creating"</span>
        case "running":<span class="cov0" title="0">
                resultStatus = "Running"</span>
        case "stopping":<span class="cov0" title="0">
                resultStatus = "Suspending"</span>
        case "stopped":<span class="cov0" title="0">
                resultStatus = "Suspended"</span>
        case "starting":<span class="cov0" title="0">
                resultStatus = "Resuming"</span>
        case "rebooting":<span class="cov0" title="0">
                resultStatus = "Rebooting"</span>
        case "terminating":<span class="cov0" title="0">
                resultStatus = "Terminating"</span>
        case "terminated":<span class="cov0" title="0">
                resultStatus = "Terminated"</span>
        case "failed":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                resultStatus = "Failed"</span>
        }
        <span class="cov0" title="0">return irs.VMStatus(resultStatus)</span>
}

func (vmHandler *ClouditVMHandler) attachSgToVnic(authHeader map[string]string, vmID string, reqClient *client.RestClient, vnicMac string, sgGroup []server.SecGroupInfo) <span class="cov0" title="0">{

        reqInfo := server.VMReqInfo{
                Secgroups: sgGroup,
        }
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
                JSONBody:    reqInfo,
        }
        nic.Put(reqClient, vmID, &amp;requestOpts, vnicMac)
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2020.01.

package resources

import (
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/ace/specs"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMSpec = "VMSPEC"
)

type ClouditVMSpecHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func setterVMSpec(region string, vmSpec specs.VMSpecInfo) *irs.VMSpecInfo <span class="cov0" title="0">{
        vmSpecInfo := &amp;irs.VMSpecInfo{
                Region:       region,
                Name:         vmSpec.Name,
                VCpu:         irs.VCpuInfo{Count: strconv.Itoa(vmSpec.Cpu)},
                Gpu:          []irs.GpuInfo{{Count: strconv.Itoa(vmSpec.GPU)}},
                KeyValueList: nil,
        }
        vmSpecInfo.Mem = strconv.FormatFloat(float64(vmSpec.Mem)*1024, 'f', 0, 64)
        return vmSpecInfo
}</span>

func (vmSpecHandler *ClouditVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListVMSpec()")

        vmSpecHandler.Client.TokenID = vmSpecHandler.CredentialInfo.AuthToken
        authHeader := vmSpecHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        list, err := specs.List(vmSpecHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                getError := errors.New(fmt.Sprintf("failed to get VM spec list, err : %s", err.Error()))
                LoggingError(hiscallInfo, getError)
                return nil, getError
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmSpecList := make([]*irs.VMSpecInfo, len(*list))
        for i, spec := range *list </span><span class="cov0" title="0">{
                vmSpecList[i] = setterVMSpec(Region, spec)
        }</span>
        <span class="cov0" title="0">return vmSpecList, nil</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetVMSpec()")

        start := call.Start()
        specInfo, err := vmSpecHandler.GetVMSpecByName(Region, Name)
        if err != nil </span><span class="cov0" title="0">{
                notFoundErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err.Error()))
                LoggingError(hiscallInfo, notFoundErr)
                return irs.VMSpecInfo{}, notFoundErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return *specInfo, nil</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListOrgVMSpec()")

        vmSpecHandler.Client.TokenID = vmSpecHandler.CredentialInfo.AuthToken
        authHeader := vmSpecHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        list, err := specs.List(vmSpecHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("failed to get VM spec list, err : %s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return "", getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var jsonResult struct {
                Result []specs.VMSpecInfo `json:"list"`
        }
        jsonResult.Result = *list
        jsonBytes, err := json.Marshal(jsonResult)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetOrgVMSpec()")

        start := call.Start()
        specInfo, err := vmSpecHandler.GetVMSpecByName(Region, Name)
        if err != nil </span><span class="cov0" title="0">{
                notFoundErr := errors.New(fmt.Sprintf("failed to get VM spec, err : %s", err.Error()))
                LoggingError(hiscallInfo, notFoundErr)
                return "", notFoundErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        jsonBytes, err := json.Marshal(specInfo)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, err</span>
}

func (vmSpecHandler *ClouditVMSpecHandler) GetVMSpecByName(region string, specName string) (*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        vmSpecHandler.Client.TokenID = vmSpecHandler.CredentialInfo.AuthToken
        authHeader := vmSpecHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        specList, err := specs.List(vmSpecHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var specInfo *irs.VMSpecInfo
        for _, spec := range *specList </span><span class="cov0" title="0">{
                if strings.EqualFold(spec.Name, specName) </span><span class="cov0" title="0">{
                        specInfo = setterVMSpec(region, spec)
                        break</span>
                }
        }

        <span class="cov0" title="0">if specInfo == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find vmSpec with name %s", specName))
                return nil, err
        }</span>

        <span class="cov0" title="0">return specInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/cloudit/client/dna/subnet"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        defaultVPCName    = "Default-VPC"
        defaultVPCCIDR    = "10.0.0.0/16"
        defaultSubnetName = "Default Network"
        VPC               = "VPC"
)

type ClouditVPCHandler struct {
        CredentialInfo idrv.CredentialInfo
        Client         *client.RestClient
}

func (vpcHandler *ClouditVPCHandler) setterVPC(subnets []subnet.SubnetInfo) *irs.VPCInfo <span class="cov0" title="0">{
        // VPC  
        vpcInfo := irs.VPCInfo{
                IId: irs.IID{
                        NameId:   defaultVPCName,
                        SystemId: defaultVPCName,
                },
                IPv4_CIDR: defaultVPCCIDR,
        }
        //   
        subnetInfoList := make([]irs.SubnetInfo, len(subnets))
        for i, s := range subnets </span><span class="cov0" title="0">{
                subnetInfo := vpcHandler.setterSubnet(s)
                subnetInfoList[i] = *subnetInfo
        }</span>
        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetInfoList

        return &amp;vpcInfo</span>
}

func (vpcHandler *ClouditVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, VPC, "CreateVPC()")

        // Create Subnet
        start := call.Start()
        subnetList := make([]subnet.SubnetInfo, len(vpcReqInfo.SubnetInfoList))
        for i, vpcSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                result, err := vpcHandler.CreateSubnet(vpcSubnet)
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VPCInfo{}, err
                }</span>
                <span class="cov0" title="0">subnetList[i] = result</span>
        }
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(subnetList)
        return *vpcInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, VPC, "ListVPC()")

        start := call.Start()
        subnetList, err := vpcHandler.ListSubnet()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(subnetList)
        vpcInfoList := []*irs.VPCInfo{vpcInfo}
        return vpcInfoList, nil</span>
}

func (vpcHandler *ClouditVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "GetVPC()")

        start := call.Start()
        vpcInfo, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return *vpcInfo[0], err</span>
}

func (vpcHandler *ClouditVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "DeleteVPC()")

        vpcInfo, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        for _, subnetInfo := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                subnetList, err := vpcHandler.ListSubnet()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return false, err
                }</span>
                <span class="cov0" title="0">for _, value := range subnetList </span><span class="cov0" title="0">{
                        if value.ID == subnetInfo.IId.SystemId </span><span class="cov0" title="0">{
                                if value.Protection == 0 </span><span class="cov0" title="0">{
                                        if ok, _ := vpcHandler.DeleteSubnet(subnetInfo.IId); ok </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (vpcHandler *ClouditVPCHandler) setterSubnet(subnet subnet.SubnetInfo) *irs.SubnetInfo <span class="cov0" title="0">{
        subnetInfo := irs.SubnetInfo{
                IId: irs.IID{
                        NameId:   subnet.Name,
                        SystemId: subnet.ID,
                },
                IPv4_CIDR: subnet.Addr + "/" + subnet.Prefix,
        }
        return &amp;subnetInfo
}</span>

func (vpcHandler *ClouditVPCHandler) CreateSubnet(subnetReqInfo irs.SubnetInfo) (subnet.SubnetInfo, error) <span class="cov0" title="0">{
        //    
        checkSubnet, _ := vpcHandler.getSubnetByName(subnetReqInfo.IId.NameId)
        if checkSubnet != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("virtualNetwork with name %s already exist", subnetReqInfo.IId.NameId)
                createErr := errors.New(errMsg)
                return subnet.SubnetInfo{}, createErr
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        var creatableSubnet subnet.SubnetInfo

        // 1.   Subnet  
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        if creatableSubnetList, err := subnet.ListCreatableSubnet(vpcHandler.Client, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                return subnet.SubnetInfo{}, err
        }</span> else<span class="cov0" title="0"> {
                if len(*creatableSubnetList) == 0 </span><span class="cov0" title="0">{
                        allocateErr := errors.New("there is no PublicIPs to allocate")
                        return subnet.SubnetInfo{}, allocateErr
                }</span> else<span class="cov0" title="0"> {
                        creatableSubnet = (*creatableSubnetList)[0]
                }</span>
        }

        // 2. Subnet 
        <span class="cov0" title="0">reqInfo := subnet.VNetworkReqInfo{
                Name:   subnetReqInfo.IId.NameId,
                Addr:   creatableSubnet.Addr,
                Prefix: creatableSubnet.Prefix,
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        subnetInfo, err := subnet.Create(vpcHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                return subnet.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">return *subnetInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) ListSubnet() ([]subnet.SubnetInfo, error) <span class="cov0" title="0">{
        vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        subnetList, err := subnet.List(vpcHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return *subnetList, err</span>
}

func (vpcHandler *ClouditVPCHandler) GetSubnet(subnetIId irs.IID) (subnet.SubnetInfo, error) <span class="cov0" title="0">{
        //    
        subnetInfo, err := vpcHandler.getSubnetByName(subnetIId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return subnet.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">return *subnetInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) DeleteSubnet(subnetIId irs.IID) (bool, error) <span class="cov0" title="0">{
        //    
        subnetInfo, err := vpcHandler.getSubnetByName(subnetIId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        if err := subnet.Delete(vpcHandler.Client, subnetInfo.Addr, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *ClouditVPCHandler) getSubnetByName(subnetName string) (*subnet.SubnetInfo, error) <span class="cov0" title="0">{
        var subnetInfo *subnet.SubnetInfo

        vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        subnetList, err := subnet.List(vpcHandler.Client, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range *subnetList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, subnetName) </span><span class="cov0" title="0">{
                        subnetInfo = &amp;s
                        break</span>
                }
        }

        <span class="cov0" title="0">if subnetInfo == nil </span><span class="cov0" title="0">{
                err := errors.New(fmt.Sprintf("failed to find subnet with name %s", subnetName))
                return nil, err
        }</span>
        <span class="cov0" title="0">return subnetInfo, nil</span>
}

func (vpcHandler *ClouditVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "AddSubnet()")

        checkSubnet, _ := vpcHandler.getSubnetByName(subnetInfo.IId.NameId)
        if checkSubnet != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("virtualNetwork with name %s already exist", subnetInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        var creatableSubnet subnet.SubnetInfo

        // 1.   Subnet  
        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }
        if creatableSubnetList, err := subnet.ListCreatableSubnet(vpcHandler.Client, &amp;requestOpts); err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span> else<span class="cov0" title="0"> {
                if len(*creatableSubnetList) == 0 </span><span class="cov0" title="0">{
                        allocateErr := errors.New("there is no PublicIPs to allocate")
                        LoggingError(hiscallInfo, allocateErr)
                        return irs.VPCInfo{}, allocateErr
                }</span> else<span class="cov0" title="0"> {
                        creatableSubnet = (*creatableSubnetList)[0]
                }</span>
        }

        // 2. Subnet 
        <span class="cov0" title="0">reqInfo := subnet.VNetworkReqInfo{
                Name:   subnetInfo.IId.NameId,
                Addr:   creatableSubnet.Addr,
                Prefix: creatableSubnet.Prefix,
        }

        createOpts := client.RequestOpts{
                JSONBody:    reqInfo,
                MoreHeaders: authHeader,
        }

        start := call.Start()
        _, err := subnet.Create(vpcHandler.Client, &amp;createOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        result, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (vpcHandler *ClouditVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, subnetIID.NameId, "RemoveSubnet()")

        subnetInfo, err := vpcHandler.getSubnetByName(subnetIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>

        <span class="cov0" title="0">vpcHandler.Client.TokenID = vpcHandler.CredentialInfo.AuthToken
        authHeader := vpcHandler.Client.AuthenticatedHeaders()

        requestOpts := client.RequestOpts{
                MoreHeaders: authHeader,
        }

        start := call.Start()
        err = subnet.Delete(vpcHandler.Client, subnetInfo.Addr, &amp;requestOpts)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package docker

import (
        "C"
        "github.com/sirupsen/logrus"
        cblog "github.com/cloud-barista/cb-log"
        "context"
        "github.com/docker/docker/client"

        dkcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type DockerDriver struct{}
var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>


func (DockerDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "DOCKER DRIVER Version 1.0"
}</span>

func (DockerDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = false
        drvCapabilityInfo.SecurityHandler = false
        drvCapabilityInfo.KeyPairHandler = false
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = false

        return drvCapabilityInfo
}</span>

func (driver *DockerDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of XXX Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/XXX_CloudConnection".
        // 4. return CloudConnection Interface of XXX_CloudConnection.

        //thisContext, _ := context.WithTimeout(context.Background(), 600*time.Second)
        thisContext := context.Background()

        // ex)
        // IdentityEndpoint = "http://18.191.129.154:1004"
        // APIVersion = "v1.36"
        Host:= connectionInfo.CredentialInfo.Host
        APIVersion:= connectionInfo.CredentialInfo.APIVersion
        client, err := client.NewClient(Host, APIVersion, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := dkcon.DockerCloudConnection{
                ConnectionInfo:      connectionInfo,
                Context:             thisContext,
                Client:                     client,
        }
        return &amp;iConn, nil</span>
}

var CloudDriver DockerDriver
</pre>
		
		<pre class="file" id="file86" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package connect

import (
        "context"
        cblog "github.com/cloud-barista/cb-log"
        "github.com/docker/docker/client"
        dkrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/docker/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type DockerCloudConnection struct {
        ConnectionInfo      idrv.ConnectionInfo
        Context                    context.Context
        Client              *client.Client
}

func (cloudConn *DockerCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called CreateImageHandler()!")
        imageHandler := dkrs.DockerImageHandler{cloudConn.ConnectionInfo.RegionInfo, cloudConn.Context, cloudConn.Client}
        return &amp;imageHandler, nil
}</span>


func (cloudConn *DockerCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called CreateVMHandler()!")
        vmHandler := dkrs.DockerVMHandler{
                Region:         cloudConn.ConnectionInfo.RegionInfo,
                Context:        cloudConn.Context,
                Client:         cloudConn.Client,
        }
        return &amp;vmHandler, nil
}</span>

func (cloudConn *DockerCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateVPCHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn DockerCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateSecurityHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn *DockerCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateKeyPairHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn *DockerCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Error("Docker Cloud Driver: called CreateVMSpecHandler(), but not supported!")
        return nil, nil
}</span>

func (cloudConn *DockerCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called IsConnected()!")
        if cloudConn == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if cloudConn.Client == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (cloudConn *DockerCloudConnection) Close() error <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called Close()!")
        return cloudConn.Client.Close()
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package resources

import (
        "github.com/sirupsen/logrus"
        cblog "github.com/cloud-barista/cb-log"
        "context"
        "github.com/docker/docker/client"
        "github.com/docker/docker/api/types"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "bytes"
        "fmt"
        "strings"
)

type DockerImageHandler struct {
        Region        idrv.RegionInfo
        Context       context.Context
        Client        *client.Client
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>


// (1) pull from dockerhub
// (2) get repo digests id from pulling return
// (3) get all image summary from local repos
// (4) get image ID and OS Info from inspection
func (imageHandler *DockerImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called CreateImage()!")

        // (1) pull from dockerhub
        //ref) images, err := cli.ImagePull(context.Background(), "alpine:latest", types.ImagePullOptions{})
        out, err := imageHandler.Client.ImagePull(imageHandler.Context, imageReqInfo.IId.NameId, types.ImagePullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        buf := new(bytes.Buffer)
        buf.ReadFrom(out)
        msg := buf.String()
//        cblogger.Info(msg)

        // (2) get repo digests id from pulling return
        repoDigests, err := getRepoDigests(msg)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        // (3) get all image summary from local repos
        <span class="cov0" title="0">images, err := imageHandler.Client.ImageList(imageHandler.Context, types.ImageListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        // (4) get image ID and OS Info from inspection
        <span class="cov0" title="0">for _, image := range images </span><span class="cov0" title="0">{
                if strings.Contains(image.RepoDigests[0], repoDigests) </span><span class="cov0" title="0">{
                        imageReqInfo.IId.SystemId = image.ID
                        // (3) inspect image info for OS info
                        osName, err := getOSInfo(imageHandler, image.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Error(err)
                                return irs.ImageInfo{}, err
                        }</span>
                        <span class="cov0" title="0">return irs.ImageInfo{imageReqInfo.IId, osName, "", nil}, nil</span>
                }
        }
        
        <span class="cov0" title="0">return irs.ImageInfo{}, fmt.Errorf("[Local Repos:" + imageReqInfo.IId.NameId + "] does not exist!")</span>
}

func getRepoDigests(msg string) (string, error) <span class="cov0" title="0">{

        /*---------- msg example
        {"status":"Pulling from panubo/sshd","id":"latest"}
        {"status":"Digest: sha256:b260ab0136c734d80ef643387af0eeb807deb7e1f0a85cb432c7f310eca3bb83"}
        {"status":"Status: Image is up to date for panubo/sshd:latest"}
        ------------*/
        strList := strings.Split(msg, "\n")        

        for _, str := range strList </span><span class="cov0" title="0">{
                if strings.Contains(str, "sha256") </span><span class="cov0" title="0">{
                        tmpList := strings.Split(str, ":")
                        str1 := strings.Trim(tmpList[2], " ") // sha256
                        runes := []rune(tmpList[3])  // b260ab0136c734d80ef643387af0eeb807deb7e1f0a85cb432c7f310eca3bb83"}
                        str2 := string(runes[0:len(tmpList[3])-3]) // b260ab0136c734d80ef643387af0eeb807deb7e1f0a85cb432c7f310eca3bb83
                        return str1+":"+str2, nil

                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed image pulling-" + msg)</span>
}

func getOSInfo(imageHandler *DockerImageHandler, imageID string) (string, error) <span class="cov0" title="0">{
        inspec, _, err := imageHandler.Client.ImageInspectWithRaw(imageHandler.Context, imageID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">return inspec.Os + ":" + inspec.OsVersion + ":" + inspec.Architecture, nil</span>
}

func (imageHandler *DockerImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ListImage()!")
        
        //ref) images, err := cli.ImageList(context.Background(), types.ImageListOptions{})
        images, err := imageHandler.Client.ImageList(imageHandler.Context, types.ImageListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">listImages := make([]*irs.ImageInfo, len(images))
        for i, image := range images </span><span class="cov0" title="0">{
                osName, err := getOSInfo(imageHandler, image.ID)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return []*irs.ImageInfo{}, err
                }</span>

                <span class="cov0" title="0">listImages[i] = &amp;irs.ImageInfo{irs.IID{"", image.ID}, osName, "", nil }</span> 
        }

        <span class="cov0" title="0">return listImages, nil</span>
}

func (imageHandler *DockerImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called GetImage()!")

        // inspect image info for OS info
        osName, err := getOSInfo(imageHandler, imageIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">return irs.ImageInfo{imageIID, osName, "", nil}, nil</span>
}

func (imageHandler *DockerImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called DeleteImage()!")


        response, err := imageHandler.Client.ImageRemove(imageHandler.Context, imageIID.SystemId, types.ImageRemoveOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n\n=================\n %#v", response)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Docker Driver.
//
// by CB-Spider Team, 2020.05.

package resources

import (
        "context"
        "github.com/docker/docker/client"
        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/go-connections/nat"

        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "time"
        "strconv"
)

type DockerVMHandler struct {
        Region        idrv.RegionInfo
        Context       context.Context
        Client        *client.Client
}

func (vmHandler *DockerVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called StartVM()!")

/*
 ref) https://godoc.org/github.com/docker/docker/api/types/container#Config
type Config struct {
    Hostname        string              // Hostname
    Domainname      string              // Domainname
    User            string              // User that will run the command(s) inside the container, also support user:group
    AttachStdin     bool                // Attach the standard input, makes possible user interaction
    AttachStdout    bool                // Attach the standard output
    AttachStderr    bool                // Attach the standard error
    ExposedPorts    nat.PortSet         `json:",omitempty"` // List of exposed ports
    Tty             bool                // Attach standard streams to a tty, including stdin if it is not closed.
    OpenStdin       bool                // Open stdin
    StdinOnce       bool                // If true, close stdin after the 1 attached client disconnects.
    Env             []string            // List of environment variable to set in the container
    Cmd             strslice.StrSlice   // Command to run when starting the container
    Healthcheck     *HealthConfig       `json:",omitempty"` // Healthcheck describes how to check the container is healthy
    ArgsEscaped     bool                `json:",omitempty"` // True if command is already escaped (meaning treat as a command line) (Windows specific).
    Image           string              // Name of the image as it was passed by the operator (e.g. could be symbolic)
    Volumes         map[string]struct{} // List of volumes (mounts) used for the container
    WorkingDir      string              // Current directory (PWD) in the command will be launched
    Entrypoint      strslice.StrSlice   // Entrypoint to run when starting the container
    NetworkDisabled bool                `json:",omitempty"` // Is network disabled
    MacAddress      string              `json:",omitempty"` // Mac Address of the container
    OnBuild         []string            // ONBUILD metadata that were defined on the image Dockerfile
    Labels          map[string]string   // List of labels set to this container
    StopSignal      string              `json:",omitempty"` // Signal to stop a container
    StopTimeout     *int                `json:",omitempty"` // Timeout (in seconds) to stop a container
    Shell           strslice.StrSlice   `json:",omitempty"` // Shell for shell-form of RUN, CMD, ENTRYPOINT
}
*/


        // set Port binding
        config := &amp;container.Config{
                Image: vmReqInfo.ImageIID.NameId,
                //Image: "panubo/sshd",
                //Cmd:   []string{"echo", "hello world"},
                //Tty:   true,
                ExposedPorts: nat.PortSet{
                                //"80/tcp": struct{}{},
                        },
        }
        // @todo now, fixed port binding. by powerkim, 2020.05.19
        hostConfig := &amp;container.HostConfig{
                PortBindings: nat.PortMap{
                        "80/tcp": []nat.PortBinding{
                                {
                                        HostIP: "0.0.0.0",
                                        HostPort: "8080",
                                },
                        },
                },
        }

/*
        hostConfig := &amp;container.HostConfig{
                PortBindings: nat.PortMap{
                        "22/tcp": []nat.PortBinding{
                                {
                                        HostIP: "0.0.0.0",
                                        HostPort: "44",
                                },
                        },
                },
        }
*/
        resp, err := vmHandler.Client.ContainerCreate(vmHandler.Context, config, hostConfig, nil, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">if err := vmHandler.Client.ContainerStart(vmHandler.Context, resp.ID, types.ContainerStartOptions{}); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
/*
        statusCh, errCh := vmHandler.Client.ContainerWait(vmHandler.Context, resp.ID, container.WaitConditionNotRunning)
        select {
        case err := &lt;-errCh:
                if err != nil {
                        cblogger.Error(err)
                        return irs.VMInfo{}, err
                }
        case &lt;-statusCh:
        }

        out, err := vmHandler.Client.ContainerLogs(vmHandler.Context, resp.ID, types.ContainerLogsOptions{ShowStdout: true})
        if err != nil {
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }
        stdcopy.StdCopy(os.Stdout, os.Stderr, out)
*/

        <span class="cov0" title="0">contJson, err := vmHandler.Client.ContainerInspect(vmHandler.Context, resp.ID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">return getVMInfoByContainerJSON(vmHandler.Region, vmReqInfo.IId, contJson), nil</span>
}

func getVMInfoByContainerJSON(regionInfo idrv.RegionInfo, vmReqIID irs.IID, contJson types.ContainerJSON) irs.VMInfo <span class="cov0" title="0">{
/* ref) https://godoc.org/github.com/docker/docker/api/types#ContainerJSON
        type ContainerJSON struct {
            *ContainerJSONBase
            Mounts          []MountPoint
            Config          *container.Config
            NetworkSettings *NetworkSettings
        }
        type ContainerJSONBase struct {
            ID              string `json:"Id"`
            Created         string
            Path            string
            Args            []string
            State           *ContainerState
            Image           string
            ResolvConfPath  string
            HostnamePath    string
            HostsPath       string
            LogPath         string
            Node            *ContainerNode `json:",omitempty"` // Node is only propagated by Docker Swarm standalone API
            Name            string
            RestartCount    int
            Driver          string
            Platform        string
            MountLabel      string
            ProcessLabel    string
            AppArmorProfile string
            ExecIDs         []string
            HostConfig      *container.HostConfig
            GraphDriver     GraphDriverData
            SizeRw          *int64 `json:",omitempty"`
            SizeRootFs      *int64 `json:",omitempty"`
        }
*/
        container := contJson.ContainerJSONBase
        networks := contJson.NetworkSettings.Networks["bridge"] // @todo Now, only bridge.

        iid := vmReqIID
        iid.SystemId = container.ID

        int64Time, _ := strconv.ParseInt(container.Created, 10, 64)

        vmInfo := irs.VMInfo{
                IId:        iid,
                StartTime:       time.Unix(int64Time, 0),
                Region:          irs.RegionInfo {regionInfo.Region, regionInfo.Zone},
                ImageIId:         irs.IID{container.Image, container.Image},
                VMSpecName:      "",
                VpcIID:          irs.IID{},
                SubnetIID:       irs.IID{},
                SecurityGroupIIds: []irs.IID{},

                KeyPairIId:     irs.IID{},

                VMUserId:       "",
                VMUserPasswd:   "",

                NetworkInterface: networks.NetworkID,
                PublicIP:         "",
                PublicDNS:        "",
                PrivateIP:        networks.IPAddress,
                PrivateDNS:       "",

                VMBootDisk:     "", // ex) /dev/sda1
                VMBlockDisk:    "", // ex)

                KeyValueList: []irs.KeyValue{},
        } 
        return vmInfo
}</span>

func (vmHandler *DockerVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called SuspendVM()!")

        err := vmHandler.Client.ContainerPause(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.Suspending, nil</span>
}

func (vmHandler *DockerVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ResumeVM()!")

        err := vmHandler.Client.ContainerUnpause(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.Resuming, nil</span>
}

func (vmHandler *DockerVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called RebootVM()!")

        err := vmHandler.Client.ContainerRestart(vmHandler.Context, vmIID.SystemId, nil)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.Rebooting, nil</span>
}

// (1) docker stop
// (2) docker rm
func (vmHandler *DockerVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called TerminateVM()!")

        err := vmHandler.Client.ContainerStop(vmHandler.Context, vmIID.SystemId, nil)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">statusCh, errCh := vmHandler.Client.ContainerWait(vmHandler.Context, vmIID.SystemId, container.WaitConditionNotRunning)
        select </span>{
        case err := &lt;-errCh:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return "", err
                }</span>
        case &lt;-statusCh:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">err = vmHandler.Client.ContainerRemove(vmHandler.Context, vmIID.SystemId, types.ContainerRemoveOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return irs.NotExist, nil</span>
}

func (vmHandler *DockerVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ListVMStatus()!")

        // []types.Container
        containers, err := vmHandler.Client.ContainerList(vmHandler.Context, types.ContainerListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return []*irs.VMStatusInfo{}, err
        }</span>

        <span class="cov0" title="0">var vmStatusInfoList []*irs.VMStatusInfo
        // Container = CM = VM
        for _, container := range containers </span><span class="cov0" title="0">{
                vmStatusInfo := irs.VMStatusInfo{irs.IID{"",container.ID}, getMappedStatus(container.State)}
                vmStatusInfoList = append(vmStatusInfoList, &amp;vmStatusInfo)
        }</span>

        <span class="cov0" title="0">return vmStatusInfoList, nil</span>
}

func getMappedStatus(containerStatus string) irs.VMStatus <span class="cov0" title="0">{
// Container Status: "created", "running", "paused", "restarting", "removing", "exited", "dead"        
// Spider Status:     Creating,  Running,  Suspended,   Rebooting,  Terminating, 

        // Set VM Status Info
        switch containerStatus </span>{
                case "created":<span class="cov0" title="0">
                        return irs.Creating</span>
                case "running":<span class="cov0" title="0">
                        return irs.Running</span>
                case "paused":<span class="cov0" title="0">
                        return irs.Suspended</span>
                case "restarting":<span class="cov0" title="0">
                        return irs.Rebooting</span>
                case "removing":<span class="cov0" title="0">
                        return irs.Terminating</span>
                default:<span class="cov0" title="0">
                        return irs.Failed</span>
        }
}

func (vmHandler *DockerVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called GetVMStatus()!")

        // types.Container
        container, err := vmHandler.Client.ContainerInspect(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">return getMappedStatus(container.State.Status), nil</span>
}

func (vmHandler *DockerVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called ListVM()!")

        // []types.Container
        containers, err := vmHandler.Client.ContainerList(vmHandler.Context, types.ContainerListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return []*irs.VMInfo{}, err
        }</span>

        <span class="cov0" title="0">var vmList []*irs.VMInfo
        // Container = CM = VM
        for _, container := range containers </span><span class="cov0" title="0">{
                vmInfo := getVMInfoByContainer(vmHandler.Region, container)        
                vmList = append(vmList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmList, nil</span>
}

func getVMInfoByContainer(regionInfo idrv.RegionInfo, container types.Container) irs.VMInfo <span class="cov0" title="0">{
/* 
type Container struct {
    ID         string `json:"Id"`
    Names      []string
    Image      string
    ImageID    string
    Command    string
    Created    int64
    Ports      []Port
    SizeRw     int64 `json:",omitempty"`
    SizeRootFs int64 `json:",omitempty"`
    Labels     map[string]string
    State      string
    Status     string
    HostConfig struct {
        NetworkMode string `json:",omitempty"`
    }
    NetworkSettings *SummaryNetworkSettings
    Mounts          []MountPoint
}
*/                

        // @todo NameId
        vmIID := irs.IID{"", container.ID}
        networks := container.NetworkSettings.Networks["bridge"] // @todo Now, only bridge.
 
        vmInfo := irs.VMInfo {
                IId:                 vmIID,
                StartTime:         time.Unix(container.Created, 0),  // @todo refine time display.
                Region:          irs.RegionInfo {regionInfo.Region, regionInfo.Zone},
                ImageIId:  irs.IID{container.Image, container.ImageID},
                VMSpecName:      "",
                VpcIID:          irs.IID{}, 
                SubnetIID:       irs.IID{},
                SecurityGroupIIds: []irs.IID{},

                KeyPairIId:        irs.IID{},

                VMUserId:        "",
                VMUserPasswd:         "",

                NetworkInterface: networks.NetworkID,
                PublicIP:         "",
                PublicDNS:        "",
                PrivateIP:        networks.IPAddress,
                PrivateDNS:       "",

                VMBootDisk:          "", // ex) /dev/sda1
                VMBlockDisk:         "", // ex)

                KeyValueList: []irs.KeyValue{},
        }

        return vmInfo
}</span>


func (vmHandler *DockerVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Docker Cloud Driver: called GetVM()!")

        // types.Container
        container, err := vmHandler.Client.ContainerInspect(vmHandler.Context, vmIID.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">return getVMInfoByContainerJSON(vmHandler.Region, vmIID, container), nil</span>
}

</pre>
		
		<pre class="file" id="file89" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by jazmandorf@gmail.com MZC

package gcp

import (
        "C"

        "context"
        "encoding/json"
        "fmt"

        gcpcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"

        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"

        o2 "golang.org/x/oauth2"
        goo "golang.org/x/oauth2/google"

        compute "google.golang.org/api/compute/v1"
)

type GCPDriver struct {
}

func (GCPDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "GCP DRIVER Version 1.0"
}</span>

func (GCPDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        //drvCapabilityInfo.VNicHandler = true
        //drvCapabilityInfo.PublicIPHandler = true
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true
        drvCapabilityInfo.VPCHandler = true

        return drvCapabilityInfo
}</span>

func (driver *GCPDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        Ctx, VMClient, err := getVMClient(connectionInfo.CredentialInfo)
        fmt.Println("################## getVMClient ##################")
        fmt.Println("getVMClient")
        fmt.Println("################## getVMClient ##################")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := gcpcon.GCPCloudConnection{
                Region:      connectionInfo.RegionInfo,
                Credential:  connectionInfo.CredentialInfo,
                Ctx:         Ctx,
                VMClient:    VMClient,
                ImageClient: VMClient,
                // PublicIPClient:      VMClient,
                SecurityGroupClient: VMClient,
                // VNetClient:          VMClient,
                // VNicClient:          VMClient,
                SubnetClient:  VMClient,
                VMSpecHandler: VMClient,
                VPCHandler:    VMClient,
        }

        //fmt.Println("################## resource ConnectionInfo ##################")
        //fmt.Println("iConn : ", iConn)
        //fmt.Println("################## resource ConnectionInfo ##################")
        return &amp;iConn, nil</span>
}

func getVMClient(credential idrv.CredentialInfo) (context.Context, *compute.Service, error) <span class="cov0" title="0">{

        // GCP   ClientSecret
        gcpType := "service_account"
        data := make(map[string]string)

        data["type"] = gcpType
        data["private_key"] = credential.PrivateKey
        data["client_email"] = credential.ClientEmail

        fmt.Println("################## data ##################")
        //fmt.Println("data to json : ", data)
        fmt.Println("################## data ##################")

        res, _ := json.Marshal(data)
        // data, err := ioutil.ReadFile(credential.ClientSecret)
        authURL := "https://www.googleapis.com/auth/compute"

        conf, err := goo.JWTConfigFromJSON(res, authURL)

        if err != nil </span><span class="cov0" title="0">{

                return nil, nil, err
        }</span>

        <span class="cov0" title="0">client := conf.Client(o2.NoContext)

        vmClient, err := compute.New(client)

        ctx := context.Background()

        return ctx, vmClient, nil</span>
}

var CloudDriver GCPDriver
</pre>
		
		<pre class="file" id="file90" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by jaz, 2019.07.

package connect

import (
        "context"

        cblog "github.com/cloud-barista/cb-log"
        gcprs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
        compute "google.golang.org/api/compute/v1"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type GCPCloudConnection struct {
        Region              idrv.RegionInfo
        Credential          idrv.CredentialInfo
        Ctx                 context.Context
        VMClient            *compute.Service
        ImageClient         *compute.Service
        PublicIPClient      *compute.Service
        SecurityGroupClient *compute.Service
        VNetClient          *compute.Service
        VNicClient          *compute.Service
        SubnetClient        *compute.Service
        VMSpecHandler       *compute.Service
        VPCHandler          *compute.Service
}

// func (cloudConn *GCPCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
//         cblogger.Info("GCP Cloud Driver: called CreateVNetworkHandler()!")

//         vNetHandler := gcprs.GCPVNetworkHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNetClient, cloudConn.Credential}
//         return &amp;vNetHandler, nil
// }

func (cloudConn *GCPCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateImageHandler()!")
        imageHandler := gcprs.GCPImageHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.ImageClient, cloudConn.Credential}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateSecurityHandler()!")
        sgHandler := gcprs.GCPSecurityHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.SecurityGroupClient, cloudConn.Credential}
        return &amp;sgHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := gcprs.GCPKeyPairHandler{cloudConn.Credential, cloudConn.Region}
        return &amp;keypairHandler, nil
}</span>

// func (cloudConn *GCPCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
//         cblogger.Info("GCP Cloud Driver: called CreateVNicHandler()!")
//         vNicHandler := gcprs.GCPVNicHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNicClient, cloudConn.Credential}
//         return &amp;vNicHandler, nil
// }

// func (cloudConn *GCPCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
//         cblogger.Info("GCP Cloud Driver: called CreatePublicIPHandler()!")
//         publicIPHandler := gcprs.GCPPublicIPHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.PublicIPClient, cloudConn.Credential}
//         return &amp;publicIPHandler, nil
// }

func (cloudConn *GCPCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateVMHandler()!")
        vmHandler := gcprs.GCPVMHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := gcprs.GCPVPCHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn *GCPCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("GCP Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := gcprs.GCPVMSpecHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
        return &amp;vmSpecHandler, nil
}</span>

func (GCPCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (GCPCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "os"

        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        CBVMUser = "cscservice"
        //CBKeyPairPath = "/cloud-control-manager/cloud-driver/driver-libs/.ssh-gcp/"
        // by powerkim, 2019.10.30
        CBKeyPairPath = "/cloud-driver-libs/.ssh-gcp/"
)

const CBDefaultVNetName string = "cb-vnet"   // CB Default Virtual Network Name
const CBDefaultSubnetName string = "cb-vnet" // CB Default Subnet Name

type GcpCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

//VPC
func GetCBDefaultVNetName() string <span class="cov0" title="0">{
        return CBDefaultVNetName
}</span>

//Subnet
func GetCBDefaultSubnetName() string <span class="cov0" title="0">{
        return CBDefaultSubnetName
}</span>

func GetKeyValueList(i map[string]interface{}) []irs.KeyValue <span class="cov0" title="0">{
        var keyValueList []irs.KeyValue
        for k, v := range i </span><span class="cov0" title="0">{
                //cblogger.Infof("K:[%s]====&gt;", k)
                _, ok := v.(string)
                if !ok </span><span class="cov0" title="0">{
                        cblogger.Errorf("Key[%s]   ", k)
                        continue</span>
                }
                //if strings.EqualFold(k, "users") {
                //        continue
                //}
                //cblogger.Infof("====&gt;", v)
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, v.(string)})
                cblogger.Info("getKeyValueList : ", keyValueList)</span>
        }

        <span class="cov0" title="0">return keyValueList</span>
}

// KeyPair   
func CreateHashString(credentialInfo idrv.CredentialInfo) (string, error) <span class="cov0" title="0">{
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + credentialInfo.TenantId + credentialInfo.SubscriptionId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}

// Public KeyPair  
func GetPublicKey(credentialInfo idrv.CredentialInfo, keyPairName string) (string, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString, err := CreateHashString(credentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"
        publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(publicKeyBytes), nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"

        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"
        compute "google.golang.org/api/compute/v1"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type GCPImageHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

/*
   GCP          .
     .
   .
Insert  
name, sourceDisk(sourceImage),storageLocations( ex : ["asia"])
      
, ,, , Cloud storage
1) Disk  :
        {"sourceDisk": "projects/mcloud-barista-251102/zones/asia-northeast1-b/disks/my-root-pd",}
2) Image  :
        {"sourceImage": "projects/mcloud-barista-251102/global/images/image-1",}



*/

func (imageHandler *GCPImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        return irs.ImageInfo{}, errors.New("Feature not implemented.")
}</span>

/*
//  Name        .
func (imageHandler *GCPImageHandler) ListImage() ([]*irs.ImageInfo, error) {

        //projectId := imageHandler.Credential.ProjectID
        projectId := "gce-uefi-images"

        // list, err := imageHandler.Client.Images.List(projectId).Do()
        list, err := imageHandler.Client.Images.List(projectId).Do()
        if err != nil {
                cblogger.Error(err)
                return nil, err
        }
        var imageList []*irs.ImageInfo
        for _, item := range list.Items {
                info := mappingImageInfo(item)
                imageList = append(imageList, &amp;info)
        }

        //spew.Dump(imageList)
        return imageList, nil
}
*/

//  Name        .
func (imageHandler *GCPImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("  ")

        //https://cloud.google.com/compute/docs/images?hl=ko
        arrImageProjectList := []string{
                "gce-uefi-images", //  VM  

                // VM   
                "centos-cloud",
                "cos-cloud",
                "coreos-cloud",
                "debian-cloud",
                "rhel-cloud",
                "rhel-sap-cloud",
                "suse-cloud",
                "suse-sap-cloud",
                "ubuntu-os-cloud",
                "windows-cloud",
                "windows-sql-cloud",
        }

        var imageList []*irs.ImageInfo

        cnt := 0
        nextPageToken := ""
        var req *compute.ImagesListCall
        var res *compute.ImageList
        var err error
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        for _, projectId := range arrImageProjectList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s]     ", projectId)

                // 
                req = imageHandler.Client.Images.List(projectId)
                res, err = req.Do()
                if err != nil </span><span class="cov0" title="0">{
                        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
                        callLogInfo.ErrorMSG = err.Error()
                        callogger.Info(call.String(callLogInfo))
                        cblogger.Errorf("[%s]      !", projectId)
                        cblogger.Error(err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">nextPageToken = res.NextPageToken
                cblogger.Debug("NextPageToken : ", nextPageToken)

                //    
                for </span><span class="cov0" title="0">{
                        for _, item := range res.Items </span><span class="cov0" title="0">{
                                cnt++
                                spew.Dump(item)
                                info := mappingImageInfo(item)
                                imageList = append(imageList, &amp;info)
                        }</span> // for :   

                        //   
                        <span class="cov0" title="0">if nextPageToken != "" </span><span class="cov0" title="0">{
                                res, err = req.PageToken(nextPageToken).Do()
                                nextPageToken = res.NextPageToken
                                cblogger.Debug("NextPageToken : ", nextPageToken)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                } // for :   
        }
        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        //spew.Dump(imageList)
        return imageList, nil</span>
}

//Name  VM  URL Image API  CB   
type GcpImageInfo struct {
        ImageUrl string //for CB(VM Start)
        Name     string //for CB
        GuestOS  string //for CB (Item.Family)
        Status   string //for CB

        ProjectId string //for image api call
        //Id        uint64 //for image api call
        Id string

        SourceType  string //for keyValue
        SourceImage string //for keyValue
        SelfLink    string //for keyValue
        Family      string //for keyValue
}

//GCP      CB    .
func (imageHandler *GCPImageHandler) ConvertGcpImageInfoToCbImageInfo(imageInfo GcpImageInfo) irs.ImageInfo <span class="cov0" title="0">{
        cblogger.Info(imageInfo)
        spew.Dump(imageInfo)

        cbImageInfo := irs.ImageInfo{
                IId: irs.IID{
                        NameId:   imageInfo.Name,
                        SystemId: imageInfo.Name,
                },
                GuestOS: imageInfo.GuestOS,
                Status:  imageInfo.Status,

                KeyValueList: []irs.KeyValue{
                        {"Name", imageInfo.Name},
                        //{"Id", strconv.FormatUint(imageInfo.Id, 10)},
                        {"Id", imageInfo.Id},
                        {"ImageUrl", imageInfo.ImageUrl},
                        {"SourceImage", imageInfo.SourceImage}, // VM  SourceImage SelfLink   .
                        {"SourceType", imageInfo.SourceType},
                        {"SelfLink", imageInfo.SelfLink},
                        {"Family", imageInfo.Family},
                        {"ProjectId", imageInfo.ProjectId},
                },
        }

        return cbImageInfo
}</span>

// #239  Name  URL   
//  URL projectId Name  .
func (imageHandler *GCPImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info(imageIID)

        //"https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/ubuntu-minimal-1804-bionic-v20200415"
        //projectId := imageHandler.Credential.ProjectID
        projectId := ""
        imageName := ""

        arrLink := strings.Split(imageIID.SystemId, "/")
        if len(arrLink) &gt; 0 </span><span class="cov0" title="0">{
                imageName = arrLink[len(arrLink)-1]
                for pos, item := range arrLink </span><span class="cov0" title="0">{
                        if strings.EqualFold(item, "projects") </span><span class="cov0" title="0">{
                                projectId = arrLink[pos+1]
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">cblogger.Infof("projectId : [%s] / imageName : [%s]", projectId, imageName)
        if projectId == "" </span><span class="cov0" title="0">{
                return irs.ImageInfo{}, errors.New("ProjectId information not found in URL.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "Images.Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        image, err := imageHandler.Client.Images.Get(projectId, imageName).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        imageInfo := mappingImageInfo(image)
        return imageInfo, nil</span>
}

// #239  Name  URL   
//     . -  GetImage()        .
func (imageHandler *GCPImageHandler) GetImageByUrl(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info(imageIID)

        //     .
        gcpImageInfo, err := imageHandler.FindImageInfo(imageIID.SystemId)
        //return irs.ImageInfo{IId: irs.IID{SystemId: gcpImageInfo.Url}}, err
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">cblogger.Info(gcpImageInfo)
        //return irs.ImageInfo{}, nil
        return imageHandler.ConvertGcpImageInfoToCbImageInfo(gcpImageInfo), nil</span>

        /*
                //projectId := imageHandler.Credential.ProjectID
                projectId := "gce-uefi-images"

                image, err := imageHandler.Client.Images.Get(projectId, imageIID.SystemId).Do()
                if err != nil {
                        cblogger.Error(err)
                        return irs.ImageInfo{}, err
                }
                imageInfo := mappingImageInfo(image)
                return imageInfo, nil
        */
}

// public Image       ?
func (imageHandler *GCPImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{

        //     .
        gcpImageInfo, err := imageHandler.FindImageInfo(imageIID.SystemId)
        //return irs.ImageInfo{IId: irs.IID{SystemId: gcpImageInfo.Url}}, err
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        //projectId := imageHandler.Credential.ProjectID
        <span class="cov0" title="0">projectId := gcpImageInfo.ProjectId
        imageId := gcpImageInfo.Id

        //res, err := imageHandler.Client.Images.Delete(projectId, imageIID.SystemId).Do()
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        res, err := imageHandler.Client.Images.Delete(projectId, imageId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        fmt.Println(res)
        return true, err</span>
}

// #239  Name  URL   
//    URL      .
//https://cloud.google.com/compute/docs/images?hl=ko
//@TODO :    ProjectId       URL      .
func (imageHandler *GCPImageHandler) FindImageInfo(reqImageName string) (GcpImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s]    ", reqImageName)

        //https://cloud.google.com/compute/docs/images?hl=ko
        arrImageProjectList := []string{
                //"ubuntu-os-cloud",

                "gce-uefi-images", //  VM  

                // VM   
                "centos-cloud",
                "cos-cloud",
                "coreos-cloud",
                "debian-cloud",
                "rhel-cloud",
                "rhel-sap-cloud",
                "suse-cloud",
                "suse-sap-cloud",
                "ubuntu-os-cloud",
                "windows-cloud",
                "windows-sql-cloud",
        }

        cnt := 0
        //curImageLink := ""
        imageInfo := GcpImageInfo{}
        nextPageToken := ""
        var req *compute.ImagesListCall
        var res *compute.ImageList
        var err error
        for _, projectId := range arrImageProjectList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s]      ", projectId)

                // 
                req = imageHandler.Client.Images.List(projectId)
                //req.Filter("name=" + reqImageName)
                //req.Filter("SelfLink=" + reqImageName)

                res, err = req.Do()
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s]      !", projectId)
                        cblogger.Error(err)
                        return GcpImageInfo{}, err
                }</span>

                <span class="cov0" title="0">nextPageToken = res.NextPageToken
                cblogger.Info("NestPageToken : ", nextPageToken)

                //    
                for </span><span class="cov0" title="0">{
                        /*
                                //list, err := imageHandler.Client.Images.List(projectId).Do() // 1000 // 500
                                req := imageHandler.Client.Images.List(projectId)
                                ret, err := req.Do()
                                cblogger.Info("First -------------&gt; ", ret.NextPageToken)
                                list, err := req.PageToken(ret.NextPageToken).Do()
                                cblogger.Info("Second -------------&gt; ", list.NextPageToken)
                        */

                        // 
                        for _, item := range res.Items </span><span class="cov0" title="0">{
                                cnt++

                                //curImageLink = imageInfo.SourceImage // SelfLink     SourceImage    . // SourceImage Name   .
                                //cblogger.Debugf(" SourceImage : [%s]", curImageLink)

                                //SourceImage   SelfLink  .
                                //SelfLink: [Output Only] Server-defined URL for the resource.
                                //if curImageLink == "" {

                                //2020-07-24 Name  URL    Split  
                                /*
                                        arrLink := strings.Split(item.SelfLink, "/")
                                        if len(arrLink) &gt; 0 {
                                                curImageLink = arrLink[len(arrLink)-1]
                                        }
                                        cblogger.Debugf("  [%d] : [%s] : [%s]", item.Id, item.SelfLink, curImageLink)
                                */
                                //cblogger.Debug("")
                                //}

                                //2020-07-24 Name  URL    SelfLink  .
                                if strings.EqualFold(reqImageName, item.SelfLink) </span><span class="cov0" title="0">{
                                        //if strings.EqualFold(reqImageName, item.Name) || strings.EqualFold(reqImageName, curImageLink) {
                                        //cblogger.Debug("=====************** !!! *********======")
                                        cblogger.Debugf("=====************** [%d] !!! *********======", cnt)
                                        if item.SelfLink == "" </span><span class="cov0" title="0">{
                                                cblogger.Errorf("  [%s]    Image URL[SelfLink] .", reqImageName)
                                                return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information does not contain URL information.")
                                        }</span>
                                        //imageInfo.Id = item.Id
                                        <span class="cov0" title="0">imageInfo.Id = strconv.FormatUint(item.Id, 10)
                                        imageInfo.ImageUrl = item.SelfLink //item.SourceImage URL  item.Name  SelfLink .

                                        imageInfo.GuestOS = item.Family
                                        imageInfo.Status = item.Status

                                        //imageInfo.Name = item.Name
                                        imageInfo.Name = item.SelfLink //2020-07-24 Name URL .  #239
                                        imageInfo.SourceImage = item.SourceImage
                                        imageInfo.SourceType = item.SourceType
                                        imageInfo.SelfLink = item.SelfLink
                                        imageInfo.Family = item.Family
                                        imageInfo.ProjectId = projectId

                                        cblogger.Info("  ")
                                        //spew.Dump(imageInfo)
                                        return imageInfo, nil</span>
                                }
                        } // for :     

                        //   
                        <span class="cov0" title="0">if nextPageToken != "" </span><span class="cov0" title="0">{
                                res, err = req.PageToken(nextPageToken).Do()
                                nextPageToken = res.NextPageToken
                                cblogger.Info("NestPageToken : ", nextPageToken)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                } // for :   
        }

        <span class="cov0" title="0">cblogger.Errorf("  [%s]      . -     : [%d]", reqImageName, cnt)
        return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information not found")</span>
}

//  Name    . - 2020-07-24 URL      .
//@TODO :    ProjectId             .
func (imageHandler *GCPImageHandler) FindImageInfoByName(reqImageName string) (GcpImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s]    ", reqImageName)

        //https://cloud.google.com/compute/docs/images?hl=ko
        arrImageProjectList := []string{
                //"ubuntu-os-cloud",

                "gce-uefi-images", //  VM  

                // VM   
                "centos-cloud",
                "cos-cloud",
                "coreos-cloud",
                "debian-cloud",
                "rhel-cloud",
                "rhel-sap-cloud",
                "suse-cloud",
                "suse-sap-cloud",
                "ubuntu-os-cloud",
                "windows-cloud",
                "windows-sql-cloud",
        }

        cnt := 0
        curImageLink := ""
        imageInfo := GcpImageInfo{}
        nextPageToken := ""
        var req *compute.ImagesListCall
        var res *compute.ImageList
        var err error
        for _, projectId := range arrImageProjectList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s]      ", projectId)

                // 
                req = imageHandler.Client.Images.List(projectId)
                req.Filter("name=" + reqImageName)

                res, err = req.Do()
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s]      !", projectId)
                        cblogger.Error(err)
                        return GcpImageInfo{}, err
                }</span>

                <span class="cov0" title="0">nextPageToken = res.NextPageToken
                cblogger.Info("NestPageToken : ", nextPageToken)

                //    
                for </span><span class="cov0" title="0">{
                        /*
                                //list, err := imageHandler.Client.Images.List(projectId).Do() // 1000 // 500
                                req := imageHandler.Client.Images.List(projectId)
                                ret, err := req.Do()
                                cblogger.Info("First -------------&gt; ", ret.NextPageToken)
                                list, err := req.PageToken(ret.NextPageToken).Do()
                                cblogger.Info("Second -------------&gt; ", list.NextPageToken)
                        */

                        // 
                        for _, item := range res.Items </span><span class="cov0" title="0">{
                                cnt++

                                //curImageLink = imageInfo.SourceImage // SelfLink     SourceImage    . // SourceImage Name   .
                                cblogger.Debugf(" SourceImage : [%s]", curImageLink)

                                //SourceImage   SelfLink  .
                                //SelfLink: [Output Only] Server-defined URL for the resource.
                                //if curImageLink == "" {

                                arrLink := strings.Split(item.SelfLink, "/")
                                if len(arrLink) &gt; 0 </span><span class="cov0" title="0">{
                                        curImageLink = arrLink[len(arrLink)-1]
                                }</span>
                                <span class="cov0" title="0">cblogger.Debugf("  [%d] : [%s] : [%s]", item.Id, item.SelfLink, curImageLink)
                                cblogger.Debug("")
                                //}

                                if strings.EqualFold(reqImageName, item.Name) || strings.EqualFold(reqImageName, curImageLink) </span><span class="cov0" title="0">{
                                        //cblogger.Debug("=====************** !!! *********======")
                                        cblogger.Infof("=====************** [%d] !!! *********======", cnt)
                                        if item.SelfLink == "" </span><span class="cov0" title="0">{
                                                cblogger.Errorf("  [%s]    Image URL[SelfLink] .", reqImageName)
                                                return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information does not contain URL information.")
                                        }</span>
                                        //imageInfo.Id = item.Id
                                        <span class="cov0" title="0">imageInfo.Id = strconv.FormatUint(item.Id, 10)
                                        imageInfo.ImageUrl = item.SelfLink //item.SourceImage URL  item.Name  SelfLink .

                                        imageInfo.GuestOS = item.Family
                                        imageInfo.Status = item.Status

                                        imageInfo.Name = item.Name
                                        imageInfo.SourceImage = item.SourceImage
                                        imageInfo.SourceType = item.SourceType
                                        imageInfo.SelfLink = item.SelfLink
                                        imageInfo.Family = item.Family
                                        imageInfo.ProjectId = projectId

                                        cblogger.Info("  ")
                                        spew.Dump(imageInfo)
                                        return imageInfo, nil</span>
                                }
                        } // for :     

                        //   
                        <span class="cov0" title="0">if nextPageToken != "" </span><span class="cov0" title="0">{
                                res, err = req.PageToken(nextPageToken).Do()
                                nextPageToken = res.NextPageToken
                                cblogger.Info("NestPageToken : ", nextPageToken)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                } // for :   
        }

        <span class="cov0" title="0">cblogger.Errorf("  [%s]      . -     : [%d]", reqImageName, cnt)
        return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information not found")</span>
}

/*
//  Id   
//  : https://cloud.google.com/compute/docs/images?hl=ko
func (imageHandler *GCPImageHandler) FindImageInfo(projectId string, reqImageName string) (GcpImageInfo, error) {
        cblogger.Infof("[%s]  [%s]    ", projectId, reqImageName)

        list, err := imageHandler.Client.Images.List(projectId).Do()
        if err != nil {
                cblogger.Error(err)
                return GcpImageInfo{}, err
        }

        imageInfo := GcpImageInfo{}
        curImageLink := ""
        for _, item := range list.Items {
                curImageLink = ""
                arrLink := strings.Split(item.SelfLink, "/")
                if len(arrLink) &gt; 0 {
                        curImageLink = arrLink[len(arrLink)-1]
                }
                cblogger.Infof("  [%s] : [%s] : [%s]", item.Id, item.SelfLink, curImageLink)

                if strings.EqualFold(reqImageName, item.Name) || strings.EqualFold(reqImageName, curImageLink) {
                        imageInfo.Id = item.Id
                        imageInfo.Url = curImageLink
                        return imageInfo, nil
                }
        }

        cblogger.Errorf("  [%s]      .", reqImageName)
        return GcpImageInfo{}, errors.New("Not Found : [" + reqImageName + "] Image information not found")
        //return GcpImageInfo{},nil
}
*/

//@TODO :     .(       ...)
func mappingImageInfo(imageInfo *compute.Image) irs.ImageInfo <span class="cov0" title="0">{
        //lArr := strings.Split(imageInfo.Licenses[0], "/")
        //os := lArr[len(lArr)-1]

        //cblogger.Info("===================================")
        //spew.Dump(imageInfo)

        imageList := irs.ImageInfo{
                IId: irs.IID{
                        NameId: imageInfo.SelfLink,
                        //NameId: imageInfo.Name, //2020-07-23         NameId SystemId 
                        //SystemId: imageInfo.Name, //    Name  . - 2020-05-14    
                        SystemId: imageInfo.SelfLink, //2020-05-14  VM  URL     (     )
                        //SystemId: strconv.FormatUint(imageInfo.Id, 10), //  VM .

                        //SystemId: imageInfo.SourceImage, //imageInfo.SourceImage  ("")  
                },
                //Id:      strconv.FormatUint(imageInfo.Id, 10),
                //Id:      imageInfo.SelfLink,
                //Name:    imageInfo.Name,
                GuestOS: imageInfo.Family,
                Status:  imageInfo.Status,
                KeyValueList: []irs.KeyValue{
                        {"Name", imageInfo.Name},
                        {"SourceImage", imageInfo.SourceImage}, // VM  SourceImage SelfLink   .
                        {"SourceType", imageInfo.SourceType},
                        {"SelfLink", imageInfo.SelfLink},
                        //{"GuestOsFeature", imageInfo.GuestOsFeatures[0].Type},        //Data       .
                        {"Family", imageInfo.Family},
                        {"DiskSizeGb", strconv.FormatInt(imageInfo.DiskSizeGb, 10)},
                },
        }

        return imageList

}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "golang.org/x/crypto/ssh"
)

type GCPKeyPairHandler struct {
        CredentialInfo idrv.CredentialInfo
        Region         idrv.RegionInfo
}

func (keyPairHandler *GCPKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        keyPairName := strings.ToLower(keyPairReqInfo.IId.NameId)
        cblogger.Infof("keyPairName [%s] --&gt; [%s]", keyPairReqInfo.IId.NameId, keyPairName)

        //projectId := keyPairHandler.CredentialInfo.ProjectID
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        //       .
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Path   .", keyPairPath)

                errDir := os.MkdirAll(keyPairPath, 0755)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path  ", keyPairPath)
                        cblogger.Error(errDir)
                        return irs.KeyPairInfo{}, errDir
                }</span>
        }

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateHashString()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        savePrivateFileTo := keyPairPath + hashString + "--" + keyPairName
        savePublicFileTo := keyPairPath + hashString + "--" + keyPairName + ".pub"
        bitSize := 4096

        // Check KeyPair Exists
        if _, err := os.Stat(savePrivateFileTo); err == nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("KeyPair with name %s already exist", keyPairName)
                createErr := errors.New(errMsg)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, createErr
        }</span>

        //   RSA  () 
        <span class="cov0" title="0">privateKey, err := generatePrivateKey(bitSize)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  RSA PEM  
        <span class="cov0" title="0">privateKeyBytes := encodePrivateKeyToPEM(privateKey)

        // rsa.PublicKey  .pub     
        // "ssh-rsa ..." 
        publicKeyBytes, err := generatePublicKey(&amp;privateKey.PublicKey)
        publicKeyString := string(publicKeyBytes)
        // projectId  cb-user 
        publicKeyString = strings.TrimSpace(publicKeyString) + " " + "cb-user"
        fmt.Println("publicKeyString : ", publicKeyString)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  private Key 
        <span class="cov0" title="0">err = writeKeyToFile(privateKeyBytes, savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        //  public Key 
        <span class="cov0" title="0">err = writeKeyToFile([]byte(publicKeyString), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairName,
                        SystemId: keyPairName,
                },
                PublicKey:  publicKeyString,
                PrivateKey: string(privateKeyBytes),
        }
        return keyPairInfo, nil</span>
}

func (keyPairHandler *GCPKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Fail CreateHashString")
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var keyPairInfoList []*irs.KeyPairInfo

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: "List",
                CloudOSAPI:   "ioutil.ReadDir()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        files, err := ioutil.ReadDir(keyPairPath)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                //cblogger.Error("Fail ReadDir(keyPairPath)")
                //cblogger.Error(err)
                //return nil, err

                //        
                return nil, nil
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        for _, f := range files </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), ".pub") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.Contains(f.Name(), hashString) </span><span class="cov0" title="0">{
                        fileNameArr := strings.Split(f.Name(), "--")
                        keypairInfo, err := keyPairHandler.GetKey(irs.IID{SystemId: fileNameArr[1]})
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Error("Fail GetKey")
                                cblogger.Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keyPairInfoList = append(keyPairInfoList, &amp;keypairInfo)</span>
                }
        }

        <span class="cov0" title="0">return keyPairInfoList, nil</span>
}

func (keyPairHandler *GCPKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("keyPairName : [%s]", keyIID.SystemId)
        keyPairName := strings.ToLower(keyIID.SystemId)
        cblogger.Infof("keyPairName   : [%s]", keyPairName)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Fail CreateHashString")
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyPairName
        publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.SystemId,
                CloudOSAPI:   "os.Stat()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //    
        if _, err := os.Stat(privateKeyPath); err != nil </span><span class="cov0" title="0">{
                callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.KeyPairInfo{}, errors.New("Not Found : [" + keyIID.SystemId + "] KeyPair Not Found.")
        }</span>
        <span class="cov0" title="0">callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        callogger.Info(call.String(callLogInfo))

        // Private Key, Public Key   
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keypairInfo := irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keyPairName,
                        SystemId: keyPairName,
                },
                PublicKey:  string(publicKeyBytes),
                PrivateKey: string(privateKeyBytes),
        }
        return keypairInfo, nil</span>
}

func (keyPairHandler *GCPKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("keyPairName : [%s]", keyIID.SystemId)
        keyPairName := strings.ToLower(keyIID.SystemId)
        cblogger.Infof("keyPairName   : [%s]", keyPairName)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString, err := CreateHashString(keyPairHandler.CredentialInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Fail CreateHashString")
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">privateKeyPath := keyPairPath + hashString + "--" + keyPairName
        publicKeyPath := keyPairPath + hashString + "--" + keyPairName + ".pub"

        //    
        if _, err := os.Stat(privateKeyPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, errors.New("Not Found : [" + keyIID.SystemId + "] KeyPair Not Found.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairName,
                CloudOSAPI:   "Remove()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        // Private Key, Public Key 
        err = os.Remove(privateKeyPath)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

//   RSA  () 
func generatePrivateKey(bitSize int) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        // Private Key 
        privateKey, err := rsa.GenerateKey(rand.Reader, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        // Private Key 
        <span class="cov0" title="0">err = privateKey.Validate()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Private Key generated()")
        //fmt.Println(privateKey)
        return privateKey, nil</span>
}

//  RSA PEM  
func encodePrivateKeyToPEM(privateKey *rsa.PrivateKey) []byte <span class="cov0" title="0">{
        // Get ASN.1 DER format
        privDER := x509.MarshalPKCS1PrivateKey(privateKey)

        // pem.Block
        privBlock := pem.Block{
                Type:    "RSA PRIVATE KEY",
                Headers: nil,
                Bytes:   privDER,
        }

        // Private key in PEM format
        privatePEM := pem.EncodeToMemory(&amp;privBlock)
        fmt.Println("privateKey Rsa -&gt; Pem  ")
        //fmt.Println(privatePEM)
        return privatePEM
}</span>

// rsa.PublicKey  .pub     
// "ssh-rsa ..." 
func generatePublicKey(privatekey *rsa.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        publicRsaKey, err := ssh.NewPublicKey(privatekey)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">pubKeyBytes := ssh.MarshalAuthorizedKey(publicRsaKey)

        log.Println("Public key ")
        //fmt.Println(pubKeyBytes)
        return pubKeyBytes, nil</span>
}

//  Key 
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key : %s", saveFileTo)
        return nil</span>
}

// Credential  hash 
/*func createHashString(credentialInfo idrv.CredentialInfo) (string, error) {
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + credentialInfo.TenantId + credentialInfo.SubscriptionId
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil {
                return "", err
        }
        return fmt.Sprintf("%x", hasher.Sum(nil)), nil
}*/
</pre>
		
		<pre class="file" id="file94" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        compute "google.golang.org/api/compute/v1"
)

type GCPSecurityHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

//@TODO : 
func (securityHandler *GCPSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Info(securityReqInfo)

        vNetworkHandler := GCPVPCHandler{
                Client:     securityHandler.Client,
                Region:     securityHandler.Region,
                Ctx:        securityHandler.Ctx,
                Credential: securityHandler.Credential,
        }

        vNetInfo, errVnet := vNetworkHandler.GetVPC(securityReqInfo.VpcIID)
        spew.Dump(vNetInfo)
        if errVnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVnet)
                return irs.SecurityInfo{}, errVnet
        }</span>

        <span class="cov0" title="0">if len(*securityReqInfo.SecurityRules) &lt; 1 </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("invalid value - The SecurityRules policy to add is empty")
        }</span>

        //GCP  1  Inbound Outbound 1    CIDR 1  1  .
        //, 1        irs.SecurityReqInfo   
        // irs.SecurityReqInfo *[]SecurityRuleInfo           .
        <span class="cov0" title="0">commonPolicy := *securityReqInfo.SecurityRules
        commonDirection := commonPolicy[0].Direction
        commonCidr := strings.Split(commonPolicy[0].CIDR, ",")

        if len(commonCidr[0]) &lt; 2 </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("invalid value - The CIDR is empty")
        }</span>

        <span class="cov0" title="0">projectID := securityHandler.Credential.ProjectID
        // @TODO: SecurityGroup     
        ports := *securityReqInfo.SecurityRules
        var firewallAllowed []*compute.FirewallAllowed

        //    All -1 .
        //GCP     All.
        //GCP  
        //https://cloud.google.com/vpc/docs/firewalls?hl=ko&amp;_ga=2.238147008.-1577666838.1589162755#protocols_and_ports
        for _, item := range ports </span><span class="cov0" title="0">{
                var port string
                fp := item.FromPort
                tp := item.ToPort

                //GCP 1  1 Direction    Inbound Outbound     .
                if !strings.EqualFold(item.Direction, commonDirection) </span><span class="cov0" title="0">{
                        return irs.SecurityInfo{}, errors.New("invalid value - GCP can only use one Direction for one security policy")
                }</span>

                // CB Rule  Port  -1   GCP Rule  .
                <span class="cov0" title="0">if fp == "-1" || tp == "-1" </span><span class="cov0" title="0">{
                        if (fp == "-1" &amp;&amp; tp == "-1") || (fp == "-1" &amp;&amp; tp == "") || (fp == "" &amp;&amp; tp == "-1") </span><span class="cov0" title="0">{
                                port = ""
                        }</span> else<span class="cov0" title="0"> if fp == "-1" </span><span class="cov0" title="0">{
                                port = tp
                        }</span> else<span class="cov0" title="0"> {
                                port = fp
                        }</span>
                } else<span class="cov0" title="0"> {
                        //   
                        if tp != "" &amp;&amp; fp != "" </span><span class="cov0" title="0">{
                                port = fp + "-" + tp
                                //From Port  
                        }</span> else<span class="cov0" title="0"> if tp != "" &amp;&amp; fp == "" </span><span class="cov0" title="0">{
                                port = tp
                                //To Port  
                        }</span> else<span class="cov0" title="0"> if tp == "" &amp;&amp; fp != "" </span><span class="cov0" title="0">{
                                port = fp
                        }</span> else<span class="cov0" title="0"> {
                                port = ""
                        }</span>
                }

                <span class="cov0" title="0">if port == "" </span><span class="cov0" title="0">{
                        firewallAllowed = append(firewallAllowed, &amp;compute.FirewallAllowed{
                                IPProtocol: item.IPProtocol,
                        })
                }</span> else<span class="cov0" title="0"> {
                        firewallAllowed = append(firewallAllowed, &amp;compute.FirewallAllowed{
                                IPProtocol: item.IPProtocol,
                                Ports: []string{
                                        port,
                                },
                        })
                }</span>
        }

        <span class="cov0" title="0">if strings.EqualFold(commonDirection, "inbound") || strings.EqualFold(commonDirection, "INGRESS") </span><span class="cov0" title="0">{
                commonDirection = "INGRESS"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(commonDirection, "outbound") || strings.EqualFold(commonDirection, "EGRESS") </span><span class="cov0" title="0">{
                commonDirection = "EGRESS"
        }</span> else<span class="cov0" title="0"> {
                // cblogger.Errorf("!!!!!!!!! SecurityReqInfo.Direction [%s]  INGRESS .", securityReqInfo.Direction)
                return irs.SecurityInfo{}, errors.New("invalid value - The direction[" + securityReqInfo.Direction + "] information is unknown")
        }</span>

        <span class="cov0" title="0">prefix := "https://www.googleapis.com/compute/v1/projects/" + projectID
        //networkURL := prefix + "/global/networks/" + securityReqInfo.VpcIID.NameId
        networkURL := prefix + "/global/networks/" + securityReqInfo.VpcIID.SystemId

        fireWall := &amp;compute.Firewall{
                Allowed:   firewallAllowed,
                Direction: commonDirection, //INGRESS(inbound), EGRESS(outbound)
                // SourceRanges: []string{
                //         // "0.0.0.0/0",
                //         commonCidr,
                // },
                Name: securityReqInfo.IId.NameId,
                TargetTags: []string{
                        securityReqInfo.IId.NameId,
                },
                Network: networkURL,
        }

        //CIDR 
        if strings.EqualFold(commonDirection, "INGRESS") </span><span class="cov0" title="0">{
                //fireWall.SourceRanges = []string{commonCidr}
                fireWall.SourceRanges = commonCidr
        }</span> else<span class="cov0" title="0"> {
                //fireWall.DestinationRanges = []string{commonCidr}
                fireWall.DestinationRanges = commonCidr
        }</span>

        <span class="cov0" title="0">cblogger.Info("  ")
        cblogger.Debug(fireWall)
        //spew.Dump(fireWall)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "Firewalls.Insert()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        res, err := securityHandler.Client.Firewalls.Insert(projectID, fireWall).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        fmt.Println("create result : ", res)
        time.Sleep(time.Second * 3)
        //secInfo, _ := securityHandler.GetSecurity(securityReqInfo.IId)
        secInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: securityReqInfo.IId.NameId})
        return secInfo, nil</span>
}

func (securityHandler *GCPSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        //result, err := securityHandler.Client.ListAll(securityHandler.Ctx)
        projectID := securityHandler.Credential.ProjectID
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "",
                CloudOSAPI:   "Firewalls.List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := securityHandler.Client.Firewalls.List(projectID).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var securityInfo []*irs.SecurityInfo
        for _, item := range result.Items </span><span class="cov0" title="0">{
                name := item.Name
                //systemId := strconv.FormatUint(item.Id, 10)
                //secInfo, _ := securityHandler.GetSecurity(irs.IID{NameId: name, SystemId: systemId})
                secInfo, _ := securityHandler.GetSecurity(irs.IID{SystemId: name})

                securityInfo = append(securityInfo, &amp;secInfo)
        }</span>

        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *GCPSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        projectID := securityHandler.Credential.ProjectID

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "Firewalls.Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        security, err := securityHandler.Client.Firewalls.Get(projectID, securityIID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var commonCidr string
        if strings.EqualFold(security.Direction, "INGRESS") </span><span class="cov0" title="0">{
                commonCidr = strings.Join(security.SourceRanges, ", ")
        }</span> else<span class="cov0" title="0"> {
                commonCidr = strings.Join(security.DestinationRanges, ", ")
        }</span>

        <span class="cov0" title="0">var securityRules []irs.SecurityRuleInfo
        for _, item := range security.Allowed </span><span class="cov0" title="0">{
                var portArr []string
                var fromPort string
                var toPort string
                if ports := item.Ports; ports != nil </span><span class="cov0" title="0">{
                        portArr = strings.Split(item.Ports[0], "-")
                        fromPort = portArr[0]
                        if len(portArr) &gt; 1 </span><span class="cov0" title="0">{
                                toPort = portArr[len(portArr)-1]
                        }</span> else<span class="cov0" title="0"> {
                                toPort = ""
                        }</span>

                } else<span class="cov0" title="0"> {
                        fromPort = ""
                        toPort = ""
                }</span>

                <span class="cov0" title="0">securityRules = append(securityRules, irs.SecurityRuleInfo{
                        FromPort:   fromPort,
                        ToPort:     toPort,
                        IPProtocol: item.IPProtocol,
                        Direction:  security.Direction,
                        CIDR:       commonCidr,
                })</span>
        }
        <span class="cov0" title="0">vpcArr := strings.Split(security.Network, "/")
        vpcName := vpcArr[len(vpcArr)-1]
        securityInfo := irs.SecurityInfo{
                IId: irs.IID{
                        NameId: security.Name,
                        //SystemId: strconv.FormatUint(security.Id, 10),
                        SystemId: security.Name,
                },
                VpcIID: irs.IID{
                        NameId:   vpcName,
                        SystemId: vpcName,
                },

                // Direction: security.Direction,
                KeyValueList: []irs.KeyValue{
                        {Key: "Priority", Value: strconv.FormatInt(security.Priority, 10)},
                        // {"SourceRanges", security.SourceRanges[0]},
                        {Key: "Allowed", Value: security.Allowed[0].IPProtocol},
                        {Key: "Vpc", Value: vpcName},
                },
                SecurityRules: &amp;securityRules,
        }

        return securityInfo, nil</span>
}

func (securityHandler *GCPSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        projectID := securityHandler.Credential.ProjectID

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        res, err := securityHandler.Client.Firewalls.Delete(projectID, securityIID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        fmt.Println(res)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        _ "errors"
        "fmt"
        "strings"
        "time"

        compute "google.golang.org/api/compute/v1"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type GCPVMHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

func (vmHandler *GCPVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // Set VM Create Information
        // GCP  reqinfo ProjectID  .
        cblogger.Info(vmReqInfo)

        //ctx := vmHandler.Ctx
        vmName := vmReqInfo.IId.NameId
        projectID := vmHandler.Credential.ProjectID
        prefix := "https://www.googleapis.com/compute/v1/projects/" + projectID
        //imageURL := "projects/ubuntu-os-cloud/global/images/ubuntu-minimal-1804-bionic-v20191024"
        imageURL := vmReqInfo.ImageIID.SystemId
        region := vmHandler.Region.Region

        zone := vmHandler.Region.Zone
        // email  ?  
        clientEmail := vmHandler.Credential.ClientEmail

        /* // 2020-05-15 Name      -    .  URL 
        // URL
        cblogger.Infof("[%s] Image Name  Image Url  .", vmReqInfo.ImageIID.SystemId)
        imageHandler := GCPImageHandler{Credential: vmHandler.Credential, Region: vmHandler.Region, Client: vmHandler.Client}

        imageInfo, errImage := imageHandler.FindImageInfo(vmReqInfo.ImageIID.SystemId)
        if errImage != nil {
                return irs.VMInfo{}, nil
        }

        cblogger.Infof("ImageName: [%s] ---&gt; ImageUrl : [%s]", vmReqInfo.ImageIID.SystemId, imageInfo.ImageUrl)
        imageURL = imageInfo.ImageUrl
        */

        //PublicIP
        // var publicIPAddress string
        // cblogger.Info("PublicIp  ")
        // publicIpHandler := GCPPublicIPHandler{
        //         vmHandler.Region, vmHandler.Ctx, vmHandler.Client, vmHandler.Credential}

        //PublicIp     Ip 
        // if vmReqInfo.PublicIPId != "" {
        //         cblogger.Info("PublicIp   ")
        //         publicIPInfo, err := publicIpHandler.GetPublicIP(vmReqInfo.PublicIPId)
        //         if err != nil {
        //                 cblogger.Error(err)
        //                 return irs.VMInfo{}, err
        //         }
        //         cblogger.Info("PublicIp ")
        //         cblogger.Info(publicIPInfo)
        //         publicIPAddress = publicIPInfo.PublicIP
        // } else { //PublicIp   
        //         cblogger.Info("PublicIp  ")
        //         // PublicIPHandler     .
        //         publicIpName := vmReqInfo.VMName
        //         publicIpReqInfo := irs.PublicIPReqInfo{Name: publicIpName}
        //         publicIPInfo, err := publicIpHandler.CreatePublicIP(publicIpReqInfo)

        //         if err != nil {
        //                 cblogger.Error(err)
        //                 return irs.VMInfo{}, err
        //         }
        //         cblogger.Info("PublicIp ")
        //         cblogger.Info(publicIPInfo)
        //         publicIPAddress = publicIPInfo.PublicIP
        // }

        //KEYPAIR HANDLER
        keypairHandler := GCPKeyPairHandler{
                vmHandler.Credential, vmHandler.Region}
        keypairInfo, errKeypair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        pubKey := "cb-user:" + keypairInfo.PublicKey
        if errKeypair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeypair)
                return irs.VMInfo{}, errKeypair
        }</span>

        <span class="cov0" title="0">cblogger.Info("keypairInfo ")
        spew.Dump(keypairInfo)

        /*
                type GCPImageHandler struct {
                        Region     idrv.RegionInfo
                        Ctx        context.Context
                        Client     *compute.Service
                        Credential idrv.CredentialInfo
                }
        */

        // Security Group Tags
        var securityTags []string
        for _, item := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                //securityTags = append(securityTags, item.NameId)
                securityTags = append(securityTags, item.SystemId)
        }</span>
        <span class="cov0" title="0">cblogger.Info("Security Tags  : ", securityTags)
        //networkURL := prefix + "/global/networks/" + vmReqInfo.VpcIID.NameId
        networkURL := prefix + "/global/networks/" + vmReqInfo.VpcIID.SystemId
        //subnetWorkURL := prefix + "/regions/" + region + "/subnetworks/" + vmReqInfo.SubnetIID.NameId
        subnetWorkURL := prefix + "/regions/" + region + "/subnetworks/" + vmReqInfo.SubnetIID.SystemId

        cblogger.Info("networkURL  : ", networkURL)
        cblogger.Info("subnetWorkURL  : ", subnetWorkURL)
        instance := &amp;compute.Instance{
                Name: vmName,
                Metadata: &amp;compute.Metadata{
                        Items: []*compute.MetadataItems{
                                {Key: "ssh-keys",
                                        Value: &amp;pubKey},
                        },
                },
                Labels: map[string]string{
                        //"keypair": strings.ToLower(vmReqInfo.KeyPairIID.NameId),
                        "keypair": strings.ToLower(vmReqInfo.KeyPairIID.SystemId),
                },
                Description: "compute sample instance",
                MachineType: prefix + "/zones/" + zone + "/machineTypes/" + vmReqInfo.VMSpecName,
                Disks: []*compute.AttachedDisk{
                        {
                                AutoDelete: true,
                                Boot:       true,
                                Type:       "PERSISTENT",
                                InitializeParams: &amp;compute.AttachedDiskInitializeParams{
                                        DiskName:    vmName + "-" + zone, //disk name     
                                        SourceImage: imageURL,
                                },
                        },
                },
                NetworkInterfaces: []*compute.NetworkInterface{
                        {
                                AccessConfigs: []*compute.AccessConfig{
                                        {
                                                Type: "ONE_TO_ONE_NAT",
                                                Name: "External NAT", // default

                                        },
                                },
                                Network:    networkURL,
                                Subnetwork: subnetWorkURL,
                        },
                },
                ServiceAccounts: []*compute.ServiceAccount{
                        {
                                Email: clientEmail,
                                Scopes: []string{
                                        compute.DevstorageFullControlScope,
                                        compute.ComputeScope,
                                },
                        },
                },
                Tags: &amp;compute.Tags{
                        Items: securityTags,
                },
        }

        cblogger.Info("VM  ")
        cblogger.Info(instance)
        spew.Dump(instance)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmName,
                CloudOSAPI:   "Insert()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        op, err1 := vmHandler.Client.Instances.Insert(projectID, zone, instance).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info("VM    ")
        cblogger.Info(op)
        spew.Dump(op)
        if err1 != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err1.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error("VM  ")
                cblogger.Error(err1)
                return irs.VMInfo{}, err1
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        /*
                js, err := op.MarshalJSON()
                if err != nil {
                        cblogger.Info("VM  ")
                        cblogger.Error(err)
                        return irs.VMInfo{}, err
                }

                cblogger.Info("Insert vm to marshal Json : ", string(js))
                cblogger.Infof("Got compute.Operation, err: %#v, %v", op, err)
        */

        //    api Start   projectID, zone, InstanceID
        //vm, err := vmHandler.Client.Instances.Start(project string, zone string, instance string)

        //time.Sleep(time.Second * 10)

        //2021-05-11 WaitForRun   GetVM()       . (     WaitForRun  .)
        vmStatus, _ := vmHandler.WaitForRun(irs.IID{NameId: vmName, SystemId: vmName})
        cblogger.Info("VM  : ", vmStatus)

        cblogger.Info("VM    - GetVM()")
        // 30  VM Running    GetVM VM    .
        vmInfo, errVmInfo := vmHandler.GetVM(irs.IID{NameId: vmName, SystemId: vmName})
        if errVmInfo != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VM     .", vmName)
                cblogger.Error(errVmInfo)
                return irs.VMInfo{}, errVmInfo
        }</span>

        //ImageIId NameId    
        <span class="cov0" title="0">vmInfo.ImageIId.NameId = vmReqInfo.ImageIID.NameId
        return vmInfo, nil</span>

        /* 2020-05-13 Start &amp; Get          
        vm, err2 := vmHandler.Client.Instances.Get(projectID, zone, vmName).Context(ctx).Do()
        if err2 != nil {
                cblogger.Error(err2)
                return irs.VMInfo{}, err2
        }
        //vmInfo := vmHandler.mappingServerInfo(vm)
        var securityTag []irs.IID

        for _, item := range vm.Tags.Items {
                iId := irs.IID{
                        NameId:   item,
                        SystemId: item,
                }

                securityTag = append(securityTag, iId)
        }
        //var vpcHandler *GCPVPCHandler
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId: vm.Name,
                        //SystemId: strconv.FormatUint(vm.Id, 10),
                        SystemId: vm.Name,
                },
                Region: irs.RegionInfo{
                        Region: vmHandler.Region.Region,
                        Zone:   vmHandler.Region.Zone,
                },
                VMUserId:          "cb-user",
                NetworkInterface:  vm.NetworkInterfaces[0].Name,
                SecurityGroupIIds: securityTag,
                VMSpecName:        vm.MachineType,
                KeyPairIId: irs.IID{
                        NameId:   vm.Labels["keypair"],
                        SystemId: vm.Labels["keypair"],
                },
                ImageIId:  vmHandler.getImageInfo(vm.Disks[0].Source),
                PublicIP:  vm.NetworkInterfaces[0].AccessConfigs[0].NatIP,
                PrivateIP: vm.NetworkInterfaces[0].NetworkIP,
                VpcIID:    vmReqInfo.VpcIID,
                SubnetIID: vmReqInfo.SubnetIID,
                KeyValueList: []irs.KeyValue{
                        {"SubNetwork", vm.NetworkInterfaces[0].Subnetwork},
                        {"AccessConfigName", vm.NetworkInterfaces[0].AccessConfigs[0].Name},
                        {"NetworkTier", vm.NetworkInterfaces[0].AccessConfigs[0].NetworkTier},
                        {"DiskDeviceName", vm.Disks[0].DeviceName},
                        {"DiskName", vm.Disks[0].Source},
                },
        }

        return vmInfo, nil
        */
}

// VM       30 
func (vmHandler *GCPVMHandler) WaitForRun(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt;  VM     Running   .")

        waitStatus := "Running"

        //===================================
        // Suspending  3   .
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)
                if curStatus == irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM  [%s]  .", curStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM  [%s]  1  .", waitStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("(%d )  VM Status  [%s]    .", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("   VM  [" + waitStatus + "]    .")
                }</span>
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}

// stop  
func (vmHandler *GCPVMHandler) SuspendVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        ctx := vmHandler.Ctx

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "Stop()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        inst, err := vmHandler.Client.Instances.Stop(projectID, zone, vmID.SystemId).Context(ctx).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(inst)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        fmt.Println("instance stop status :", inst.Status)
        return irs.VMStatus("Suspending"), nil</span>
}

func (vmHandler *GCPVMHandler) ResumeVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{

        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        ctx := vmHandler.Ctx

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "Start()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        inst, err := vmHandler.Client.Instances.Start(projectID, zone, vmID.SystemId).Context(ctx).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(inst)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        fmt.Println("instance resume status :", inst.Status)
        return irs.VMStatus("Resuming"), nil</span>
}

func (vmHandler *GCPVMHandler) RebootVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "SuspendVM()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        _, err := vmHandler.SuspendVM(vmID)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        _, err2 := vmHandler.ResumeVM(vmID)
        if err2 != nil </span><span class="cov0" title="0">{
                return irs.VMStatus("Failed"), err2
        }</span>

        <span class="cov0" title="0">return irs.VMStatus("Rebooting"), nil</span>
}

func (vmHandler *GCPVMHandler) TerminateVM(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        ctx := vmHandler.Ctx

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "Delete()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        inst, err := vmHandler.Client.Instances.Delete(projectID, zone, vmID.SystemId).Context(ctx).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        spew.Dump(inst)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        fmt.Println("instance status :", inst.Status)

        return irs.VMStatus("Terminating"), nil</span>
}

func (vmHandler *GCPVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        //serverList, err := vmHandler.Client.ListAll(vmHandler.Ctx)
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        serverList, err := vmHandler.Client.Instances.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vmStatusList []*irs.VMStatusInfo
        for _, s := range serverList.Items </span><span class="cov0" title="0">{
                if s.Name != "" </span><span class="cov0" title="0">{
                        vmId := s.Name
                        status, _ := vmHandler.GetVMStatus(irs.IID{NameId: vmId, SystemId: vmId})
                        vmStatusInfo := irs.VMStatusInfo{
                                IId: irs.IID{
                                        NameId: vmId,
                                        //SystemId: strconv.FormatUint(s.Id, 10),
                                        SystemId: vmId,
                                },

                                VmStatus: status,
                        }
                        vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
                }</span>
        }

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "PROVISIONING") </span><span class="cov0" title="0">{
                resultStatus = "Creating"
                //resultStatus = "Resuming" // Resume     Pending   Pending Resuming .
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "RUNNING") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "STOPPING") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Terminated") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "STAGING") </span><span class="cov0" title="0">{
                resultStatus = "Resuming"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]      .", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "  CB VM    .")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM   : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

func (vmHandler *GCPVMHandler) GetVMStatus(vmID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{ // GCP ID uint64  GCP Name ID .
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "GetVMStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        instanceView, err := vmHandler.Client.Instances.Get(projectID, zone, vmID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        // Get powerState, provisioningState
        //vmStatus := instanceView.Status
        vmStatus, errStatus := ConvertVMStatusString(instanceView.Status)
        //return irs.VMStatus(vmStatus), err
        return vmStatus, errStatus</span>
}

func (vmHandler *GCPVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        cblogger.Info("VMLIST zone info :", zone)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        serverList, err := vmHandler.Client.Instances.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                cblogger.Infof("  Vm List  ")
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vmList []*irs.VMInfo
        for _, server := range serverList.Items </span><span class="cov0" title="0">{
                vmInfo := vmHandler.mappingServerInfo(server)
                vmList = append(vmList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmList, nil</span>
}

func (vmHandler *GCPVMHandler) GetVM(vmID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmID.SystemId,
                CloudOSAPI:   "GetVM()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        vm, err := vmHandler.Client.Instances.Get(projectID, zone, vmID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        spew.Dump(vm)

        vmInfo := vmHandler.mappingServerInfo(vm)
        return vmInfo, nil</span>
}

// func getVmStatus(vl *compute.Service) string {
//         var powerState, provisioningState string

//         for _, stat := range vl {
//                 statArr := strings.Split(*stat.Code, "/")

//                 if statArr[0] == "PowerState" {
//                         powerState = statArr[1]
//                 } else if statArr[0] == "ProvisioningState" {
//                         provisioningState = statArr[1]
//                 }
//         }

//         // Set VM Status Info
//         var vmState string
//         if powerState != "" &amp;&amp; provisioningState != "" {
//                 vmState = powerState + "(" + provisioningState + ")"
//         } else if powerState != "" &amp;&amp; provisioningState == "" {
//                 vmState = powerState
//         } else if powerState == "" &amp;&amp; provisioningState != "" {
//                 vmState = provisioningState
//         } else {
//                 vmState = "-"
//         }
//         return vmState
// }

func (vmHandler *GCPVMHandler) mappingServerInfo(server *compute.Instance) irs.VMInfo <span class="cov0" title="0">{
        cblogger.Info("=====================================================")
        spew.Dump(server)

        //var gcpHanler *GCPVMHandler
        vpcArr := strings.Split(server.NetworkInterfaces[0].Network, "/")
        subnetArr := strings.Split(server.NetworkInterfaces[0].Subnetwork, "/")
        vpcName := vpcArr[len(vpcArr)-1]
        subnetName := subnetArr[len(subnetArr)-1]

        type IIDBox struct {
                Items []irs.IID
        }

        var iIdBox IIDBox
        for _, item := range server.Tags.Items </span><span class="cov0" title="0">{
                iId := irs.IID{
                        NameId:   item,
                        SystemId: item,
                }
                iIdBox.Items = append(iIdBox.Items, iId)
        }</span>

        <span class="cov0" title="0">vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId: server.Name,
                        //SystemId: strconv.FormatUint(server.Id, 10),
                        SystemId: server.Name,
                },
                //VMSpecName: server.MachineType,

                Region: irs.RegionInfo{
                        Region: vmHandler.Region.Region,
                        Zone:   vmHandler.Region.Zone,
                },
                VMUserId:          "cb-user",
                NetworkInterface:  server.NetworkInterfaces[0].Name,
                SecurityGroupIIds: iIdBox.Items,
                KeyPairIId: irs.IID{
                        NameId:   server.Labels["keypair"],
                        SystemId: server.Labels["keypair"],
                },
                ImageIId:  vmHandler.getImageInfo(server.Disks[0].Source),
                PublicIP:  server.NetworkInterfaces[0].AccessConfigs[0].NatIP,
                PrivateIP: server.NetworkInterfaces[0].NetworkIP,
                VpcIID: irs.IID{
                        NameId:   vpcName,
                        SystemId: vpcName,
                },
                SubnetIID: irs.IID{
                        NameId:   subnetName,
                        SystemId: subnetName,
                },
                KeyValueList: []irs.KeyValue{
                        {"SubNetwork", server.NetworkInterfaces[0].Subnetwork},
                        {"AccessConfigName", server.NetworkInterfaces[0].AccessConfigs[0].Name},
                        {"NetworkTier", server.NetworkInterfaces[0].AccessConfigs[0].NetworkTier},
                        {"DiskDeviceName", server.Disks[0].DeviceName},
                        {"DiskName", server.Disks[0].Source},
                },
        }

        arrVmSpec := strings.Split(server.MachineType, "/")
        cblogger.Info(arrVmSpec)
        if len(arrVmSpec) &gt; 1 </span><span class="cov0" title="0">{
                cblogger.Info(arrVmSpec[len(arrVmSpec)-1])
                vmInfo.VMSpecName = arrVmSpec[len(arrVmSpec)-1]
        }</span>

        //2020-05-13T00:15:37.183-07:00
        <span class="cov0" title="0">if len(server.CreationTimestamp) &gt; 5 </span><span class="cov0" title="0">{
                cblogger.Infof("    : [%s]", server.CreationTimestamp)
                t, err := time.Parse(time.RFC3339, server.CreationTimestamp)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Infof("======&gt; [%v]", t)
                        vmInfo.StartTime = t
                }</span>
        }

        <span class="cov0" title="0">return vmInfo</span>
}

// URL      
//@TODO : 2020-05-15     URL  .
func (vmHandler *GCPVMHandler) getImageInfo(diskname string) irs.IID <span class="cov0" title="0">{
        projectID := vmHandler.Credential.ProjectID
        zone := vmHandler.Region.Zone
        dArr := strings.Split(diskname, "/")
        var result string
        if dArr != nil </span><span class="cov0" title="0">{
                result = dArr[len(dArr)-1]
        }</span>
        <span class="cov0" title="0">cblogger.Infof("result : [%s]", result)

        info, err := vmHandler.Client.Disks.Get(projectID, zone, result).Do()

        cblogger.Infof("********************************** Disk  ****************")
        spew.Dump(info)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.IID{}
        }</span>

        /* 2020-05-14     
        arrImageUrl := strings.Split(info.SourceImage, "/")
        imageName := ""
        if len(arrImageUrl) &gt; 0 {
                imageName = arrImageUrl[len(arrImageUrl)-1]
        }
        iId := irs.IID{
                NameId:   imageName,
                SystemId: imageName,
        }
        */

        <span class="cov0" title="0">iId := irs.IID{
                NameId:   info.SourceImage, //2020-05-14 NameId        
                SystemId: info.SourceImage,
        }

        /*
                iId := irs.IID{
                        NameId: info.Name,
                        //SystemId: strconv.FormatUint(info.Id, 10),
                        SystemId: info.Name,
                }
        */
        return iId</span>
}

// func (vmHandler *GCPVMHandler) getKeyPairInfo(diskname string) irs.IID {
//         projectID := vmHandler.Credential.ProjectID
//         zone := vmHandler.Region.Zone
//         var gcpKeyPairHandler *GCPKeyPairHandler
//         iId := irs.IID{
//                 NameId:   "cb-user",
//                 SystemId: "cb-user",
//         }
//         result, err := gcpKeyPairHandler.GetKey(iId)

//         spew.Dump(result)
//         if err != nil {
//                 cblogger.Error(err)
//                 return result
//         }

//         return result
// }
</pre>
		
		<pre class="file" id="file96" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2020.01.

package resources

import (
        "context"
        _ "errors"
        "strconv"
        "strings"

        compute "google.golang.org/api/compute/v1"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

type GCPVMSpecHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

func (vmSpecHandler *GCPVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{

        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.MachineTypes.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return []*irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        var vmSpecInfo []*irs.VMSpecInfo
        for _, i := range resp.Items </span><span class="cov0" title="0">{
                info := irs.VMSpecInfo{
                        Region: zone,
                        Name:   i.Name,
                        VCpu: irs.VCpuInfo{
                                Count: strconv.FormatInt(i.GuestCpus, 10),
                        },
                        Mem: strconv.FormatInt(i.MemoryMb, 10),
                }
                vmSpecInfo = append(vmSpecInfo, &amp;info)
        }</span>
        <span class="cov0" title="0">return vmSpecInfo, nil</span>
}

func (vmSpecHandler *GCPVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // default info
        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        info, err := vmSpecHandler.Client.MachineTypes.Get(projectID, zone, Name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        vmSpecInfo := irs.VMSpecInfo{
                Region: Region,
                Name:   Name,
                VCpu: irs.VCpuInfo{
                        Count: strconv.FormatInt(info.GuestCpus, 10),
                        Clock: "",
                },
                Mem: strconv.FormatInt(info.MemoryMb, 10),
                Gpu: []irs.GpuInfo{
                        {
                                Count: "",
                                Mfr:   "",
                                Model: "",
                                Mem:   "",
                        },
                },
        }

        return vmSpecInfo, nil</span>
}

func (vmSpecHandler *GCPVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        resp, err := vmSpecHandler.Client.MachineTypes.List(projectID, zone).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        j, _ := resp.MarshalJSON()

        return string(j), err</span>
}

func (vmSpecHandler *GCPVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        projectID := vmSpecHandler.Credential.ProjectID
        zone := vmSpecHandler.Region.Zone

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        info, err := vmSpecHandler.Client.MachineTypes.Get(projectID, zone, Name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        j, _ := info.MarshalJSON()

        return string(j), err</span>
}

// gcp  n1     
// 1. n1   
// 2.      .
// 3.     GPU  

func CheckMachineType(Name string) bool <span class="cov0" title="0">{
        prefix := "n1"

        if ok := strings.HasPrefix(prefix, Name); ok </span><span class="cov0" title="0">{
                return ok
        }</span>

        <span class="cov0" title="0">return false</span>

}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// program by ysjeon@mz.co.kr, 2019.07.
// modify by devunet@mz.co.kr, 2019.11.

package resources

import (
        "context"
        "errors"
        "strconv"
        "strings"

        compute "google.golang.org/api/compute/v1"

        "time"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
)

type GCPVPCHandler struct {
        Region     idrv.RegionInfo
        Ctx        context.Context
        Client     *compute.Service
        Credential idrv.CredentialInfo
}

//@TODO : VPC     /            (    )
func (vVPCHandler *GCPVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        if vpcReqInfo.IId.NameId == "" </span><span class="cov0" title="0">{
                cblogger.Infof(" VPC [%s] .", vpcReqInfo.IId.NameId)
                return irs.VPCInfo{}, errors.New("Invalid Request - VPC NameId is required.")
        }</span>

        <span class="cov0" title="0">if vpcReqInfo.SubnetInfoList == nil </span><span class="cov0" title="0">{
                cblogger.Info(" VPC Subnet  .")
                return irs.VPCInfo{}, errors.New("Invalid Request - Subnet information is required.")
        }</span>

        <span class="cov0" title="0">cblogger.Infof(" [%s] VPC  ", vpcReqInfo.IId.NameId)
        _, errChkVpc := vVPCHandler.GetVPC(irs.IID{SystemId: vpcReqInfo.IId.NameId})
        if errChkVpc == nil </span><span class="cov0" title="0">{
                cblogger.Infof(" [%s] VPCs .", vpcReqInfo.IId.NameId)
                return irs.VPCInfo{}, errors.New("Already Exist - " + vpcReqInfo.IId.NameId)
        }</span>

        <span class="cov0" title="0">projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region
        name := vpcReqInfo.IId.NameId

        autoCreateSubnetworks := false // VPC     .

        network := &amp;compute.Network{
                Name: name,
                //Name:                  GetCBDefaultVNetName(),
                AutoCreateSubnetworks: autoCreateSubnetworks, // subnet    true, false
                ForceSendFields:       []string{"AutoCreateSubnetworks"},
        }

        cblogger.Infof("[%s] VPC  ", name)
        cblogger.Info(network)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "Insert()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        req, err := vVPCHandler.Client.Networks.Insert(projectID, network).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VPC  ", name)
                cblogger.Error(err)
                callLogInfo.ErrorMSG = err.Error()

                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Infof("[%s] VPC    -  ID : [%d]", name, req.Id)
        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(req.Id, 10), true)
        if errWait != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] VPC    ", name)
                cblogger.Error(errWait)
                return irs.VPCInfo{}, errWait
        }</span>

        /*
                //VPC           .
                errChkVpcStatus := vVPCHandler.WaitForRunVpc(name, true)
                if errChkVpcStatus != nil {
                        cblogger.Errorf(" VPC[%s]   ", name)
                        return irs.VPCInfo{}, errChkVpcStatus
                }
        */

        // 
        <span class="cov0" title="0">vpcNetworkUrl := "https://www.googleapis.com/compute/v1/projects/" + projectID + "/global/networks/" + vpcReqInfo.IId.NameId
        for _, item := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                subnetName := item.IId.NameId
                cblogger.Infof(" [%s] Subnet  ", subnetName)
                checkInfo, err := vVPCHandler.Client.Subnetworks.Get(projectID, region, subnetName).Do()
                if err == nil </span><span class="cov0" title="0">{
                        cblogger.Errorf(" [%s] Subnet ", subnetName)
                        return irs.VPCInfo{}, errors.New("Already Exist - " + subnetName + " Subnet is exist")
                }</span>
                <span class="cov0" title="0">cblogger.Info(" Subnet info : ", checkInfo)

                // 
                subnetWork := &amp;compute.Subnetwork{
                        Name:        subnetName,
                        IpCidrRange: item.IPv4_CIDR,
                        Network:     vpcNetworkUrl,
                }
                cblogger.Infof("[%s] Subnet ", subnetName)
                cblogger.Info(subnetWork)

                infoSubnet, errSubnet := vVPCHandler.Client.Subnetworks.Insert(projectID, region, subnetWork).Do()
                if errSubnet != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errSubnet)
                        return irs.VPCInfo{}, errors.New("Making Subnet Error - " + subnetName)
                }</span>

                <span class="cov0" title="0">spew.Dump(infoSubnet)
                //       .
                /*
                        errChkSubnetStatus := vVPCHandler.WaitForRunSubnet(subnetName, true)
                        if errChkSubnetStatus != nil {
                                cblogger.Errorf(" Subnet[%s]   ", subnetName)
                                return irs.VPCInfo{}, errChkSubnetStatus
                        }
                */
                cblogger.Infof("[%s] Subnet   -  ID : [%d]", subnetName, infoSubnet.Id)
                errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
                if errWait != nil </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%s] Subnet    ", subnetName)
                        cblogger.Error(errWait)
                        return irs.VPCInfo{}, errWait
                }</span>

                <span class="cov0" title="0">cblogger.Infof("[%s] Subnet ", subnetName)
                cblogger.Info(infoSubnet)</span>
        }

        //   .
        <span class="cov0" title="0">vpcInfo, errVPC := vVPCHandler.GetVPC(irs.IID{SystemId: vpcReqInfo.IId.NameId})
        if errVPC != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("  [%s] VPC   ", vpcReqInfo.IId.NameId)
                cblogger.Error(errVPC)
                return vpcInfo, errVPC
        }</span>
        <span class="cov0" title="0">vpcInfo.IId.NameId = vpcReqInfo.IId.NameId

        return vpcInfo, nil</span>
}

//VPC   
//waitFound : true -   ( ) / false -    ( )
func (vVPCHandler *GCPVPCHandler) WaitForRunVpc(name string, waitFound bool) error <span class="cov0" title="0">{
        cblogger.Info("======&gt; VPC   .")

        before_time := time.Now()
        max_time := 300 // 300 

        cblogger.Infof("VPC   %v  1   ", waitFound)
        for </span><span class="cov0" title="0">{
                cblogger.Infof("==&gt; [%s] VPC  ", name)
                vpcInfo, errVnet := vVPCHandler.Client.Networks.Get(vVPCHandler.Credential.ProjectID, name).Do()
                //spew.Dump(vpcInfo)

                //============================
                //  
                //============================
                if waitFound </span><span class="cov0" title="0">{
                        if errVnet != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] VPC   ", name)
                                cblogger.Error(errVnet)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]  [%s] VPC     .", max_time, name)
                                        return errVnet
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cblogger.Infof("==&gt; [%s] VPC   ", name)
                                spew.Dump(vpcInfo)
                                //cblogger.Info(vpcInfo)
                                return nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        //============================
                        //   
                        //============================
                        if errVnet == nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] VPC   ", name)
                                //cblogger.Info(vpcInfo)
                                spew.Dump(vpcInfo)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]  [%s] VPC    Wait  .", max_time, name)
                                        return errors.New("300   " + name + " VPC    Wait  .")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cblogger.Infof("==&gt; [%s] VPC  ", name)
                                return nil
                        }</span>
                } //end of if waitFound :  
        }

        <span class="cov0" title="0">return nil</span>
}

//Subnet   
//waitFound : true -   ( ) / false -    ( )
func (vVPCHandler *GCPVPCHandler) WaitForRunSubnet(subnetName string, waitFound bool) error <span class="cov0" title="0">{
        cblogger.Info("======&gt; Subnet   .")

        before_time := time.Now()
        max_time := 300 // 300 

        cblogger.Infof("Subnet   %v  1   ", waitFound)
        for </span><span class="cov0" title="0">{
                cblogger.Infof("--&gt;  [%s] Subnet  ", subnetName)
                chkInfo, err := vVPCHandler.Client.Subnetworks.Get(vVPCHandler.Credential.ProjectID, vVPCHandler.Region.Region, subnetName).Do()
                //spew.Dump(chkInfo)
                //============================
                //  
                //============================
                if waitFound </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] Subnet   ", subnetName)
                                spew.Dump(err)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]  [%s] Subnet     .", max_time, subnetName)
                                        return errors.New(" Subnet      .)")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cblogger.Infof("==&gt; [%s] Subnet   ", subnetName)
                                //cblogger.Info(chkInfo)
                                spew.Dump(chkInfo)
                                return nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        //============================
                        //   
                        //============================
                        if err == nil </span><span class="cov0" title="0">{
                                cblogger.Errorf("==&gt; [%s] Subnet   ", subnetName)
                                //cblogger.Info(chkInfo)
                                spew.Dump(chkInfo)

                                time.Sleep(time.Second * 1)
                                after_time := time.Now()
                                diff := after_time.Sub(before_time)
                                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                                        cblogger.Errorf("[%d]  [%s] Subnet    Wait  .", max_time, subnetName)
                                        return errors.New("300   " + subnetName + " Subnet    Wait  .")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                spew.Dump(err)
                                cblogger.Infof("==&gt; [%s] Subnet  ", subnetName)
                                return nil
                        }</span>
                } // end of if :   
        }

        <span class="cov0" title="0">return nil</span>
}

//https://cloud.google.com/compute/docs/reference/rest/v1/globalOperations/list
//GET https://compute.googleapis.com/compute/v1/projects/{project}/global/operations
//https://godoc.org/google.golang.org/api/compute/v1#GlobalOperationsGetCall.Do
//https://cloud.google.com/compute/docs/reference/rest/v1/globalOperations/list

//https://cloud.google.com/compute/docs/reference/rest/v1/globalOperations/get
//
// resourceId : API    
//VPC : 
//https://www.googleapis.com/compute/v1/projects/mcloud-barista2020/global/networks/cb-vpc-load-test
//Subnet : Regions
//https://www.googleapis.com/compute/v1/projects/mcloud-barista2020/regions/asia-northeast3/operations/operation-1590139586815-5a6393937274c-71aebdca-1574e4d7
// 404   global region         
func (vVPCHandler *GCPVPCHandler) WaitUntilComplete(resourceId string, isGlobalAction bool) error <span class="cov0" title="0">{
        //compute.ZoneOperationsGetCall
        //chkInfo, err := vVPCHandler.Client.Subnetworks.Get(vVPCHandler.Credential.ProjectID, vVPCHandler.Region.Region, subnetName).Do()

        //project string, operation string
        project := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region
        //resourceId := ""

        before_time := time.Now()
        max_time := 300 // 300 

        var opSatus *compute.Operation
        var err error

        for </span><span class="cov0" title="0">{
                //opSatus, err := vVPCHandler.Client.GlobalOperations.Get(project, resourceId).Do()
                if isGlobalAction </span><span class="cov0" title="0">{
                        opSatus, err = vVPCHandler.Client.GlobalOperations.Get(project, resourceId).Do()
                }</span> else<span class="cov0" title="0"> {
                        opSatus, err = vVPCHandler.Client.RegionOperations.Get(project, region, resourceId).Do()
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cblogger.Infof("==&gt;  :  : [%d] / [%s]", opSatus.Progress, opSatus.Status)

                //PENDING, RUNNING, or DONE.
                //if (opSatus.Status == "RUNNING" || opSatus.Status == "DONE") &amp;&amp; opSatus.Progress &gt;= 100 {
                if opSatus.Status == "DONE" </span><span class="cov0" title="0">{
                        cblogger.Info("    Wait .")
                        return nil
                }</span>

                <span class="cov0" title="0">time.Sleep(time.Second * 1)
                after_time := time.Now()
                diff := after_time.Sub(before_time)
                if int(diff.Seconds()) &gt; max_time </span><span class="cov0" title="0">{
                        cblogger.Errorf("[%d]  [%s]    Wait  .", max_time, resourceId)
                        return errors.New("     Wait  .)")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (vVPCHandler *GCPVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        projectID := vVPCHandler.Credential.ProjectID
        //region := vVPCHandler.Region.Region
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "",
                CloudOSAPI:   "List()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        vpcList, err := vVPCHandler.Client.Networks.List(projectID).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()

                callogger.Info(call.String(callLogInfo))

                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vpcInfo []*irs.VPCInfo

        for _, item := range vpcList.Items </span><span class="cov0" title="0">{
                iId := irs.IID{
                        NameId: item.Name,
                        //SystemId: strconv.FormatUint(item.Id, 10),
                        SystemId: item.Name,
                }
                subnetInfo, err := vVPCHandler.GetVPC(iId)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return vpcInfo, err
                }</span>

                <span class="cov0" title="0">vpcInfo = append(vpcInfo, &amp;subnetInfo)</span>

        }

        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (vVPCHandler *GCPVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{

        projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region
        //name := VPCID
        systemId := vpcIID.SystemId
        //name := vpcIID.NameId

        //cblogger.Infof("NameID : [%s] / SystemID : [%s]", name, systemId)
        cblogger.Infof("SystemID : [%s]", systemId)
        subnetInfoList := []irs.SubnetInfo{}

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "Get()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        infoVPC, err := vVPCHandler.Client.Networks.Get(projectID, systemId).Do()
        //infoVPC, err := vVPCHandler.Client.Networks.Get(projectID, name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()

                callogger.Info(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        spew.Dump(infoVPC)
        if infoVPC.Subnetworks != nil </span><span class="cov0" title="0">{
                for _, item := range infoVPC.Subnetworks </span><span class="cov0" title="0">{
                        str := strings.Split(item, "/")
                        region = str[len(str)-3]
                        subnet := str[len(str)-1]
                        infoSubnet, err := vVPCHandler.Client.Subnetworks.Get(projectID, region, subnet).Do()
                        if err != nil </span><span class="cov0" title="0">{
                                cblogger.Error(err)
                                return irs.VPCInfo{}, err
                        }</span>
                        <span class="cov0" title="0">subnetInfoList = append(subnetInfoList, mappingSubnet(infoSubnet))</span>
                }

        }

        <span class="cov0" title="0">networkInfo := irs.VPCInfo{
                IId: irs.IID{
                        NameId: infoVPC.Name,
                        //SystemId: strconv.FormatUint(infoVPC.Id, 10),
                        SystemId: infoVPC.Name,
                },
                IPv4_CIDR:      "Not support IPv4_CIDR at GCP VPC",
                SubnetInfoList: subnetInfoList,
                KeyValueList: []irs.KeyValue{
                        {"RoutingMode", infoVPC.RoutingConfig.RoutingMode},
                        {"Description", infoVPC.Description},
                        {"SelfLink", infoVPC.SelfLink},
                },
        }

        return networkInfo, nil</span>
}

func mappingSubnet(subnet *compute.Subnetwork) irs.SubnetInfo <span class="cov0" title="0">{
        //str := subnet.SelfLink
        str := strings.Split(subnet.SelfLink, "/")
        subnetName := str[len(str)-1]
        regionStr := strings.Split(subnet.Region, "/")
        region := regionStr[len(regionStr)-1]
        subnetInfo := irs.SubnetInfo{
                IId: irs.IID{
                        NameId: subnet.Name,
                        //SystemId: strconv.FormatUint(subnet.Id, 10),
                        SystemId: subnet.Name,
                },
                IPv4_CIDR: subnet.IpCidrRange,
                KeyValueList: []irs.KeyValue{
                        {"region", region},
                        {"subnet", subnetName},
                },
        }
        return subnetInfo
}</span>

func (vVPCHandler *GCPVPCHandler) DeleteVPC(vpcID irs.IID) (bool, error) <span class="cov0" title="0">{
        projectID := vVPCHandler.Credential.ProjectID
        //region := vVPCHandler.Region.Region
        //name := VPCID
        //name := vpcID.NameId
        name := vpcID.SystemId
        cblogger.Infof("Name : [%s]", name)
        subnetInfo, subErr := vVPCHandler.GetVPC(vpcID)
        if subErr != nil </span><span class="cov0" title="0">{
                cblogger.Error(subErr)
                return false, subErr
        }</span>
        <span class="cov0" title="0">if subnetInfo.SubnetInfoList != nil </span><span class="cov0" title="0">{
                for _, item := range subnetInfo.SubnetInfoList </span><span class="cov0" title="0">{
                        for _, si := range item.KeyValueList </span><span class="cov0" title="0">{
                                if si.Key == "region" </span><span class="cov0" title="0">{
                                        region := si.Value
                                        infoSubnet, infoSubErr := vVPCHandler.Client.Subnetworks.Delete(projectID, region, item.IId.NameId).Do()
                                        if infoSubErr != nil </span><span class="cov0" title="0">{
                                                //cblogger.Error(infoSubErr)
                                                return false, infoSubErr
                                        }</span>
                                        <span class="cov0" title="0">cblogger.Info("Delete subnet result :", infoSubnet)
                                        //cblogger.Info("Subnet Deleting....wait 10seconds")
                                        //time.Sleep(time.Second * 10)

                                        //   
                                        /*
                                                errChkSubnetStatus := vVPCHandler.WaitForRunSubnet(item.IId.NameId, false)
                                                if errChkSubnetStatus != nil {
                                                        return false, errChkSubnetStatus
                                                }
                                        */

                                        cblogger.Infof("[%s] Subnet   -  ID : [%d]", item.IId.NameId, infoSubnet.Id)
                                        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
                                        if errWait != nil </span><span class="cov0" title="0">{
                                                cblogger.Errorf("[%s] Subnet    ", item.IId.NameId)
                                                cblogger.Error(errWait)
                                                return false, errWait
                                        }</span>

                                }
                        }
                }
        }
        //cblogger.Info("VPC Deleting....wait 15seconds")
        //time.Sleep(time.Second * 15)
        <span class="cov0" title="0">cblogger.Info("[NOW Delete VPC]")
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcID.SystemId,
                CloudOSAPI:   "Delete()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        info, err := vVPCHandler.Client.Networks.Delete(projectID, name).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //time.Sleep(time.Second * 15)
        cblogger.Info(info)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return false, err
        }</span>

        // 
        /*
                errChkVpcStatus := vVPCHandler.WaitForRunVpc(name, false)
                if errChkVpcStatus != nil {
                        return false, errChkVpcStatus
                }
        */

        <span class="cov0" title="0">cblogger.Infof("[%s] VPC    -  ID : [%d]", name)
        errChkVpcStatus := vVPCHandler.WaitUntilComplete(strconv.FormatUint(info.Id, 10), true)
        callogger.Info(call.String(callLogInfo))
        if errChkVpcStatus != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = errChkVpcStatus.Error()
                callogger.Info(call.String(callLogInfo))
                cblogger.Errorf("[%s] Subnet    ", name)
                cblogger.Error(errChkVpcStatus)
                return false, errChkVpcStatus
        }</span>

        //fmt.Println(info)
        <span class="cov0" title="0">return true, nil</span>
}

func (VPCHandler *GCPVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet  - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        //resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        _, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>
        //cblogger.Debug(resSubnet)

        <span class="cov0" title="0">return VPCHandler.GetVPC(vpcIID)</span>
        //return irs.VPCInfo{}, nil
}

//    nil . -       .
func (vVPCHandler *GCPVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Info(reqSubnetInfo)

        projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region

        // 
        vpcNetworkUrl := "https://www.googleapis.com/compute/v1/projects/" + projectID + "/global/networks/" + vpcId
        subnetName := reqSubnetInfo.IId.NameId
        cblogger.Infof(" [%s] Subnet  ", subnetName)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        checkInfo, err := vVPCHandler.Client.Subnetworks.Get(projectID, region, subnetName).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err == nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                cblogger.Errorf(" [%s] Subnet ", subnetName)
                callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, errors.New("Already Exist - " + subnetName + " Subnet is exist")
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info("Subnet info : ", checkInfo)

        // 
        subnetWork := &amp;compute.Subnetwork{
                Name:        subnetName,
                IpCidrRange: reqSubnetInfo.IPv4_CIDR,
                Network:     vpcNetworkUrl,
        }
        cblogger.Infof("[%s] Subnet ", subnetName)
        cblogger.Info(subnetWork)

        infoSubnet, errSubnet := vVPCHandler.Client.Subnetworks.Insert(projectID, region, subnetWork).Do()
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.SubnetInfo{}, errors.New("Making Subnet Error - " + subnetName)
        }</span>

        <span class="cov0" title="0">spew.Dump(infoSubnet)
        //       .
        cblogger.Infof("[%s] Subnet   -  ID : [%d]", subnetName, infoSubnet.Id)
        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
        if errWait != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Subnet    ", subnetName)
                cblogger.Error(errWait)
                return irs.SubnetInfo{}, errWait
        }</span>

        <span class="cov0" title="0">cblogger.Infof("[%s] Subnet ", subnetName)
        cblogger.Info(infoSubnet)

        //  
        //mappingSubnet()    .

        return irs.SubnetInfo{}, nil</span>
}

func (vVPCHandler *GCPVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC [%s] Subnet ", vpcIID.SystemId, subnetIID.SystemId)

        projectID := vVPCHandler.Credential.ProjectID
        region := vVPCHandler.Region.Region

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.GCP,
                RegionZone:   vVPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        infoSubnet, infoSubErr := vVPCHandler.Client.Subnetworks.Delete(projectID, region, subnetIID.SystemId).Do()
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if infoSubErr != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = infoSubErr.Error()

                callogger.Info(call.String(callLogInfo))
                cblogger.Error(infoSubErr)
                return false, infoSubErr
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Info("Delete subnet result :", infoSubnet)

        //   
        cblogger.Infof("[%s] Subnet   -  ID : [%d]", subnetIID.SystemId, infoSubnet.Id)
        errWait := vVPCHandler.WaitUntilComplete(strconv.FormatUint(infoSubnet.Id, 10), false)
        if errWait != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] Subnet    ", subnetIID.SystemId)
                cblogger.Error(errWait)
                return false, errWait
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Mock Driver of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package mock

import (
        "C"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"

        mkcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/connect"
        mkrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type MockDriver struct{}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

func (MockDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "MOCK DRIVER Version 1.0"
}</span>

func (MockDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

func (driver *MockDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov8" title="1">{
        // &lt;standard flow&gt;
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of XXX Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/XXX_CloudConnection".
        // 4. return CloudConnection Interface of XXX_CloudConnection.

        // ex)
        // MockName = "mock01"
        iConn := mkcon.MockConnection{
                Region:   connectionInfo.RegionInfo,
                MockName: connectionInfo.CredentialInfo.MockName,
        }
        
        // Please, do not delete this line.
        mkrs.PrepareVMImage(iConn.MockName)
        mkrs.PrepareVMSpec(iConn.MockName)

        return &amp;iConn, nil
}</span>

var CloudDriver MockDriver
</pre>
		
		<pre class="file" id="file99" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.05.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        mkrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/mock/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/sirupsen/logrus"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

type MockConnection struct {
        Region   idrv.RegionInfo
        MockName string
}

func (cloudConn *MockConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateImageHandler()!")
        handler := mkrs.MockImageHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateVMHandler()!")
        handler := mkrs.MockVMHandler{cloudConn.Region, cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateVPCHandler()!")
        handler := mkrs.MockVPCHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn MockConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateSecurityHandler()!")
        handler := mkrs.MockSecurityHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateKeyPairHandler()!")
        handler := mkrs.MockKeyPairHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov8" title="1">{
        cblogger.Info("Mock Driver: called CreateVMSpecHandler()!")
        handler := mkrs.MockVMSpecHandler{cloudConn.MockName}
        return &amp;handler, nil
}</span>

func (cloudConn *MockConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        cblogger.Info("Mock Driver: called IsConnected()!")
        if cloudConn == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (cloudConn *MockConnection) Close() error <span class="cov0" title="0">{
        cblogger.Info("Mock Driver: called Close()!")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var imgInfoMap map[string][]*irs.ImageInfo

type MockImageHandler struct {
        MockName string
}

var PrepareImageInfoList []*irs.ImageInfo

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        imgInfoMap = make(map[string][]*irs.ImageInfo)
}</span>

// Be called before using the User function.
// Called in MockDriver
func PrepareVMImage(mockName string) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called PrepareVMImage()!")

        if imgInfoMap[mockName] != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">PrepareImageInfoList = []*irs.ImageInfo{
                {irs.IID{"mock-vmimage-01", "mock-vmimage-01"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-02", "mock-vmimage-02"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-03", "mock-vmimage-03"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-04", "mock-vmimage-04"}, "TestGuestOS", "TestStatus", nil},
                {irs.IID{"mock-vmimage-05", "mock-vmimage-05"}, "TestGuestOS", "TestStatus", nil},
        }
        imgInfoMap[mockName] = PrepareImageInfoList</span>
}

// (1) create imageInfo object
// (2) insert ImageInfo into global Map
func (imageHandler *MockImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateImage()!")

        mockName := imageHandler.MockName
        imageReqInfo.IId.SystemId = imageReqInfo.IId.NameId

        // (1) create imageInfo object
        imageInfo := irs.ImageInfo{irs.IID{imageReqInfo.IId.NameId, imageReqInfo.IId.SystemId}, "TestGuestOS", "TestStatus", nil}

        // (2) insert ImageInfo into global Map
        imgInfoList, _ := imgInfoMap[mockName]
        imgInfoList = append(imgInfoList, &amp;imageInfo)
        imgInfoMap[mockName] = imgInfoList

        return imageInfo, nil
}</span>

func (imageHandler *MockImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListImage()!")

        mockName := imageHandler.MockName
        imgInfoList, ok := imgInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.ImageInfo{}, nil
        }</span>
        // cloning list of Image
        <span class="cov8" title="1">resultList := make([]*irs.ImageInfo, len(imgInfoList))
        copy(resultList, imgInfoList)
        return resultList, nil</span>
}

func (imageHandler *MockImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetImage()!")

        imgInfoList, err := imageHandler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range imgInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == imageIID.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.ImageInfo{}, fmt.Errorf("%s image does not exist!!", imageIID.NameId)</span>
}

func (imageHandler *MockImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteImage()!")

        imgInfoList, err := imageHandler.ListImage()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := imageHandler.MockName
        for idx, info := range imgInfoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == imageIID.SystemId </span><span class="cov8" title="1">{
                        imgInfoList = append(imgInfoList[:idx], imgInfoList[idx+1:]...)
                        imgInfoMap[mockName] = imgInfoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        _ "github.com/sirupsen/logrus"
)

var keyPairInfoMap map[string][]*irs.KeyPairInfo

type MockKeyPairHandler struct {
        MockName string
}

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        keyPairInfoMap = make(map[string][]*irs.KeyPairInfo)
}</span>

// (1) create keyPairInfo object
// (2) insert keyPairInfo into global Map
func (keyPairHandler *MockKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateKey()!")

        mockName := keyPairHandler.MockName
        keyPairReqInfo.IId.SystemId = keyPairReqInfo.IId.NameId

        // (1) create keyPairInfo object
        keyPairInfo := irs.KeyPairInfo{keyPairReqInfo.IId,
                "XXXXFingerprint", "XXXXPublicKey", "XXXXPrivateKey", "cb-user", nil}

        // (2) insert KeyPairInfo into global Map
        infoList, _ := keyPairInfoMap[mockName]
        infoList = append(infoList, &amp;keyPairInfo)
        keyPairInfoMap[mockName] = infoList

        return keyPairInfo, nil
}</span>

func (keyPairHandler *MockKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListKey()!")

        mockName := keyPairHandler.MockName
        infoList, ok := keyPairInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.KeyPairInfo{}, nil
        }</span>
        // cloning list of KeyPair
        <span class="cov8" title="1">resultList := make([]*irs.KeyPairInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (keyPairHandler *MockKeyPairHandler) GetKey(iid irs.IID) (irs.KeyPairInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetKey()!")

        infoList, err := keyPairHandler.ListKey()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.KeyPairInfo{}, fmt.Errorf("%s keypair does not exist!!", iid.NameId)</span>
}

func (keyPairHandler *MockKeyPairHandler) DeleteKey(iid irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteKey()!")

        infoList, err := keyPairHandler.ListKey()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := keyPairHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                        keyPairInfoMap[mockName] = infoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.10.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var securityInfoMap map[string][]*irs.SecurityInfo

type MockSecurityHandler struct {
        MockName string
}

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        securityInfoMap = make(map[string][]*irs.SecurityInfo)
}</span>

// (1) create securityInfo object
// (2) insert securityInfo into global Map
func (securityHandler *MockSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateSecurity()!")

        mockName := securityHandler.MockName
        securityReqInfo.IId.SystemId = securityReqInfo.IId.NameId
        securityReqInfo.VpcIID.SystemId = securityReqInfo.VpcIID.NameId
        // (1) create securityInfo object
        securityInfo := irs.SecurityInfo{securityReqInfo.IId,
                securityReqInfo.VpcIID,
                securityReqInfo.Direction,
                securityReqInfo.SecurityRules,
                nil}

        // (2) insert SecurityInfo into global Map
        infoList, _ := securityInfoMap[mockName]
        infoList = append(infoList, &amp;securityInfo)
        securityInfoMap[mockName] = infoList

        return CloneSecurityInfo(securityInfo), nil
}</span>

func CloneSecurityInfoList(srcInfoList []*irs.SecurityInfo) []*irs.SecurityInfo <span class="cov8" title="1">{
        clonedInfoList := []*irs.SecurityInfo{}
        for _, srcInfo := range srcInfoList </span><span class="cov8" title="1">{
                clonedInfo := CloneSecurityInfo(*srcInfo)
                clonedInfoList = append(clonedInfoList, &amp;clonedInfo)
        }</span>
        <span class="cov8" title="1">return clonedInfoList</span>
}

func CloneSecurityInfo(srcInfo irs.SecurityInfo) irs.SecurityInfo <span class="cov8" title="1">{
        /*
                type SecurityInfo struct {
                        IId IID // {NameId, SystemId}
                        VpcIID        IID    // {NameId, SystemId}
                        Direction     string // @todo userd??
                        SecurityRules *[]SecurityRuleInfo
                        KeyValueList []KeyValue
                }
        */

        // clone SecurityInfo
        clonedInfo := irs.SecurityInfo{
                IId:       irs.IID{srcInfo.IId.NameId, srcInfo.IId.SystemId},
                VpcIID:    irs.IID{srcInfo.VpcIID.NameId, srcInfo.VpcIID.SystemId},
                Direction: srcInfo.Direction,

                // Need not clone
                SecurityRules: srcInfo.SecurityRules,
                KeyValueList:  srcInfo.KeyValueList,
        }

        return clonedInfo
}</span>

func (securityHandler *MockSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListSecurity()!")

        mockName := securityHandler.MockName
        infoList, ok := securityInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.SecurityInfo{}, nil
        }</span>

        <span class="cov8" title="1">return CloneSecurityInfoList(infoList), nil</span>
}

func (securityHandler *MockSecurityHandler) GetSecurity(iid irs.IID) (irs.SecurityInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetSecurity()!")

        infoList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>

        // infoList is already cloned in ListSecurity()
        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.SecurityInfo{}, fmt.Errorf("%s SecurityGroup does not exist!!", iid.NameId)</span>
}

func (securityHandler *MockSecurityHandler) DeleteSecurity(iid irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteSecurity()!")

        infoList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := securityHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                        securityInfoMap[mockName] = infoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.10.

package resources

import (
        "fmt"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var vmInfoMap map[string][]*irs.VMInfo
var vmStatusInfoMap map[string][]*irs.VMStatusInfo

type MockVMHandler struct {
        Region   idrv.RegionInfo
        MockName string
}

func init() <span class="cov8" title="1">{
        vmInfoMap = make(map[string][]*irs.VMInfo)
        vmStatusInfoMap = make(map[string][]*irs.VMStatusInfo)
}</span>

func (vmHandler *MockVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called StartVM()!")

        mockName := vmHandler.MockName
        vmReqInfo.IId.SystemId = vmReqInfo.IId.NameId

        // image validation
        imageHandler := MockImageHandler{mockName}
        validatedImgInfo, err := imageHandler.GetImage(vmReqInfo.ImageIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // spec validation
        <span class="cov8" title="1">vmSpecHandler := MockVMSpecHandler{mockName}
        validatedSpecInfo, err := vmSpecHandler.GetVMSpec(vmHandler.Region.Region, vmReqInfo.VMSpecName)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // vpc validation
        <span class="cov8" title="1">vpcHandler := MockVPCHandler{mockName}
        validatedVPCInfo, err := vpcHandler.GetVPC(vmReqInfo.VpcIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // subnet validation
        <span class="cov8" title="1">var validatedSubnetInfo *irs.SubnetInfo = nil
        for _, info := range validatedVPCInfo.SubnetInfoList </span><span class="cov8" title="1">{
                if info.IId.NameId == vmReqInfo.SubnetIID.NameId </span><span class="cov8" title="1">{
                        validatedSubnetInfo = &amp;info
                }</span>
        }
        <span class="cov8" title="1">if validatedSubnetInfo == nil </span><span class="cov0" title="0">{
                errMSG := vmReqInfo.SubnetIID.NameId + " subnet iid does not exist!!"
                cblogger.Error(errMSG)
                return irs.VMInfo{}, fmt.Errorf(errMSG)
        }</span>

        // sg validation
        <span class="cov8" title="1">securityHandler := MockSecurityHandler{mockName}
        sgInfoList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov8" title="1">validatedSgIIDs := []irs.IID{}
        for _, info1 := range vmReqInfo.SecurityGroupIIDs </span><span class="cov8" title="1">{
                flg := false
                for _, info2 := range sgInfoList </span><span class="cov8" title="1">{
                        if (*info2).IId.NameId == info1.NameId </span><span class="cov8" title="1">{
                                validatedSgIIDs = append(validatedSgIIDs, info2.IId)
                                flg = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !flg </span><span class="cov0" title="0">{
                        errMSG := info1.NameId + " security group iid does not exist!!"
                        cblogger.Error(errMSG)
                        return irs.VMInfo{}, fmt.Errorf(errMSG)
                }</span>
        }

        // keypair validation
        <span class="cov8" title="1">keyPairHandler := MockKeyPairHandler{mockName}
        validatedKeyPairInfo, err := keyPairHandler.GetKey(vmReqInfo.KeyPairIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // vm creation
        <span class="cov8" title="1">vmInfo := irs.VMInfo{
                IId:       vmReqInfo.IId,
                StartTime: time.Now(),

                Region:            irs.RegionInfo{vmHandler.Region.Region, vmHandler.Region.Zone},
                ImageIId:          validatedImgInfo.IId,
                VMSpecName:        validatedSpecInfo.Name,
                VpcIID:            validatedVPCInfo.IId,
                SubnetIID:         validatedSubnetInfo.IId,
                SecurityGroupIIds: validatedSgIIDs,

                KeyPairIId: validatedKeyPairInfo.IId,

                VMUserId:     vmReqInfo.VMUserId,
                VMUserPasswd: vmReqInfo.VMUserPasswd,

                NetworkInterface: vmReqInfo.IId.NameId + "_" + mockName + "mockni",
                PublicIP:         "4.3.2.1",
                PublicDNS:        vmReqInfo.IId.NameId + "." + mockName + ".spider.barista.com",
                PrivateIP:        "1.2.3.4",
                PrivateDNS:       vmReqInfo.IId.NameId + "." + mockName + ".spider.barista.com",

                VMBootDisk:  "/dev/sda1",
                VMBlockDisk: "/dev/sda1",

                KeyValueList: nil,
        }

        infoList, _ := vmInfoMap[mockName]
        infoList = append(infoList, &amp;vmInfo)
        vmInfoMap[mockName] = infoList

        // vm status creation
        vmStatusInfo := irs.VMStatusInfo{vmReqInfo.IId, irs.Running}

        statusInfoList, _ := vmStatusInfoMap[mockName]
        statusInfoList = append(statusInfoList, &amp;vmStatusInfo)
        vmStatusInfoMap[mockName] = statusInfoList

        return vmInfo, nil</span>
}

func (vmHandler *MockVMHandler) SuspendVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called SuspendVM()!")

        mockName := vmHandler.MockName

        statusInfoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                errMSG := mockName + " vm status does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">var validatedStatusInfo *irs.VMStatusInfo = nil
        for _, info := range statusInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        validatedStatusInfo = info
                }</span>
        }
        <span class="cov8" title="1">if validatedStatusInfo == nil </span><span class="cov0" title="0">{
                errMSG := iid.NameId + " status iid does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">validatedStatusInfo.VmStatus = irs.Suspended
        return irs.Suspending, nil</span>
}

func (vmHandler *MockVMHandler) ResumeVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ResumeVM()!")

        mockName := vmHandler.MockName

        statusInfoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{

                errMSG := mockName + " vm status does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">var validatedStatusInfo *irs.VMStatusInfo = nil
        for _, info := range statusInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        validatedStatusInfo = info
                }</span>
        }
        <span class="cov8" title="1">if validatedStatusInfo == nil </span><span class="cov0" title="0">{
                errMSG := iid.NameId + " vm status iid does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">validatedStatusInfo.VmStatus = irs.Running
        return irs.Resuming, nil</span>
}

func (vmHandler *MockVMHandler) RebootVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called RebootVM()!")

        mockName := vmHandler.MockName

        statusInfoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                errMSG := mockName + " vm status does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">var validatedStatusInfo *irs.VMStatusInfo = nil
        for _, info := range statusInfoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        validatedStatusInfo = info
                }</span>
        }
        <span class="cov8" title="1">if validatedStatusInfo == nil </span><span class="cov0" title="0">{
                errMSG := iid.NameId + " vm status iid does not exist!!"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">if validatedStatusInfo.VmStatus == irs.Suspended </span><span class="cov0" title="0">{
                errMSG := "reboot not supported in SUSPENDED status"
                cblogger.Error(errMSG)
                return "", fmt.Errorf(errMSG)
        }</span>

        <span class="cov8" title="1">validatedStatusInfo.VmStatus = irs.Running
        return irs.Rebooting, nil</span>
}

func (vmHandler *MockVMHandler) TerminateVM(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called TerminateVM()!")

        infoList, err := vmHandler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">statusInfoList, err := vmHandler.ListVMStatus()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">mockName := vmHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                }</span>
        }
        <span class="cov8" title="1">vmInfoMap[mockName] = infoList

        for idx, info := range statusInfoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        statusInfoList = append(statusInfoList[:idx], statusInfoList[idx+1:]...)
                }</span>
        }
        <span class="cov8" title="1">vmStatusInfoMap[mockName] = statusInfoList

        return irs.Terminating, nil</span>
}

func (vmHandler *MockVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVMStatus()!")

        mockName := vmHandler.MockName
        infoList, ok := vmStatusInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VMStatusInfo{}, nil
        }</span>
        // cloning list of VM Status
        <span class="cov8" title="1">resultList := make([]*irs.VMStatusInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (vmHandler *MockVMHandler) GetVMStatus(iid irs.IID) (irs.VMStatus, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVMStatus()!")

        infoList, err := vmHandler.ListVMStatus()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return (*info).VmStatus, nil
                }</span>
        }

        <span class="cov0" title="0">errMSG := iid.NameId + " status iid does not exist!!"
        cblogger.Error(errMSG)
        return "", fmt.Errorf(errMSG)</span>
}

func (vmHandler *MockVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVM()!")

        mockName := vmHandler.MockName
        infoList, ok := vmInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VMInfo{}, nil
        }</span>

        // cloning list of VM
        <span class="cov8" title="1">resultList := make([]*irs.VMInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (vmHandler *MockVMHandler) GetVM(iid irs.IID) (irs.VMInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVM()!")

        infoList, err := vmHandler.ListVM()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        // infoList is already cloned in ListVM()
        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">errMSG := iid.NameId + " vm iid does not exist!!"
        cblogger.Error(errMSG)
        return irs.VMInfo{}, fmt.Errorf(errMSG)</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.09.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var vmSpecInfoMap map[string][]*irs.VMSpecInfo

type MockVMSpecHandler struct {
        MockName string
}

var PrepareVMSpecInfoList []*irs.VMSpecInfo

func init() <span class="cov8" title="1">{
        vmSpecInfoMap = make(map[string][]*irs.VMSpecInfo)
}</span>

// Be called before using the User function.
// Called in MockDriver
func PrepareVMSpec(mockName string) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called prepare()!")

        if vmSpecInfoMap[mockName] != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">PrepareVMSpecInfoList = []*irs.VMSpecInfo{
                {"default", "mock-vmspec-01", irs.VCpuInfo{"4", "2.7"}, "32768", []irs.GpuInfo{{"2", "NVIDIA", "V100", "16384MB"}}, nil},
                {"default", "mock-vmspec-02", irs.VCpuInfo{"4", "3.2"}, "32768", []irs.GpuInfo{{"1", "NVIDIA", "V100", "16384MB"}}, nil},
                {"default", "mock-vmspec-03", irs.VCpuInfo{"8", "2.7"}, "62464", nil, nil},
                {"default", "mock-vmspec-04", irs.VCpuInfo{"8", "2.7"}, "1024", nil, nil},
        }
        vmSpecInfoMap[mockName] = PrepareVMSpecInfoList</span>
}

func (vmSpecHandler *MockVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVMSpec()!")

        mockName := vmSpecHandler.MockName

        infoList, ok := vmSpecInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VMSpecInfo{}, nil
        }</span>
        <span class="cov8" title="1">var list []*irs.VMSpecInfo
        for _, info := range infoList </span><span class="cov8" title="1">{
                if info.Region == Region </span><span class="cov8" title="1">{
                        list = append(list, info)
                }</span>
        }
        // cloning list of VMSpec
        <span class="cov8" title="1">resultList := make([]*irs.VMSpecInfo, len(list))
        copy(resultList, list)
        return resultList, nil</span>
}

func (vmSpecHandler *MockVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVMSpec()!")

        infoList, err := vmSpecHandler.ListVMSpec(Region)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMSpecInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).Name == Name </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VMSpecInfo{}, fmt.Errorf("%s VMSpec does not exist!!", Name)</span>
}

func (vmSpecHandler *MockVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov8" title="1">{ // return string: json format
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListOrgVMSpec()!")
        return "", nil
}</span>

func (vmSpecHandler *MockVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov8" title="1">{ // return string: json format
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetOrgVMSpec()!")
        return "", nil
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Mock Driver.
//
// by CB-Spider Team, 2020.10.

package resources

import (
        "fmt"

        cblog "github.com/cloud-barista/cb-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        _ "github.com/sirupsen/logrus"
)

var vpcInfoMap map[string][]*irs.VPCInfo

type MockVPCHandler struct {
        MockName string
}

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        vpcInfoMap = make(map[string][]*irs.VPCInfo)
}</span>

// (1) create vpcInfo object
// (2) insert vpcInfo into global Map
func (vpcHandler *MockVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called CreateVPC()!")

        mockName := vpcHandler.MockName
        vpcReqInfo.IId.SystemId = vpcReqInfo.IId.NameId

        // set SystemID of Subnet list
        for i, subnetInfo := range vpcReqInfo.SubnetInfoList </span><span class="cov8" title="1">{
                subnetInfo.IId.SystemId = subnetInfo.IId.NameId
                vpcReqInfo.SubnetInfoList[i] = subnetInfo
        }</span>

        // (1) create vpcInfo object
        <span class="cov8" title="1">vpcInfo := irs.VPCInfo{
                vpcReqInfo.IId,
                vpcReqInfo.IPv4_CIDR,
                vpcReqInfo.SubnetInfoList,
                nil}

        // (2) insert VPCInfo into global Map
        infoList, _ := vpcInfoMap[mockName]
        infoList = append(infoList, &amp;vpcInfo)
        vpcInfoMap[mockName] = infoList

        return vpcInfo, nil</span>
}

func (vpcHandler *MockVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called ListVPC()!")

        mockName := vpcHandler.MockName
        infoList, ok := vpcInfoMap[mockName]
        if !ok </span><span class="cov0" title="0">{
                return []*irs.VPCInfo{}, nil
        }</span>
        // cloning list of VPC
        <span class="cov8" title="1">resultList := make([]*irs.VPCInfo, len(infoList))
        copy(resultList, infoList)
        return resultList, nil</span>
}

func (vpcHandler *MockVPCHandler) GetVPC(iid irs.IID) (irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called GetVPC()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VPCInfo{}, fmt.Errorf("%s VPCGroup does not exist!!", iid.NameId)</span>
}

func (vpcHandler *MockVPCHandler) DeleteVPC(iid irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called DeleteVPC()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">mockName := vpcHandler.MockName
        for idx, info := range infoList </span><span class="cov8" title="1">{
                if info.IId.SystemId == iid.SystemId </span><span class="cov8" title="1">{
                        infoList = append(infoList[:idx], infoList[idx+1:]...)
                        vpcInfoMap[mockName] = infoList
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (vpcHandler *MockVPCHandler) AddSubnet(iid irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called AddSubnet()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>

        <span class="cov8" title="1">subnetInfo.IId.SystemId = subnetInfo.IId.NameId
        for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        info.SubnetInfoList = append(info.SubnetInfoList, subnetInfo)
                        return *info, nil
                }</span>
        }

        <span class="cov0" title="0">return irs.VPCInfo{}, fmt.Errorf("%s VPCGroup does not exist!!", iid.NameId)</span>
}

func (vpcHandler *MockVPCHandler) RemoveSubnet(iid irs.IID, subnetIID irs.IID) (bool, error) <span class="cov8" title="1">{
        cblogger := cblog.GetLogger("CB-SPIDER")
        cblogger.Info("Mock Driver: called RemoveSubnet()!")

        infoList, err := vpcHandler.ListVPC()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">for _, info := range infoList </span><span class="cov8" title="1">{
                if (*info).IId.NameId == iid.NameId </span><span class="cov8" title="1">{
                        for idx, subInfo := range info.SubnetInfoList </span><span class="cov8" title="1">{
                                if subInfo.IId.SystemId == subnetIID.SystemId </span><span class="cov8" title="1">{
                                        info.SubnetInfoList = append(info.SubnetInfoList[:idx], info.SubnetInfoList[idx+1:]...)
                                        return true, nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package openstack

import (
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack"

        oscon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/connect"
        osrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"
)

type OpenStackDriver struct{}

func (OpenStackDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "OPENSTACK DRIVER Version 1.0"
}</span>

func (OpenStackDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

// modifiled by powerkim, 2019.07.29.
func (driver *OpenStackDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        // Initialize Logger
        osrs.InitLog()

        Client, err := getServiceClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ImageClient, err := getImageClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">NetworkClient, err := getNetworkClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">VolumeClient, err := getVolumeClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := oscon.OpenStackCloudConnection{Region: connectionInfo.RegionInfo, Client: Client, ImageClient: ImageClient, NetworkClient: NetworkClient, VolumeClient: VolumeClient}

        return &amp;iConn, nil</span>
}

// moved by powerkim, 2019.07.29.
func getServiceClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{

        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }

        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := openstack.NewComputeV2(provider, gophercloud.EndpointOpts{
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, err</span>
}

func getImageClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{

        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }
        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c, err := openstack.NewImageServiceV2(provider, gophercloud.EndpointOpts{
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c, err</span>
}

func getNetworkClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{

        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }

        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := openstack.NewNetworkV2(provider, gophercloud.EndpointOpts{
                Name:   "neutron",
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, err</span>
}
func getVolumeClient(connInfo idrv.ConnectionInfo) (*gophercloud.ServiceClient, error) <span class="cov0" title="0">{
        authOpts := gophercloud.AuthOptions{
                IdentityEndpoint: connInfo.CredentialInfo.IdentityEndpoint,
                Username:         connInfo.CredentialInfo.Username,
                Password:         connInfo.CredentialInfo.Password,
                DomainName:       connInfo.CredentialInfo.DomainName,
                TenantID:         connInfo.CredentialInfo.ProjectID,
        }
        provider, err := openstack.AuthenticatedClient(authOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := openstack.NewBlockStorageV2(provider, gophercloud.EndpointOpts{
                Region: connInfo.RegionInfo.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client, err</span>
}

var CloudDriver OpenStackDriver
</pre>
		
		<pre class="file" id="file107" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by CB-Spider Team, 2019.06.

package connect

import (
        cblog "github.com/cloud-barista/cb-log"
        "github.com/gophercloud/gophercloud"
        "github.com/sirupsen/logrus"

        osrs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER")
}</span>

// OpenStackCloudConnection modified by powerkim, 2019.07.29
type OpenStackCloudConnection struct {
        Region        idrv.RegionInfo
        Client        *gophercloud.ServiceClient
        ImageClient   *gophercloud.ServiceClient
        NetworkClient *gophercloud.ServiceClient
        VolumeClient  *gophercloud.ServiceClient
}

func (cloudConn *OpenStackCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateImageHandler()!")
        imageHandler := osrs.OpenStackImageHandler{Client: cloudConn.Client, ImageClient: cloudConn.ImageClient}
        return &amp;imageHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateVPCHandler()!")
        vpcHandler := osrs.OpenStackVPCHandler{Client: cloudConn.NetworkClient}
        return &amp;vpcHandler, nil
}</span>

func (cloudConn OpenStackCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateSecurityHandler()!")
        securityHandler := osrs.OpenStackSecurityHandler{Client: cloudConn.Client, NetworkClient: cloudConn.NetworkClient}
        return &amp;securityHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateKeyPairHandler()!")
        keypairHandler := osrs.OpenStackKeyPairHandler{Client: cloudConn.Client}
        return &amp;keypairHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateVMHandler()!")
        vmHandler := osrs.OpenStackVMHandler{Region: cloudConn.Region, Client: cloudConn.Client, NetworkClient: cloudConn.NetworkClient, VolumeClient: cloudConn.VolumeClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("OpenStack Cloud Driver: called CreateVMSpecHandler()!")
        vmSpecHandler := osrs.OpenStackVMSpecHandler{Client: cloudConn.Client}
        return &amp;vmSpecHandler, nil
}</span>

func (cloudConn *OpenStackCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (cloudConn *OpenStackCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/external"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/networks"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/ports"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/subnets"
        "github.com/gophercloud/gophercloud/pagination"
        "github.com/sirupsen/logrus"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
)

const (
        CBVirutalNetworkName = "CB-VNet"
        DNSNameservers       = "8.8.8.8"
)

var once sync.Once
var cblogger *logrus.Logger
var calllogger *logrus.Logger

func InitLog() <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                // cblog is a global variable.
                cblogger = cblog.GetLogger("CB-SPIDER")
                calllogger = call.GetLogger("HISCALL")
        }</span>)
}

func LoggingError(hiscallInfo call.CLOUDLOGSCHEMA, err error) <span class="cov0" title="0">{
        cblogger.Error(err.Error())
        hiscallInfo.ErrorMSG = err.Error()
        calllogger.Info(call.String(hiscallInfo))
}</span>

func LoggingInfo(hiscallInfo call.CLOUDLOGSCHEMA, start time.Time) <span class="cov0" title="0">{
        hiscallInfo.ElapsedTime = call.Elapsed(start)
        calllogger.Info(call.String(hiscallInfo))
}</span>

func GetCallLogScheme(endpoint string, resourceType call.RES_TYPE, resourceName string, apiName string) call.CLOUDLOGSCHEMA <span class="cov0" title="0">{
        cblogger.Info(fmt.Sprintf("Call %s %s", call.OPENSTACK, apiName))
        return call.CLOUDLOGSCHEMA{
                CloudOS:      call.OPENSTACK,
                RegionZone:   endpoint,
                ResourceType: resourceType,
                ResourceName: resourceName,
                CloudOSAPI:   apiName,
        }
}</span>

func GetPublicVPCInfo(client *gophercloud.ServiceClient, typeName string) (string, error) <span class="cov0" title="0">{
        // VPC  
        iTrue := true
        listOpts := external.ListOptsExt{
                ListOptsBuilder: networks.ListOpts{},
                External:        &amp;iTrue,
        }
        page, err := networks.List(client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get vpc list, err=%s", err)
                return "", err
        }</span>
        // external VPC 
        <span class="cov0" title="0">var extVpcList []NetworkWithExt
        err = networks.ExtractNetworksInto(page, &amp;extVpcList)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get vpc list, err=%s", err)
                getErr := errors.New(fmt.Sprintf("Failed to get vpc list, err=%s", err.Error()))
                return "", getErr
        }</span>
        <span class="cov0" title="0">if len(extVpcList) == 0 </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get vpc list")
                return "", errors.New(fmt.Sprintf("Failed to get vpc list, external vpc not exist"))
        }</span>
        <span class="cov0" title="0">extVpc := extVpcList[0]
        if typeName == "ID" </span><span class="cov0" title="0">{
                return extVpc.ID, nil
        }</span> else<span class="cov0" title="0"> if typeName == "NAME" </span><span class="cov0" title="0">{
                return extVpc.Name, nil
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}

// GetCBVNetId   (CB-VNet) Id  
func GetCBVNetId(client *gophercloud.ServiceClient) (string, error) <span class="cov0" title="0">{
        listOpt := networks.ListOpts{
                Name: CBVirutalNetworkName,
        }

        var vNetworkId string

        pager := networks.List(client, listOpt)
        err := pager.EachPage(func(page pagination.Page) (bool, error) </span><span class="cov0" title="0">{
                // Get vNetwork
                list, err := networks.ExtractNetworks(page)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                // Add to List
                <span class="cov0" title="0">for _, n := range list </span><span class="cov0" title="0">{
                        vNetworkId = n.ID
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return vNetworkId, nil</span>
}

func GetFlavorByName(client *gophercloud.ServiceClient, flavorName string) (string, error) <span class="cov0" title="0">{
        pages, err := flavors.ListDetail(client, nil).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">flavorList, err := flavors.ExtractFlavors(pages)
        for _, flavor := range flavorList </span><span class="cov0" title="0">{
                if flavor.Name == flavorName </span><span class="cov0" title="0">{
                        return flavor.ID, nil
                }</span>
        }
        <span class="cov0" title="0">return "", errors.New(fmt.Sprintf("could not found Flavor with name %s ", flavorName))</span>
}

func GetSecurityByName(networkClient *gophercloud.ServiceClient, securityName string) (*secgroups.SecurityGroup, error) <span class="cov0" title="0">{
        pages, err := secgroups.List(networkClient).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">secGroupList, err := secgroups.ExtractSecurityGroups(pages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range secGroupList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, securityName) </span><span class="cov0" title="0">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New(fmt.Sprintf("could not found SecurityGroups with name %s ", securityName))</span>
}

func GetNetworkByName(networkClient *gophercloud.ServiceClient, networkName string) (*networks.Network, error) <span class="cov0" title="0">{
        pages, err := networks.List(networkClient, networks.ListOpts{Name: networkName}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">netList, err := networks.ExtractNetworks(pages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range netList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.Name, networkName) </span><span class="cov0" title="0">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New(fmt.Sprintf("could not found SecurityGroups with name %s ", networkName))</span>
}

func GetSubnetByID(networkClient *gophercloud.ServiceClient, subnetId string) (*subnets.Subnet, error) <span class="cov0" title="0">{
        subnet, err := subnets.Get(networkClient, subnetId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return subnet, nil</span>
}

func GetPortByDeviceID(networkClient *gophercloud.ServiceClient, deviceID string) (*ports.Port, error) <span class="cov0" title="0">{
        pages, err := ports.List(networkClient, ports.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">portList, err := ports.ExtractPorts(pages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range portList </span><span class="cov0" title="0">{
                if strings.EqualFold(s.DeviceID, deviceID) </span><span class="cov0" title="0">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New(fmt.Sprintf("could not found SecurityGroups with name %s ", deviceID))</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package resources

import (
        "bytes"
        "errors"
        "fmt"
        "io/ioutil"
        "os"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/images"
        "github.com/gophercloud/gophercloud/openstack/imageservice/v2/imagedata"
        imgsvc "github.com/gophercloud/gophercloud/openstack/imageservice/v2/images"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Image = "IMAGE"
)

type OpenStackImageHandler struct {
        Client      *gophercloud.ServiceClient
        ImageClient *gophercloud.ServiceClient
}

func setterImage(image images.Image) *irs.ImageInfo <span class="cov0" title="0">{
        imageInfo := &amp;irs.ImageInfo{
                IId: irs.IID{
                        NameId:   image.Name,
                        SystemId: image.ID,
                },
                Status: image.Status,
        }

        //   
        var metadataList []irs.KeyValue
        for key, val := range image.Metadata </span><span class="cov0" title="0">{
                metadata := irs.KeyValue{
                        Key:   key,
                        Value: val.(string),
                }
                metadataList = append(metadataList, metadata)
        }</span>
        <span class="cov0" title="0">imageInfo.KeyValueList = metadataList

        return imageInfo</span>
}

func (imageHandler *OpenStackImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageReqInfo.IId.NameId, "CreateImage()")

        // @TODO: Image     
        type ImageReqInfo struct {
                Name            string
                ContainerFormat string
                DiskFormat      string
        }
        reqInfo := ImageReqInfo{
                Name:            imageReqInfo.IId.NameId,
                ContainerFormat: "bare",
                DiskFormat:      "iso",
        }

        createOpts := imgsvc.CreateOpts{
                Name:            reqInfo.Name,
                ContainerFormat: reqInfo.ContainerFormat,
                DiskFormat:      reqInfo.DiskFormat,
        }

        // Check Image file exists
        rootPath := os.Getenv("CBSPIDER_ROOT")
        imageFilePath := fmt.Sprintf("%s/image/%s.iso", rootPath, reqInfo.Name)
        if _, err := os.Stat(imageFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Image files in path %s not exist", imageFilePath))
                LoggingError(hiscallInfo, createErr)
                return irs.ImageInfo{}, createErr
        }</span>

        // Create Image
        <span class="cov0" title="0">start := call.Start()
        image, err := imgsvc.Create(imageHandler.ImageClient, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Upload Image file
        imageBytes, err := ioutil.ReadFile(imageFilePath)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">result := imagedata.Upload(imageHandler.ImageClient, image.ID, bytes.NewReader(imageBytes))
        if result.Err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>

        //  Imgae  
        <span class="cov0" title="0">mappedImageInfo := images.Image{
                ID:       image.ID,
                Created:  image.CreatedAt.String(),
                MinDisk:  image.MinDiskGigabytes,
                MinRAM:   image.MinRAMMegabytes,
                Name:     image.Name,
                Status:   string(image.Status),
                Updated:  image.UpdatedAt.String(),
                Metadata: image.Properties,
        }
        imageInfo := setterImage(mappedImageInfo)
        return *imageInfo, nil</span>
}

func (imageHandler *OpenStackImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, Image, "ListImage()")

        start := call.Start()
        pager, err := images.ListDetail(imageHandler.Client, images.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageList, err := images.ExtractImages(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">imageInfoList := make([]*irs.ImageInfo, len(imageList))
        for i, img := range imageList </span><span class="cov0" title="0">{
                imageInfo := setterImage(img)
                imageInfoList[i] = imageInfo
        }</span>
        <span class="cov0" title="0">return imageInfoList, nil</span>
}

func (imageHandler *OpenStackImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "GetImage()")

        imageId, err := imageHandler.IDFromName(imageHandler.Client, imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">start := call.Start()
        image, err := images.Get(imageHandler.Client, imageId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.ImageInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        imageInfo := setterImage(*image)
        return *imageInfo, nil</span>
}

func (imageHandler *OpenStackImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(imageHandler.Client.IdentityEndpoint, call.VMIMAGE, imageIID.NameId, "DeleteImage()")

        imageId, err := imageHandler.IDFromName(imageHandler.Client, imageIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">start := call.Start()
        err = images.Delete(imageHandler.Client, imageId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}

func (imageHandler *OpenStackImageHandler) IDFromName(serviceClient *gophercloud.ServiceClient, imageName string) (string, error) <span class="cov0" title="0">{
        pager, err := images.ListDetail(serviceClient, images.ListOpts{Name: imageName}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">imageList, err := images.ExtractImages(pager)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(imageList) &gt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("found multiple images with name %s", imageName))
        }</span> else<span class="cov0" title="0"> if len(imageList) == 0 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("could not found image with name %s", imageName))
        }</span>
        <span class="cov0" title="0">return imageList[0].ID, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package resources

import (
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        KeyPair = "KEYPAIR"
)

type OpenStackKeyPairHandler struct {
        Client *gophercloud.ServiceClient
}

func setterKeypair(keypair keypairs.KeyPair) *irs.KeyPairInfo <span class="cov0" title="0">{
        keypairInfo := &amp;irs.KeyPairInfo{
                IId: irs.IID{
                        NameId:   keypair.Name,
                        SystemId: keypair.Name,
                },
                Fingerprint: keypair.Fingerprint,
                PublicKey:   keypair.PublicKey,
                PrivateKey:  keypair.PrivateKey,
        }
        return keypairInfo
}</span>

func (keyPairHandler *OpenStackKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyPairReqInfo.IId.NameId, "CreateKey()")

        create0pts := keypairs.CreateOpts{
                Name:      keyPairReqInfo.IId.NameId,
                PublicKey: "",
        }

        start := call.Start()
        keyPair, err := keypairs.Create(keyPairHandler.Client, create0pts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        //  KeyPair  
        keyPairInfo := setterKeypair(*keyPair)
        return *keyPairInfo, nil</span>
}

func (keyPairHandler *OpenStackKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, KeyPair, "ListKey()")

        //   
        start := call.Start()
        pager, err := keypairs.List(keyPairHandler.Client).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keypair, err := keypairs.ExtractKeyPairs(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        //    
        <span class="cov0" title="0">keyPairList := make([]*irs.KeyPairInfo, len(keypair))
        for i, k := range keypair </span><span class="cov0" title="0">{
                keyPairList[i] = setterKeypair(k)
        }</span>
        <span class="cov0" title="0">return keyPairList, nil</span>
}

func (keyPairHandler *OpenStackKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "GetKey()")

        start := call.Start()
        keyPair, err := keypairs.Get(keyPairHandler.Client, keyIID.NameId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.KeyPairInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        keyPairInfo := setterKeypair(*keyPair)
        return *keyPairInfo, nil</span>
}

func (keyPairHandler *OpenStackKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(keyPairHandler.Client.IdentityEndpoint, call.VMKEYPAIR, keyIID.NameId, "DeleteKey()")

        start := call.Start()
        err := keypairs.Delete(keyPairHandler.Client, keyIID.NameId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package resources

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/secgroups"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/security/rules"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        Inbound       = "inbound"
        Outbound      = "outbound"
        ICMP          = "icmp"
        SecurityGroup = "SECURITYGROUP"
)

type OpenStackSecurityHandler struct {
        Client        *gophercloud.ServiceClient
        NetworkClient *gophercloud.ServiceClient
}

func (securityHandler *OpenStackSecurityHandler) setterSeg(secGroup secgroups.SecurityGroup) *irs.SecurityInfo <span class="cov0" title="0">{
        secInfo := &amp;irs.SecurityInfo{
                IId: irs.IID{
                        NameId:   secGroup.Name,
                        SystemId: secGroup.ID,
                },
        }

        listOpts := rules.ListOpts{
                SecGroupID: secGroup.ID,
        }
        pager, err := rules.List(securityHandler.NetworkClient, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">secList, err := rules.ExtractRules(pager)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        //    
        <span class="cov0" title="0">secRuleList := make([]irs.SecurityRuleInfo, len(secList))
        for i, rule := range secList </span><span class="cov0" title="0">{
                var direction string
                if strings.EqualFold(rule.Direction, string(rules.DirIngress)) </span><span class="cov0" title="0">{
                        direction = Inbound
                }</span> else<span class="cov0" title="0"> {
                        direction = Outbound
                }</span>

                <span class="cov0" title="0">ruleInfo := irs.SecurityRuleInfo{
                        Direction:  direction,
                        IPProtocol: strings.ToLower(rule.Protocol),
                        CIDR:       rule.RemoteIPPrefix,
                }

                if strings.ToLower(rule.Protocol) == ICMP </span><span class="cov0" title="0">{
                        ruleInfo.FromPort = "-1"
                        ruleInfo.ToPort = "-1"
                }</span> else<span class="cov0" title="0"> {
                        ruleInfo.FromPort = strconv.Itoa(rule.PortRangeMin)
                        ruleInfo.ToPort = strconv.Itoa(rule.PortRangeMax)
                }</span>

                <span class="cov0" title="0">secRuleList[i] = ruleInfo</span>
        }
        <span class="cov0" title="0">secInfo.SecurityRules = &amp;secRuleList

        return secInfo</span>
}

func (securityHandler *OpenStackSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityReqInfo.IId.NameId, "CreateSecurity()")

        // Check SecurityGroup Exists
        secGroupList, err := securityHandler.ListSecurity()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">for _, sg := range secGroupList </span><span class="cov0" title="0">{
                if sg.IId.NameId == securityReqInfo.IId.NameId </span><span class="cov0" title="0">{
                        createErr := errors.New(fmt.Sprintf("Security Group with name %s already exist", securityReqInfo.IId.NameId))
                        LoggingError(hiscallInfo, createErr)
                        return irs.SecurityInfo{}, createErr
                }</span>
        }

        // Create SecurityGroup
        <span class="cov0" title="0">createOpts := secgroups.CreateOpts{
                Name:        securityReqInfo.IId.NameId,
                Description: securityReqInfo.IId.NameId,
        }

        start := call.Start()
        group, err := secgroups.Create(securityHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Create SecurityGroup Rules
        for _, rule := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{

                var direction string
                if strings.EqualFold(strings.ToLower(rule.Direction), Inbound) </span><span class="cov0" title="0">{
                        direction = string(rules.DirIngress)
                }</span> else<span class="cov0" title="0"> {
                        direction = string(rules.DirEgress)
                }</span>

                <span class="cov0" title="0">var createRuleOpts rules.CreateOpts

                if strings.ToLower(rule.IPProtocol) == ICMP </span><span class="cov0" title="0">{
                        createRuleOpts = rules.CreateOpts{
                                Direction:      rules.RuleDirection(direction),
                                EtherType:      rules.EtherType4,
                                SecGroupID:     group.ID,
                                Protocol:       rules.RuleProtocol(strings.ToLower(rule.IPProtocol)),
                                RemoteIPPrefix: rule.CIDR,
                        }
                }</span> else<span class="cov0" title="0"> {
                        fromPort, _ := strconv.Atoi(rule.FromPort)
                        toPort, _ := strconv.Atoi(rule.ToPort)
                        createRuleOpts = rules.CreateOpts{
                                Direction:      rules.RuleDirection(direction),
                                EtherType:      rules.EtherType4,
                                SecGroupID:     group.ID,
                                PortRangeMin:   fromPort,
                                PortRangeMax:   toPort,
                                Protocol:       rules.RuleProtocol(strings.ToLower(rule.IPProtocol)),
                                RemoteIPPrefix: rule.CIDR,
                        }
                }</span>

                <span class="cov0" title="0">_, err := rules.Create(securityHandler.NetworkClient, createRuleOpts).Extract()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.SecurityInfo{}, err
                }</span>
        }

        //  SecurityGroup  
        <span class="cov0" title="0">securityInfo, err := securityHandler.GetSecurity(irs.IID{SystemId: group.ID})
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">return securityInfo, nil</span>
}

func (securityHandler *OpenStackSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, SecurityGroup, "ListSecurity()")

        //   
        start := call.Start()
        pager, err := secgroups.List(securityHandler.Client).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        security, err := secgroups.ExtractSecurityGroups(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        //    
        <span class="cov0" title="0">var securityList []*irs.SecurityInfo
        securityList = make([]*irs.SecurityInfo, len(security))
        for i, v := range security </span><span class="cov0" title="0">{
                securityList[i] = securityHandler.setterSeg(v)
        }</span>
        <span class="cov0" title="0">return securityList, nil</span>
}

func (securityHandler *OpenStackSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "GetSecurity()")

        start := call.Start()
        securityGroup, err := secgroups.Get(securityHandler.Client, securityIID.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.SecurityInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        securityInfo := securityHandler.setterSeg(*securityGroup)
        return *securityInfo, nil</span>
}

func (securityHandler *OpenStackSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(securityHandler.Client.IdentityEndpoint, call.SECURITYGROUP, securityIID.NameId, "DeleteSecurity()")

        start := call.Start()
        result := secgroups.Delete(securityHandler.Client, securityIID.SystemId)
        if result.Err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, result.Err)
                return false, result.Err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by hyokyung.kim@innogrid.co.kr, 2019.07.

package resources

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "strings"
        "time"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/blockstorage/v2/volumes"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/floatingips"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/keypairs"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/startstop"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/images"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/servers"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VM             = "VM"
        SSHDefaultUser = "cb-user"
)

type OpenStackVMHandler struct {
        Region        idrv.RegionInfo
        Client        *gophercloud.ServiceClient
        NetworkClient *gophercloud.ServiceClient
        VolumeClient  *gophercloud.ServiceClient
}

func (vmHandler *OpenStackVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmReqInfo.IId.NameId, "StartVM()")

        //    
        pager, err := servers.List(vmHandler.Client, servers.ListOpts{Name: vmReqInfo.IId.NameId}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to get vm with name %s", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>
        <span class="cov0" title="0">existServer, err := servers.ExtractServers(pager)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("failed to extract vm information with name %s", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>
        <span class="cov0" title="0">if len(existServer) != 0 </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("VirtualMachine with name %s already exist", vmReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VMInfo{}, createErr
        }</span>

        /*vNetId, err := GetCBVNetId(vmHandler.NetworkClient)
        if err != nil {
                return irs.VMInfo{}, err
        }
        if vNetId == "" {
                cblogger.Error(fmt.Sprintf("failed to get vnetwork"))
                return irs.VMInfo{}, err
        }*/

        //     (Name)
        /*imageHandler := OpenStackImageHandler{
                Client: vmHandler.Client,
        }
        image, err := imageHandler.GetImage(vmReqInfo.IId)
        if err != nil {
                cblogger.Error(fmt.Sprintf("failed to get image, err : %s", err))
                return irs.VMInfo{}, err
        }*/

        //     (Name)
        /*vNetworkHandler := OpenStackVPCHandler{
                Client: vmHandler.Client,
        }
        vNetwork, err := vNetworkHandler.GetVNetwork(vmReqInfo.VirtualNetworkId)
        if err != nil {
                cblogger.Error(fmt.Sprintf("failed to get virtual network, err : %s", err))
                return irs.VMInfo{}, err
        }*/

        //    (Name)
        /*securityHandler := OpenStackSecurityHandler{
                Client:        vmHandler.Client,
                NetworkClient: vmHandler.NetworkClient,
        }
        secGroups := make([]string, len(vmReqInfo.SecurityGroupIIDs))
        for i, s := range vmReqInfo.SecurityGroupIIDs {
                security, err := securityHandler.GetSecurity(s)
                if err != nil {
                        cblogger.Error(fmt.Sprintf("failed to get security group, err : %s", err))
                        return irs.VMInfo{}, err
                        //continue
                }
                secGroups[i] = security.IId.SystemId
        }*/

        // Flavor   (Name)
        /*flavorId, err := GetFlavor(vmHandler.Client, vmReqInfo.VMSpecName)
        if err != nil {
                cblogger.Error(fmt.Sprintf("failed to get vm spec, err : %s", err))
                return irs.VMInfo{}, err
        }*/

        //     (Name)
        <span class="cov0" title="0">imageHandler := OpenStackImageHandler{
                Client: vmHandler.Client,
        }
        image, err := imageHandler.GetImage(vmReqInfo.ImageIID)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(fmt.Sprintf("failed to get image, err : %s", err))
                return irs.VMInfo{}, err
        }</span>

        // Flavor   (Name)
        <span class="cov0" title="0">vmSpecId, err := GetFlavorByName(vmHandler.Client, vmReqInfo.VMSpecName)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        // VM 
        <span class="cov0" title="0">serverCreateOpts := servers.CreateOpts{
                Name: vmReqInfo.IId.NameId,
                //ImageName: vmReqInfo.ImageIID.NameId,
                ImageRef: image.IId.SystemId,
                //FlavorName: vmReqInfo.VMSpecName,
                FlavorRef: vmSpecId,
                Networks: []servers.Network{
                        {UUID: vmReqInfo.VpcIID.SystemId},
                },
        }

        sgIdArr := make([]string, len(vmReqInfo.SecurityGroupIIDs))
        for i, sg := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                sgIdArr[i] = sg.SystemId
        }</span>
        <span class="cov0" title="0">serverCreateOpts.SecurityGroups = sgIdArr

        // Add KeyPair
        createOpts := keypairs.CreateOptsExt{
                KeyName: vmReqInfo.KeyPairIID.NameId,
        }

        // KeyPair  
        keyPair, err := keypairs.Get(vmHandler.Client, vmReqInfo.KeyPairIID.NameId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>

        // cloud-init  
        <span class="cov0" title="0">rootPath := os.Getenv("CBSPIDER_ROOT")
        fileData, err := ioutil.ReadFile(rootPath + "/cloud-driver-libs/.cloud-init-openstack/cloud-init")
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">fileStr := string(fileData)
        fileStr = strings.ReplaceAll(fileStr, "{{username}}", SSHDefaultUser)
        fileStr = strings.ReplaceAll(fileStr, "{{public_key}}", keyPair.PublicKey)

        // cloud-init  
        serverCreateOpts.UserData = []byte(fileStr)
        createOpts.CreateOptsBuilder = serverCreateOpts

        start := call.Start()
        server, err := servers.Create(vmHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var serverResult *servers.Server
        var serverInfo irs.VMInfo

        // VM   wait
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                // Check VM Deploy Status
                serverResult, err = servers.Get(vmHandler.Client, server.ID).Extract()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.VMInfo{}, err
                }</span>

                <span class="cov0" title="0">if strings.ToLower(serverResult.Status) == "active" </span><span class="cov0" title="0">{
                        // Associate Public IP
                        if ok, err := vmHandler.AssociatePublicIP(serverResult.ID); !ok </span><span class="cov0" title="0">{
                                LoggingError(hiscallInfo, err)
                                return irs.VMInfo{}, err
                        }</span>
                        // Get server info
                        <span class="cov0" title="0">serverResult, err = servers.Get(vmHandler.Client, server.ID).Extract()
                        serverInfo = vmHandler.mappingServerInfo(*serverResult)
                        break</span>
                }
                <span class="cov0" title="0">curRetryCnt++
                time.Sleep(1 * time.Second)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                        return irs.VMInfo{}, errors.New(fmt.Sprintf("failed to start vm, exceeded maximum retry count %d", maxRetryCnt))
                }</span>
        }

        <span class="cov0" title="0">return serverInfo, nil</span>
}

func (vmHandler *OpenStackVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "SuspendVM()")

        /*vmID, err := vmHandler.getVmIdByName(vmNameID)
        if err != nil {
                cblogger.Error(err)
                return irs.Failed, err
        }*/
        start := call.Start()
        err := startstop.Stop(vmHandler.Client, vmIID.SystemId).Err
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        //   (OpenStack      )
        return irs.Suspending, nil</span>
}

func (vmHandler *OpenStackVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "ResumeVM()")

        /*vmID, err := vmHandler.getVmIdByName(vmNameID)
        if err != nil {
                cblogger.Error(err)
                return irs.Failed, err
        }*/
        start := call.Start()
        err := startstop.Start(vmHandler.Client, vmIID.SystemId).Err
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        //   (OpenStack      )
        return irs.Resuming, nil</span>
}

func (vmHandler *OpenStackVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "RebootVM()")

        /*vmID, err := vmHandler.getVmIdByName(vmNameID)
        if err != nil {
                cblogger.Error(err)
                return irs.Failed, err
        }*/
        start := call.Start()
        rebootOpts := servers.RebootOpts{
                Type: servers.SoftReboot,
        }

        err := servers.Reboot(vmHandler.Client, vmIID.SystemId, rebootOpts).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        //   (OpenStack      )
        return irs.Rebooting, nil</span>
}

func (vmHandler *OpenStackVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "TerminateVM()")

        // VM  
        server, err := vmHandler.GetVM(vmIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // VM  PublicIP 
        <span class="cov0" title="0">pager, err := floatingips.List(vmHandler.Client).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">publicIPList, err := floatingips.ExtractFloatingIPs(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>

        // IP  PublicIP 
        <span class="cov0" title="0">var publicIPId string
        for _, p := range publicIPList </span><span class="cov0" title="0">{
                if strings.EqualFold(server.PublicIP, p.IP) </span><span class="cov0" title="0">{
                        publicIPId = p.ID
                        break</span>
                }
        }
        // Public IP 
        <span class="cov0" title="0">if publicIPId != "" </span><span class="cov0" title="0">{
                err := floatingips.Delete(vmHandler.Client, publicIPId).ExtractErr()
                if err != nil </span><span class="cov0" title="0">{
                        LoggingError(hiscallInfo, err)
                        return irs.Failed, err
                }</span>
        }

        // VM 
        <span class="cov0" title="0">start := call.Start()
        err = servers.Delete(vmHandler.Client, server.IId.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.Failed, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        //   (OpenStack      )
        return irs.Terminating, nil</span>
}

func (vmHandler *OpenStackVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVMStatus()")

        start := call.Start()
        pager, err := servers.List(vmHandler.Client, nil).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        servers, err := servers.ExtractServers(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        // Add to List
        <span class="cov0" title="0">vmStatusList := make([]*irs.VMStatusInfo, len(servers))
        for idx, s := range servers </span><span class="cov0" title="0">{
                vmStatus := getVmStatus(s.Status)
                vmStatusInfo := irs.VMStatusInfo{
                        IId: irs.IID{
                                NameId:   s.Name,
                                SystemId: s.ID,
                        },
                        VmStatus: vmStatus,
                }
                vmStatusList[idx] = &amp;vmStatusInfo
        }</span>
        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func (vmHandler *OpenStackVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVMStatus()")

        start := call.Start()
        serverResult, err := servers.Get(vmHandler.Client, vmIID.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmStatus := getVmStatus(serverResult.Status)
        return vmStatus, nil</span>
}

func (vmHandler *OpenStackVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, VM, "ListVM()")

        //   
        start := call.Start()
        pager, err := servers.List(vmHandler.Client, nil).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        servers, err := servers.ExtractServers(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        //    
        <span class="cov0" title="0">vmList := make([]*irs.VMInfo, len(servers))
        for i, v := range servers </span><span class="cov0" title="0">{
                serverInfo := vmHandler.mappingServerInfo(v)
                vmList[i] = &amp;serverInfo
        }</span>
        <span class="cov0" title="0">return vmList, nil</span>
}

func (vmHandler *OpenStackVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmHandler.Client.IdentityEndpoint, call.VM, vmIID.NameId, "GetVM()")

        //  vmID    (old)
        /*serverResult, err := servers.Get(vmHandler.Client, vmID).Extract()
        if err != nil {
                cblogger.Info(err)
                return irs.VMInfo{}, err
        }*/
        /*vmID, err := vmHandler.getVmIdByName(vmIID.NameId)
        if err != nil {
                return irs.VMInfo{}, err
        }*/

        start := call.Start()
        serverResult, err := servers.Get(vmHandler.Client, vmIID.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmInfo := vmHandler.mappingServerInfo(*serverResult)
        return vmInfo, nil</span>
}

func (vmHandler *OpenStackVMHandler) AssociatePublicIP(serverID string) (bool, error) <span class="cov0" title="0">{
        // PublicIP 
        externVPCName, _ := GetPublicVPCInfo(vmHandler.NetworkClient, "NAME")
        createOpts := floatingips.CreateOpts{
                Pool: externVPCName,
        }
        publicIP, err := floatingips.Create(vmHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // PublicIP VM 
        <span class="cov0" title="0">curRetryCnt := 0
        //maxRetryCnt := 60
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                associateOpts := floatingips.AssociateOpts{
                        FloatingIP: publicIP.IP,
                }
                err = floatingips.AssociateInstance(vmHandler.Client, serverID, associateOpts).ExtractErr()
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(fmt.Sprintf("[%d] err = %s", curRetryCnt, err))
                }</span>

                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                curRetryCnt++

                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf(fmt.Sprintf("failed to associate floating ip to vm, exceeded maximum retry count %d", maxRetryCnt))
                        return false, errors.New(fmt.Sprintf("failed to associate floating ip to vm, exceeded maximum retry count %d", maxRetryCnt))
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func getVmStatus(vmStatus string) irs.VMStatus <span class="cov0" title="0">{
        var resultStatus string
        switch strings.ToLower(vmStatus) </span>{
        case "build":<span class="cov0" title="0">
                resultStatus = "Creating"</span>
        case "active":<span class="cov0" title="0">
                resultStatus = "Running"</span>
        case "shutoff":<span class="cov0" title="0">
                resultStatus = "Suspended"</span>
        case "reboot":<span class="cov0" title="0">
                resultStatus = "Rebooting"</span>
        case "error":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                resultStatus = "Failed"</span>
        }
        <span class="cov0" title="0">return irs.VMStatus(resultStatus)</span>
}

func (vmHandler *OpenStackVMHandler) mappingServerInfo(server servers.Server) irs.VMInfo <span class="cov0" title="0">{

        // Get Default VM Info
        vmInfo := irs.VMInfo{
                IId: irs.IID{
                        NameId:   server.Name,
                        SystemId: server.ID,
                },
                Region: irs.RegionInfo{
                        Zone:   vmHandler.Region.Zone,
                        Region: vmHandler.Region.Region,
                },
                KeyPairIId: irs.IID{
                        NameId:   server.KeyName,
                        SystemId: server.KeyName,
                },
                //VMUserId:          server.UserID,
                //VMUserPasswd:      server.AdminPass,
                NetworkInterface:  server.HostID,
                KeyValueList:      nil,
                SecurityGroupIIds: nil,
        }
        if creatTime, err := time.Parse(time.RFC3339, server.Created.String()); err == nil </span><span class="cov0" title="0">{
                vmInfo.StartTime = creatTime
        }</span>

        // VM Image  
        <span class="cov0" title="0">if len(server.Image) != 0 </span><span class="cov0" title="0">{
                imageId := server.Image["id"].(string)
                vmInfo.ImageIId = irs.IID{
                        SystemId: imageId,
                }
                image, _ := images.Get(vmHandler.Client, imageId).Extract()
                if image != nil </span><span class="cov0" title="0">{
                        vmInfo.ImageIId.NameId = image.Name
                }</span>
        }

        // VM Flavor  
        <span class="cov0" title="0">flavorId := server.Flavor["id"].(string)
        flavor, _ := flavors.Get(vmHandler.Client, flavorId).Extract()
        if flavor != nil </span><span class="cov0" title="0">{
                vmInfo.VMSpecName = flavor.Name
        }</span>

        // VM SecurityGroup  
        <span class="cov0" title="0">if len(server.SecurityGroups) != 0 </span><span class="cov0" title="0">{
                securityGroupIdArr := make([]irs.IID, len(server.SecurityGroups))
                for i, secGroupMap := range server.SecurityGroups </span><span class="cov0" title="0">{
                        secGroupName := secGroupMap["name"].(string)
                        securityGroupIdArr[i] = irs.IID{
                                NameId: secGroupName,
                        }
                        secGroup, _ := GetSecurityByName(vmHandler.Client, secGroupName)
                        if secGroup != nil </span><span class="cov0" title="0">{
                                securityGroupIdArr[i].SystemId = secGroup.ID
                        }</span>
                }
                <span class="cov0" title="0">vmInfo.SecurityGroupIIds = securityGroupIdArr</span>
        }

        <span class="cov0" title="0">for k, subnet := range server.Addresses </span><span class="cov0" title="0">{
                // VPC  
                vmInfo.VpcIID.NameId = k
                network, _ := GetNetworkByName(vmHandler.NetworkClient, vmInfo.VpcIID.NameId)
                if network != nil </span><span class="cov0" title="0">{
                        vmInfo.VpcIID.SystemId = network.ID
                }</span>
                // PrivateIP, PublicIp 
                <span class="cov0" title="0">for _, addr := range subnet.([]interface{}) </span><span class="cov0" title="0">{
                        addrMap := addr.(map[string]interface{})
                        if addrMap["OS-EXT-IPS:type"] == "floating" </span><span class="cov0" title="0">{
                                vmInfo.PublicIP = addrMap["addr"].(string)
                        }</span> else<span class="cov0" title="0"> if addrMap["OS-EXT-IPS:type"] == "fixed" </span><span class="cov0" title="0">{
                                vmInfo.PrivateIP = addrMap["addr"].(string)
                        }</span>
                }
        }

        // Subnet, Network Interface  
        <span class="cov0" title="0">port, _ := GetPortByDeviceID(vmHandler.NetworkClient, vmInfo.IId.SystemId)
        if port != nil </span><span class="cov0" title="0">{
                // Subnet  
                if len(port.FixedIPs) &gt; 0 </span><span class="cov0" title="0">{
                        ipInfo := port.FixedIPs[0]
                        vmInfo.SubnetIID.SystemId = ipInfo.SubnetID
                }</span>
                <span class="cov0" title="0">subnet, _ := GetSubnetByID(vmHandler.NetworkClient, vmInfo.SubnetIID.SystemId)
                if subnet != nil </span><span class="cov0" title="0">{
                        vmInfo.SubnetIID.NameId = subnet.Name
                }</span>

                // Network Interface  
                <span class="cov0" title="0">vmInfo.NetworkInterface = port.ID</span>
        }

        // Volume Disk 
        <span class="cov0" title="0">pages, _ := volumes.List(vmHandler.VolumeClient, volumes.ListOpts{}).AllPages()
        volList, _ := volumes.ExtractVolumes(pages)

        for _, vol := range volList </span><span class="cov0" title="0">{
                for _, attach := range vol.Attachments </span><span class="cov0" title="0">{
                        if attach.ServerID == vmInfo.IId.SystemId </span><span class="cov0" title="0">{
                                vmInfo.VMBlockDisk = attach.Device
                        }</span>
                }
        }

        <span class="cov0" title="0">return vmInfo</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package resources

import (
        "encoding/json"
        "errors"
        "fmt"
        "strconv"

        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/compute/v2/flavors"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VMSpec = "VMSPEC"
)

type OpenStackVMSpecHandler struct {
        Client *gophercloud.ServiceClient
}

func setterVMSpec(region string, vmSpec flavors.Flavor) *irs.VMSpecInfo <span class="cov0" title="0">{
        vmSpecInfo := &amp;irs.VMSpecInfo{
                Region:       region,
                Name:         vmSpec.Name,
                VCpu:         irs.VCpuInfo{Count: strconv.Itoa(vmSpec.VCPUs)},
                Mem:          strconv.Itoa(vmSpec.RAM),
                Gpu:          nil,
                KeyValueList: nil,
        }

        return vmSpecInfo
}</span>

func (vmSpecHandler *OpenStackVMSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListVMSpec()")

        start := call.Start()
        pager, err := flavors.ListDetail(vmSpecHandler.Client, flavors.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        list, err := flavors.ExtractFlavors(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">vmSpecList := make([]*irs.VMSpecInfo, len(list))
        for i, spec := range list </span><span class="cov0" title="0">{
                vmSpecList[i] = setterVMSpec(Region, spec)
        }</span>
        <span class="cov0" title="0">return vmSpecList, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetVMSpec()")

        vmSpecId, err := vmSpecHandler.getIDFromName(vmSpecHandler.Client, Name)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMSpecInfo{}, err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        vmSpec, err := flavors.Get(vmSpecHandler.Client, vmSpecId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VMSpecInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vmSpecInfo := setterVMSpec(Region, *vmSpec)
        return *vmSpecInfo, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, VMSpec, "ListOrgVMSpec()")

        start := call.Start()
        pager, err := flavors.ListDetail(vmSpecHandler.Client, flavors.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        list, err := flavors.ExtractFlavors(pager)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">var jsonResult struct {
                Result []flavors.Flavor `json:"list"`
        }
        jsonResult.Result = list
        jsonBytes, err := json.Marshal(jsonResult)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vmSpecHandler.Client.IdentityEndpoint, call.VMSPEC, Name, "GetOrgVMSpec()")

        vmSpecId, err := vmSpecHandler.getIDFromName(vmSpecHandler.Client, Name)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">start := call.Start()
        vmSpec, err := flavors.Get(vmSpecHandler.Client, vmSpecId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        jsonBytes, err := json.Marshal(vmSpec)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return "", err
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

func (vmSpecHandler *OpenStackVMSpecHandler) getIDFromName(serviceClient *gophercloud.ServiceClient, imageName string) (string, error) <span class="cov0" title="0">{
        pager, err := flavors.ListDetail(serviceClient, flavors.ListOpts{}).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">flavorList, err := flavors.ExtractFlavors(pager)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var flavorNameList []flavors.Flavor
        for _, flavor := range flavorList </span><span class="cov0" title="0">{
                if flavor.Name == imageName </span><span class="cov0" title="0">{
                        flavorNameList = append(flavorNameList, flavor)
                }</span>
        }

        <span class="cov0" title="0">if len(flavorNameList) &gt; 1 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("found multiple images with name %s", imageName))
        }</span> else<span class="cov0" title="0"> if len(flavorNameList) == 0 </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("could not found image with name %s", imageName))
        }</span>
        <span class="cov0" title="0">return flavorNameList[0].ID, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package resources

import (
        "errors"
        "fmt"

        "github.com/Azure/go-autorest/autorest/to"
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/external"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/layer3/routers"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/networks"
        "github.com/gophercloud/gophercloud/openstack/networking/v2/subnets"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const (
        VPC = "VPC"
)

type OpenStackVPCHandler struct {
        Client *gophercloud.ServiceClient
}

type NetworkWithExt struct {
        networks.Network
        external.NetworkExternalExt
}

func (vpcHandler *OpenStackVPCHandler) setterVPC(nvpc NetworkWithExt) *irs.VPCInfo <span class="cov0" title="0">{

        // VPC  
        vpcInfo := irs.VPCInfo{
                IId: irs.IID{
                        NameId:   nvpc.Name,
                        SystemId: nvpc.ID,
                },
        }
        var External string
        if nvpc.External == true </span><span class="cov0" title="0">{
                External = "Yes"
        }</span> else<span class="cov0" title="0"> if nvpc.External == false </span><span class="cov0" title="0">{
                External = "No"
        }</span>
        <span class="cov0" title="0">keyValueList := []irs.KeyValue{
                {Key: "External Network", Value: External},
        }
        vpcInfo.KeyValueList = keyValueList

        //   
        subnetInfoList := make([]irs.SubnetInfo, len(nvpc.Subnets))

        for i, subnetId := range nvpc.Subnets </span><span class="cov0" title="0">{
                subnetInfo, err := vpcHandler.GetSubnet(irs.IID{SystemId: subnetId})
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error("Failed to get subnet with Id %s, err=%s", subnetId, err)
                        continue</span>
                }
                <span class="cov0" title="0">subnetInfoList[i] = subnetInfo</span>
        }
        <span class="cov0" title="0">vpcInfo.SubnetInfoList = subnetInfoList

        return &amp;vpcInfo</span>
}

func (vpcHandler *OpenStackVPCHandler) setterSubnet(subnet subnets.Subnet) *irs.SubnetInfo <span class="cov0" title="0">{
        subnetInfo := irs.SubnetInfo{
                IId: irs.IID{
                        NameId:   subnet.Name,
                        SystemId: subnet.ID,
                },
                IPv4_CIDR: subnet.CIDR,
        }
        return &amp;subnetInfo
}</span>

func (vpcHandler *OpenStackVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcReqInfo.IId.NameId, "CreateVPC()")

        // Check VPC Exists
        listOpts := networks.ListOpts{Name: vpcReqInfo.IId.NameId}
        page, err := networks.List(vpcHandler.Client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">vpcList, err := networks.ExtractNetworks(page)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">if len(vpcList) != 0 </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("VPC with name %s already exist", vpcReqInfo.IId.NameId))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // Create VPC
        <span class="cov0" title="0">createOpts := networks.CreateOpts{
                Name: vpcReqInfo.IId.NameId,
        }

        start := call.Start()
        vpc, err := networks.Create(vpcHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        // Create Subnet
        for _, subnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                _, err := vpcHandler.CreateSubnet(vpc.ID, subnet)
                if err != nil </span><span class="cov0" title="0">{
                        // TODO: VPC   (rollback)
                        /*if ok, err := vpcHandler.DeleteVPC(irs.IID{SystemId: vpc.ID}); !ok {
                                cblogger.Error("Failed to delete vpc with Id %s, err=%s", vpc.ID, err)
                                return irs.VPCInfo{}, err
                        }*/
                        LoggingError(hiscallInfo, err)
                        return irs.VPCInfo{}, err
                }</span>
        }

        <span class="cov0" title="0">vpcInfo, err := vpcHandler.GetVPC(irs.IID{SystemId: vpc.ID})
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to get vpc with Id %s, err=%s", vpc.ID, err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // TODO: nested flow 
        // Create Router
        <span class="cov0" title="0">routerId, err := vpcHandler.CreateRouter(vpcReqInfo.IId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to get create router, err=%s", err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>

        // TODO: nested flow 
        // Create Interface
        <span class="cov0" title="0">for _, subnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                if ok, err := vpcHandler.AddInterface(subnet.IId.SystemId, *routerId); !ok </span><span class="cov0" title="0">{
                        createErr := errors.New(fmt.Sprintf("Failed to get create router interface, err=%s", err.Error()))
                        LoggingError(hiscallInfo, createErr)
                        return irs.VPCInfo{}, createErr
                }</span>
        }

        <span class="cov0" title="0">return vpcInfo, nil</span>
}
func (vpcHandler *OpenStackVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, VPC, "ListVPC()")

        listOpts := external.ListOptsExt{
                ListOptsBuilder: networks.ListOpts{},
        }

        start := call.Start()
        page, err := networks.List(vpcHandler.Client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc list, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return nil, getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        var vpcList []NetworkWithExt
        err = networks.ExtractNetworksInto(page, &amp;vpcList)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc list, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return nil, getErr
        }</span>

        // Get VPC List
        <span class="cov0" title="0">vpcInfoList := make([]*irs.VPCInfo, len(vpcList))
        for i, vpc := range vpcList </span><span class="cov0" title="0">{
                vpcInfo := vpcHandler.setterVPC(vpc)
                vpcInfoList[i] = vpcInfo
        }</span>
        <span class="cov0" title="0">return vpcInfoList, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "GetVPC()")

        var vpc NetworkWithExt
        start := call.Start()
        err := networks.Get(vpcHandler.Client, vpcIID.SystemId).ExtractInto(&amp;vpc)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc with Id %s, err=%s", vpcIID.SystemId, err.Error()))
                LoggingError(hiscallInfo, getErr)
                return irs.VPCInfo{}, getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        vpcInfo := vpcHandler.setterVPC(vpc)
        return *vpcInfo, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, vpcIID.NameId, "DeleteVPC()")

        vpcInfo, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get vpc with Id %s, err=%s", vpcIID.SystemId, err.Error()))
                LoggingError(hiscallInfo, getErr)
                return false, getErr
        }</span>

        // TODO: nested flow 
        // Delete Interface
        <span class="cov0" title="0">routerId, err := vpcHandler.GetRouter(vpcIID.NameId)
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to get router, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return false, getErr
        }</span>
        <span class="cov0" title="0">for _, subnet := range vpcInfo.SubnetInfoList </span><span class="cov0" title="0">{
                if ok, err := vpcHandler.DeleteInterface(subnet.IId.SystemId, *routerId); !ok </span><span class="cov0" title="0">{
                        getErr := errors.New(fmt.Sprintf("Failed to delete router interface, err=%s", err.Error()))
                        LoggingError(hiscallInfo, getErr)
                        return false, getErr
                }</span>
        }

        // TODO: nested flow 
        // Delete Router
        <span class="cov0" title="0">if routerId != nil </span><span class="cov0" title="0">{
                err = routers.Delete(vpcHandler.Client, *routerId).ExtractErr()
                if err != nil </span><span class="cov0" title="0">{
                        getErr := errors.New(fmt.Sprintf("Failed to delete router, err=%s", err.Error()))
                        LoggingError(hiscallInfo, getErr)
                        return false, getErr
                }</span>
        }

        // TODO: nested flow 
        // Delete Subnet
        /*for _, subnet := range vpcInfo.SubnetInfoList {
                if ok, err:= vpcHandler.DeleteSubnet(irs.IID{SystemId: subnet.IId.SystemId}); !ok {
                        cblogger.Error("Failed to delete subnet, err=%s", err)
                        return false, err
                }
        }*/

        // TODO: nested flow 
        //Delete VPC
        <span class="cov0" title="0">start := call.Start()
        err = networks.Delete(vpcHandler.Client, vpcInfo.IId.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                getErr := errors.New(fmt.Sprintf("Failed to delete vpc, err=%s", err.Error()))
                LoggingError(hiscallInfo, getErr)
                return false, getErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        subnetCreateOpts := subnets.CreateOpts{
                NetworkID:      vpcId,
                Name:           reqSubnetInfo.IId.NameId,
                CIDR:           reqSubnetInfo.IPv4_CIDR,
                IPVersion:      gophercloud.IPv4,
                DNSNameservers: []string{DNSNameservers},
        }
        subnet, err := subnets.Create(vpcHandler.Client, subnetCreateOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to create Subnet with name %s, err=%s", reqSubnetInfo.IId.NameId, err)
                return irs.SubnetInfo{}, err
        }</span>
        <span class="cov0" title="0">subnetInfo := vpcHandler.setterSubnet(*subnet)
        return *subnetInfo, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) GetSubnet(subnetIId irs.IID) (irs.SubnetInfo, error) <span class="cov0" title="0">{
        subnet, err := subnets.Get(vpcHandler.Client, subnetIId.SystemId).Extract()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get Subnet with Id %s, err=%s", subnetIId.SystemId, err)
                return irs.SubnetInfo{}, nil
        }</span>
        <span class="cov0" title="0">subnetInfo := vpcHandler.setterSubnet(*subnet)
        return *subnetInfo, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteSubnet(subnetIId irs.IID) (bool, error) <span class="cov0" title="0">{
        err := subnets.Delete(vpcHandler.Client, subnetIId.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to delete Subnet with Id %s, err=%s", subnetIId.SystemId, err)
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) CreateRouter(vpcName string) (*string, error) <span class="cov0" title="0">{
        externVPCId, _ := GetPublicVPCInfo(vpcHandler.Client, "ID")
        routerName := vpcName + "-Router"
        createOpts := routers.CreateOpts{
                Name:         routerName,
                AdminStateUp: to.BoolPtr(true),
                GatewayInfo: &amp;routers.GatewayInfo{
                        NetworkID: externVPCId,
                },
        }

        // Create Router
        router, err := routers.Create(vpcHandler.Client, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;router.ID, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) GetRouter(vpcName string) (*string, error) <span class="cov0" title="0">{
        // Get Router Info
        routerName := vpcName + "-Router"
        listOpts := routers.ListOpts{Name: routerName}
        page, err := routers.List(vpcHandler.Client, listOpts).AllPages()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to list router, err=%s", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">routerList, err := routers.ExtractRouters(page)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to extract router, err=%s", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(routerList) != 1 </span><span class="cov0" title="0">{
                cblogger.Error("Failed to get router with name %s, err=%s", routerName)
                return nil, err
        }</span>

        <span class="cov0" title="0">routerId := routerList[0].ID
        return &amp;routerId, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteRouter(vpcName string) (bool, error) <span class="cov0" title="0">{
        // Get Router
        routerId, err := vpcHandler.GetRouter(vpcName)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to delete router with Id %s, err=%s", routerId)
                return false, err
        }</span>
        // Delete Router
        <span class="cov0" title="0">err = routers.Delete(vpcHandler.Client, *routerId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Failed to delete router with Id %s, err=%s", routerId)
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) AddInterface(subnetId string, routerId string) (bool, error) <span class="cov0" title="0">{
        createOpts := routers.AddInterfaceOpts{
                SubnetID: subnetId,
        }

        // Add Interface
        _, err := routers.AddInterface(vpcHandler.Client, routerId, createOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) DeleteInterface(subnetId string, routerId string) (bool, error) <span class="cov0" title="0">{
        deleteOpts := routers.RemoveInterfaceOpts{
                SubnetID: subnetId,
        }

        // Delete Interface
        _, err := routers.RemoveInterface(vpcHandler.Client, routerId, deleteOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, subnetInfo.IId.NameId, "AddSubnet()")

        subnetCreateOpts := subnets.CreateOpts{
                NetworkID:      vpcIID.SystemId,
                Name:           subnetInfo.IId.NameId,
                CIDR:           subnetInfo.IPv4_CIDR,
                IPVersion:      gophercloud.IPv4,
                DNSNameservers: []string{DNSNameservers},
        }

        start := call.Start()
        _, err := subnets.Create(vpcHandler.Client, subnetCreateOpts).Extract()
        if err != nil </span><span class="cov0" title="0">{
                createErr := errors.New(fmt.Sprintf("Failed to create Subnet with name %s, err=%s", subnetCreateOpts.Name, err.Error()))
                LoggingError(hiscallInfo, createErr)
                return irs.VPCInfo{}, createErr
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        result, err := vpcHandler.GetVPC(vpcIID)
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (vpcHandler *OpenStackVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        // log HisCall
        hiscallInfo := GetCallLogScheme(vpcHandler.Client.IdentityEndpoint, call.VPCSUBNET, subnetIID.NameId, "RemoveSubnet()")

        start := call.Start()
        err := subnets.Delete(vpcHandler.Client, subnetIID.SystemId).ExtractErr()
        if err != nil </span><span class="cov0" title="0">{
                LoggingError(hiscallInfo, err)
                return false, err
        }</span>
        <span class="cov0" title="0">LoggingInfo(hiscallInfo, start)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is a Cloud Driver Example for PoC Test.
//
// by CB-Spider Team, 2019.06.

//package main

package tencent

import (
        "errors"

        tcon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/connect"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        icon "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/connect"

        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/profile"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
)

type TencentDriver struct {
}

func (TencentDriver) GetDriverVersion() string <span class="cov0" title="0">{
        return "Test Tencent Driver Version 0.1"
}</span>

func (TencentDriver) GetDriverCapability() idrv.DriverCapabilityInfo <span class="cov0" title="0">{
        var drvCapabilityInfo idrv.DriverCapabilityInfo

        drvCapabilityInfo.ImageHandler = true
        drvCapabilityInfo.VPCHandler = true
        drvCapabilityInfo.SecurityHandler = true
        drvCapabilityInfo.KeyPairHandler = true
        drvCapabilityInfo.VNicHandler = false
        drvCapabilityInfo.PublicIPHandler = false
        drvCapabilityInfo.VMHandler = true
        drvCapabilityInfo.VMSpecHandler = true

        return drvCapabilityInfo
}</span>

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER TencentDriver")
}</span>

func getVmClient(connectionInfo idrv.ConnectionInfo) (*cvm.Client, error) <span class="cov0" title="0">{
        // setup Region
        cblogger.Debug("TencentDriver : getVpcClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - Zone : [" + connectionInfo.RegionInfo.Zone + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - ClientId : [" + connectionInfo.CredentialInfo.ClientId + "]")

        zoneId := connectionInfo.RegionInfo.Zone
        if len(zoneId) &lt; 1 </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return nil, errors.New("Connection  Zone  ")
        }</span>

        <span class="cov0" title="0">credential := common.NewCredential(
                connectionInfo.CredentialInfo.ClientId,
                connectionInfo.CredentialInfo.ClientSecret,
        )

        cpf := profile.NewClientProfile()
        cpf.HttpProfile.Endpoint = "cvm.tencentcloudapi.com"
        cpf.Language = "en-US" //  
        client, err := cvm.NewClient(credential, connectionInfo.RegionInfo.Region, cpf)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Could not create aws New Session")
                cblogger.Error(err)
                // fmt.Println("Could not create aws New Session", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func getVpcClient(connectionInfo idrv.ConnectionInfo) (*vpc.Client, error) <span class="cov0" title="0">{
        // setup Region
        cblogger.Debug("TencentDriver : getVpcClient() - Region : [" + connectionInfo.RegionInfo.Region + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - Zone : [" + connectionInfo.RegionInfo.Zone + "]")
        cblogger.Debug("TencentDriver : getVpcClient() - ClientId : [" + connectionInfo.CredentialInfo.ClientId + "]")

        zoneId := connectionInfo.RegionInfo.Zone
        if len(zoneId) &lt; 1 </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return nil, errors.New("Connection  Zone  ")
        }</span>

        <span class="cov0" title="0">credential := common.NewCredential(
                connectionInfo.CredentialInfo.ClientId,
                connectionInfo.CredentialInfo.ClientSecret,
        )

        cpf := profile.NewClientProfile()
        cpf.HttpProfile.Endpoint = "vpc.tencentcloudapi.com"
        cpf.Language = "en-US" //  
        client, err := vpc.NewClient(credential, connectionInfo.RegionInfo.Region, cpf)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error("Could not create aws New Session")
                cblogger.Error(err)
                // fmt.Println("Could not create aws New Session", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func (driver *TencentDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) <span class="cov0" title="0">{
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.

        //fmt.Println("ConnectCloud   idrv.ConnectionInfo ")
        //spew.Dump(connectionInfo)

        // sample code, do not user like this^^
        //var iConn icon.CloudConnection
        vmClient, err := getVmClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">vpcClient, err := getVpcClient(connectionInfo)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">iConn := tcon.TencentCloudConnection{
                Region:         connectionInfo.RegionInfo,
                VNetworkClient: vpcClient,

                VMClient:       vmClient,
                KeyPairClient:  vmClient,
                ImageClient:    vmClient,
                SecurityClient: vpcClient,
                VmSpecClient:   vmClient,

                //VNicClient:     vmClient,
                //PublicIPClient: vmClient,
        }

        return &amp;iConn, nil</span> // return type: (icon.CloudConnection, error)
}

/*
func (TencentDriver) ConnectCloud(connectionInfo idrv.ConnectionInfo) (icon.CloudConnection, error) {
        // 1. get info of credential and region for Test A Cloud from connectionInfo.
        // 2. create a client object(or service  object) of Test A Cloud with credential info.
        // 3. create CloudConnection Instance of "connect/TDA_CloudConnection".
        // 4. return CloudConnection Interface of TDA_CloudConnection.
        // sample code, do not user like this^^
        var iConn icon.CloudConnection
        iConn = tcon.TencentCloudConnection{}
        return iConn, nil // return type: (icon.CloudConnection, error)
}
*/
var CloudDriver TencentDriver
</pre>
		
		<pre class="file" id="file116" style="display: none">// Proof of Concepts of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by devunet@mz.co.kr, 2021.05.04

package connect

import (
        "github.com/sirupsen/logrus"

        cblog "github.com/cloud-barista/cb-log"
        trs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        //"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        //"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors"
        //"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/profile"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
)

type TencentCloudConnection struct {
        Region         idrv.RegionInfo
        VNetworkClient *vpc.Client

        VMClient       *cvm.Client
        KeyPairClient  *cvm.Client
        ImageClient    *cvm.Client
        SecurityClient *vpc.Client
        VmSpecClient   *cvm.Client

        //VNicClient     *cvm.Client
        //PublicIPClient *cvm.Client
}

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER TencentCloudConnection")
}</span>

func (cloudConn *TencentCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateKeyPairHandler()")

        keyPairHandler := trs.TencentKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}

        return &amp;keyPairHandler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateVMHandler() (irs.VMHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start CreateVMHandler()")

        vmHandler := trs.TencentVMHandler{cloudConn.Region, cloudConn.VMClient}
        return &amp;vmHandler, nil
}</span>

func (cloudConn *TencentCloudConnection) IsConnected() (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (cloudConn *TencentCloudConnection) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (cloudConn *TencentCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentVPCHandler{cloudConn.Region, cloudConn.VNetworkClient}

        return &amp;handler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateImageHandler() (irs.ImageHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentImageHandler{cloudConn.Region, cloudConn.ImageClient}

        return &amp;handler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentSecurityHandler{cloudConn.Region, cloudConn.SecurityClient}

        return &amp;handler, nil
}</span>

func (cloudConn *TencentCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) <span class="cov0" title="0">{
        cblogger.Info("Start")
        handler := trs.TencentVmSpecHandler{cloudConn.Region, cloudConn.VmSpecClient}
        return &amp;handler, nil
}</span>

/*
func (cloudConn *TencentCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
        cblogger.Info("Start")
        handler := trs.TencentVNicHandler{cloudConn.Region, cloudConn.VNicClient}

        return &amp;handler, nil
}

func (cloudConn *TencentCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
        cblogger.Info("Start")
        handler := trs.TencentPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}

        return &amp;handler, nil
}
*/
</pre>
		
		<pre class="file" id="file117" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/ec2"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
)

const CBDefaultVNetName string = "CB-VNet"          // CB Default Virtual Network Name
const CBDefaultSubnetName string = "CB-VNet-Subnet" // CB Default Subnet Name
const CBDefaultCidrBlock string = "192.168.0.0/16"  // CB Default CidrBlock

const CBKeyPairPath string = "/cloud-driver-libs/.ssh-tencent/"
const CBCloudInitFilePath string = "/cloud-driver-libs/.cloud-init-tencent/cloud-init"
const CBDefaultVmUserName string = "cb-user" // default VM User Name

type TencentCBNetworkInfo struct {
        VpcName   string
        VpcId     string
        CidrBlock string
        IsDefault bool
        State     string

        SubnetName string
        SubnetId   string
}

const CUSTOM_ERR_CODE_TOOMANY string = "600"  //awserr.New("600", "n  xxxx  .", nil)
const CUSTOM_ERR_CODE_NOTFOUND string = "404" //awserr.New("404", "XXX   .", nil)

//VPC
func GetCBDefaultVNetName() string <span class="cov0" title="0">{
        return CBDefaultVNetName
}</span>

//Subnet
func GetCBDefaultSubnetName() string <span class="cov0" title="0">{
        return CBDefaultSubnetName
}</span>

func GetCBDefaultCidrBlock() string <span class="cov0" title="0">{
        return CBDefaultCidrBlock
}</span>

//Name Tag 
func SetNameTag(Client *ec2.EC2, Id string, value string) bool <span class="cov0" title="0">{
        // Tag Name 
        cblogger.Infof("Name Tage  - ResourceId : [%s]  Value : [%s] ", Id, value)
        _, errtag := Client.CreateTags(&amp;ec2.CreateTagsInput{
                Resources: []*string{&amp;Id},
                Tags: []*ec2.Tag{
                        {
                                Key:   aws.String("Name"),
                                Value: aws.String(value),
                        },
                },
        })
        if errtag != nil </span><span class="cov0" title="0">{
                cblogger.Error("Name Tag   : ")
                cblogger.Error(errtag)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func JSONMarshal(t interface{}) ([]byte, error) <span class="cov0" title="0">{
        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err := encoder.Encode(t)
        return buffer.Bytes(), err
}</span>

//Cloud Object JSON String  
func ConvertJsonStringNoEscape(v interface{}) (string, error) <span class="cov0" title="0">{
        //jsonBytes, errJson := json.Marshal(v)

        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        errJson := encoder.Encode(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON  ")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        //fmt.Println("After marshal", string(buffer.Bytes()))
        //spew.Dump(string(buffer.Bytes()))
        //spew.Dump("\"TEST")

        <span class="cov0" title="0">jsonString := string(buffer.Bytes())
        //jsonString = strings.Replace(jsonString, "\n", "", -1)
        jsonString = strings.Replace(jsonString, "\"", "", -1)

        return jsonString, nil</span>
}

//Cloud Object JSON String  
func ConvertJsonString(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonBytes, errJson := json.Marshal(v)

        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("JSON  ")
                cblogger.Error(errJson)
                return "", errJson
        }</span>

        <span class="cov0" title="0">jsonString := string(jsonBytes)

        return jsonString, nil</span>
}

//CB-KeyValue   String  
func ConvertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                cblogger.Debugf("Nil Value")
                return "", errors.New("Nil. Value")
        }</span>

        <span class="cov0" title="0">var result string
        t := reflect.ValueOf(value)
        cblogger.Debug("==&gt;ValueOf : ", t)

        switch value.(type) </span>{
        case float32:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 32)</span> // f, fmt, prec, bitSize
        case float64:<span class="cov0" title="0">
                result = strconv.FormatFloat(t.Float(), 'f', -1, 64)</span> // f, fmt, prec, bitSize
                //strconv.FormatFloat(instanceTypeInfo.MemorySize, 'f', 0, 64)

        default:<span class="cov0" title="0">
                cblogger.Debug("--&gt; default type:", reflect.ValueOf(value).Type())
                result = fmt.Sprint(value)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

//Cloud Object CB-KeyValue     
func ConvertKeyValueList(v interface{}) ([]irs.KeyValue, error) <span class="cov0" title="0">{
        //spew.Dump(v)
        var keyValueList []irs.KeyValue
        var i map[string]interface{}

        jsonBytes, errJson := json.Marshal(v)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error("KeyValue  ")
                cblogger.Error(errJson)
                return nil, errJson
        }</span>

        <span class="cov0" title="0">json.Unmarshal(jsonBytes, &amp;i)

        for k, v := range i </span><span class="cov0" title="0">{
                cblogger.Debugf("K:[%s]====&gt;", k)
                /*
                        cblogger.Infof("v:[%s]====&gt;", reflect.ValueOf(v))

                        vv := reflect.ValueOf(v)
                        cblogger.Infof("value ====&gt;[%s]", vv.String())
                        s := fmt.Sprint(v)
                        cblogger.Infof("value2 ====&gt;[%s]", s)
                */
                //value := fmt.Sprint(v)
                value, errString := ConvertToString(v)
                if errString != nil </span><span class="cov0" title="0">{
                        //cblogger.Errorf("Key[%s]    - [%s]", k, errString)
                        cblogger.Debugf("Key[%s]    - [%s]", k, errString) //  Error Warn 
                        continue</span>
                }
                <span class="cov0" title="0">keyValueList = append(keyValueList, irs.KeyValue{k, value})</span>

                /*
                        _, ok := v.(string)
                        if !ok {
                                cblogger.Errorf("Key[%s]   ", k)
                                continue
                        }
                        keyValueList = append(keyValueList, irs.KeyValue{k, v.(string)})
                */
        }
        <span class="cov0" title="0">cblogger.Debug("getKeyValueList : ", keyValueList)
        //keyValueList = append(keyValueList, irs.KeyValue{"test", typeToString([]float32{3.14, 1.53, 2.0000000000000})})

        return keyValueList, nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Cloud Driver Interface of CB-Spider.  // The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "strings"

        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"

        //irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/new-resources"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
)

type TencentImageHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

//@TODO -       -  IID     .(Id   .)
func (imageHandler *TencentImageHandler) CreateImage(imageReqInfo irs.ImageReqInfo) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Info(imageReqInfo)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageReqInfo.IId.NameId,
                CloudOSAPI:   "CreateImage()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewCreateImageRequest()
        request.ImageName = common.StringPtr(imageReqInfo.IId.NameId)
        request.ImageDescription = common.StringPtr(imageReqInfo.IId.NameId)
        //request.InstanceId = common.StringPtr("InstanceId") // -    Id

        //request.ForcePoweroff = common.StringPtr("ForcePoweroff")        //

        // // Whether to enable Sysprep when creating a Windows image. Click here to learn more about Sysprep.
        // // https://intl.cloud.tencent.com/document/product/213/35876
        // request.Sysprep = common.StringPtr("Sysprep")

        callLogStart := call.Start()
        response, err := imageHandler.Client.CreateImage(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        // imageInfo := irs.ImageInfo{
        //         IId: irs.IID{NameId: imageReqInfo.IId.NameId, SystemId: *response.Response.ImageId},
        // }

        //OS    GetImage  .
        imageInfo, errGetImage := imageHandler.GetImage(irs.IID{SystemId: *response.Response.ImageId})
        if errGetImage != nil </span><span class="cov0" title="0">{
                cblogger.Error(errGetImage)
                return irs.ImageInfo{}, errGetImage
        }</span>
        <span class="cov0" title="0">imageInfo.IId.NameId = imageReqInfo.IId.NameId
        return imageInfo, nil</span>
}

func (imageHandler *TencentImageHandler) ListImage() ([]*irs.ImageInfo, error) <span class="cov0" title="0">{
        var imageInfoList []*irs.ImageInfo

        cblogger.Debug("Start")
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: "ListImage()",
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeImagesRequest()
        request.Limit = common.Uint64Ptr(100) //default : 20 / max : 100

        callLogStart := call.Start()
        response, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        //cnt := 0
        for _, curImage := range response.Response.ImageSet </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s] AMI  ", *curImage.ImageId)
                imageInfo := ExtractImageDescribeInfo(curImage)
                imageInfoList = append(imageInfoList, &amp;imageInfo)
        }</span>

        //spew.Dump(imageInfoList)
        <span class="cov0" title="0">return imageInfoList, nil</span>
}

func ExtractImageDescribeInfo(image *cvm.Image) irs.ImageInfo <span class="cov0" title="0">{
        //spew.Dump(image)
        imageInfo := irs.ImageInfo{
                //IId: irs.IID{*image.Name, *image.ImageId},
                IId:     irs.IID{NameId: *image.ImageId, SystemId: *image.ImageId},
                GuestOS: *image.OsName,
                Status:  *image.ImageState,
        }

        //NORMAL -&gt; available
        if strings.EqualFold(imageInfo.Status, "NORMAL") </span><span class="cov0" title="0">{
                imageInfo.Status = "available"
        }</span>

        //KeyValue  
        <span class="cov0" title="0">keyValueList, errKeyValue := ConvertKeyValueList(image)
        if errKeyValue != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%] KeyValue  ", *image.ImageId)
                cblogger.Error(errKeyValue)
        }</span>

        <span class="cov0" title="0">imageInfo.KeyValueList = keyValueList
        return imageInfo</span>
}

func (imageHandler *TencentImageHandler) GetImage(imageIID irs.IID) (irs.ImageInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("imageID : [%s]", imageIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.SystemId,
                CloudOSAPI:   "DescribeImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeImagesRequest()
        request.ImageIds = common.StringPtrs([]string{imageIID.SystemId})

        callLogStart := call.Start()
        response, err := imageHandler.Client.DescribeImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.ImageInfo{}, err
        }</span>

        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                imageInfo := ExtractImageDescribeInfo(response.Response.ImageSet[0])
                return imageInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.ImageInfo{}, errors.New("   ")
        }</span>

}

func (imageHandler *TencentImageHandler) DeleteImage(imageIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("imageIID : [%s]", imageIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   imageHandler.Region.Zone,
                ResourceType: call.VMIMAGE,
                ResourceName: imageIID.NameId,
                CloudOSAPI:   "DeleteImages()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDeleteImagesRequest()
        request.ImageIds = common.StringPtrs([]string{imageIID.NameId})

        callLogStart := call.Start()
        response, err := imageHandler.Client.DeleteImages(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return false, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package resources

import (
        "bytes"
        "crypto/md5"
        "crypto/rsa"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        _ "github.com/davecgh/go-spew/spew"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
        "golang.org/x/crypto/ssh"
)

type TencentKeyPairHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

func (keyPairHandler *TencentKeyPairHandler) ListKey() ([]*irs.KeyPairInfo, error) <span class="cov0" title="0">{
        var keyPairList []*irs.KeyPairInfo
        cblogger.Debug("Start ListKey()")

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: "ListKey()",
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeKeyPairsRequest()

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        for _, pair := range response.Response.KeyPairSet </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(pair)
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Infof("[%s] KeyPair Local     Skip.", *pair.KeyName)
                        cblogger.Info(errKeyPair.Error())
                        //return nil, errKeyPair
                }</span> else<span class="cov0" title="0"> {
                        keyPairList = append(keyPairList, &amp;keyPairInfo)
                }</span>
        }

        <span class="cov0" title="0">return keyPairList, nil</span>
}

//KeyPair  
func ExtractKeyPairDescribeInfo(keyPair *cvm.KeyPair) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        spew.Dump(keyPair)
        keyPairInfo := irs.KeyPairInfo{
                IId: irs.IID{NameId: *keyPair.KeyName, SystemId: *keyPair.KeyId},
                //PublicKey: *keyPair.PublicKey,
        }

        //PrivateKey      PrivateKey Nil.
        // if !reflect.ValueOf(keyPair.PrivateKey).IsNil() {
        //         keyPairInfo.PrivateKey = *keyPair.PrivateKey
        //         keyPairInfo.PublicKey = *keyPair.PublicKey
        // }
        // 

        // Local Keyfile 
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        hashString := strings.ReplaceAll(*keyPair.KeyId, ":", "") //       .        .
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, privateKeyPath)
        cblogger.Debugf("[%s] ==&gt; [%s]", keyPairInfo.IId.NameId, publicKeyPath)

        // Private Key, Public Key   
        privateKeyBytes, err := ioutil.ReadFile(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Local Private   ", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">publicKeyBytes, err := ioutil.ReadFile(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%s] KeyPair Local Public   ", keyPairInfo.IId.NameId)
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">keyPairInfo.PublicKey = string(publicKeyBytes)
        keyPairInfo.PrivateKey = string(privateKeyBytes)

        keyValueList := []irs.KeyValue{
                {Key: "KeyId", Value: *keyPair.KeyId},
                //{Key: "KeyMaterial", Value: *keyPair.KeyMaterial},
        }

        keyPairInfo.KeyValueList = keyValueList

        return keyPairInfo, nil</span>
}

//KeyPair   ,    "_" 
func (keyPairHandler *TencentKeyPairHandler) CreateKey(keyPairReqInfo irs.KeyPairReqInfo) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        cblogger.Info(keyPairReqInfo)

        //=================================================
        //     (cb-spider   )
        //=================================================
        isExist, errExist := keyPairHandler.isExist(keyPairReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.KeyPairInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, errors.New("A keyPair with the name " + keyPairReqInfo.IId.NameId + " already exists.")
        }</span>

        <span class="cov0" title="0">keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyPairReqInfo.IId.NameId,
                CloudOSAPI:   "CreateKeyPair()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewCreateKeyPairRequest()
        request.KeyName = common.StringPtr(keyPairReqInfo.IId.NameId)
        request.ProjectId = common.Int64Ptr(0)

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.CreateKeyPair(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        cblogger.Infof("Created [%s]key pair", *response.Response.KeyPair.KeyName)
        //spew.Dump(result)
        keyPairInfo := irs.KeyPairInfo{
                //Name:        *result.KeyName,
                IId:        irs.IID{NameId: keyPairReqInfo.IId.NameId, SystemId: *response.Response.KeyPair.KeyId},
                PublicKey:  *response.Response.KeyPair.PublicKey,
                PrivateKey: *response.Response.KeyPair.PrivateKey,
                KeyValueList: []irs.KeyValue{
                        {Key: "KeyId", Value: *response.Response.KeyPair.KeyId},
                },
        }

        //spew.Dump(keyPairInfo)

        //=============================
        //      .
        //=============================
        hashString := strings.ReplaceAll(*response.Response.KeyPair.KeyId, ":", "") //       .        .
        savePrivateFileTo := keyPairPath + hashString + ".pem"
        savePublicFileTo := keyPairPath + hashString + ".pub"
        //cblogger.Infof("hashString : [%s]", hashString)
        cblogger.Infof("savePrivateFileTo : [%s]", savePrivateFileTo)
        cblogger.Infof("savePublicFileTo : [%s]", savePublicFileTo)

        //  private Key 
        err = writeKeyToFile([]byte(keyPairInfo.PrivateKey), savePrivateFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        //  public Key 
        <span class="cov0" title="0">err = writeKeyToFile([]byte(keyPairInfo.PublicKey), savePublicFileTo)
        if err != nil </span><span class="cov0" title="0">{
                return irs.KeyPairInfo{}, err
        }</span>

        <span class="cov0" title="0">return keyPairInfo, nil</span>
}

// cb-spider       .
func (keyPairHandler *TencentKeyPairHandler) isExist(chkName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Debugf("chkName : %s", chkName)

        request := cvm.NewDescribeKeyPairsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("key-name"),
                        Values: common.StringPtrs([]string{chkName}),
                },
        }

        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("SSH Key   - KeyId:[%s] / KeyName:[%s]", *response.Response.KeyPairSet[0].KeyId, *response.Response.KeyPairSet[0].KeyName)
        return true, nil</span>
}

func (keyPairHandler *TencentKeyPairHandler) GetKey(keyIID irs.IID) (irs.KeyPairInfo, error) <span class="cov0" title="0">{
        //keyPairID := keyName
        cblogger.Infof("keyName : [%s]", keyIID.SystemId)

        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        if err := keyPairHandler.CheckKeyPairFolder(keyPairPath); err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DescribeKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeKeyPairsRequest()
        request.KeyIds = common.StringPtrs([]string{keyIID.SystemId})

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.KeyPairInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                keyPairInfo, errKeyPair := ExtractKeyPairDescribeInfo(response.Response.KeyPairSet[0])
                if errKeyPair != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errKeyPair.Error())
                        return irs.KeyPairInfo{}, errKeyPair
                }</span>

                //spew.Dump(keyPairInfo)
                <span class="cov0" title="0">return keyPairInfo, nil</span>
        } else<span class="cov0" title="0"> {
                return irs.KeyPairInfo{}, errors.New("   .")
        }</span>
}

//Tencent  FingerPrint       KeyId      .
func (keyPairHandler *TencentKeyPairHandler) GetLocalKeyId(keyIID irs.IID) (string, error) <span class="cov0" title="0">{
        // Local Keyfile   
        request := cvm.NewDescribeKeyPairsRequest()
        request.KeyIds = common.StringPtrs([]string{keyIID.SystemId})
        response, err := keyPairHandler.Client.DescribeKeyPairs(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return "", err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                return *response.Response.KeyPairSet[0].KeyId, nil
        }</span> else<span class="cov0" title="0"> {
                return "", errors.New("InvalidKeyPair.NotFound: The KeyPair " + keyIID.SystemId + " does not exist")
        }</span>
}

func (keyPairHandler *TencentKeyPairHandler) DeleteKey(keyIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("   : [%s]", keyIID.SystemId)

        keyPairId, errGet := keyPairHandler.GetLocalKeyId(keyIID)
        if errGet != nil </span><span class="cov0" title="0">{
                return false, errGet
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   keyPairHandler.Region.Zone,
                ResourceType: call.VMKEYPAIR,
                ResourceName: keyIID.NameId,
                CloudOSAPI:   "DeleteKeyPairs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDeleteKeyPairsRequest()
        request.KeyIds = common.StringPtrs([]string{keyIID.SystemId})

        callLogStart := call.Start()
        response, err := keyPairHandler.Client.DeleteKeyPairs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return false, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        //====================
        // Local Keyfile 
        //====================
        keyPairPath := os.Getenv("CBSPIDER_ROOT") + CBKeyPairPath
        cblogger.Infof("Getenv[CBSPIDER_ROOT] : [%s]", os.Getenv("CBSPIDER_ROOT"))
        cblogger.Infof("CBKeyPairPath : [%s]", CBKeyPairPath)
        cblogger.Infof("Final keyPairPath : [%s]", keyPairPath)

        hashString := strings.ReplaceAll(keyPairId, ":", "") //       .        .
        privateKeyPath := keyPairPath + hashString + ".pem"
        publicKeyPath := keyPairPath + hashString + ".pub"

        // Private Key, Public Key 
        err = os.Remove(privateKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">err = os.Remove(publicKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

//=================================
//          
//=================================
func (keyPairHandler *TencentKeyPairHandler) CheckKeyPairFolder(keyPairPath string) error <span class="cov0" title="0">{
        //       .
        _, errChkDir := os.Stat(keyPairPath)
        if os.IsNotExist(errChkDir) </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Path   .", keyPairPath)

                //errDir := os.MkdirAll(keyPairPath, 0755)
                errDir := os.MkdirAll(keyPairPath, 0700)
                //errDir := os.MkdirAll(keyPairPath, os.ModePerm) // os.ModePerm : 0777        //os.ModeDir
                if errDir != nil </span><span class="cov0" title="0">{
                        //log.Fatal(err)
                        cblogger.Errorf("[%s] Path  ", keyPairPath)
                        cblogger.Error(errDir)
                        return errDir
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ParseKey reads the given RSA private key and create a public one for it.
func makePublicKeyFromPrivateKey(pem string) (string, error) <span class="cov0" title="0">{
        key, err := ssh.ParseRawPrivateKey([]byte(pem))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">rsaKey, ok := key.(*rsa.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q is not a RSA key", pem)
        }</span>
        <span class="cov0" title="0">pub, err := ssh.NewPublicKey(&amp;rsaKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(bytes.TrimRight(ssh.MarshalAuthorizedKey(pub), "\n")), nil</span>
}

//  Key 
func writeKeyToFile(keyBytes []byte, saveFileTo string) error <span class="cov0" title="0">{
        err := ioutil.WriteFile(saveFileTo, keyBytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Key : %s", saveFileTo)
        return nil</span>
}

// @TODO - PK   . (A User / B User / User  IAM        .)
//       -  AWS  KeyPair FingerPrint   -       .
// KeyPair    (PK    )
func CreateHashString(credentialInfo idrv.CredentialInfo, Region idrv.RegionInfo) (string, error) <span class="cov0" title="0">{
        log.Println("credentialInfo.ClientId : " + credentialInfo.ClientId)
        log.Println("Region.Region : " + Region.Region)
        keyString := credentialInfo.ClientId + credentialInfo.ClientSecret + Region.Region
        //keyString := credentialInfo
        hasher := md5.New()
        _, err := io.WriteString(hasher, keyString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by CB-Spider Team, 2019.06.

package resources

import (
        "errors"
        "strings"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
)

type TencentSecurityHandler struct {
        Region idrv.RegionInfo
        Client *vpc.Client
}

//https://intl.cloud.tencent.com/document/product/213/34272
//https://intl.cloud.tencent.com/ko/document/api/215/36083
/*
@TODO     . -    
     : (,) / (-) / ALL()
Port: A single port number, or a port range in the format of 8000-8010. The Port field is accepted only if the value of the Protocol field is TCP or UDP. Otherwise Protocol and Port are mutually exclusive.
Action : ACCEPT or DROP
*/
func (securityHandler *TencentSecurityHandler) CreateSecurity(securityReqInfo irs.SecurityReqInfo) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securityReqInfo : ", securityReqInfo)

        //=================================================
        //     (cb-spider   )
        //=================================================
        isExist, errExist := securityHandler.isExist(securityReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.SecurityInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.SecurityInfo{}, errors.New("A SecurityGroup with the name " + securityReqInfo.IId.NameId + " already exists.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityReqInfo.IId.NameId,
                CloudOSAPI:   "CreateSecurityGroupWithPolicies()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewCreateSecurityGroupWithPoliciesRequest()
        request.GroupName = common.StringPtr(securityReqInfo.IId.NameId)
        request.GroupDescription = common.StringPtr(securityReqInfo.IId.NameId) //  

        cblogger.Debug("  ")
        securityGroupPolicySet := &amp;vpc.SecurityGroupPolicySet{}
        for _, curPolicy := range *securityReqInfo.SecurityRules </span><span class="cov0" title="0">{
                securityGroupPolicy := new(vpc.SecurityGroupPolicy)
                securityGroupPolicy.Protocol = common.StringPtr(curPolicy.IPProtocol)
                //securityGroupPolicy.CidrBlock = common.StringPtr("0.0.0.0/0")
                securityGroupPolicy.CidrBlock = common.StringPtr(curPolicy.CIDR)
                securityGroupPolicy.Action = common.StringPtr("accept")

                if curPolicy.ToPort != "" &amp;&amp; curPolicy.ToPort != curPolicy.FromPort </span><span class="cov0" title="0">{
                        securityGroupPolicy.Port = common.StringPtr(curPolicy.FromPort + "-" + curPolicy.ToPort)
                }</span> else<span class="cov0" title="0"> {
                        securityGroupPolicy.Port = common.StringPtr(curPolicy.FromPort)
                }</span>

                <span class="cov0" title="0">if strings.EqualFold(curPolicy.Direction, "inbound") </span><span class="cov0" title="0">{
                        securityGroupPolicySet.Ingress = append(securityGroupPolicySet.Ingress, securityGroupPolicy)
                }</span> else<span class="cov0" title="0"> {
                        securityGroupPolicySet.Egress = append(securityGroupPolicySet.Egress, securityGroupPolicy)
                }</span>
        }

        <span class="cov0" title="0">request.SecurityGroupPolicySet = securityGroupPolicySet

        callLogStart := call.Start()
        response, err := securityHandler.Client.CreateSecurityGroupWithPolicies(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                spew.Dump(request)
                return irs.SecurityInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        securityInfo, errSecurity := securityHandler.GetSecurity(irs.IID{SystemId: *response.Response.SecurityGroup.SecurityGroupId})
        if errSecurity != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSecurity)
                return irs.SecurityInfo{}, errSecurity
        }</span>

        <span class="cov0" title="0">securityInfo.IId.NameId = securityReqInfo.IId.NameId
        return securityInfo, nil</span>
}

func (securityHandler *TencentSecurityHandler) ListSecurity() ([]*irs.SecurityInfo, error) <span class="cov0" title="0">{
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: "ListSecurity()",
                CloudOSAPI:   "DescribeSecurityGroups()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeSecurityGroupsRequest()
        request.Limit = common.StringPtr("100") //default : 20 / max : 100

        callLogStart := call.Start()
        response, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        var results []*irs.SecurityInfo
        for _, securityGroup := range response.Response.SecurityGroupSet </span><span class="cov0" title="0">{
                //         securityInfo := ExtractSecurityInfo(securityGroup)
                securityInfo, errSecurity := securityHandler.GetSecurity(irs.IID{NameId: *securityGroup.SecurityGroupName, SystemId: *securityGroup.SecurityGroupId})
                if errSecurity != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errSecurity)
                        return nil, errSecurity
                }</span>
                <span class="cov0" title="0">results = append(results, &amp;securityInfo)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// cb-spider       .
func (securityHandler *TencentSecurityHandler) isExist(chkName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Debugf("chkName : %s", chkName)

        request := vpc.NewDescribeSecurityGroupsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("security-group-name"),
                        Values: common.StringPtrs([]string{chkName}),
                },
        }

        response, err := securityHandler.Client.DescribeSecurityGroups(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("   - VpcId:[%s] / VpcName:[%s]", *response.Response.SecurityGroupSet[0].SecurityGroupId, *response.Response.SecurityGroupSet[0].SecurityGroupName)
        return true, nil</span>
}

func (securityHandler *TencentSecurityHandler) GetSecurity(securityIID irs.IID) (irs.SecurityInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securitySystemId : [%s]", securityIID.SystemId)
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DescribeSecurityGroupPolicies()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeSecurityGroupsRequest()
        request.SecurityGroupIds = common.StringPtrs([]string{securityIID.SystemId})

        callLogStart := call.Start()
        response, err := securityHandler.Client.DescribeSecurityGroups(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.SecurityInfo{}, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                securityInfo := irs.SecurityInfo{}
                securityInfo.IId = irs.IID{NameId: *response.Response.SecurityGroupSet[0].SecurityGroupName, SystemId: *response.Response.SecurityGroupSet[0].SecurityGroupId}

                securityInfo.SecurityRules, err = securityHandler.GetSecurityRuleInfo(securityIID)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                        return irs.SecurityInfo{}, err
                }</span>
                <span class="cov0" title="0">return securityInfo, nil</span>
        } else<span class="cov0" title="0"> {
                return irs.SecurityInfo{}, errors.New("InvalidSecurityGroupId.NotFound: The SecurityGroup " + securityIID.SystemId + " does not exist")
        }</span>
}

func (securityHandler *TencentSecurityHandler) GetSecurityRuleInfo(securityIID irs.IID) (*[]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("securitySystemId : [%s]", securityIID.SystemId)

        request := vpc.NewDescribeSecurityGroupPoliciesRequest()
        request.SecurityGroupId = common.StringPtr(securityIID.SystemId)

        response, err := securityHandler.Client.DescribeSecurityGroupPolicies(request)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())

        var securityRuleInfos []irs.SecurityRuleInfo
        var ingress []irs.SecurityRuleInfo
        var egress []irs.SecurityRuleInfo
        ingress, err = securityHandler.ExtractPolicyGroups(response.Response.SecurityGroupPolicySet.Ingress, "inbound")
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">egress, err = securityHandler.ExtractPolicyGroups(response.Response.SecurityGroupPolicySet.Egress, "outbound")
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">securityRuleInfos = append(ingress, egress...)

        return &amp;securityRuleInfos, nil</span>
}

//@TODO Port     .
//direction : inbound / outbound
func (securityHandler *TencentSecurityHandler) ExtractPolicyGroups(policyGroups []*vpc.SecurityGroupPolicy, direction string) ([]irs.SecurityRuleInfo, error) <span class="cov0" title="0">{
        var results []irs.SecurityRuleInfo

        var fromPort string
        var toPort string

        /*
                var newDirection string
                //ingress -&gt; inbound
                if strings.EqualFold(direction, "ingress") {
                        newDirection = "inbound"
                } else if strings.EqualFold(direction, "egress") {
                        newDirection = "outbound"
                } else { //UnKnown
                        newDirection = direction
                }
        */

        for _, curPolicy := range policyGroups </span><span class="cov0" title="0">{
                if len(*curPolicy.Port) &gt; 0 </span><span class="cov0" title="0">{

                        //WEB UI             (-) .
                        portArr := strings.Split(*curPolicy.Port, ",")
                        for _, curPort := range portArr </span><span class="cov0" title="0">{
                                portRange := strings.Split(curPort, "-")
                                fromPort = portRange[0]
                                if len(portRange) &gt; 1 </span><span class="cov0" title="0">{
                                        toPort = portRange[len(portRange)-1]
                                }</span> else<span class="cov0" title="0"> {
                                        toPort = ""
                                }</span>

                                <span class="cov0" title="0">securityRuleInfo := irs.SecurityRuleInfo{
                                        Direction:  direction, // "inbound | outbound"
                                        CIDR:       *curPolicy.CidrBlock,
                                        IPProtocol: *curPolicy.Protocol,
                                        FromPort:   fromPort,
                                        ToPort:     toPort,
                                }
                                results = append(results, securityRuleInfo)</span>
                        }
                }
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (securityHandler *TencentSecurityHandler) DeleteSecurity(securityIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("securityNameId : [%s]", securityIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   securityHandler.Region.Zone,
                ResourceType: call.SECURITYGROUP,
                ResourceName: securityIID.SystemId,
                CloudOSAPI:   "DeleteSecurityGroup()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDeleteSecurityGroupRequest()
        request.SecurityGroupId = common.StringPtr(securityIID.SystemId)

        callLogStart := call.Start()
        response, err := securityHandler.Client.DeleteSecurityGroup(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return false, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">cblogger.Debug(response.ToJsonString())
        callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">// Proof of Concepts for the Cloud-Barista Multi-Cloud Project.
//      * Cloud-Barista: https://github.com/cloud-barista
//
// EC2 Hander (AWS SDK GO Version 1.16.26, Thanks AWS.)
//
// by CB-Spider Team, 2019.03.
package resources

import (
        "encoding/base64"
        "errors"
        "io/ioutil"
        "os"
        "reflect"
        "strconv"
        "strings"
        "time"

        cblog "github.com/cloud-barista/cb-log"
        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"
        "github.com/sirupsen/logrus"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
)

var cblogger *logrus.Logger

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        cblogger = cblog.GetLogger("CB-SPIDER Tencent VMHandler")
}</span>

type TencentVMHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

//VM      VM  .
func (vmHandler *TencentVMHandler) isExist(vmName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("VM(Name) : %s", vmName)
        request := cvm.NewDescribeInstancesRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("instance-name"),
                        Values: common.StringPtrs([]string{vmName}),
                },
        }

        response, err := vmHandler.Client.DescribeInstances(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("VM   - VmId:[%s] / VmName:[%s]", *response.Response.InstanceSet[0].InstanceId, *response.Response.InstanceSet[0].InstanceName)
        return true, nil</span>
}

// VM  Zone  Credential Zone .
func (vmHandler *TencentVMHandler) StartVM(vmReqInfo irs.VMReqInfo) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vmReqInfo)

        zoneId := vmHandler.Region.Zone
        cblogger.Debugf("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return irs.VMInfo{}, errors.New("Connection  Zone  ")
        }</span>

        //=================================================
        //     (cb-spider   )
        //=================================================
        <span class="cov0" title="0">isExist, errExist := vmHandler.isExist(vmReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.VMInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("A VM with the name " + vmReqInfo.IId.NameId + " already exists.")
        }</span>

        // 2021-04-28 cbuser   Local KeyPair VM   
        //=============================
        // KeyPair PublicKey  
        //=============================
        <span class="cov0" title="0">cblogger.Infof("[%s] KeyPair  ", vmReqInfo.KeyPairIID.SystemId)
        keypairHandler := TencentKeyPairHandler{
                //CredentialInfo:
                Region: vmHandler.Region,
                Client: vmHandler.Client,
        }
        cblogger.Info(keypairHandler)

        keyPairInfo, errKeyPair := keypairHandler.GetKey(vmReqInfo.KeyPairIID)
        if errKeyPair != nil </span><span class="cov0" title="0">{
                cblogger.Error(errKeyPair)
                return irs.VMInfo{}, errKeyPair
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmReqInfo.IId.NameId,
                CloudOSAPI:   "RunInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewRunInstancesRequest()
        request.InstanceType = common.StringPtr(vmReqInfo.VMSpecName)

        request.ImageId = common.StringPtr(vmReqInfo.ImageIID.SystemId)
        request.VirtualPrivateCloud = &amp;cvm.VirtualPrivateCloud{
                VpcId:    common.StringPtr(vmReqInfo.VpcIID.SystemId),
                SubnetId: common.StringPtr(vmReqInfo.SubnetIID.SystemId),
        }

        request.InstanceChargeType = common.StringPtr("POSTPAID_BY_HOUR")

        request.InternetAccessible = &amp;cvm.InternetAccessible{
                //         InternetChargeType: common.StringPtr("TRAFFIC_POSTPAID_BY_HOUR"),
                PublicIpAssigned:        common.BoolPtr(true),
                InternetMaxBandwidthOut: common.Int64Ptr(1), //Public Ip  The maximum outbound bandwidth of the public network 1Mbps .
        }

        request.InstanceName = common.StringPtr(vmReqInfo.IId.NameId)
        request.LoginSettings = &amp;cvm.LoginSettings{
                KeyIds: common.StringPtrs([]string{vmReqInfo.KeyPairIID.SystemId}),
        }

        //=============================
        //   - SystemId 
        //=============================
        cblogger.Debug("SystemId    IID    SystemId     .")
        var newSecurityGroupIds []string
        for _, curSecurityGroup := range vmReqInfo.SecurityGroupIIDs </span><span class="cov0" title="0">{
                cblogger.Infof("  : [%s]", curSecurityGroup)
                newSecurityGroupIds = append(newSecurityGroupIds, curSecurityGroup.SystemId)
        }</span>

        <span class="cov0" title="0">cblogger.Debug("  ")
        cblogger.Debug(newSecurityGroupIds)
        request.SecurityGroupIds = common.StringPtrs(newSecurityGroupIds)

        //=============================
        // Placement 
        //=============================
        request.Placement = &amp;cvm.Placement{
                Zone: common.StringPtr(vmHandler.Region.Zone),
        }

        //=============================
        // SystemDisk 
        //=============================
        request.SystemDisk = &amp;cvm.SystemDisk{
                DiskType: common.StringPtr("CLOUD_PREMIUM"),
        }

        //=============================
        // UserData (File)
        //=============================
        //       cloud-init   
        rootPath := os.Getenv("CBSPIDER_ROOT")
        fileDataCloudInit, err := ioutil.ReadFile(rootPath + CBCloudInitFilePath)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">userData := string(fileDataCloudInit)
        userData = strings.ReplaceAll(userData, "{{username}}", CBDefaultVmUserName)
        userData = strings.ReplaceAll(userData, "{{public_key}}", keyPairInfo.PublicKey)
        userDataBase64 := base64.StdEncoding.EncodeToString([]byte(userData))
        cblogger.Debugf("cloud-init data : [%s]", userDataBase64)
        request.UserData = common.StringPtr(userDataBase64)

        cblogger.Info("=====  ====")
        spew.Config.Dump(request)
        callLogStart := call.Start()
        response, err := vmHandler.Client.RunInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>
        <span class="cov0" title="0">spew.Dump(response)
        callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        //=========================================
        // VM      
        //-----------------------------------------
        // WaitForRun     Public Ip     
        // cb-tumblebug     Tencent Running    .
        //=========================================
        newVmIID := irs.IID{SystemId: *response.Response.InstanceIdSet[0]}

        curStatus, errStatus := vmHandler.WaitForRun(newVmIID)
        if errStatus != nil </span><span class="cov0" title="0">{
                cblogger.Error(errStatus.Error())
                return irs.VMInfo{}, nil
        }</span>
        <span class="cov0" title="0">cblogger.Info("==&gt; VM[%s]  [%s]", newVmIID, curStatus)

        vmInfo, errVmInfo := vmHandler.GetVM(newVmIID)
        vmInfo.IId.NameId = vmReqInfo.IId.NameId
        return vmInfo, errVmInfo</span>
}

func (vmHandler *TencentVMHandler) SuspendVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StopInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewStopInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})
        /*
                Whether to force shut down an instance after a normal shutdown fails. Valid values:
                TRUE: force shut down an instance after a normal shutdown fails
                FALSE: do not force shut down an instance after a normal shutdown fails
                Default value: FALSE.
        */
        // request.ForceStop = common.BoolPtr(true)

        /*
                Instance shutdown mode. Valid values:

                SOFT_FIRST: perform a soft shutdown first, and force shut down the instance if the soft shutdown fails
                HARD: force shut down the instance directly
                SOFT: soft shutdown only
                Default value: SOFT.
        */
        // request.StopType = common.StringPtr("SOFT")

        /*
                Billing method of a pay-as-you-go instance after shutdown. Valid values:

                KEEP_CHARGING: billing continues after shutdown
                STOP_CHARGING: billing stops after shutdown
                Default value: KEEP_CHARGING. This parameter is only valid for some pay-as-you-go instances using cloud disks. For more information, see No charges when shut down for pay-as-you-go instances.
                https://intl.cloud.tencent.com/document/product/213/19918
        */
        // request.StoppedMode = common.StringPtr("STOP_CHARGING")

        callLogStart := call.Start()
        response, err := vmHandler.Client.StopInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Suspending"), nil</span>
}

func (vmHandler *TencentVMHandler) ResumeVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "StartInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewStartInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.StartInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Resuming"), nil</span>
}

func (vmHandler *TencentVMHandler) RebootVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "RebootInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewRebootInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.RebootInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Rebooting"), nil</span>
}

func (vmHandler *TencentVMHandler) TerminateVM(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.NameId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "TerminateInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewTerminateInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.TerminateInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        return irs.VMStatus("Terminating"), nil</span>
}

func (vmHandler *TencentVMHandler) GetVM(vmIID irs.IID) (irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMInfo{}, err
        }</span>

        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMInfo{}, errors.New("VM    ")
        }</span>

        <span class="cov0" title="0">vmInfo, errVmInfo := vmHandler.ExtractDescribeInstances(response.Response.InstanceSet[0])
        cblogger.Info("vmInfo", vmInfo)
        return vmInfo, errVmInfo</span>
}

func (vmHandler *TencentVMHandler) ExtractDescribeInstances(curVm *cvm.Instance) (irs.VMInfo, error) <span class="cov0" title="0">{
        //cblogger.Info("ExtractDescribeInstances", curVm)
        //spew.Dump(curVm)

        //VM      
        vmInfo := irs.VMInfo{
                IId:        irs.IID{SystemId: *curVm.InstanceId},
                VMSpecName: *curVm.InstanceType,
                VMUserId:   "cb-user",
                //KeyPairIId: irs.IID{SystemId: *curVm.},
        }

        if !reflect.ValueOf(curVm.ImageId).IsNil() </span><span class="cov0" title="0">{
                vmInfo.ImageIId = irs.IID{SystemId: *curVm.ImageId}
        }</span>

        // vmInfo.StartTime = *curVm.CreatedTime
        <span class="cov0" title="0">vmStartTime := *curVm.CreatedTime
        timeLen := len(vmStartTime)
        cblogger.Debug("     ")
        cblogger.Debugf("======&gt;   [%s]", timeLen)
        if timeLen &gt; 7 </span><span class="cov0" title="0">{
                cblogger.Debugf("======&gt;    [%s]", vmStartTime[timeLen-1:])
                var NewStartTime string
                if vmStartTime[timeLen-1:] == "Z" &amp;&amp; timeLen == 17 </span><span class="cov0" title="0">{
                        //cblogger.Infof("======&gt;   : [%s]", StartTime[:timeLen-1])
                        NewStartTime = vmStartTime[:timeLen-1] + ":00Z"
                        cblogger.Debugf("======&gt;    : [%s]", NewStartTime)
                }</span> else<span class="cov0" title="0"> {
                        NewStartTime = vmStartTime
                }</span>

                <span class="cov0" title="0">cblogger.Debugf("Convert StartTime string [%s] to time.time", NewStartTime)

                //layout := "2020-05-07T01:36Z"
                t, err := time.Parse(time.RFC3339, NewStartTime)
                if err != nil </span><span class="cov0" title="0">{
                        cblogger.Error(err)
                }</span> else<span class="cov0" title="0"> {
                        cblogger.Debugf("======&gt; [%v]", t)
                        vmInfo.StartTime = t
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.LoginSettings).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(curVm.LoginSettings.KeyIds).IsNil() </span><span class="cov0" title="0">{
                        if len(curVm.LoginSettings.KeyIds) &gt; 0 </span><span class="cov0" title="0">{
                                vmInfo.KeyPairIId = irs.IID{SystemId: *curVm.LoginSettings.KeyIds[0]}
                        }</span>
                }
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.PublicIpAddresses).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PublicIP = *curVm.PublicIpAddresses[0]
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.Placement.Zone).IsNil() </span><span class="cov0" title="0">{
                vmInfo.Region = irs.RegionInfo{
                        Region: vmHandler.Region.Region, //  
                        Zone:   *curVm.Placement.Zone,
                }
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.VirtualPrivateCloud.VpcId).IsNil() </span><span class="cov0" title="0">{
                vmInfo.VpcIID = irs.IID{SystemId: *curVm.VirtualPrivateCloud.VpcId}
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.VirtualPrivateCloud.SubnetId).IsNil() </span><span class="cov0" title="0">{
                vmInfo.SubnetIID = irs.IID{SystemId: *curVm.VirtualPrivateCloud.SubnetId}
        }</span>

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.SecurityGroupIds).IsNil() </span><span class="cov0" title="0">{
                for _, curSecurityGroupId := range curVm.SecurityGroupIds </span><span class="cov0" title="0">{
                        vmInfo.SecurityGroupIIds = append(vmInfo.SecurityGroupIIds, irs.IID{SystemId: *curSecurityGroupId})
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.PrivateIpAddresses).IsNil() </span><span class="cov0" title="0">{
                vmInfo.PrivateIP = *curVm.PrivateIpAddresses[0]
        }</span>

        <span class="cov0" title="0">keyValueList := []irs.KeyValue{
                {Key: "InstanceState", Value: *curVm.InstanceState},
                {Key: "OsName", Value: *curVm.OsName},
        }

        //
        if !reflect.ValueOf(curVm.InstanceChargeType).IsNil() </span><span class="cov0" title="0">{
                keyValueList = append(keyValueList, irs.KeyValue{Key: "InstanceChargeType", Value: *curVm.InstanceChargeType})
        }</span>

        //  
        <span class="cov0" title="0">if !reflect.ValueOf(curVm.DataDisks).IsNil() </span><span class="cov0" title="0">{
                if len(curVm.DataDisks) &gt; 0 </span><span class="cov0" title="0">{
                        if !reflect.ValueOf(curVm.DataDisks[0].DiskId).IsNil() </span><span class="cov0" title="0">{
                                vmInfo.VMBlockDisk = *curVm.DataDisks[0].DiskId
                        }</span>
                }
        }

        //  
        <span class="cov0" title="0">if !reflect.ValueOf(curVm.SystemDisk).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(curVm.SystemDisk.DiskType).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SystemDiskType", Value: *curVm.SystemDisk.DiskType})
                }</span>
                <span class="cov0" title="0">if !reflect.ValueOf(curVm.SystemDisk.DiskId).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SystemDiskId", Value: *curVm.SystemDisk.DiskId})
                        vmInfo.VMBootDisk = *curVm.SystemDisk.DiskId
                }</span>
                <span class="cov0" title="0">if !reflect.ValueOf(curVm.SystemDisk.DiskSize).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "SystemDiskSize", Value: strconv.FormatInt(*curVm.SystemDisk.DiskSize, 10)})
                }</span>
        }

        <span class="cov0" title="0">if !reflect.ValueOf(curVm.InternetAccessible).IsNil() </span><span class="cov0" title="0">{
                if !reflect.ValueOf(curVm.InternetAccessible.InternetChargeType).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "InternetChargeType", Value: *curVm.InternetAccessible.InternetChargeType})
                }</span>
                <span class="cov0" title="0">if !reflect.ValueOf(curVm.InternetAccessible.InternetMaxBandwidthOut).IsNil() </span><span class="cov0" title="0">{
                        keyValueList = append(keyValueList, irs.KeyValue{Key: "InternetMaxBandwidthOut", Value: strconv.FormatInt(*curVm.InternetAccessible.InternetMaxBandwidthOut, 10)})
                }</span>
        }

        <span class="cov0" title="0">vmInfo.KeyValueList = keyValueList

        return vmInfo, nil</span>
}

func (vmHandler *TencentVMHandler) ListVM() ([]*irs.VMInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("Start")

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVM()",
                CloudOSAPI:   "DescribeInstances()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesRequest()
        request.Limit = common.Int64Ptr(100)

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstances(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>

        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        var vmInfoList []*irs.VMInfo
        for _, curVm := range response.Response.InstanceSet </span><span class="cov0" title="0">{
                vmInfo, _ := vmHandler.GetVM(irs.IID{SystemId: *curVm.InstanceId})
                vmInfoList = append(vmInfoList, &amp;vmInfo)
        }</span>

        <span class="cov0" title="0">return vmInfoList, nil</span>
}

func (vmHandler *TencentVMHandler) GetVMStatus(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Infof("vmNameId : [%s]", vmIID.SystemId)

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: vmIID.SystemId,
                CloudOSAPI:   "DescribeInstancesStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesStatusRequest()
        request.InstanceIds = common.StringPtrs([]string{vmIID.SystemId})

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstancesStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMStatus("Failed"), err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VMStatus("Failed"), errors.New("    ")
        }</span>

        <span class="cov0" title="0">vmStatus, errStatus := ConvertVMStatusString(*response.Response.InstanceStatusSet[0].InstanceState)
        cblogger.Infof("vmStatus : [%s]", vmStatus)
        return vmStatus, errStatus</span>
}

func (vmHandler *TencentVMHandler) ListVMStatus() ([]*irs.VMStatusInfo, error) <span class="cov0" title="0">{
        cblogger.Debug("Start")

        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmHandler.Region.Zone,
                ResourceType: call.VM,
                ResourceName: "ListVMStatus()",
                CloudOSAPI:   "DescribeInstancesStatus()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstancesStatusRequest()
        request.Limit = common.Int64Ptr(100)

        callLogStart := call.Start()
        response, err := vmHandler.Client.DescribeInstancesStatus(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>
        //spew.Dump(response)
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))
        cblogger.Debug(response.ToJsonString())

        var vmStatusList []*irs.VMStatusInfo
        for _, curVm := range response.Response.InstanceStatusSet </span><span class="cov0" title="0">{
                vmStatus, _ := ConvertVMStatusString(*curVm.InstanceState)

                vmStatusInfo := irs.VMStatusInfo{
                        IId:      irs.IID{SystemId: *curVm.InstanceId},
                        VmStatus: vmStatus,
                }
                cblogger.Info(vmStatusInfo.IId.SystemId, " Instance Status : ", vmStatusInfo.VmStatus)
                vmStatusList = append(vmStatusList, &amp;vmStatusInfo)
        }</span>

        <span class="cov0" title="0">return vmStatusList, nil</span>
}

func ConvertVMStatusString(vmStatus string) (irs.VMStatus, error) <span class="cov0" title="0">{
        var resultStatus string
        cblogger.Infof("vmStatus : [%s]", vmStatus)

        if strings.EqualFold(vmStatus, "pending") </span><span class="cov0" title="0">{
                //resultStatus = "Creating"        // VM   Pending CB      .
                resultStatus = "Resuming" // Resume     Pending   Pending Resuming .
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "running") </span><span class="cov0" title="0">{
                resultStatus = "Running"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopping") </span><span class="cov0" title="0">{
                resultStatus = "Suspending"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "stopped") </span><span class="cov0" title="0">{
                resultStatus = "Suspended"
                //} else if strings.EqualFold(vmStatus, "pending") {
                //        resultStatus = "Resuming"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Rebooting") </span><span class="cov0" title="0">{
                resultStatus = "Rebooting"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "shutting-down") </span><span class="cov0" title="0">{
                resultStatus = "Terminating"
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(vmStatus, "Terminated") </span><span class="cov0" title="0">{
                resultStatus = "Terminated"
        }</span> else<span class="cov0" title="0"> {
                //resultStatus = "Failed"
                cblogger.Errorf("vmStatus [%s]      .", vmStatus)
                return irs.VMStatus("Failed"), errors.New(vmStatus + "  CB VM    .")
        }</span>
        <span class="cov0" title="0">cblogger.Infof("VM   : [%s] ==&gt; [%s]", vmStatus, resultStatus)
        return irs.VMStatus(resultStatus), nil</span>
}

// VM       30 
func (vmHandler *TencentVMHandler) WaitForRun(vmIID irs.IID) (irs.VMStatus, error) <span class="cov0" title="0">{
        cblogger.Info("======&gt; VM   Public IP      Running   .")

        //waitStatus := "NotExist"        //VM  .
        waitStatus := "Running"
        //waitStatus := "Creating" //     VM     .

        //===================================
        // Suspending  3   .
        //===================================
        curRetryCnt := 0
        maxRetryCnt := 120
        for </span><span class="cov0" title="0">{
                curStatus, errStatus := vmHandler.GetVMStatus(vmIID)
                if errStatus != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errStatus.Error())
                }</span>

                <span class="cov0" title="0">cblogger.Info("===&gt;VM Status : ", curStatus)

                if curStatus == irs.VMStatus(waitStatus) </span><span class="cov0" title="0">{ //|| curStatus == irs.VMStatus("Running") {
                        cblogger.Infof("===&gt;VM  [%s]  .", curStatus)
                        break</span>
                }

                //if curStatus != irs.VMStatus(waitStatus) {
                <span class="cov0" title="0">curRetryCnt++
                cblogger.Errorf("VM  [%s]  1  .", waitStatus)
                time.Sleep(time.Second * 1)
                if curRetryCnt &gt; maxRetryCnt </span><span class="cov0" title="0">{
                        cblogger.Errorf("(%d )  VM Status  [%s]    .", maxRetryCnt, waitStatus)
                        return irs.VMStatus("Failed"), errors.New("   VM  [" + waitStatus + "]    .")
                }</span>
        }

        <span class="cov0" title="0">return irs.VMStatus(waitStatus), nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package resources

import (
        "errors"
        "reflect"
        "strconv"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
)

//https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.DescribeInstanceTypes
type TencentVmSpecHandler struct {
        Region idrv.RegionInfo
        Client *cvm.Client
}

//@TODO : Region : zone id(Region  zone id  .)
func (vmSpecHandler *TencentVmSpecHandler) ListVMSpec(Region string) ([]*irs.VMSpecInfo, error) <span class="cov0" title="0">{
        //cblogger.Infof("ListVMSpec(ZoneId:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return nil, errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"),
                        Values: common.StringPtrs([]string{zoneId}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return nil, err
        }</span>

        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        var vmSpecInfoList []*irs.VMSpecInfo
        for _, curSpec := range response.Response.InstanceTypeConfigSet </span><span class="cov0" title="0">{
                cblogger.Debugf("[%s] VM Spec  ", *curSpec.InstanceType)
                vmSpecInfo := ExtractVMSpecInfo(curSpec)
                vmSpecInfoList = append(vmSpecInfoList, &amp;vmSpecInfo)
        }</span>

        <span class="cov0" title="0">cblogger.Debug(vmSpecInfoList)
        //spew.Dump(vmSpecInfoList)
        return vmSpecInfoList, nil</span>
}

func (vmSpecHandler *TencentVmSpecHandler) GetVMSpec(Region string, Name string) (irs.VMSpecInfo, error) <span class="cov0" title="0">{
        //cblogger.Infof("Start GetVMSpec(ZoneId:[%s], Name:[%s])", Region, Name)
        cblogger.Infof("Spec Name:[%s]", Name)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return irs.VMSpecInfo{}, errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"), // 
                        Values: common.StringPtrs([]string{zoneId}),
                },
                &amp;cvm.Filter{
                        Name:   common.StringPtr("instance-type"), //  
                        Values: common.StringPtrs([]string{Name}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return irs.VMSpecInfo{}, err
        }</span>

        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(response.Response.InstanceTypeConfigSet) &gt; 0 </span><span class="cov0" title="0">{
                vmSpecInfo := ExtractVMSpecInfo(response.Response.InstanceTypeConfigSet[0])
                cblogger.Debug(vmSpecInfo)
                return vmSpecInfo, nil
        }</span> else<span class="cov0" title="0"> {
                return irs.VMSpecInfo{}, errors.New("   ")
        }</span>
}

func (vmSpecHandler *TencentVmSpecHandler) ListOrgVMSpec(Region string) (string, error) <span class="cov0" title="0">{
        //cblogger.Infof("ListOrgVMSpec(ZoneId:[%s])", Region)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return "", errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: "ListOrgVMSpec()",
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"),
                        Values: common.StringPtrs([]string{zoneId}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return "", err
        }</span>

        //spew.Dump(response)
        // cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        jsonString, errJson := ConvertJsonString(response.Response.InstanceTypeConfigSet)
        if errJson != nil </span><span class="cov0" title="0">{
                cblogger.Error(errJson)
                return "", errJson
        }</span>
        <span class="cov0" title="0">cblogger.Debug(jsonString)
        return jsonString, errJson</span>
}

func (vmSpecHandler *TencentVmSpecHandler) GetOrgVMSpec(Region string, Name string) (string, error) <span class="cov0" title="0">{
        cblogger.Infof("Spec Name:[%s]", Name)
        //cblogger.Infof("Start GetOrgVMSpec(ZoneId:[%s], Name:[%s])", Region, Name)

        zoneId := vmSpecHandler.Region.Zone
        //zoneId := Region
        cblogger.Infof("Session Zone : [%s]", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return "", errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   vmSpecHandler.Region.Zone,
                ResourceType: call.VMSPEC,
                ResourceName: Name,
                CloudOSAPI:   "DescribeInstanceTypeConfigs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := cvm.NewDescribeInstanceTypeConfigsRequest()
        request.Filters = []*cvm.Filter{
                &amp;cvm.Filter{
                        Name:   common.StringPtr("zone"),
                        Values: common.StringPtrs([]string{zoneId}),
                },
                &amp;cvm.Filter{
                        Name:   common.StringPtr("instance-type"), //  
                        Values: common.StringPtrs([]string{Name}),
                },
        }
        callLogStart := call.Start()
        response, err := vmSpecHandler.Client.DescribeInstanceTypeConfigs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))

                cblogger.Error(err)
                return "", err
        }</span>

        //spew.Dump(response)
        //cblogger.Debug(response.ToJsonString())
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        if len(response.Response.InstanceTypeConfigSet) &gt; 0 </span><span class="cov0" title="0">{
                jsonString, errJson := ConvertJsonString(response.Response.InstanceTypeConfigSet[0])
                if errJson != nil </span><span class="cov0" title="0">{
                        cblogger.Error(errJson)
                        return "", errJson
                }</span>
                <span class="cov0" title="0">cblogger.Debug(jsonString)
                return jsonString, errJson</span>
        } else<span class="cov0" title="0"> {
                return "", errors.New("   ")
        }</span>
}

//   
func ExtractVMSpecInfo(instanceTypeInfo *cvm.InstanceTypeConfig) irs.VMSpecInfo <span class="cov0" title="0">{
        cblogger.Debugf("ExtractVMSpecInfo : SpecName:[%s]", *instanceTypeInfo.InstanceType)
        //spew.Dump(instanceTypeInfo)

        vCpuInfo := irs.VCpuInfo{}
        // gpuInfoList := []irs.GpuInfo{}

        // 
        vmSpecInfo := irs.VMSpecInfo{
                Name:   *instanceTypeInfo.InstanceType,
                Region: *instanceTypeInfo.Zone,
        }

        //Memory  
        if !reflect.ValueOf(instanceTypeInfo.Memory).IsNil() </span><span class="cov0" title="0">{
                vmSpecInfo.Mem = strconv.FormatInt(*instanceTypeInfo.Memory, 10)
        }</span>

        //VCPU   - Count
        <span class="cov0" title="0">if !reflect.ValueOf(instanceTypeInfo.CPU).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Count = strconv.FormatInt(*instanceTypeInfo.CPU, 10)
        }</span>
        <span class="cov0" title="0">vmSpecInfo.VCpu = vCpuInfo

        //GPU    GPU 
        if !reflect.ValueOf(instanceTypeInfo.GPU).IsNil() </span><span class="cov0" title="0">{
                vCpuInfo.Count = strconv.FormatInt(*instanceTypeInfo.GPU, 10)
                vmSpecInfo.Gpu = []irs.GpuInfo{irs.GpuInfo{Count: strconv.FormatInt(*instanceTypeInfo.GPU, 10)}}
        }</span>

        //KeyValue  
        <span class="cov0" title="0">keyValueList, errKeyValue := ConvertKeyValueList(instanceTypeInfo)
        if errKeyValue != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("[%] KeyValue  ", *instanceTypeInfo.InstanceType)
                cblogger.Error(errKeyValue)
        }</span>
        <span class="cov0" title="0">vmSpecInfo.KeyValueList = keyValueList

        return vmSpecInfo</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">// Cloud Driver Interface of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// This is Resouces interfaces of Cloud Driver.
//
// by devunet@mz.co.kr

package resources

import (
        "errors"
        "strconv"

        call "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/call-log"
        idrv "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces"
        irs "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/davecgh/go-spew/spew"

        "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
        vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
)

type TencentVPCHandler struct {
        Region idrv.RegionInfo
        Client *vpc.Client
}

func (VPCHandler *TencentVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info(vpcReqInfo)

        //=================================================
        //     (cb-spider   )
        //=================================================
        isExist, errExist := VPCHandler.isExist(vpcReqInfo.IId.NameId)
        if errExist != nil </span><span class="cov0" title="0">{
                cblogger.Error(errExist)
                return irs.VPCInfo{}, errExist
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New("A VPC with the name " + vpcReqInfo.IId.NameId + " already exists.")
        }</span>

        <span class="cov0" title="0">zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return irs.VPCInfo{}, errors.New("Connection  Zone  .")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        //=========================
        // VPC 
        //=========================
        request := vpc.NewCreateVpcRequest()
        request.VpcName = common.StringPtr(vpcReqInfo.IId.NameId)
        request.CidrBlock = common.StringPtr(vpcReqInfo.IPv4_CIDR)

        callLogStart := call.Start()
        response, err := VPCHandler.Client.CreateVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        newVpcId := *response.Response.Vpc.VpcId // Subnet       VPC Id .

        //=========================
        // Subnet 
        //========================
        requestSubnet := vpc.NewCreateSubnetsRequest()

        requestSubnet.VpcId = common.StringPtr(newVpcId)
        requestSubnet.Subnets = []*vpc.SubnetInput{}

        for _, curSubnet := range vpcReqInfo.SubnetInfoList </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet ", curSubnet.IId.NameId)
                reqSubnet := &amp;vpc.SubnetInput{
                        CidrBlock:  common.StringPtr(curSubnet.IPv4_CIDR),
                        SubnetName: common.StringPtr(curSubnet.IId.NameId),
                        Zone:       common.StringPtr(zoneId),
                        //RouteTableId: common.StringPtr("route"),
                }
                requestSubnet.Subnets = append(requestSubnet.Subnets, reqSubnet)
        }</span>

        <span class="cov0" title="0">responseSubnet, errSubnet := VPCHandler.Client.CreateSubnets(requestSubnet)
        cblogger.Debug(responseSubnet.ToJsonString())
        spew.Dump(responseSubnet)
        if errSubnet != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }</span>

        //  VPC Subnet  irs.VPCInfo{}         GetVPC .
        // Subnet  VPC   .
        <span class="cov0" title="0">retVpcInfo, errVpc := VPCHandler.GetVPC(irs.IID{SystemId: newVpcId})
        if errVpc != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpc)
                return irs.VPCInfo{}, errVpc
        }</span>
        <span class="cov0" title="0">retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId //   NameId cb-spider       .

        return retVpcInfo, nil</span>
}

//VPC  
func ExtractVpcDescribeInfo(vpcInfo *vpc.Vpc) irs.VPCInfo <span class="cov0" title="0">{
        // cblogger.Debug("  ")
        // spew.Dump(vpcInfo)
        resVpcInfo := irs.VPCInfo{
                //NameId       Tencent Name   .
                IId:       irs.IID{SystemId: *vpcInfo.VpcId, NameId: *vpcInfo.VpcName},
                IPv4_CIDR: *vpcInfo.CidrBlock,
        }

        return resVpcInfo
}</span>

func (VPCHandler *TencentVPCHandler) ListVPC() ([]*irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("Start")

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeVpcsRequest()
        callLogStart := call.Start()
        response, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        //spew.Dump(result)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Info("VPC  : ", *response.Response.TotalCount)

        var vpcInfoList []*irs.VPCInfo
        if *response.Response.TotalCount &gt; 0 </span><span class="cov0" title="0">{
                for _, curVpc := range response.Response.VpcSet </span><span class="cov0" title="0">{
                        cblogger.Debugf("[%s] VPC   - [%s]", *curVpc.VpcId, *curVpc.VpcName)
                        vpcInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: *curVpc.VpcId})
                        // cblogger.Info("==&gt; ")
                        // spew.Dump(vpcInfo)
                        if vpcErr != nil </span><span class="cov0" title="0">{
                                cblogger.Error(vpcErr)
                                return nil, vpcErr
                        }</span>
                        <span class="cov0" title="0">vpcInfoList = append(vpcInfoList, &amp;vpcInfo)</span>
                }
        }

        <span class="cov0" title="0">cblogger.Debugf("    : [%d]", len(vpcInfoList))
        // spew.Dump(vpcInfoList)
        return vpcInfoList, nil</span>
}

// cb-spider       .
func (VPCHandler *TencentVPCHandler) isExist(chkName string) (bool, error) <span class="cov0" title="0">{
        cblogger.Debugf("chkName : %s", chkName)

        request := vpc.NewDescribeVpcsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("vpc-name"),
                        Values: common.StringPtrs([]string{chkName}),
                },
        }

        response, err := VPCHandler.Client.DescribeVpcs(request)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">cblogger.Infof("VPC   - VpcId:[%s] / VpcName:[%s]", *response.Response.VpcSet[0].VpcId, *response.Response.VpcSet[0].VpcName)
        return true, nil</span>
}

func (VPCHandler *TencentVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "GetVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDescribeVpcsRequest()
        request.VpcIds = common.StringPtrs([]string{vpcIID.SystemId})

        callLogStart := call.Start()
        response, err := VPCHandler.Client.DescribeVpcs(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("An API error has returned: %s", err.Error())
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        cblogger.Debug("VPC  : ", *response.Response.TotalCount)
        if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New("Notfound: '" + vpcIID.SystemId + "' VPC Not found")
        }</span>

        <span class="cov0" title="0">vpcInfo := ExtractVpcDescribeInfo(response.Response.VpcSet[0])
        cblogger.Debug(vpcInfo)

        //=======================
        // Subnet 
        //=======================
        var errSubnet error
        vpcInfo.SubnetInfoList, errSubnet = VPCHandler.ListSubnet(vpcIID.SystemId)
        if errSubnet != nil </span><span class="cov0" title="0">{
                callogger.Error(errSubnet)
                return vpcInfo, errSubnet
        }</span>

        <span class="cov0" title="0">return vpcInfo, nil</span>
}

func (VPCHandler *TencentVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDeleteVpcRequest()
        request.VpcId = common.StringPtr(vpcIID.SystemId)

        callLogStart := call.Start()
        _, err := VPCHandler.Client.DeleteVpc(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil </span><span class="cov0" title="0">{
                cblogger.Errorf("An API error has returned: %s", err.Error())
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}

func (VPCHandler *TencentVPCHandler) ListSubnet(reqVpcId string) ([]irs.SubnetInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("reqVpcId : [%s]", reqVpcId)
        var arrSubnetInfoList []irs.SubnetInfo

        /*
                // logger for HisCall
                callogger := call.GetLogger("HISCALL")
                callLogInfo := call.CLOUDLOGSCHEMA{
                        CloudOS:      call.TENCENT,
                        RegionZone:   VPCHandler.Region.Zone,
                        ResourceType: call.VPCSUBNET,
                        ResourceName: "ListSubnet - VpcId:" + reqVpcId,
                        CloudOSAPI:   "DescribeSubnets()",
                        ElapsedTime:  "",
                        ErrorMSG:     "",
                }
        */

        request := vpc.NewDescribeSubnetsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("vpc-id"),
                        Values: common.StringPtrs([]string{reqVpcId}),
                },
        }

        // callLogStart := call.Start()
        response, err := VPCHandler.Client.DescribeSubnets(request)
        // callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        //cblogger.Debug(response.ToJsonString())
        spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                // callLogInfo.ErrorMSG = err.Error()
                // callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return nil, err
        }</span>
        // callogger.Info(call.String(callLogInfo))

        <span class="cov0" title="0">for _, curSubnet := range response.Response.SubnetSet </span><span class="cov0" title="0">{
                cblogger.Infof("[%s] Subnet  ", *curSubnet.SubnetId)
                resSubnetInfo := irs.SubnetInfo{
                        IId:       irs.IID{SystemId: *curSubnet.SubnetId, NameId: *curSubnet.SubnetName},
                        IPv4_CIDR: *curSubnet.CidrBlock,
                        //Status:    *subnetInfo.State,
                }

                keyValueList := []irs.KeyValue{
                        {Key: "VpcId", Value: *curSubnet.VpcId},
                        {Key: "IsDefault", Value: strconv.FormatBool(*curSubnet.IsDefault)},
                        {Key: "AvailabilityZone", Value: *curSubnet.Zone},
                }
                resSubnetInfo.KeyValueList = keyValueList
                arrSubnetInfoList = append(arrSubnetInfoList, resSubnetInfo)
        }</span>

        <span class="cov0" title="0">return arrSubnetInfoList, nil</span>
}

//        .
// reqSubnetNameId :  Name
func (VPCHandler *TencentVPCHandler) isExistSubnet(reqSubnetNameId string) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("reqSubnetNameId : [%s]", reqSubnetNameId)

        request := vpc.NewDescribeSubnetsRequest()
        request.Filters = []*vpc.Filter{
                &amp;vpc.Filter{
                        Name:   common.StringPtr("subnet-name"),
                        Values: common.StringPtrs([]string{reqSubnetNameId}),
                },
        }

        //spew.Dump(request)
        response, err := VPCHandler.Client.DescribeSubnets(request)
        //cblogger.Debug("  ")
        //spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                cblogger.Error(err)
                return false, err
        }</span>

        <span class="cov0" title="0">if *response.Response.TotalCount &lt; 1 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (VPCHandler *TencentVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] Subnet  - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" </span><span class="cov0" title="0">{
                cblogger.Error("Connection  Zone  .")
                return irs.VPCInfo{}, errors.New("Connection  Zone  .")
        }</span>

        <span class="cov0" title="0">if subnetInfo.IId.NameId == "" </span><span class="cov0" title="0">{
                return irs.VPCInfo{}, errors.New(" SubnetId  .")
        }</span>

        <span class="cov0" title="0">isExit, errSubnetInfo := VPCHandler.isExistSubnet(subnetInfo.IId.NameId)
        if errSubnetInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errSubnetInfo)
                return irs.VPCInfo{}, errSubnetInfo
        }</span>

        <span class="cov0" title="0">cblogger.Info("Subnet  : ")
        cblogger.Info(isExit)

        if isExit </span><span class="cov0" title="0">{
                cblogger.Errorf(" [%S] Subnet         .", subnetInfo.IId.NameId)
                return irs.VPCInfo{}, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + subnetInfo.IId.NameId + "' already exists.")
        }</span>

        // logger for HisCall
        <span class="cov0" title="0">callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewCreateSubnetRequest()

        request.VpcId = common.StringPtr(vpcIID.SystemId)
        request.SubnetName = common.StringPtr(subnetInfo.IId.NameId)
        request.CidrBlock = common.StringPtr(subnetInfo.IPv4_CIDR)
        request.Zone = common.StringPtr(VPCHandler.Region.Zone)

        callLogStart := call.Start()
        response, err := VPCHandler.Client.CreateSubnet(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return irs.VPCInfo{}, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        retVpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil </span><span class="cov0" title="0">{
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, err
        }</span>

        //retVpcInfo.SubnetInfoList[0].IId.NameId = vpcReqInfo.IId.NameId //   NameId     .

        <span class="cov0" title="0">return retVpcInfo, nil</span>
}

func (VPCHandler *TencentVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) <span class="cov0" title="0">{
        cblogger.Infof("[%s] VPC [%s] Subnet ", vpcIID.SystemId, subnetIID.SystemId)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.TENCENT,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DeleteSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }

        request := vpc.NewDeleteSubnetRequest()
        request.SubnetId = common.StringPtr(subnetIID.SystemId)

        callLogStart := call.Start()
        response, err := VPCHandler.Client.DeleteSubnet(request)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        cblogger.Debug(response.ToJsonString())
        //spew.Dump(response)
        if err != nil </span><span class="cov0" title="0">{
                callLogInfo.ErrorMSG = err.Error()
                callogger.Error(call.String(callLogInfo))
                cblogger.Error(err)
                return false, err
        }</span>
        <span class="cov0" title="0">callogger.Info(call.String(callLogInfo))

        return true, nil</span>
}

/*
func (VPCHandler *TencentVPCHandler) CreateVPC(vpcReqInfo irs.VPCReqInfo) (irs.VPCInfo, error) {
        cblogger.Info(vpcReqInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" {
                cblogger.Error("Connection  Zone  .")
                return irs.VPCInfo{}, errors.New("Connection  Zone  .")
        }

        input := &amp;ec2.CreateVpcInput{
                CidrBlock: aws.String(vpcReqInfo.IPv4_CIDR),
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcReqInfo.IId.NameId,
                CloudOSAPI:   "CreateVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        retVpcInfo := ExtractVpcDescribeInfo(result.Vpc)
        retVpcInfo.IId.NameId = vpcReqInfo.IId.NameId // NameId     .

        //IGW Name Tag 
        if SetNameTag(VPCHandler.Client, *result.Vpc.VpcId, vpcReqInfo.IId.NameId) {
                cblogger.Infof("VPC %s Name  ", vpcReqInfo.IId.NameId)
        } else {
                cblogger.Errorf("VPC %s Name  ", vpcReqInfo.IId.NameId)
        }

        //====================================
        // PublicIP   IGW  
        //====================================
        //IGW 
        resultIGW, errIGW := VPCHandler.Client.CreateInternetGateway(&amp;ec2.CreateInternetGatewayInput{})
        if errIGW != nil {
                if aerr, ok := errIGW.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGW.Error())
                }
                return retVpcInfo, errIGW
        }

        cblogger.Info(resultIGW)

        //IGW Name Tag 
        if SetNameTag(VPCHandler.Client, *resultIGW.InternetGateway.InternetGatewayId, vpcReqInfo.IId.NameId) {
                cblogger.Infof("IGW %s Name  ", vpcReqInfo.IId.NameId)
        } else {
                cblogger.Errorf("IGW %s Name  ", vpcReqInfo.IId.NameId)
        }

        // VPC IGW
        inputIGW := &amp;ec2.AttachInternetGatewayInput{
                InternetGatewayId: aws.String(*resultIGW.InternetGateway.InternetGatewayId),
                VpcId:             aws.String(retVpcInfo.IId.SystemId),
        }

        resultIGWAttach, errIGWAttach := VPCHandler.Client.AttachInternetGateway(inputIGW)
        if err != nil {
                if aerr, ok := errIGWAttach.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(errIGWAttach.Error())
                }
                return retVpcInfo, errIGWAttach
        }

        cblogger.Info(resultIGWAttach)

        //  VPC    IGW   
        errRoute := VPCHandler.CreateRouteIGW(retVpcInfo.IId.SystemId, *resultIGW.InternetGateway.InternetGatewayId)
        if errRoute != nil {
                return retVpcInfo, errRoute
        }

        //==========================
        // Subnet 
        //==========================
        //VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, vpcReqInfo.SubnetInfoList[0])
        var resSubnetList []irs.SubnetInfo
        for _, curSubnet := range vpcReqInfo.SubnetInfoList {
                cblogger.Infof("[%s] Subnet ", curSubnet.IId.NameId)
                cblogger.Infof("Reqt Subnet Info [%v]", curSubnet)
                resSubnet, errSubnet := VPCHandler.CreateSubnet(retVpcInfo.IId.SystemId, curSubnet)

                if errSubnet != nil {
                        return retVpcInfo, errSubnet
                }
                resSubnetList = append(resSubnetList, resSubnet)
        }
        retVpcInfo.SubnetInfoList = resSubnetList
        return retVpcInfo, nil
}

//  VPC   IGW(Internet Gateway)    (AWS    [] Tab )
func (VPCHandler *TencentVPCHandler) CreateRouteIGW(vpcId string, igwId string) error {
        cblogger.Infof("VPC ID : [%s] / IGW ID : [%s]", vpcId, igwId)
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil {
                return errRoute
        }

        cblogger.Infof("RouteTable[%s] IGW[%s]  (0.0.0.0/0)   .", routeTableId, igwId)
        input := &amp;ec2.CreateRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                GatewayId:            aws.String(igwId),
                RouteTableId:         aws.String(routeTableId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: igwId,
                CloudOSAPI:   "CreateRoute()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.CreateRoute(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil {
                cblogger.Errorf("RouteTable[%s] IGW[%s]  (0.0.0.0/0)   ", routeTableId, igwId)
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return err
        }
        cblogger.Infof("RouteTable[%s] IGW[%s]  (0.0.0.0/0)   ", routeTableId, igwId)
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return nil
}

//https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_Route_Tables.html
//https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html
//   VPC     
func (VPCHandler *TencentVPCHandler) GetDefaultRouteTable(vpcId string) (string, error) {
        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return "", err
        }

        cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &gt; 0 {
                routeTableId := *result.RouteTables[0].RouteTableId
                cblogger.Infof("  ID  : [%s]", routeTableId)
                return routeTableId, nil
        } else {
                return "", errors.New("VPC    ID   .")
        }
}

func (VPCHandler *TencentVPCHandler) CreateSubnet(vpcId string, reqSubnetInfo irs.SubnetInfo) (irs.SubnetInfo, error) {
        cblogger.Info(reqSubnetInfo)

        zoneId := VPCHandler.Region.Zone
        cblogger.Infof("Zone : %s", zoneId)
        if zoneId == "" {
                cblogger.Error("Connection  Zone  .")
                return irs.SubnetInfo{}, errors.New("Connection  Zone  .")
        }

        if reqSubnetInfo.IId.SystemId != "" {
                vpcInfo, errVpcInfo := VPCHandler.GetSubnet(reqSubnetInfo.IId.SystemId)
                if errVpcInfo == nil {
                        cblogger.Errorf(" [%S] Subnet         .", reqSubnetInfo.IId.SystemId)
                        cblogger.Info(vpcInfo)
                        return vpcInfo, errors.New("InvalidVNetwork.Duplicate: The Subnet '" + reqSubnetInfo.IId.SystemId + "' already exists.")
                }
        }

        // 
        input := &amp;ec2.CreateSubnetInput{
                CidrBlock: aws.String(reqSubnetInfo.IPv4_CIDR),
                VpcId:     aws.String(vpcId),
                //AvailabilityZoneId: aws.String(zoneId),        //use1-az1, use1-az2, use1-az3, use1-az4, use1-az5, use1-az6
                AvailabilityZone: aws.String(zoneId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetInfo.IId.NameId,
                CloudOSAPI:   "CreateSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        cblogger.Info(input)
        result, err := VPCHandler.Client.CreateSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)

        //vNetworkInfo := irs.VNetworkInfo{}
        vNetworkInfo := ExtractSubnetDescribeInfo(result.Subnet)

        //Subnet Name 
        if SetNameTag(VPCHandler.Client, *result.Subnet.SubnetId, reqSubnetInfo.IId.NameId) {
                cblogger.Infof("Subnet %s Name  ", reqSubnetInfo.IId.NameId)
        } else {
                cblogger.Errorf("Subnet %s Name  ", reqSubnetInfo.IId.NameId)
        }

        vNetworkInfo.IId.NameId = reqSubnetInfo.IId.NameId

        // VPC    Subnet   .
        errSubnetRoute := VPCHandler.AssociateRouteTable(vpcId, vNetworkInfo.IId.SystemId)
        if errSubnetRoute != nil {
        } else {
                return vNetworkInfo, errSubnetRoute
        }

        return vNetworkInfo, nil
}

// VPC    Subnet  .
func (VPCHandler *TencentVPCHandler) AssociateRouteTable(vpcId string, subnetId string) error {
        routeTableId, errRoute := VPCHandler.GetDefaultRouteTable(vpcId)
        if errRoute != nil {
                return errRoute
        }

        input := &amp;ec2.AssociateRouteTableInput{
                RouteTableId: aws.String(routeTableId),
                SubnetId:     aws.String(subnetId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetId,
                CloudOSAPI:   "AssociateRouteTable()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.AssociateRouteTable(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return err
        }

        callogger.Info(call.String(callLogInfo))
        cblogger.Info(result)
        //spew.Dump(result)
        return nil
}

func (VPCHandler *TencentVPCHandler) ListVPC() ([]*irs.VPCInfo, error) {
        cblogger.Debug("Start")
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListVPC",
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(&amp;ec2.DescribeVpcsInput{})
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                callLogInfo.ErrorMSG = err.Error()
                callogger.Info(call.String(callLogInfo))
                return nil, err
        }
        callogger.Info(call.String(callLogInfo))

        var vNetworkInfoList []*irs.VPCInfo
        for _, curVpc := range result.Vpcs {
                cblogger.Infof("[%s] VPC  ", *curVpc.VpcId)
                vNetworkInfo, vpcErr := VPCHandler.GetVPC(irs.IID{SystemId: *curVpc.VpcId})
                if vpcErr != nil {
                        return nil, vpcErr
                }
                vNetworkInfoList = append(vNetworkInfoList, &amp;vNetworkInfo)
        }

        spew.Dump(vNetworkInfoList)
        return vNetworkInfoList, nil
}

func (VPCHandler *TencentVPCHandler) GetVPC(vpcIID irs.IID) (irs.VPCInfo, error) {
        cblogger.Info("VPC IID : ", vpcIID.SystemId)

        input := &amp;ec2.DescribeVpcsInput{
                VpcIds: []*string{
                        aws.String(vpcIID.SystemId),
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcIID.SystemId,
                CloudOSAPI:   "DescribeVpcs()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DescribeVpcs(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.VPCInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        //spew.Dump(result)

        if reflect.ValueOf(result.Vpcs).IsNil() {
                return irs.VPCInfo{}, nil
        }

        var errSubnet error
        awsVpcInfo := ExtractVpcDescribeInfo(result.Vpcs[0])
        awsVpcInfo.SubnetInfoList, errSubnet = VPCHandler.ListSubnet(vpcIID.SystemId)
        if errSubnet != nil {
                return awsVpcInfo, errSubnet
        }

        return awsVpcInfo, nil
}

//VPC  
func ExtractVpcDescribeInfo(vpcInfo *ec2.Vpc) irs.VPCInfo {
        awsVpcInfo := irs.VPCInfo{
                IId:       irs.IID{SystemId: *vpcInfo.VpcId},
                IPv4_CIDR: *vpcInfo.CidrBlock,
                //IsDefault: *vpcInfo.IsDefault,
                //State:     *vpcInfo.State,
        }

        //Name Tag "Name"  
        //NameId   .
        return awsVpcInfo
}

func (VPCHandler *TencentVPCHandler) DeleteSubnet(subnetIID irs.IID) (bool, error) {
        input := &amp;ec2.DeleteSubnetInput{
                SubnetId: aws.String(subnetIID.SystemId),
        }
        cblogger.Info(input)

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: subnetIID.SystemId,
                CloudOSAPI:   "DeleteSubnet()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        start := call.Start()

        _, err := VPCHandler.Client.DeleteSubnet(input)
        callLogInfo.ElapsedTime = call.Elapsed(start)
        cblogger.Info(err)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return false, err
        }

        callogger.Info(call.String(callLogInfo))
        return true, nil
}

func (VPCHandler *TencentVPCHandler) DeleteVPC(vpcIID irs.IID) (bool, error) {
        cblogger.Infof("Delete VPC : [%s]", vpcIID.SystemId)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil {
                return false, errVpcInfo
        }

        //=================
        // Subnet
        //=================
        for _, curSubnet := range vpcInfo.SubnetInfoList {
                cblogger.Infof("[%s] Subnet ", curSubnet.IId.SystemId)
                delSubnet, errSubnet := VPCHandler.DeleteSubnet(curSubnet.IId)
                if errSubnet != nil {
                        return false, errSubnet
                }

                if delSubnet {
                        cblogger.Infof("  ==&gt; [%s] Subnet ", curSubnet.IId.SystemId)
                } else {
                        cblogger.Errorf("  ==&gt; [%s] Subnet ", curSubnet.IId.SystemId)
                        return false, errors.New("Subnet   VPC   .") //    
                }
        }

        cblogger.Infof("[%s] VPC  .", vpcInfo.IId.SystemId)
        cblogger.Info("VPC    IGW / Route  ")

        //    IGW   .
        errRoute := VPCHandler.DeleteRouteIGW(vpcInfo.IId.SystemId)
        if errRoute != nil {
                cblogger.Error("   0.0.0.0/0 IGW   ")
                cblogger.Error(errRoute)
                if "InvalidRoute.NotFound" == errRoute.Error() {
                        cblogger.Infof("[%s] #255      .", errRoute)
                } else {
                        return false, errRoute
                }
                //} else {
                //        cblogger.Info("   0.0.0.0/0 IGW   ")
        }

        //VPC   IGW . (VPC   IGW )
        errIgw := VPCHandler.DeleteAllIGW(vpcInfo.IId.SystemId)
        if errIgw != nil {
                cblogger.Error(" IGW   : ", errIgw)
        } else {
                cblogger.Info(" IGW  ")
        }

        input := &amp;ec2.DeleteVpcInput{
                VpcId: aws.String(vpcInfo.IId.SystemId),
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")
        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: vpcInfo.IId.SystemId,
                CloudOSAPI:   "DeleteVpc()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        result, err := VPCHandler.Client.DeleteVpc(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return false, err
        }
        callogger.Info(call.String(callLogInfo))

        cblogger.Info(result)
        spew.Dump(result)
        return true, nil
}

// VPC  0.0.0.0/0   .
// #255       0.0.0.0    
func (VPCHandler *TencentVPCHandler) DeleteRouteIGW(vpcId string) error {
        cblogger.Infof("VPC ID : [%s]", vpcId)
        routeTableId := ""

        input := &amp;ec2.DescribeRouteTablesInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeRouteTables(input)
        if err != nil {
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)

        if len(result.RouteTables) &lt; 1 {
                return errors.New("VPC       .")
        }

        routeTableId = *result.RouteTables[0].RouteTableId
        cblogger.Infof("  ID  : [%s]", routeTableId)

        cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)  .", routeTableId)

        //ec2.Route
        findIgw := false
        for _, curRoute := range result.RouteTables[0].Routes {
                cblogger.Infof("DestinationCidrBlock[%s] Check", *curRoute.DestinationCidrBlock)

                if "0.0.0.0/0" == *curRoute.DestinationCidrBlock {
                        cblogger.Infof("===&gt;RouteTable[%s]  (0.0.0.0/0)  !!", routeTableId)
                        findIgw = true
                        break
                }
        }

        if !findIgw {
                cblogger.Infof("RouteTable[%s]  IGW (0.0.0.0/0)     . ", routeTableId)
                return nil
        }

        cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)  .", routeTableId)
        inputDel := &amp;ec2.DeleteRouteInput{
                DestinationCidrBlock: aws.String("0.0.0.0/0"),
                RouteTableId:         aws.String(routeTableId),
        }
        cblogger.Info(inputDel)

        //https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteRoute.html
        resultDel, err := VPCHandler.Client.DeleteRoute(inputDel)
        if err != nil {
                cblogger.Errorf("RouteTable[%s]  (0.0.0.0/0)   ", routeTableId)
                if aerr, ok := err.(awserr.Error); ok {
                        //InvalidRoute.NotFound
                        cblogger.Errorf("Error Code : [%s] - Error:[%s] - Message:[%s]", aerr.Code(), aerr.Error(), aerr.Message())
                        switch aerr.Code() {
                        case "InvalidRoute.NotFound": //NotFound   (#255)
                                return errors.New(aerr.Code())
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }
        cblogger.Infof("RouteTable[%s]  (0.0.0.0/0)   ", routeTableId)

        cblogger.Info(resultDel)
        spew.Dump(resultDel)
        cblogger.Info("   0.0.0.0/0 IGW   ")
        return nil
}

//VPC   IGW .
func (VPCHandler *TencentVPCHandler) DeleteAllIGW(vpcId string) error {
        input := &amp;ec2.DescribeInternetGatewaysInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("attachment.vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        result, err := VPCHandler.Client.DescribeInternetGateways(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)

        // VPC     IGW 
        // ,  .
        for _, curIgw := range result.InternetGateways {
                //IGW   IGW  .
                VPCHandler.DetachInternetGateway(vpcId, *curIgw.InternetGatewayId)
                //IGW 
                VPCHandler.DeleteIGW(*curIgw.InternetGatewayId)
        }

        return nil
}

// VPC  IGW  .
func (VPCHandler *TencentVPCHandler) DetachInternetGateway(vpcId string, igwId string) error {
        cblogger.Infof("VPC[%s]  IGW[%s]  .", vpcId, igwId)

        input := &amp;ec2.DetachInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
                VpcId:             aws.String(vpcId),
        }

        result, err := VPCHandler.Client.DetachInternetGateway(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)
        return nil
}

// IGW  .
func (VPCHandler *TencentVPCHandler) DeleteIGW(igwId string) error {
        input := &amp;ec2.DeleteInternetGatewayInput{
                InternetGatewayId: aws.String(igwId),
        }

        result, err := VPCHandler.Client.DeleteInternetGateway(input)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                }
                return err
        }

        cblogger.Info(result)
        spew.Dump(result)
        return nil
}

//VPC    .
func (VPCHandler *TencentVPCHandler) ListSubnet(vpcId string) ([]irs.SubnetInfo, error) {
        cblogger.Debug("Start")
        var arrSubnetInfoList []irs.SubnetInfo

        input := &amp;ec2.DescribeSubnetsInput{
                Filters: []*ec2.Filter{
                        {
                                Name: aws.String("vpc-id"),
                                Values: []*string{
                                        aws.String(vpcId),
                                },
                        },
                },
        }

        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: "ListSubnet",
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()

        //spew.Dump(input)
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)

        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return nil, err
        }
        callogger.Info(call.String(callLogInfo))

        spew.Dump(result)
        for _, curSubnet := range result.Subnets {
                cblogger.Infof("[%s] Subnet  ", *curSubnet.SubnetId)
                arrSubnetInfo := ExtractSubnetDescribeInfo(curSubnet)
                arrSubnetInfoList = append(arrSubnetInfoList, arrSubnetInfo)
        }

        spew.Dump(arrSubnetInfoList)
        return arrSubnetInfoList, nil
}

func (VPCHandler *TencentVPCHandler) GetSubnet(reqSubnetId string) (irs.SubnetInfo, error) {
        cblogger.Infof("SubnetId : [%s]", reqSubnetId)

        input := &amp;ec2.DescribeSubnetsInput{
                SubnetIds: []*string{
                        aws.String(reqSubnetId),
                },
        }

        spew.Dump(input)
        // logger for HisCall
        callogger := call.GetLogger("HISCALL")

        callLogInfo := call.CLOUDLOGSCHEMA{
                CloudOS:      call.AWS,
                RegionZone:   VPCHandler.Region.Zone,
                ResourceType: call.VPCSUBNET,
                ResourceName: reqSubnetId,
                CloudOSAPI:   "DescribeSubnets()",
                ElapsedTime:  "",
                ErrorMSG:     "",
        }
        callLogStart := call.Start()
        result, err := VPCHandler.Client.DescribeSubnets(input)
        callLogInfo.ElapsedTime = call.Elapsed(callLogStart)
        cblogger.Info(result)
        //spew.Dump(result)
        if err != nil {
                if aerr, ok := err.(awserr.Error); ok {
                        switch aerr.Code() {
                        default:
                                cblogger.Error(aerr.Error())
                                callLogInfo.ErrorMSG = aerr.Error()
                        }
                } else {
                        // Print the error, cast err to awserr.Error to get the Code and
                        // Message from an error.
                        cblogger.Error(err.Error())
                        callLogInfo.ErrorMSG = err.Error()
                }
                callogger.Info(call.String(callLogInfo))
                return irs.SubnetInfo{}, err
        }
        callogger.Info(call.String(callLogInfo))

        if !reflect.ValueOf(result.Subnets).IsNil() {
                retSubnetInfo := ExtractSubnetDescribeInfo(result.Subnets[0])
                return retSubnetInfo, nil
        } else {
                return irs.SubnetInfo{}, errors.New("InvalidSubnet.NotFound: The CBVnetwork '" + reqSubnetId + "' does not exist")
        }
}


//Subnet  
func ExtractSubnetDescribeInfo(subnetInfo *ec2.Subnet) irs.SubnetInfo {
        vNetworkInfo := irs.SubnetInfo{
                IId:       irs.IID{SystemId: *subnetInfo.SubnetId},
                IPv4_CIDR: *subnetInfo.CidrBlock,
                //Status:    *subnetInfo.State,
        }

        keyValueList := []irs.KeyValue{
                {Key: "VpcId", Value: *subnetInfo.VpcId},
                {Key: "MapPublicIpOnLaunch", Value: strconv.FormatBool(*subnetInfo.MapPublicIpOnLaunch)},
                {Key: "AvailableIpAddressCount", Value: strconv.FormatInt(*subnetInfo.AvailableIpAddressCount, 10)},
                {Key: "AvailabilityZone", Value: *subnetInfo.AvailabilityZone},
                {Key: "Status", Value: *subnetInfo.State},
        }
        vNetworkInfo.KeyValueList = keyValueList

        return vNetworkInfo
}

func (VPCHandler *TencentVPCHandler) AddSubnet(vpcIID irs.IID, subnetInfo irs.SubnetInfo) (irs.VPCInfo, error) {
        cblogger.Infof("[%s] Subnet  - CIDR : %s", subnetInfo.IId.NameId, subnetInfo.IPv4_CIDR)
        resSubnet, errSubnet := VPCHandler.CreateSubnet(vpcIID.SystemId, subnetInfo)
        if errSubnet != nil {
                cblogger.Error(errSubnet)
                return irs.VPCInfo{}, errSubnet
        }
        cblogger.Info(resSubnet)

        vpcInfo, errVpcInfo := VPCHandler.GetVPC(vpcIID)
        if errVpcInfo != nil {
                cblogger.Error(errVpcInfo)
                return irs.VPCInfo{}, errVpcInfo
        }

        findSubnet := false
        cblogger.Debug("==============   =========")
        for posSubnet, curSubnetInfo := range vpcInfo.SubnetInfoList {
                cblogger.Debugf("%d - [%s] Subnet  ", posSubnet, curSubnetInfo.IId.SystemId)
                if resSubnet.IId.SystemId == curSubnetInfo.IId.SystemId {
                        cblogger.Infof("   [%s] Subnet  . - SystemID:[%s]", subnetInfo.IId.NameId, curSubnetInfo.IId.SystemId)
                        //for ~ range     . for loop    vpcInfo    .
                        cblogger.Infof("  : %d", posSubnet)
                        //vpcInfo.SubnetInfoList[posSubnet].IId.NameId = "~"
                        vpcInfo.SubnetInfoList[posSubnet].IId.NameId = subnetInfo.IId.NameId
                        findSubnet = true
                        break
                }
        }

        if !findSubnet {
                cblogger.Errorf("   VPC     [%s] [%s]  .", subnetInfo.IId.NameId, resSubnet.IId.SystemId)
                return irs.VPCInfo{}, errors.New("MismatchSubnet.NotFound: No SysmteId[" + resSubnet.IId.SystemId + "] found for newly created Subnet[" + subnetInfo.IId.NameId + "].")
        }
        //spew.Dump(vpcInfo)

        return vpcInfo, nil
}

func (VPCHandler *TencentVPCHandler) RemoveSubnet(vpcIID irs.IID, subnetIID irs.IID) (bool, error) {
        cblogger.Infof("[%s] VPC [%s] Subnet ", vpcIID.SystemId, subnetIID.SystemId)

        return VPCHandler.DeleteSubnet(subnetIID)
        //return false, nil
}
*/
</pre>
		
		<pre class="file" id="file124" style="display: none">// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.03.

package iidmanager

import (
        "fmt"
        "sync"
        "strings"

        "github.com/sirupsen/logrus"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        "github.com/cloud-barista/cb-store/config"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type IIDRWLOCK struct {
        rwMutex        sync.RWMutex // for global readwrite Locking
}
//====================================================================


//====================================================================
type IIDInfo struct {
        ConnectionName  string  // ex) "aws-seoul-config"
        ResourceType    string  // ex) "VM"
        IId             resources.IID  // ex) {NameId, SystemId} = {"powerkim_vm_01", "i-0bc7123b7e5cbf79d"}
}
//====================================================================

func (iidRWLock *IIDRWLOCK)IsExistIID(connectionName string, resourceType string, iId resources.IID) (bool, error) <span class="cov8" title="1">{
        cblog.Debug("check the IID.NameId:" + iId.NameId + " existence")

iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        return isExist(connectionName, resourceType, iId.NameId)
}</span>

func (iidRWLock *IIDRWLOCK)CreateIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Debug("check the IID.NameId:" + iId.NameId + " existence")

iidRWLock.rwMutex.Lock()
defer iidRWLock.rwMutex.Unlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        ret, err := isExist(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if ret == true </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(iId.NameId + " already exists!")
        }</span>

        <span class="cov8" title="1">iidInfo, err2 := forceCreateIID(connectionName, resourceType, iId)

        // escape: "%2F" =&gt; "/"
        iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err2</span>
}

func (iidRWLock *IIDRWLOCK)UpdateIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov0" title="0">{
        cblog.Debug("check the IID.NameId:" + iId.NameId + " existence")

iidRWLock.rwMutex.Lock()
defer iidRWLock.rwMutex.Unlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        ret, err := isExist(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if ret == false </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(iId.NameId + " does not exists!")
        }</span>

        <span class="cov0" title="0">iidInfo, err2 := forceCreateIID(connectionName, resourceType, iId)

        // escape: "%2F" =&gt; "/"
        iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err2</span>
}

// 1. check params
// 2. check pre-existing id
// 3. insert new IIDInfo into cb-store
func forceCreateIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateIID()")

        cblog.Debug("check params")
        err := checkParams(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        
        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")
        err = insertInfo(connectionName, resourceType, iId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">iidInfo := &amp;IIDInfo{connectionName, resourceType, iId}
        return iidInfo, nil</span>
}

func (iidRWLock *IIDRWLOCK)ListIID(connectionName string, resourceType string) ([]*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListIID()")

iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()
        iIDInfoList, err := listInfo(connectionName, resourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // escape: "%2F" =&gt; "/"
        <span class="cov8" title="1">for i, iidInfo := range iIDInfoList </span><span class="cov8" title="1">{
                iIDInfoList[i].IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")
        }</span>

        <span class="cov8" title="1">return iIDInfoList, nil</span>
}

// 1. check params
// 2. get IIDInfo from cb-store
func (iidRWLock *IIDRWLOCK)GetIID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetIID()")

        cblog.Debug("check params")
        err := checkParams(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        iidInfo, err := getInfo(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // escape: "%2F" =&gt; "/"
        <span class="cov8" title="1">iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err</span>
}

// 1. check params
// 2. find IIDInfo from cb-store
func (iidRWLock *IIDRWLOCK)FindIID(connectionName string, resourceType string, keyword string) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call FindIID()")

        cblog.Debug("check params")
        err := checkParamsKeyword(connectionName, resourceType, &amp;keyword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        keyword = strings.ReplaceAll(keyword, "/", "%2F")

        iIDInfoList, err := listInfo(connectionName, resourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, iidInfo := range iIDInfoList </span><span class="cov8" title="1">{
                if strings.Contains(iidInfo.IId.NameId, keyword) </span><span class="cov8" title="1">{
                        // escape: "%2F" =&gt; "/"
                        iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")
                        return iidInfo, nil
                }</span>
        }
        <span class="cov0" title="0">return &amp;IIDInfo{}, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + keyword + "] does not exist!")</span>
}

// 1. check params
// 2. get IIDInfo from cb-store
func (iidRWLock *IIDRWLOCK)GetIIDbySystemID(connectionName string, resourceType string, iId resources.IID) (*IIDInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetIIDbySystemID()")

        cblog.Debug("check params")
        err := checkParamsSystemId(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.RLock()
defer iidRWLock.rwMutex.RUnlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        iidInfo, err := getInfoByValue(connectionName, resourceType, iId.SystemId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        // escape: "%2F" =&gt; "/"
        <span class="cov8" title="1">iidInfo.IId.NameId = strings.ReplaceAll(iidInfo.IId.NameId, "%2F", "/")

        return iidInfo, err</span>
}


func (iidRWLock *IIDRWLOCK)DeleteIID(connectionName string, resourceType string, iId resources.IID) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteIID()")


        cblog.Debug("check params")
        err := checkParams(connectionName, resourceType, &amp;iId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err

        }</span>

<span class="cov8" title="1">iidRWLock.rwMutex.Lock()
defer iidRWLock.rwMutex.Unlock()

        // escape: "/" =&gt; "%2F"
        iId.NameId = strings.ReplaceAll(iId.NameId, "/", "%2F")

        result, err := deleteInfo(connectionName, resourceType, iId.NameId)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(connectionName string, resourceType string, iId *resources.IID) error <span class="cov8" title="1">{
        if connectionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if resourceType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ResourceType is empty!")
        }</span>
        <span class="cov8" title="1">if iId == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("IID is empty!")
        }</span>
        <span class="cov8" title="1">if iId.NameId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IID.NameId is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func checkParamsSystemId(connectionName string, resourceType string, iId *resources.IID) error <span class="cov8" title="1">{
        if connectionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if resourceType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ResourceType is empty!")
        }</span>
        <span class="cov8" title="1">if iId == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("IID is empty!")
        }</span>
        <span class="cov8" title="1">if iId.SystemId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IID.SystemId is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func checkParamsKeyword(connectionName string, resourceType string, keyword *string) error <span class="cov8" title="1">{
        if connectionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if resourceType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ResourceType is empty!")
        }</span>
        <span class="cov8" title="1">if keyword == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Keyword is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

</pre>
		
		<pre class="file" id="file125" style="display: none">// CloudDriverInfo &lt;-&gt; CB-Store Handler for Cloud Driver Info. Manager.
// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.03.

package iidmanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        "github.com/cloud-barista/poc-cicd-spider/cloud-control-manager/cloud-driver/interfaces/resources"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type IIDInfo struct {
        ConnectionName        string        // ex) "aws-seoul-config"
        ResourceType        string        // ex) "VM"
        IId                resources.IID        // ex) {NameId, SystemId} = {"powerkim_vm_01", "i-0bc7123b7e5cbf79d"}
}
*/ //====================================================================


// format
// /resource-info-spaces/iids/{ConnectionName}/{ResourceType}/&lt;IID.NameId&gt; [IID.SystemId]
        // Key: "/resource-info-spaces/iids/{ConnectionName}/{ResourceType}/&lt;IID.NameId&gt;"
        // Value: "[IID.SystemId]"
// ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

func insertInfo(connectionName string, resourceType string, iid resources.IID) error <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + iid.NameId
        value := iid.SystemId

        err := store.Put(key, value)
        if err != nil </span><span class="cov0" title="0">{
                //cblog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create IIDInfo List &amp; return
func listInfo(connectionName string, resourceType string) ([]*IIDInfo, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">iidInfoList := make([]*IIDInfo, len(keyValueList))
        for count, kv := range keyValueList </span><span class="cov8" title="1">{
                iidInfo := &amp;IIDInfo{connectionName, resourceType, resources.IID{utils.GetNodeValue(kv.Key, 5), kv.Value} }
                iidInfoList[count] = iidInfo
        }</span>

        <span class="cov8" title="1">return iidInfoList, nil</span>
}

// 1. get a key-value
// 2. create IIDInfo &amp; return
func getInfo(connectionName string, resourceType string, nameId string) (*IIDInfo, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + nameId

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

//        if len(keyValueList) &lt; 1 {
//                return nil, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + nameId + "] does not exist!")
//        }

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/..., 
                // so we have to check the sameness of nameId.
                if utils.GetNodeValue(kv.Key, 5) == nameId </span><span class="cov8" title="1">{
                        iidInfo := &amp;IIDInfo{connectionName, resourceType, resources.IID{nameId, kv.Value} }
                        return iidInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + nameId + "] does not exist!")</span>
}

// 1. get list
// 2. find keyvalue by value
// 2. create IIDInfo &amp; return
func getInfoByValue(connectionName string, resourceType string, systemId string) (*IIDInfo, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/??? [i-0bc7123b7e5cbf79d]

        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/...,
                // so we have to check the sameness of nameId.
                if kv.Value == systemId </span><span class="cov8" title="1">{
                        iidInfo := &amp;IIDInfo{connectionName, resourceType, resources.IID{utils.GetNodeValue(kv.Key, 5), systemId} }
                        return iidInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return &amp;IIDInfo{}, nil</span>
}

// 1. get a key-value
// 2. return existence of  or not
func isExist(connectionName string, resourceType string, nameId string) (bool, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]


        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + nameId


        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/...,
                // so we have to check the sameness of nameId.
                if utils.GetNodeValue(kv.Key, 5) == nameId </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(connectionName string, resourceType string, nameId string) (bool, error) <span class="cov8" title="1">{
        // ex) /resource-info-spaces/iids/aws-seoul-config/VM/powerkim_vm_01 [i-0bc7123b7e5cbf79d]


        key := "/resource-info-spaces/iids/" + connectionName + "/" + resourceType + "/" + nameId

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/nameId/... or ~/nameId-01/..., 
                // so we have to check the sameness of nameId.
                if utils.GetNodeValue(kv.Key, 5) == nameId </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
        }

        <span class="cov0" title="0">return false, fmt.Errorf("[" + connectionName + ":" + resourceType +  ":" + nameId + "] does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file126" style="display: none">// Package for VM's SSH and SCP of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.10.

package sshrun

import (
        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"


        "io"
        "github.com/bramvdbogaerde/go-scp"
        "github.com/bramvdbogaerde/go-scp/auth"
        "golang.org/x/crypto/ssh"
        "os"
        "strings"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type SSHInfo struct {
        UserName        string  // ex) "root"
        PrivateKey      []byte  // ex)   []byte(`-----BEGIN RSA PRIVATE KEY-----
                                //              MIIEoQIBAAKCAQEArVNOLwMIp5VmZ4VPZotcoCHdEzimKalAsz+ccLfvAA1Y2ELH
                                //              ...`)
        ServerPort      string  // ex) "node12:22"
}
//====================================================================

func Connect(sshInfo SSHInfo) (scp.Client, error) <span class="cov0" title="0">{
        cblog.Info("call Connect()")

        clientConfig, _ := getClientConfig(sshInfo.UserName, sshInfo.PrivateKey, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

//====================================================================
type SSHKeyPathInfo struct {
        UserName        string  // ex) "root"
        KeyPath             string         // ex) "/root/.ssh/id_rsa // You should use the full path.
        ServerPort      string  // ex) "node12:22"
}
//====================================================================

func ConnectKeyPath(sshKeyPathInfo SSHKeyPathInfo) (scp.Client, error) <span class="cov0" title="0">{
        cblog.Info("call ConnectKeyPath()")

        clientConfig, _ := auth.PrivateKey(sshKeyPathInfo.UserName, sshKeyPathInfo.KeyPath, ssh.InsecureIgnoreHostKey())
        client := scp.NewClient(sshKeyPathInfo.ServerPort, &amp;clientConfig)
        err := client.Connect()
        return client, err
}</span>

func getClientConfig(username string, privateKey []byte, keyCallBack ssh.HostKeyCallback) (ssh.ClientConfig, error) <span class="cov0" title="0">{

        signer, err := ssh.ParsePrivateKey(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return ssh.ClientConfig{}, err
        }</span>

        <span class="cov0" title="0">clientConfig := ssh.ClientConfig{
                User: username,
                Auth: []ssh.AuthMethod{
                        ssh.PublicKeys(signer),
                },
                HostKeyCallback: keyCallBack,
        }
        return clientConfig, nil</span>
}

func Close(client scp.Client)<span class="cov0" title="0">{
        cblog.Info("call Close()")

        client.Close()        
}</span>

func RunCommand(client scp.Client, cmd string) (string, error) <span class="cov0" title="0">{
        cblog.Info("call RunCommand()")

        session := client.Session
        sshOut, err := session.StdoutPipe()
        session.Stderr = os.Stderr

        err = session.Run(cmd)
        //err = session.Start(cmd)

        return stdoutToString(sshOut), err
}</span>

func stdoutToString(sshOut io.Reader) string <span class="cov0" title="0">{
        buf := make([]byte, 1000)
        num, err := sshOut.Read(buf)
        outStr := ""
        if err == nil </span><span class="cov0" title="0">{
                outStr = string(buf[:num])
        }</span>
        <span class="cov0" title="0">for err == nil </span><span class="cov0" title="0">{
                num, err = sshOut.Read(buf)
                outStr += string(buf[:num])
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span><span class="cov0" title="0">{
                                cblog.Error(err)
                        }</span>
                }

        }
        <span class="cov0" title="0">return strings.Trim(outStr, "\n")</span>
}

func Copy(client scp.Client, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        cblog.Info("call Copy()")

        // Open a file
        file, _ := os.Open(sourcePath)
        defer file.Close()
        return client.CopyFile(file, remotePath, "0755")
}</span>

//=============== for One Call Service
func SSHRun(sshInfo SSHInfo, cmd string) (string, error) <span class="cov0" title="0">{
        cblog.Info("call SSHRun()")


        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHRunByKeyPath(sshInfo SSHKeyPathInfo, cmd string) (string, error) <span class="cov0" title="0">{
        cblog.Info("call SSHRunKeyPath()")


        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return RunCommand(sshCli, cmd)</span>
}

func SSHCopy(sshInfo SSHInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        cblog.Info("call SSHCopy()")


        sshCli, err := Connect(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

func SSHCopyByKeyPath(sshInfo SSHKeyPathInfo, sourcePath string, remotePath string) error <span class="cov0" title="0">{
        cblog.Info("call SSHCopyByKeyPath()")


        sshCli, err := ConnectKeyPath(sshInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer Close(sshCli)

        return Copy(sshCli, sourcePath, remotePath)</span>
}

</pre>
		
		<pre class="file" id="file127" style="display: none">package cloudos

import (
        "github.com/sirupsen/logrus"
        "github.com/cloud-barista/cb-store/config"

        "gopkg.in/yaml.v3"
        "io/ioutil"
        "os"
        _ "fmt"
        "strings"
        "sort"
)


var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>



type CloudOSList struct {
        Name []string `yaml:"cloudos"`
}

func readYaml() CloudOSList <span class="cov8" title="1">{
        // Set Environment Value of Project Root Path
        rootPath := os.Getenv("CBSPIDER_ROOT")
        if rootPath == "" </span><span class="cov0" title="0">{
                cblog.Error("$CBSPIDER_ROOT is not set!!")
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">data, err := ioutil.ReadFile(rootPath + "/conf/cloudos.yaml")
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                panic(err)</span>
        }

        <span class="cov8" title="1">var coList CloudOSList
        err = yaml.Unmarshal(data, &amp;coList)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                panic(err)</span>
        }

        <span class="cov8" title="1">return coList</span>
}

func ListCloudOS() []string <span class="cov8" title="1">{

        // read YAML file
        cloudosList := readYaml()

        // to Upper
        for n, cloudos := range cloudosList.Name</span><span class="cov8" title="1">{
                cloudosList.Name[n] = strings.ToUpper(cloudos)
        }</span>

        <span class="cov8" title="1">sort.Strings(cloudosList.Name)
        cblog.Info(cloudosList)

/*        for _, cloudos := range cloudosList.Name{
                fmt.Printf("\n%s", cloudos)
        }
*/

        return cloudosList.Name</span>
}

</pre>
		
		<pre class="file" id="file128" style="display: none">// Cloud ConnectionConfig Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package connectionconfiginfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type ConnectionConfigInfo struct {
        ConfigName     string // ex) "config01"
        ProviderName   string // ex) "AWS"
        DriverName     string // ex) "AWS-Test-Driver-V0.5"
        CredentialName string // ex) "credential01"
        RegionName     string // ex) "region01"
}

//====================================================================

func CreateConnectionConfigInfo(configInfo ConnectionConfigInfo) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        return CreateConnectionConfig(configInfo.ConfigName, configInfo.ProviderName, configInfo.DriverName, configInfo.CredentialName, configInfo.RegionName)
}</span>

// 1. check params
// 2. check driver files
// 3. insert them into cb-store
// You should copy the driver library into ~/libs before.
func CreateConnectionConfig(configName string, providerName string, driverName string, credentialName string, regionName string) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        cblog.Info("call CreateConnectionConfig()")

        cblog.Debug("check params")
        err := checkParams(configName, providerName, driverName, credentialName, regionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        // check the existence of the key to be inserted
        <span class="cov8" title="1">tmpcncInfo, err := getInfo(configName)
        if tmpcncInfo != nil </span><span class="cov8" title="1">{
                if tmpcncInfo.ConfigName == configName </span><span class="cov8" title="1">{
                        cblog.Debug("delete the existed key to update it")
                        _, err := deleteInfo(configName)
                        if err != nil </span><span class="cov0" title="0">{
                                cblog.Error(err)
                                return nil, err
                        }</span>                        
                }
        }


        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = insertInfo(configName, providerName, driverName, credentialName, regionName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">cncInfo := &amp;ConnectionConfigInfo{configName, providerName, driverName, credentialName, regionName}
        return cncInfo, nil</span>
}

func ListConnectionConfig() ([]*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListConnectionConfig()")

        configInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return configInfoList, nil</span>
}

// 1. check params
// 2. get DriverInfo from cb-store
func GetConnectionConfig(configName string) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetConnectionConfig()")

        if configName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ConnectionName is empty!")
        }</span>

        <span class="cov8" title="1">cncInfo, err := getInfo(configName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return cncInfo, err</span>
}

func DeleteConnectionConfig(configName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call DeleteConnectionConfig()")

        if configName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ConnectionName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(configName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(configName string, providerName string, driverName string, credentialName string, regionName string) error <span class="cov8" title="1">{
        if configName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConnectionName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">if driverName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DriverName is empty!")
        }</span>
        <span class="cov8" title="1">if credentialName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("CredentialName is empty!")
        }</span>
        <span class="cov8" title="1">if regionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("RegionName is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">// ConnectionConfigInfo &lt;-&gt; CB-Store Handler for Cloud ConnectionConfig Info. Manager.
// Cloud ConnectionConfig Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package connectionconfiginfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type ConnectionConfigInfo struct {
        ConfigName      string  // ex) "config01"
        ProviderName    string  // ex) "AWS"
        DriverName      string  // ex) "AWS-Test-Driver-V0.5"
        CredentialName  string  // ex) "credential01"
        RegionName      string  // ex) "region01"
}
*/ //====================================================================


// format
// /cloud-info-spaces/connection-configs/&lt;ID&gt;/{Param1}/{Param2}/{Param3}/{Param4} []
// /cloud-info-spaces/connection-configs/&lt;ConfigName&gt;/{ProviderName}/{DriverName}/{CredentialName}/{RegionName} []
// ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

func insertInfo(configName string, providerName string, driverName string, credentialName string, regionName string) error <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

        key := "/cloud-info-spaces/connection-configs/" + configName + "/" + providerName + "/" +
                driverName + "/" + credentialName + "/" + regionName

        var value string

        err := store.Put(key, value)
        if err != nil </span><span class="cov0" title="0">{
                //cblog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create ConnectionConfigInfo List &amp; return
func listInfo() ([]*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

        key := "/cloud-info-spaces/connection-configs"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">configInfoList := make([]*ConnectionConfigInfo, len(keyValueList))
        for count, kv := range keyValueList </span><span class="cov8" title="1">{
                cncInfo := &amp;ConnectionConfigInfo{utils.GetNodeValue(kv.Key, 3), utils.GetNodeValue(kv.Key, 4),
                                                utils.GetNodeValue(kv.Key, 5), utils.GetNodeValue(kv.Key, 6), 
                                                utils.GetNodeValue(kv.Key, 7),
                                                }
                configInfoList[count] = cncInfo
        }</span>

        <span class="cov8" title="1">return configInfoList, nil</span>
}

// 1. get a key-value
// 2. create ConnectionConfigInfo &amp; return
func getInfo(configName string) (*ConnectionConfigInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01
        
        key := "/cloud-info-spaces/connection-configs/" + configName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(configName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/...,
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == configName </span><span class="cov8" title="1">{
                        cncInfo := &amp;ConnectionConfigInfo{utils.GetNodeValue(kv.Key, 3), utils.GetNodeValue(kv.Key, 4),
                                utils.GetNodeValue(kv.Key, 5), utils.GetNodeValue(kv.Key, 6),
                                utils.GetNodeValue(kv.Key, 7),
                                }
                        return cncInfo, nil
                }</span> // end of if
        } // end of for

        <span class="cov0" title="0">return nil, fmt.Errorf(configName + ": does not exist!")</span>
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(configName string) (bool, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/connection-configs/config01/AWS/AWS-Test-Driver-V0.5/credential01/region01

        key := "/cloud-info-spaces/connection-configs/" + configName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList(
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/...,
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == configName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">return false, fmt.Errorf(configName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file130" style="display: none">// Cloud Credential Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package credentialinfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        icbs "github.com/cloud-barista/cb-store/interfaces"
        "github.com/sirupsen/logrus"

        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "io"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type CredentialInfo struct {
        CredentialName   string          // ex) "credential01"
        ProviderName     string          // ex) "AWS"
        KeyValueInfoList []icbs.KeyValue // ex) { {ClientId, XXX},
        //         {ClientSecret, XXX},
        //         {TenantId, XXX},
        //         {SubscriptionId, XXX} }
}

//====================================================================

func RegisterCredentialInfo(crdInfo CredentialInfo) (*CredentialInfo, error) <span class="cov8" title="1">{
        return RegisterCredential(crdInfo.CredentialName, crdInfo.ProviderName, crdInfo.KeyValueInfoList)
}</span>

// 1. check params
// 2. insert them into cb-store
func RegisterCredential(credentialName string, providerName string, keyValueInfoList []icbs.KeyValue) (*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call RegisterCredential()")

        cblog.Debug("check params")
        err := checkParams(credentialName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = encryptKeyValueList(keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CredentialInfo{}, err
        }</span>

        <span class="cov8" title="1">err = insertInfo(credentialName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">crdInfo := &amp;CredentialInfo{credentialName, providerName, keyValueInfoList}
        return crdInfo, nil</span>
}

func ListCredential() ([]*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListCredential()")

        credentialInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return credentialInfoList, nil</span>
}

// 1. check params
// 2. get CredentialInfo from cb-store
func GetCredential(credentialName string) (*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetCredential()")

        if credentialName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CredentialName is empty!")
        }</span>

        <span class="cov8" title="1">crdInfo, err := getInfo(credentialName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return crdInfo, err</span>
}

// 1. check params
// 2. get CredentialInfo from cb-store
// 3. decrypt CrednetialInfo
func GetCredentialDecrypt(credentialName string) (*CredentialInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetCredential()")

        if credentialName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CredentialName is empty!")
        }</span>

        <span class="cov8" title="1">crdInfo, err := getInfo(credentialName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = decryptKeyValueList(crdInfo.KeyValueInfoList)        
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CredentialInfo{}, err
        }</span>
        <span class="cov8" title="1">return crdInfo, nil</span>
}

// @todo env by powerkim, 2020.06.01.
var key = []byte("cloud-barista-cb-spider-cloud-ba") // 32 bytes

func encryptKeyValueList(keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{

        for i, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                encb, err := encrypt(key, []byte(kv.Value))
                kv.Value = string(encb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">keyValueInfoList[i] = kv</span>
        }
        <span class="cov8" title="1">return  nil</span>
}

func decryptKeyValueList(keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{

        for i, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                decb, err := decrypt(key, []byte(kv.Value))
                kv.Value = string(decb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">keyValueInfoList[i] = kv</span>
        }
        <span class="cov8" title="1">return nil</span>        
}

func encrypt(key, text []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b := base64.StdEncoding.EncodeToString(text)
        ciphertext := make([]byte, aes.BlockSize+len(b))
        iv := ciphertext[:aes.BlockSize]
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfb := cipher.NewCFBEncrypter(block, iv)
        cfb.XORKeyStream(ciphertext[aes.BlockSize:], []byte(b))
        return ciphertext, nil</span>
}

func decrypt(key, text []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(text) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                err := fmt.Errorf("decryption: " + "ciphertext too short")
                cblog.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">iv := text[:aes.BlockSize]
        text = text[aes.BlockSize:]
        cfb := cipher.NewCFBDecrypter(block, iv)
        cfb.XORKeyStream(text, text)
        data, err := base64.StdEncoding.DecodeString(string(text))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func UnRegisterCredential(credentialName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call UnRegisterCredential()")

        if credentialName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("CredentialName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(credentialName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(credentialName string, providerName string, keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{
        if credentialName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("CredentialName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                if kv.Key == "" </span><span class="cov0" title="0">{ // Value can be empty.
                        return fmt.Errorf("Key is empty!")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// CredentialInfo &lt;-&gt; CB-Store Handler for Cloud Credential Info. Manager.
// Cloud Credential Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package credentialinfomanager

import (
        "fmt"
        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type CredentialInfo struct {
        CredentialName  string  // ex) "credential01"
        ProviderName    string  // ex) "AWS"
        KeyValueInfoList        []icbs.KeyValue      // ex) { {ClientId, XXX},
                                                         {ClientSecret, XXX},
                                                         {TenantId, XXX},
                                                         {SubscriptionId, XXX} }
}
*/ //====================================================================


// format
// /cloud-info-spaces/credentials/&lt;CredentialName&gt;/{ProviderName}/{key1} [value1]
// /cloud-info-spaces/credentials/&lt;CredentialName&gt;/{ProviderName}/{key2} [value2]
// ex)
// /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
// /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
// /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
// /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]



func insertInfo(credentialName string, providerName string, keyValueList []icbs.KeyValue) error <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]

        format := "/cloud-info-spaces/credentials/" + credentialName + "/" + providerName
// @todo lock
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                key := format + "/" + kv.Key
                value := kv.Value

                err := store.Put(key, value)
                if err != nil </span><span class="cov0" title="0">{
                        //cblog.Error(err)
                        return err
                }</span>
        }
// @todo lock
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create CredentialInfo List &amp; return
func listInfo() ([]*CredentialInfo, error) <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]

        key := "/cloud-info-spaces/credentials"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var credentialInfoList []*CredentialInfo
        var inKeyValueList []icbs.KeyValue
        prevCredName := ""
        prevProviderName := ""
        for _, kv := range keyValueList </span><span class="cov8" title="1">{

                credName := utils.GetNodeValue(kv.Key, 3)
                providerName := utils.GetNodeValue(kv.Key, 4)

                if prevCredName=="" || credName == prevCredName </span><span class="cov8" title="1">{
                        prevCredName = credName
                        prevProviderName = providerName
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span> else<span class="cov0" title="0"> {
                        // insert prev CredentialInfo
                        crdInfo := &amp;CredentialInfo{prevCredName, prevProviderName, inKeyValueList}
                        credentialInfoList = append(credentialInfoList, crdInfo)

                        prevCredName = credName
                        prevProviderName = providerName
                        inKeyValueList = nil
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span>

        }

        <span class="cov8" title="1">if len(keyValueList) &gt; 0 </span><span class="cov8" title="1">{
                // insert last CredentialInfo
                crdInfo := &amp;CredentialInfo{prevCredName, prevProviderName, inKeyValueList}
                credentialInfoList = append(credentialInfoList, crdInfo)
        }</span>

        <span class="cov8" title="1">return credentialInfoList, nil</span>
}

// 1. get a key-value
// 2. create CredentialInfo &amp; return
func getInfo(credentialName string) (*CredentialInfo, error) <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]
        
        key := "/cloud-info-spaces/credentials/" + credentialName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(credentialName + ": does not exist!")
        }</span>

        // keyValueList should have ~/driverName/... or ~/driverName-01/...,
        // so we have to check the sameness of driverName.
        // and make a KeyValueList for only Target key
        <span class="cov8" title="1">var oneKeyValueList []icbs.KeyValue
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                if utils.GetNodeValue(kv.Key, 3) == credentialName </span><span class="cov8" title="1">{
                        oneKeyValueList = append(oneKeyValueList, *kv)
                }</span>
        }

        <span class="cov8" title="1">if len(oneKeyValueList) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(credentialName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">var inKeyValueList []icbs.KeyValue
        // get ProviderName
        providerName := utils.GetNodeValue(oneKeyValueList[0].Key, 4)
        // get KeyValueList
        for _, kv := range oneKeyValueList </span><span class="cov8" title="1">{
                keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                inKeyValueList = append(inKeyValueList, keyValue)
        }</span>
        <span class="cov8" title="1">return &amp;CredentialInfo{credentialName, providerName, inKeyValueList}, nil</span> 
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(credentialName string) (bool, error) <span class="cov8" title="1">{
        // ex)
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientId [value1]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/ClientSecret [value2]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/TenantId [value3]
        // /cloud-info-spaces/credentials/aws_credential01/AWS/SubscriptionId [value4]

        key := "/cloud-info-spaces/credentials/" + credentialName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var isDelete bool
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == credentialName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">isDelete = true</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">if isDelete </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, fmt.Errorf(credentialName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file132" style="display: none">// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package driverinfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        "github.com/sirupsen/logrus"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type CloudDriverInfo struct {
        DriverName        string // ex) "AWS-Test-Driver-V0.5"
        ProviderName      string // ex) "AWS"
        DriverLibFileName string // ex) "aws-test-driver-v0.5.so"  //Already, you need to insert "*.so" in $CB_SPIDER_ROOT/cloud-driver/libs.
}

//====================================================================

func RegisterCloudDriverInfo(cldInfo CloudDriverInfo) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        return RegisterCloudDriver(cldInfo.DriverName, cldInfo.ProviderName, cldInfo.DriverLibFileName)
}</span>

// 1. check params
// 2. check driver files
// 3. insert them into cb-store
// You should copy the driver library into ~/libs before.
func RegisterCloudDriver(driverName string, providerName string, driverLibFileName string) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        cblog.Info("call RegisterCloudDriver()")

        cblog.Debug("check params")
        err := checkParams(driverName, providerName, driverLibFileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        <span class="cov8" title="1">cblog.Debug("check the driver library file")
        err = checkDriverLibFile(driverLibFileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = insertInfo(driverName, providerName, driverLibFileName)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">drvInfo := &amp;CloudDriverInfo{driverName, providerName, driverLibFileName}
        return drvInfo, nil</span>
}

func ListCloudDriver() ([]*CloudDriverInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListCloudDriver()")

        cloudDriverInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cloudDriverInfoList, nil</span>
}

// 1. check params
// 2. get DriverInfo from cb-store
func GetCloudDriver(driverName string) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetCloudDriver()")

        if driverName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DriverName is empty!")
        }</span>

        <span class="cov8" title="1">drvInfo, err := getInfo(driverName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return drvInfo, err</span>
}

func UnRegisterCloudDriver(driverName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call UnRegisterCloudDriver()")

        if driverName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("DriverName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(driverName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(driverName string, providerName string, driverLibFileName string) error <span class="cov8" title="1">{
        if driverName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DriverName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">if driverLibFileName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DriverLibFileName is empty!")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. check to exist file
// 2. check to be a shared library file
func checkDriverLibFile(driverLibFileName string) error <span class="cov8" title="1">{
        // @todo
        return nil
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">// CloudDriverInfo &lt;-&gt; CB-Store Handler for Cloud Driver Info. Manager.
// Cloud Driver Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package driverinfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type CloudDriverInfo struct {
        DriverName        string        // ex) "AWS-Test-Driver-V0.5"
        ProviderName        string        // ex) "AWS"
        DriverLibFileName        string        // ex) "aws-test-driver-v0.5.so"  //Already, you need to insert "*.so" in $CB_SPIDER_ROOT/cloud-driver/libs.
}
*/ //====================================================================


// format
// /cloud-info-spaces/drivers/&lt;ID&gt;/{Param1} [Value]
// /cloud-info-spaces/drivers/&lt;DriverName&gt;/{ProviderName} [DriverLibFileName]
// ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

func insertInfo(driverName string, providerName string, driverLibFileName string) error <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

        key := "/cloud-info-spaces/drivers/" + driverName + "/" + providerName
        value := driverLibFileName

        err := store.Put(key, value)
        if err != nil </span><span class="cov0" title="0">{
                //cblog.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create CloudDriverInfo List &amp; return
func listInfo() ([]*CloudDriverInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

        key := "/cloud-info-spaces/drivers"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cloudDriverInfoList := make([]*CloudDriverInfo, len(keyValueList))
        for count, kv := range keyValueList </span><span class="cov8" title="1">{
                drvInfo := &amp;CloudDriverInfo{utils.GetNodeValue(kv.Key, 3), utils.GetNodeValue(kv.Key, 4), kv.Value}
                cloudDriverInfoList[count] = drvInfo
        }</span>

        <span class="cov8" title="1">return cloudDriverInfoList, nil</span>
}

// 1. get a key-value
// 2. create CloudDriverInfo &amp; return
func getInfo(driverName string) (*CloudDriverInfo, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]

        
        key := "/cloud-info-spaces/drivers/" + driverName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(driverName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == driverName </span><span class="cov8" title="1">{
                        providerName := utils.GetNodeValue(kv.Key, 4)
                        driverLibFileName := kv.Value
                        drvInfo := &amp;CloudDriverInfo{driverName, providerName, driverLibFileName}
                        return drvInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf(driverName + ": does not exist!")</span>
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(driverName string) (bool, error) <span class="cov8" title="1">{
        // ex) /cloud-info-spaces/drivers/AWS_driver01-V0.5/AWS [aws-test-driver-v0.5.so]


        key := "/cloud-info-spaces/drivers/" + driverName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == driverName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">return false, fmt.Errorf(driverName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file134" style="display: none">// RegionInfo &lt;-&gt; CB-Store Handler for Cloud Region Info. Manager.
// Cloud Region Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package regioninfomanager

import (
        "fmt"
        "github.com/cloud-barista/cb-store/utils"
        "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var store icbs.Store

func init() <span class="cov8" title="1">{
        store = cbstore.GetStore()
}</span>


/* //====================================================================
type RegionInfo struct {
        RegionName      string  // ex) "region01"
        ProviderName    string  // ex) "GCP"
        KeyValueInfoList        []icbs.KeyValue // ex) { {region, us-east1},
                                                //       {zone, us-east1-c},
}
*/ //====================================================================


// format
// /cloud-info-spaces/regions/&lt;RegionName&gt;/{ProviderName}/{key1} [value1]
// /cloud-info-spaces/regions/&lt;RegionName&gt;/{ProviderName}/{key2} [value2]
// ex-1)
// /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
// ex-2)
// /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
// /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]



func insertInfo(regionName string, providerName string, keyValueList []icbs.KeyValue) error <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]

        format := "/cloud-info-spaces/regions/" + regionName + "/" + providerName
// @todo lock
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                key := format + "/" + kv.Key
                value := kv.Value

                err := store.Put(key, value)
                if err != nil </span><span class="cov0" title="0">{
                        //cblog.Error(err)
                        return err
                }</span>
        }
// @todo lock
        <span class="cov8" title="1">return nil</span>
}

// 1. get key-value list
// 2. create RegionInfo List &amp; return
func listInfo() ([]*RegionInfo, error) <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]


        key := "/cloud-info-spaces/regions"
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var regionInfoList []*RegionInfo
        var inKeyValueList []icbs.KeyValue
        prevRegionName := ""
        prevProviderName := ""
        for _, kv := range keyValueList </span><span class="cov8" title="1">{

                regionName := utils.GetNodeValue(kv.Key, 3)
                providerName := utils.GetNodeValue(kv.Key, 4)

                if prevRegionName=="" || regionName == prevRegionName </span><span class="cov8" title="1">{
                        prevRegionName = regionName
                        prevProviderName = providerName
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span> else<span class="cov0" title="0"> {
                        // insert prev RegionInfo
                        rgnInfo := &amp;RegionInfo{prevRegionName, prevProviderName, inKeyValueList}
                        regionInfoList = append(regionInfoList, rgnInfo)

                        prevRegionName = regionName
                        prevProviderName = providerName
                        inKeyValueList = nil
                        keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                        inKeyValueList = append(inKeyValueList, keyValue)
                }</span>

        }

        <span class="cov8" title="1">if len(keyValueList) &gt; 0 </span><span class="cov8" title="1">{
                // insert last RegionInfo
                rgnInfo := &amp;RegionInfo{prevRegionName, prevProviderName, inKeyValueList}
                regionInfoList = append(regionInfoList, rgnInfo)
        }</span>

        <span class="cov8" title="1">return regionInfoList, nil</span>
}

// 1. get a key-value
// 2. create RegionInfo &amp; return
func getInfo(regionName string) (*RegionInfo, error) <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]

        
        key := "/cloud-info-spaces/regions/" + regionName

        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(keyValueList) &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(regionName + ": does not exist!")
        }</span>

        // keyValueList should have ~/driverName/... or ~/driverName-01/...,
        // so we have to check the sameness of driverName.
        // and make a KeyValueList for only Target key
        <span class="cov8" title="1">var oneKeyValueList []icbs.KeyValue
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                if utils.GetNodeValue(kv.Key, 3) == regionName </span><span class="cov8" title="1">{
                        oneKeyValueList = append(oneKeyValueList, *kv)
                }</span>
        }

        <span class="cov8" title="1">if len(oneKeyValueList) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(regionName + ": does not exist!")
        }</span>

        <span class="cov8" title="1">var inKeyValueList []icbs.KeyValue
        // get ProviderName
        providerName := utils.GetNodeValue(oneKeyValueList[0].Key, 4)
        // get KeyValueList
        for _, kv := range oneKeyValueList </span><span class="cov8" title="1">{
                keyValue := icbs.KeyValue{utils.GetNodeValue(kv.Key, 5), kv.Value}
                inKeyValueList = append(inKeyValueList, keyValue)
        }</span>
        <span class="cov8" title="1">return &amp;RegionInfo{regionName, providerName, inKeyValueList}, nil</span> 
}

// 1. get the original Key.
// 2. delete the key.
func deleteInfo(regionName string) (bool, error) <span class="cov8" title="1">{
        // ex-1)
        // /cloud-info-spaces/regions/aws_region01/AWS/region [ap-northeast-2]
        // ex-2)
        // /cloud-info-spaces/regions/gcp_region02/GCP/region [us-east1]
        // /cloud-info-spaces/regions/gcp_region02/GCP/zone [us-east1-c]


        key := "/cloud-info-spaces/regions/" + regionName

// @todo lock-start
        // key is not the key of cb-store, so we have to use GetList()
        keyValueList, err := store.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var isDelete bool
        for _, kv := range keyValueList </span><span class="cov8" title="1">{
                // keyValueList should have ~/driverName/... or ~/driverName-01/..., 
                // so we have to check the sameness of driverName.
                if utils.GetNodeValue(kv.Key, 3) == regionName </span><span class="cov8" title="1">{
                        err = store.Delete(kv.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">isDelete = true</span>
                }
        }
// @todo lock-end

        <span class="cov8" title="1">if isDelete </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">return false, fmt.Errorf(regionName + ": does not exist!")</span>
}

</pre>
		
		<pre class="file" id="file135" style="display: none">// Cloud regioninfomanager Info. Manager of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2019.09.

package regioninfomanager

import (
        "fmt"

        "github.com/cloud-barista/cb-store/config"
        icbs "github.com/cloud-barista/cb-store/interfaces"
        "github.com/sirupsen/logrus"
)

var cblog *logrus.Logger

func init() <span class="cov8" title="1">{
        cblog = config.Cblogger
}</span>

//====================================================================
type RegionInfo struct {
        RegionName       string          // ex) "region01"
        ProviderName     string          // ex) "GCP"
        KeyValueInfoList []icbs.KeyValue // ex) { {region, us-east1},
        //         {zone, us-east1-c},
}

//====================================================================

func RegisterRegionInfo(rgnInfo RegionInfo) (*RegionInfo, error) <span class="cov8" title="1">{
        return RegisterRegion(rgnInfo.RegionName, rgnInfo.ProviderName, rgnInfo.KeyValueInfoList)
}</span>

// 1. check params
// 2. insert them into cb-store
func RegisterRegion(regionName string, providerName string, keyValueInfoList []icbs.KeyValue) (*RegionInfo, error) <span class="cov8" title="1">{
        cblog.Info("call RegisterRegion()")

        cblog.Debug("check params")
        err := checkParams(regionName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        <span class="cov8" title="1">cblog.Debug("insert metainfo into store")

        err = insertInfo(regionName, providerName, keyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">rgnInfo := &amp;RegionInfo{regionName, providerName, keyValueInfoList}
        return rgnInfo, nil</span>
}

func ListRegion() ([]*RegionInfo, error) <span class="cov8" title="1">{
        cblog.Info("call ListRegion()")

        regionInfoList, err := listInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return regionInfoList, nil</span>
}

// 1. check params
// 2. get CredentialInfo from cb-store
func GetRegion(regionName string) (*RegionInfo, error) <span class="cov8" title="1">{
        cblog.Info("call GetRegion()")

        if regionName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RegionName is empty!")
        }</span>

        <span class="cov8" title="1">rgnInfo, err := getInfo(regionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return rgnInfo, err</span>
}

func UnRegisterRegion(regionName string) (bool, error) <span class="cov8" title="1">{
        cblog.Info("call UnRegisterRegion()")

        if regionName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("RegionName is empty!")
        }</span>

        <span class="cov8" title="1">result, err := deleteInfo(regionName)
        if err != nil </span><span class="cov8" title="1">{
                cblog.Error(err)
                return false, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//----------------

func checkParams(regionName string, providerName string, keyValueInfoList []icbs.KeyValue) error <span class="cov8" title="1">{
        if regionName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("RegionName is empty!")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ProviderName is empty!")
        }</span>
        <span class="cov8" title="1">for _, kv := range keyValueInfoList </span><span class="cov8" title="1">{
                if kv.Key == "" </span><span class="cov0" title="0">{ // Value can be empty.
                        return fmt.Errorf("Key is empty!")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package api

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
        "github.com/cloud-barista/poc-cicd-spider/interface/api/request"

        "google.golang.org/grpc"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CCMApi - CCM API  
type CCMApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientCCM    pb.CCMClient
        clientSSH    pb.SSHClient
        requestCCM   *request.CCMRequest
        requestSSH   *request.SSHRequest
        inType       string
        outType      string
}

// ImageReq - Image     
type ImageReq struct {
        ConnectionName string    `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        ImageInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// ImageInfo - Image   
type ImageInfo struct {
        Name string `yaml:"Name" json:"Name"`
}

// VPCReq - VPC     
type VPCReq struct {
        ConnectionName string  `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        VPCInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// VPCInfo - VPC   
type VPCInfo struct {
        Name           string        `yaml:"Name" json:"Name"`
        IPv4_CIDR      string        `yaml:"IPv4_CIDR" json:"IPv4_CIDR"`
        SubnetInfoList *[]SubnetInfo `yaml:"SubnetInfoList" json:"SubnetInfoList"`
}

// SubnetInfo - Subnet   
type SubnetInfo struct {
        Name      string `yaml:"Name" json:"Name"`
        IPv4_CIDR string `yaml:"IPv4_CIDR" json:"IPv4_CIDR"`
}

type SubnetReq struct {
        ConnectionName string     `yaml:"ConnectionName" json:"ConnectionName"`
        VPCName        string     `yaml:"VPCName" json:"VPCName"`
        ReqInfo        SubnetInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// SecurityReq - Security     
type SecurityReq struct {
        ConnectionName string       `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        SecurityInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// SecurityInfo - Security   
type SecurityInfo struct {
        Name          string              `yaml:"Name" json:"Name"`
        VPCName       string              `yaml:"VPCName" json:"VPCName"`
        Direction     string              `yaml:"Direction" json:"Direction"`
        SecurityRules *[]SecurityRuleInfo `yaml:"SecurityRules" json:"SecurityRules"`
}

// SecurityRuleInfo - Security Rule   
type SecurityRuleInfo struct {
        FromPort   string `yaml:"FromPort" json:"FromPort"`
        ToPort     string `yaml:"ToPort" json:"ToPort"`
        IPProtocol string `yaml:"IPProtocol" json:"IPProtocol"`
        Direction  string `yaml:"Direction" json:"Direction"`
        CIDR       string `yaml:"CIDR" json:"CIDR"`
}

// KeyReq - Key Pair     
type KeyReq struct {
        ConnectionName string  `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        KeyInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

// KeyInfo - Key   
type KeyInfo struct {
        Name string `yaml:"Name" json:"Name"`
}

// VMReq - VM     
type VMReq struct {
        ConnectionName string `yaml:"ConnectionName" json:"ConnectionName"`
        ReqInfo        VMInfo `yaml:"ReqInfo" json:"ReqInfo"`
}

//VMInfo - VM   
type VMInfo struct {
        Name               string   `yaml:"Name" json:"Name"`
        ImageName          string   `yaml:"ImageName" json:"ImageName"`
        VPCName            string   `yaml:"VPCName" json:"VPCName"`
        SubnetName         string   `yaml:"SubnetName" json:"SubnetName"`
        SecurityGroupNames []string `yaml:"SecurityGroupNames" json:"SecurityGroupNames"`
        VMSpecName         string   `yaml:"VMSpecName" json:"VMSpecName"`
        KeyPairName        string   `yaml:"KeyPairName" json:"KeyPairName"`

        VMUserId     string `yaml:"VMUserId" json:"VMUserId"`
        VMUserPasswd string `yaml:"VMUserPasswd" json:"VMUserPasswd"`
}

// SSHRUNReq - SSH    
type SSHRUNReq struct {
        UserName   string   `yaml:"UserName" json:"UserName"`
        PrivateKey []string `yaml:"PrivateKey" json:"PrivateKey"`
        ServerPort string   `yaml:"ServerPort" json:"ServerPort"`
        Command    string   `yaml:"Command" json:"Command"`
}

// ===== [ Implementations ] =====

// SetServerAddr - Spider   
func (ccm *CCMApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">ccm.gConf.GSL.SpiderCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Spider    
func (ccm *CCMApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return ccm.gConf.GSL.SpiderCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 
func (ccm *CCMApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov8" title="1">{
                ccm.gConf.GSL.SpiderCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">ccm.gConf.GSL.SpiderCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA  
func (ccm *CCMApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if ccm.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return ccm.gConf.GSL.SpiderCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 
func (ccm *CCMApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        ccm.gConf.GSL.SpiderCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout  
func (ccm *CCMApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return ccm.gConf.GSL.SpiderCli.Timeout, nil
}</span>

// SetJWTToken - JWT   
func (ccm *CCMApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov8" title="1">{
                ccm.gConf.GSL.SpiderCli.Interceptors = &amp;config.InterceptorsConfig{}
                ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT    
func (ccm *CCMApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if ccm.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return ccm.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath -   
func (ccm *CCMApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Viper     
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // SPIDER CLIENT    
        <span class="cov8" title="1">spidercli := gConf.GSL.SpiderCli

        if spidercli == nil </span><span class="cov0" title="0">{
                return errors.New("spidercli field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("spidercli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.Timeout == 0 </span><span class="cov0" title="0">{
                spidercli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if spidercli.TLS != nil </span><span class="cov0" title="0">{
                if spidercli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("spidercli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if spidercli.Interceptors != nil </span><span class="cov0" title="0">{
                if spidercli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("spidercli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if spidercli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if spidercli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("spidercli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">ccm.gConf = &amp;gConf
        return nil</span>
}

// Open -  
func (ccm *CCMApi) Open() error <span class="cov8" title="1">{

        spidercli := ccm.gConf.GSL.SpiderCli

        // grpc  
        cbconn, closer, err := gc.NewCBConnection(spidercli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                ccm.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">ccm.conn = cbconn.Conn

        // grpc  
        ccm.clientCCM = pb.NewCCMClient(ccm.conn)
        ccm.clientSSH = pb.NewSSHClient(ccm.conn)

        // grpc  Wrapper
        ccm.requestCCM = &amp;request.CCMRequest{Client: ccm.clientCCM, Timeout: spidercli.Timeout, InType: ccm.inType, OutType: ccm.outType}
        ccm.requestSSH = &amp;request.SSHRequest{Client: ccm.clientSSH, Timeout: spidercli.Timeout, InType: ccm.inType, OutType: ccm.outType}

        return nil</span>
}

// Close -  
func (ccm *CCMApi) Close() <span class="cov8" title="1">{
        if ccm.conn != nil </span><span class="cov8" title="1">{
                ccm.conn.Close()
        }</span>
        <span class="cov8" title="1">if ccm.jaegerCloser != nil </span><span class="cov0" title="0">{
                ccm.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">ccm.jaegerCloser = nil
        ccm.conn = nil
        ccm.clientCCM = nil
        ccm.clientSSH = nil
        ccm.requestCCM = nil
        ccm.requestSSH = nil</span>
}

// SetInType -     (json/yaml)
func (ccm *CCMApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                ccm.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                ccm.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if ccm.requestCCM != nil </span><span class="cov8" title="1">{
                ccm.requestCCM.InType = ccm.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType -     
func (ccm *CCMApi) GetInType() (string, error) <span class="cov8" title="1">{
        return ccm.inType, nil
}</span>

// SetOutType -     (json/yaml)
func (ccm *CCMApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                ccm.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                ccm.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if ccm.requestCCM != nil </span><span class="cov8" title="1">{
                ccm.requestCCM.OutType = ccm.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType -     
func (ccm *CCMApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return ccm.outType, nil
}</span>

// CreateImage - Image 
func (ccm *CCMApi) CreateImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateImage()</span>
}

// CreateImageByParam - Image 
func (ccm *CCMApi) CreateImageByParam(req *ImageReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListImage - Image 
func (ccm *CCMApi) ListImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListImage()</span>
}

// ListImageByParam - Image 
func (ccm *CCMApi) ListImageByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetImage - Image 
func (ccm *CCMApi) GetImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetImage()</span>
}

// GetImageByParam - Image 
func (ccm *CCMApi) GetImageByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteImage - Image 
func (ccm *CCMApi) DeleteImage(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteImage()</span>
}

// DeleteImageByParam - Image 
func (ccm *CCMApi) DeleteImageByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.DeleteImage()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVMSpec - VM Spec 
func (ccm *CCMApi) ListVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVMSpec()</span>
}

// ListVMSpecByParam - VM Spec 
func (ccm *CCMApi) ListVMSpecByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVMSpec - VM Spec 
func (ccm *CCMApi) GetVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVMSpec()</span>
}

// GetVMSpecByParam - VM Spec 
func (ccm *CCMApi) GetVMSpecByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListOrgVMSpec -   VM Spec 
func (ccm *CCMApi) ListOrgVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListOrgVMSpec()</span>
}

// ListOrgVMSpecByParam -   VM Spec 
func (ccm *CCMApi) ListOrgVMSpecByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListOrgVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetOrgVMSpec -   VM Spec 
func (ccm *CCMApi) GetOrgVMSpec(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetOrgVMSpec()</span>
}

// GetOrgVMSpecByParam -   VM Spec 
func (ccm *CCMApi) GetOrgVMSpecByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetOrgVMSpec()
        ccm.SetInType(holdType)

        return result, err</span>
}

// CreateVPC - VPC 
func (ccm *CCMApi) CreateVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateVPC()</span>
}

// CreateVPCByParam - VPC 
func (ccm *CCMApi) CreateVPCByParam(req *VPCReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVPC - VPC 
func (ccm *CCMApi) ListVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVPC()</span>
}

// ListVPCByParam - VPC 
func (ccm *CCMApi) ListVPCByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVPC - VPC 
func (ccm *CCMApi) GetVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVPC()</span>
}

// GetVPCByParam - VPC 
func (ccm *CCMApi) GetVPCByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteVPC - VPC 
func (ccm *CCMApi) DeleteVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteVPC()</span>
}

// DeleteVPCByParam - VPC 
func (ccm *CCMApi) DeleteVPCByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.DeleteVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllVPC -  VPC 
func (ccm *CCMApi) ListAllVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllVPC()</span>
}

// ListAllVPCByParam -  VPC 
func (ccm *CCMApi) ListAllVPCByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteCSPVPC -  VPC 
func (ccm *CCMApi) DeleteCSPVPC(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteCSPVPC()</span>
}

// DeleteCSPVPCByParam -  VPC 
func (ccm *CCMApi) DeleteCSPVPCByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.DeleteCSPVPC()
        ccm.SetInType(holdType)

        return result, err</span>
}

// AddSubnet - Subnet 
func (ccm *CCMApi) AddSubnet(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.AddSubnet()</span>
}

// AddSubnetByParam - Subnet 
func (ccm *CCMApi) AddSubnetByParam(req *SubnetReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.AddSubnet()
        ccm.SetInType(holdType)

        return result, err</span>
}

// RemoveSubnet - Subnet 
func (ccm *CCMApi) RemoveSubnet(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.RemoveSubnet()</span>
}

// RemoveSubnetByParam - Subnet 
func (ccm *CCMApi) RemoveSubnetByParam(connectionName string, vpcName string, subnetName string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "VPCName":"` + vpcName + `", "SubnetName":"` + subnetName + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.RemoveSubnet()
        ccm.SetInType(holdType)

        return result, err</span>
}

// RemoveCSPSubnet - CSP Subnet 
func (ccm *CCMApi) RemoveCSPSubnet(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.RemoveCSPSubnet()</span>
}

// RemoveCSPSubnetByParam - CSP Subnet 
func (ccm *CCMApi) RemoveCSPSubnetByParam(connectionName string, vpcName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "VPCName":"` + vpcName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.RemoveCSPSubnet()
        ccm.SetInType(holdType)

        return result, err</span>
}

// CreateSecurity - Security 
func (ccm *CCMApi) CreateSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateSecurity()</span>
}

// CreateSecurityByParam - Security 
func (ccm *CCMApi) CreateSecurityByParam(req *SecurityReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListSecurity - Security 
func (ccm *CCMApi) ListSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListSecurity()</span>
}

// ListSecurityByParam - Security 
func (ccm *CCMApi) ListSecurityByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetSecurity - Security 
func (ccm *CCMApi) GetSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetSecurity()</span>
}

// GetSecurityByParam - Security 
func (ccm *CCMApi) GetSecurityByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteSecurity - Security 
func (ccm *CCMApi) DeleteSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteSecurity()</span>
}

// DeleteSecurityByParam - Security 
func (ccm *CCMApi) DeleteSecurityByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.DeleteSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllSecurity -  Security 
func (ccm *CCMApi) ListAllSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllSecurity()</span>
}

// ListAllSecurityByParam -  Security 
func (ccm *CCMApi) ListAllSecurityByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteCSPSecurity -  Security 
func (ccm *CCMApi) DeleteCSPSecurity(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteCSPSecurity()</span>
}

// DeleteCSPSecurityByParam -  Security 
func (ccm *CCMApi) DeleteCSPSecurityByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.DeleteCSPSecurity()
        ccm.SetInType(holdType)

        return result, err</span>
}

// CreateKey - Key Pair 
func (ccm *CCMApi) CreateKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.CreateKey()</span>
}

// CreateKeyByParam - Key Pair 
func (ccm *CCMApi) CreateKeyByParam(req *KeyReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.CreateKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListKey - Key Pair 
func (ccm *CCMApi) ListKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListKey()</span>
}

// ListKeyByParam - Key Pair 
func (ccm *CCMApi) ListKeyByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetKey - Key Pair 
func (ccm *CCMApi) GetKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetKey()</span>
}

// GetKeyByParam - Key Pair 
func (ccm *CCMApi) GetKeyByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteKey - Key Pair 
func (ccm *CCMApi) DeleteKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteKey()</span>
}

// DeleteKeyByParam - Key Pair 
func (ccm *CCMApi) DeleteKeyByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.DeleteKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllKey -  Key Pair 
func (ccm *CCMApi) ListAllKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllKey()</span>
}

// ListAllKeyByParam -  Key Pair 
func (ccm *CCMApi) ListAllKeyByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// DeleteCSPKey -  Key Pair 
func (ccm *CCMApi) DeleteCSPKey(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.DeleteCSPKey()</span>
}

// DeleteCSPKeyByParam -  Key Pair 
func (ccm *CCMApi) DeleteCSPKeyByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.DeleteCSPKey()
        ccm.SetInType(holdType)

        return result, err</span>
}

// StartVM - VM 
func (ccm *CCMApi) StartVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.StartVM()</span>
}

// StartVMByParam - VM 
func (ccm *CCMApi) StartVMByParam(req *VMReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestCCM.InData = string(j)
        result, err := ccm.requestCCM.StartVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ControlVM - VM 
func (ccm *CCMApi) ControlVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ControlVM()</span>
}

// ControlVMByParam - VM 
func (ccm *CCMApi) ControlVMByParam(connectionName string, name string, action string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "action":"` + action + `"}`
        result, err := ccm.requestCCM.ControlVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVMStatus - VM  
func (ccm *CCMApi) ListVMStatus(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVMStatus()</span>
}

// ListVMStatusByParam - VM  
func (ccm *CCMApi) ListVMStatusByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVMStatus()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVMStatus - VM  
func (ccm *CCMApi) GetVMStatus(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVMStatus()</span>
}

// GetVMStatusByParam - VM  
func (ccm *CCMApi) GetVMStatusByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVMStatus()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListVM - VM 
func (ccm *CCMApi) ListVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListVM()</span>
}

// ListVMByParam - VM 
func (ccm *CCMApi) ListVMByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// GetVM - VM 
func (ccm *CCMApi) GetVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.GetVM()</span>
}

// GetVMByParam - VM 
func (ccm *CCMApi) GetVMByParam(connectionName string, name string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `"}`
        result, err := ccm.requestCCM.GetVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// TerminateVM - VM 
func (ccm *CCMApi) TerminateVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.TerminateVM()</span>
}

// TerminateVMByParam - VM 
func (ccm *CCMApi) TerminateVMByParam(connectionName string, name string, force string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Name":"` + name + `", "force":"` + force + `"}`
        result, err := ccm.requestCCM.TerminateVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ListAllVM -  VM 
func (ccm *CCMApi) ListAllVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.ListAllVM()</span>
}

// ListAllVMByParam -  VM 
func (ccm *CCMApi) ListAllVMByParam(connectionName string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `"}`
        result, err := ccm.requestCCM.ListAllVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// TerminateCSPVM -  VM 
func (ccm *CCMApi) TerminateCSPVM(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestCCM.InData = doc
        return ccm.requestCCM.TerminateCSPVM()</span>
}

// TerminateCSPVMByParam -  VM 
func (ccm *CCMApi) TerminateCSPVMByParam(connectionName string, id string) (string, error) <span class="cov8" title="1">{
        if ccm.requestCCM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        ccm.requestCCM.InData = `{"ConnectionName":"` + connectionName + `", "Id":"` + id + `"}`
        result, err := ccm.requestCCM.TerminateCSPVM()
        ccm.SetInType(holdType)

        return result, err</span>
}

// SSHRun - SSH 
func (ccm *CCMApi) SSHRun(doc string) (string, error) <span class="cov8" title="1">{
        if ccm.requestSSH == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">ccm.requestSSH.InData = doc
        return ccm.requestSSH.SSHRun()</span>
}

// SSHRunByParam - SSH 
func (ccm *CCMApi) SSHRunByParam(req *SSHRUNReq) (string, error) <span class="cov8" title="1">{
        if ccm.requestSSH == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := ccm.GetInType()
        ccm.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ccm.requestSSH.InData = string(j)
        result, err := ccm.requestSSH.SSHRun()
        ccm.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCloudResourceHandler - CCM API  
func NewCloudResourceHandler() (ccm *CCMApi) <span class="cov8" title="1">{

        ccm = &amp;CCMApi{}
        ccm.gConf = &amp;config.GrpcConfig{}
        ccm.gConf.GSL.SpiderCli = &amp;config.GrpcClientConfig{}

        ccm.jaegerCloser = nil
        ccm.conn = nil
        ccm.clientCCM = nil
        ccm.clientSSH = nil
        ccm.requestCCM = nil
        ccm.requestSSH = nil

        ccm.inType = "json"
        ccm.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package api

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
        "github.com/cloud-barista/poc-cicd-spider/interface/api/request"

        "google.golang.org/grpc"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CIMApi - CIM API  
type CIMApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientCIM    pb.CIMClient
        requestCIM   *request.CIMRequest
        inType       string
        outType      string
}

// KeyValue - Key / Value  
type KeyValue struct {
        Key   string `yaml:"Key" json:"Key"`
        Value string `yaml:"Value" json:"Value"`
}

// CloudDriverReq - Cloud Driver     
type CloudDriverReq struct {
        DriverName        string `yaml:"DriverName" json:"DriverName"`
        ProviderName      string `yaml:"ProviderName" json:"ProviderName"`
        DriverLibFileName string `yaml:"DriverLibFileName" json:"DriverLibFileName"`
}

// CredentialReq - Credential     
type CredentialReq struct {
        CredentialName   string     `yaml:"CredentialName" json:"CredentialName"`
        ProviderName     string     `yaml:"ProviderName" json:"ProviderName"`
        KeyValueInfoList []KeyValue `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// RegionReq - Region     
type RegionReq struct {
        RegionName       string     `yaml:"RegionName" json:"RegionName"`
        ProviderName     string     `yaml:"ProviderName" json:"ProviderName"`
        KeyValueInfoList []KeyValue `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// ConnectionConfigReq - Connection Config     
type ConnectionConfigReq struct {
        ConfigName     string `yaml:"ConfigName" json:"ConfigName"`
        ProviderName   string `yaml:"ProviderName" json:"ProviderName"`
        DriverName     string `yaml:"DriverName" json:"DriverName"`
        CredentialName string `yaml:"CredentialName" json:"CredentialName"`
        RegionName     string `yaml:"RegionName" json:"RegionName"`
}

// ===== [ Implementations ] =====

// SetServerAddr - Spider   
func (cim *CIMApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">cim.gConf.GSL.SpiderCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Spider    
func (cim *CIMApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return cim.gConf.GSL.SpiderCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 
func (cim *CIMApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov8" title="1">{
                cim.gConf.GSL.SpiderCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">cim.gConf.GSL.SpiderCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA  
func (cim *CIMApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if cim.gConf.GSL.SpiderCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return cim.gConf.GSL.SpiderCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 
func (cim *CIMApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        cim.gConf.GSL.SpiderCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout  
func (cim *CIMApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return cim.gConf.GSL.SpiderCli.Timeout, nil
}</span>

// SetJWTToken - JWT   
func (cim *CIMApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov8" title="1">{
                cim.gConf.GSL.SpiderCli.Interceptors = &amp;config.InterceptorsConfig{}
                cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT    
func (cim *CIMApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if cim.gConf.GSL.SpiderCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return cim.gConf.GSL.SpiderCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath -   
func (cim *CIMApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Viper     
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // SPIDER CLIENT    
        <span class="cov8" title="1">spidercli := gConf.GSL.SpiderCli

        if spidercli == nil </span><span class="cov0" title="0">{
                return errors.New("spidercli field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("spidercli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if spidercli.Timeout == 0 </span><span class="cov0" title="0">{
                spidercli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if spidercli.TLS != nil </span><span class="cov0" title="0">{
                if spidercli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("spidercli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if spidercli.Interceptors != nil </span><span class="cov0" title="0">{
                if spidercli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("spidercli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if spidercli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if spidercli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if spidercli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("spidercli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">cim.gConf = &amp;gConf
        return nil</span>
}

// Open -  
func (cim *CIMApi) Open() error <span class="cov8" title="1">{

        spidercli := cim.gConf.GSL.SpiderCli

        // grpc  
        cbconn, closer, err := gc.NewCBConnection(spidercli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                cim.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">cim.conn = cbconn.Conn

        // grpc  
        cim.clientCIM = pb.NewCIMClient(cim.conn)

        // grpc  Wrapper
        cim.requestCIM = &amp;request.CIMRequest{Client: cim.clientCIM, Timeout: spidercli.Timeout, InType: cim.inType, OutType: cim.outType}

        return nil</span>
}

// Close -  
func (cim *CIMApi) Close() <span class="cov8" title="1">{
        if cim.conn != nil </span><span class="cov8" title="1">{
                cim.conn.Close()
        }</span>
        <span class="cov8" title="1">if cim.jaegerCloser != nil </span><span class="cov0" title="0">{
                cim.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">cim.jaegerCloser = nil
        cim.conn = nil
        cim.clientCIM = nil
        cim.requestCIM = nil</span>
}

// SetInType -     (json/yaml)
func (cim *CIMApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                cim.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                cim.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if cim.requestCIM != nil </span><span class="cov8" title="1">{
                cim.requestCIM.InType = cim.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType -     
func (cim *CIMApi) GetInType() (string, error) <span class="cov8" title="1">{
        return cim.inType, nil
}</span>

// SetOutType -     (json/yaml)
func (cim *CIMApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                cim.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                cim.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if cim.requestCIM != nil </span><span class="cov8" title="1">{
                cim.requestCIM.OutType = cim.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType -     
func (cim *CIMApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return cim.outType, nil
}</span>

// ListCloudOS -Cloud OS 
func (cim *CIMApi) ListCloudOS() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListCloudOS()</span>
}

// CreateCloudDriver - Cloud Driver 
func (cim *CIMApi) CreateCloudDriver(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateCloudDriver()</span>
}

// CreateCloudDriverByParam - Cloud Driver 
func (cim *CIMApi) CreateCloudDriverByParam(req *CloudDriverReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateCloudDriver()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListCloudDriver -Cloud Driver 
func (cim *CIMApi) ListCloudDriver() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListCloudDriver()</span>
}

// GetCloudDriver - Cloud Driver 
func (cim *CIMApi) GetCloudDriver(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetCloudDriver()</span>
}

// GetCloudDriverByParam - Cloud Driver 
func (cim *CIMApi) GetCloudDriverByParam(driverName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"DriverName":"` + driverName + `"}`
        result, err := cim.requestCIM.GetCloudDriver()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteCloudDriver - Cloud Driver 
func (cim *CIMApi) DeleteCloudDriver(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteCloudDriver()</span>
}

// DeleteCloudDriverByParam - Cloud Driver 
func (cim *CIMApi) DeleteCloudDriverByParam(driverName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"DriverName":"` + driverName + `"}`
        result, err := cim.requestCIM.DeleteCloudDriver()
        cim.SetInType(holdType)

        return result, err</span>
}

// CreateCredential - Credential 
func (cim *CIMApi) CreateCredential(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateCredential()</span>
}

// CreateCredentialByParam - Credential 
func (cim *CIMApi) CreateCredentialByParam(req *CredentialReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateCredential()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListCredential -Credential 
func (cim *CIMApi) ListCredential() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListCredential()</span>
}

// GetCredential - Credential 
func (cim *CIMApi) GetCredential(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetCredential()</span>
}

// GetCredentialByParam - Credential 
func (cim *CIMApi) GetCredentialByParam(credentialName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"CredentialName":"` + credentialName + `"}`
        result, err := cim.requestCIM.GetCredential()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteCredential - Credential 
func (cim *CIMApi) DeleteCredential(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteCredential()</span>
}

// DeleteCredentialByParam - Credential 
func (cim *CIMApi) DeleteCredentialByParam(credentialName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"CredentialName":"` + credentialName + `"}`
        result, err := cim.requestCIM.DeleteCredential()
        cim.SetInType(holdType)

        return result, err</span>
}

// CreateRegion - Region 
func (cim *CIMApi) CreateRegion(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateRegion()</span>
}

// CreateRegionByParam - Region 
func (cim *CIMApi) CreateRegionByParam(req *RegionReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateRegion()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListRegion - Region 
func (cim *CIMApi) ListRegion() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListRegion()</span>
}

// GetRegion - Region 
func (cim *CIMApi) GetRegion(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetRegion()</span>
}

// GetRegionByParam - Region 
func (cim *CIMApi) GetRegionByParam(regionName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"RegionName":"` + regionName + `"}`
        result, err := cim.requestCIM.GetRegion()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteRegion - Region 
func (cim *CIMApi) DeleteRegion(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteRegion()</span>
}

// DeleteRegionByParam - Region 
func (cim *CIMApi) DeleteRegionByParam(regionName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"RegionName":"` + regionName + `"}`
        result, err := cim.requestCIM.DeleteRegion()
        cim.SetInType(holdType)

        return result, err</span>
}

// CreateConnectionConfig - Connection Config 
func (cim *CIMApi) CreateConnectionConfig(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.CreateConnectionConfig()</span>
}

// CreateConnectionConfigByParam - Connection Config 
func (cim *CIMApi) CreateConnectionConfigByParam(req *ConnectionConfigReq) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cim.requestCIM.InData = string(j)
        result, err := cim.requestCIM.CreateConnectionConfig()
        cim.SetInType(holdType)

        return result, err</span>
}

// ListConnectionConfig - Connection Config 
func (cim *CIMApi) ListConnectionConfig() (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return cim.requestCIM.ListConnectionConfig()</span>
}

// GetConnectionConfig - Connection Config 
func (cim *CIMApi) GetConnectionConfig(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.GetConnectionConfig()</span>
}

// GetConnectionConfigByParam - Connection Config 
func (cim *CIMApi) GetConnectionConfigByParam(configName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"ConfigName":"` + configName + `"}`
        result, err := cim.requestCIM.GetConnectionConfig()
        cim.SetInType(holdType)

        return result, err</span>
}

// DeleteConnectionConfig - Connection Config 
func (cim *CIMApi) DeleteConnectionConfig(doc string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">cim.requestCIM.InData = doc
        return cim.requestCIM.DeleteConnectionConfig()</span>
}

// DeleteConnectionConfigByParam - Connection Config 
func (cim *CIMApi) DeleteConnectionConfigByParam(configName string) (string, error) <span class="cov8" title="1">{
        if cim.requestCIM == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := cim.GetInType()
        cim.SetInType("json")
        cim.requestCIM.InData = `{"ConfigName":"` + configName + `"}`
        result, err := cim.requestCIM.DeleteConnectionConfig()
        cim.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCloudInfoManager - CIM API  
func NewCloudInfoManager() (cim *CIMApi) <span class="cov8" title="1">{

        cim = &amp;CIMApi{}
        cim.gConf = &amp;config.GrpcConfig{}
        cim.gConf.GSL.SpiderCli = &amp;config.GrpcClientConfig{}

        cim.jaegerCloser = nil
        cim.conn = nil
        cim.clientCIM = nil
        cim.requestCIM = nil

        cim.inType = "json"
        cim.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateConnectionConfig - Connection Config 
func (r *CIMRequest) CreateConnectionConfig() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.ConnectionConfigInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateConnectionConfig(ctx, &amp;pb.ConnectionConfigInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListConnectionConfig - Connection Config 
func (r *CIMRequest) ListConnectionConfig() (string, error) <span class="cov8" title="1">{
        //  
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListConnectionConfig(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetConnectionConfig - Connection Config 
func (r *CIMRequest) GetConnectionConfig() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.ConnectionConfigQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetConnectionConfig(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteConnectionConfig - Connection Config 
func (r *CIMRequest) DeleteConnectionConfig() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.ConnectionConfigQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteConnectionConfig(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file139" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCredential - Credential 
func (r *CIMRequest) CreateCredential() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CredentialInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateCredential(ctx, &amp;pb.CredentialInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListCredential -Credential 
func (r *CIMRequest) ListCredential() (string, error) <span class="cov8" title="1">{
        //  
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCredential(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetCredential - Credential 
func (r *CIMRequest) GetCredential() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CredentialQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetCredential(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteCredential - Credential 
func (r *CIMRequest) DeleteCredential() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CredentialQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCredential(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file140" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCloudDriver - Cloud Driver 
func (r *CIMRequest) CreateCloudDriver() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CloudDriverInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateCloudDriver(ctx, &amp;pb.CloudDriverInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListCloudDriver -Cloud Driver 
func (r *CIMRequest) ListCloudDriver() (string, error) <span class="cov8" title="1">{
        //  
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCloudDriver(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetCloudDriver - Cloud Driver 
func (r *CIMRequest) GetCloudDriver() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CloudDriverQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetCloudDriver(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteCloudDriver - Cloud Driver 
func (r *CIMRequest) DeleteCloudDriver() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CloudDriverQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCloudDriver(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file141" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateImage - Image 
func (r *CCMRequest) CreateImage() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.ImageCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateImage(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListImage - Image 
func (r *CCMRequest) ListImage() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.ImageAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListImage(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetImage - Image 
func (r *CCMRequest) GetImage() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.ImageQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetImage(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteImage - Image 
func (r *CCMRequest) DeleteImage() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.ImageQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteImage(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file142" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateKey - Key Pair 
func (r *CCMRequest) CreateKey() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.KeyPairCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListKey - Key Pair 
func (r *CCMRequest) ListKey() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.KeyPairAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListKey(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetKey - Key Pair 
func (r *CCMRequest) GetKey() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.KeyPairQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteKey - Key Pair 
func (r *CCMRequest) DeleteKey() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.KeyPairQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllKey -  Key Pair 
func (r *CCMRequest) ListAllKey() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.KeyPairAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListAllKey(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteCSPKey -  Key Pair 
func (r *CCMRequest) DeleteCSPKey() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CSPKeyPairQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCSPKey(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file143" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListCloudOS -Cloud OS 
func (r *CIMRequest) ListCloudOS() (string, error) <span class="cov8" title="1">{
        //  
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCloudOS(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file144" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateRegion - Region 
func (r *CIMRequest) CreateRegion() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.RegionInfo
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateRegion(ctx, &amp;pb.RegionInfoRequest{Item: &amp;item})
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListRegion - Region 
func (r *CIMRequest) ListRegion() (string, error) <span class="cov8" title="1">{
        //  
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListRegion(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetRegion - Region 
func (r *CIMRequest) GetRegion() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.RegionQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetRegion(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteRegion - Region 
func (r *CIMRequest) DeleteRegion() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.RegionQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteRegion(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file145" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateSecurity - Security 
func (r *CCMRequest) CreateSecurity() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SecurityCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListSecurity - Security 
func (r *CCMRequest) ListSecurity() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SecurityAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListSecurity(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetSecurity - Security 
func (r *CCMRequest) GetSecurity() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SecurityQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteSecurity - Security 
func (r *CCMRequest) DeleteSecurity() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SecurityQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllSecurity -  Security 
func (r *CCMRequest) ListAllSecurity() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SecurityAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListAllSecurity(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteCSPSecurity -  Security 
func (r *CCMRequest) DeleteCSPSecurity() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CSPSecurityQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCSPSecurity(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file146" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// SSHRun - SSH 
func (r *SSHRequest) SSHRun() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SSHRunRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.SSHRun(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file147" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// StartVM - VM 
func (r *CCMRequest) StartVM() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.StartVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ControlVM - VM 
func (r *CCMRequest) ControlVM() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMActionRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ControlVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListVMStatus - VM  
func (r *CCMRequest) ListVMStatus() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ListVMStatus(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVMStatus - VM  
func (r *CCMRequest) GetVMStatus() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVMStatus(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListVM - VM 
func (r *CCMRequest) ListVM() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ListVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVM - VM 
func (r *CCMRequest) GetVM() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// TerminateVM - VM 
func (r *CCMRequest) TerminateVM() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.TerminateVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllVM -  VM 
func (r *CCMRequest) ListAllVM() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.ListAllVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// TerminateCSPVM -  VM 
func (r *CCMRequest) TerminateCSPVM() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CSPVMQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.TerminateCSPVM(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file148" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ListVMSpec - VM Spec 
func (r *CCMRequest) ListVMSpec() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMSpecAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListVMSpec(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVMSpec - VM Spec 
func (r *CCMRequest) GetVMSpec() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMSpecQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVMSpec(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListOrgVMSpec -   VM Spec 
func (r *CCMRequest) ListOrgVMSpec() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMSpecAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListOrgVMSpec(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">out := resp.Result
        return out, nil</span>
}

// GetOrgVMSpec -   VM Spec 
func (r *CCMRequest) GetOrgVMSpec() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VMSpecQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetOrgVMSpec(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">out := resp.Result
        return out, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file149" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package request

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/common"
        pb "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/stub/cbspider"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateVPC - VPC 
func (r *CCMRequest) CreateVPC() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VPCCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.CreateVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListVPC - VPC 
func (r *CCMRequest) ListVPC() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VPCAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListVPC(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetVPC - VPC 
func (r *CCMRequest) GetVPC() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VPCQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.GetVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteVPC - VPC 
func (r *CCMRequest) DeleteVPC() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VPCQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListAllVPC -  VPC 
func (r *CCMRequest) ListAllVPC() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.VPCAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListAllVPC(ctx, &amp;item)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// DeleteCSPVPC -  VPC 
func (r *CCMRequest) DeleteCSPVPC() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CSPVPCQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.DeleteCSPVPC(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// AddSubnet - Subnet 
func (r *CCMRequest) AddSubnet() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SubnetAddRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.AddSubnet(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// RemoveSubnet - Subnet 
func (r *CCMRequest) RemoveSubnet() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.SubnetQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.RemoveSubnet(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// RemoveCSPSubnet - CSP Subnet 
func (r *CCMRequest) RemoveCSPSubnet() (string, error) <span class="cov8" title="1">{
        //  
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        //  
        <span class="cov8" title="1">var item pb.CSPSubnetQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        //  
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err2 := r.Client.RemoveCSPSubnet(ctx, &amp;item)
        if err2 != nil </span><span class="cov0" title="0">{
                return "", err2
        }</span>

        //  
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file150" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewConnectionCmd - Connection Config    Cobra Command 
func NewConnectionCmd() *cobra.Command <span class="cov8" title="1">{

        connectionCmd := &amp;cobra.Command{
                Use:   "connection",
                Short: "This is a manageable command for connection config",
                Long:  "This is a manageable command for connection config",
        }

        //  Adds the commands for application.
        connectionCmd.AddCommand(NewConnectionCreateCmd())
        connectionCmd.AddCommand(NewConnectionListCmd())
        connectionCmd.AddCommand(NewConnectionGetCmd())
        connectionCmd.AddCommand(NewConnectionDeleteCmd())

        return connectionCmd
}</span>

// NewConnectionCreateCmd - Connection Config    Cobra Command 
func NewConnectionCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for connection config",
                Long:  "This is create command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewConnectionListCmd - Connection Config    Cobra Command 
func NewConnectionListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for connection config",
                Long:  "This is list command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewConnectionGetCmd - Connection Config    Cobra Command 
func NewConnectionGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for connection config",
                Long:  "This is get command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return getCmd</span>
}

// NewConnectionDeleteCmd - Connection Config    Cobra Command 
func NewConnectionDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for connection config",
                Long:  "This is delete command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCredentialCmd - Credential    Cobra Command 
func NewCredentialCmd() *cobra.Command <span class="cov8" title="1">{

        credentialCmd := &amp;cobra.Command{
                Use:   "credential",
                Short: "This is a manageable command for credential",
                Long:  "This is a manageable command for credential",
        }

        //  Adds the commands for application.
        credentialCmd.AddCommand(NewCredentialCreateCmd())
        credentialCmd.AddCommand(NewCredentialListCmd())
        credentialCmd.AddCommand(NewCredentialGetCmd())
        credentialCmd.AddCommand(NewCredentialDeleteCmd())

        return credentialCmd
}</span>

// NewCredentialCreateCmd -Credential    Cobra Command 
func NewCredentialCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for credential",
                Long:  "This is create command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewCredentialListCmd - Credential    Cobra Command 
func NewCredentialListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for credential",
                Long:  "This is list command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewCredentialGetCmd - Credential    Cobra Command 
func NewCredentialGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for credential",
                Long:  "This is get command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return getCmd</span>
}

// NewCredentialDeleteCmd - Credential    Cobra Command 
func NewCredentialDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for credential",
                Long:  "This is delete command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewDriverCmd - Cloud Driver    Cobra Command 
func NewDriverCmd() *cobra.Command <span class="cov8" title="1">{

        driverCmd := &amp;cobra.Command{
                Use:   "driver",
                Short: "This is a manageable command for cloud driver",
                Long:  "This is a manageable command for cloud driver",
        }

        //  Adds the commands for application.
        driverCmd.AddCommand(NewDriverCreateCmd())
        driverCmd.AddCommand(NewDriverListCmd())
        driverCmd.AddCommand(NewDriverGetCmd())
        driverCmd.AddCommand(NewDriverDeleteCmd())

        return driverCmd
}</span>

// NewDriverCreateCmd - Cloud Driver    Cobra Command 
func NewDriverCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for cloud driver",
                Long:  "This is create command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewDriverListCmd - Cloud Driver    Cobra Command 
func NewDriverListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud driver",
                Long:  "This is list command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewDriverGetCmd - Cloud Driver    Cobra Command 
func NewDriverGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for cloud driver",
                Long:  "This is get command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return getCmd</span>
}

// NewDriverDeleteCmd - Cloud Driver    Cobra Command 
func NewDriverDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for cloud driver",
                Long:  "This is delete command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "fmt"
        "io/ioutil"

        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        "github.com/cloud-barista/poc-cicd-spider/interface/api"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

func readInDataFromFile() <span class="cov8" title="1">{
        logger := logger.NewLogger()
        if inData == "" </span><span class="cov0" title="0">{
                if inFile != "" </span><span class="cov0" title="0">{
                        dat, err := ioutil.ReadFile(inFile)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to read file : ", inFile)
                                return
                        }</span>
                        <span class="cov0" title="0">inData = string(dat)</span>
                }
        }
}

// ===== [ Public Functions ] =====

// SetupAndRun - SPIDER GRPC CLI 
func SetupAndRun(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        var (
                result string
                err    error

                cim *api.CIMApi = nil
                ccm *api.CCMApi = nil
        )

        // panic 
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("spider is stopped : ", r)
                }</span>
        }()

        <span class="cov8" title="1">if cmd.Parent().Name() == "os" || cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" ||
                cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connection" </span><span class="cov8" title="1">{

                // CIM API 
                cim = api.NewCloudInfoManager()
                err = cim.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("cim api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer cim.Close()</span>

        } else<span class="cov8" title="1"> {

                // CCM API 
                ccm = api.NewCloudResourceHandler()
                err = ccm.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = ccm.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("cim api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer ccm.Close()</span>

        }

        //   
        <span class="cov8" title="1">if outType != "json" &amp;&amp; outType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --output parameter : ", outType)
                return
        }</span>
        <span class="cov8" title="1">if inType != "json" &amp;&amp; inType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --input parameter : ", inType)
                return
        }</span>

        <span class="cov8" title="1">if cmd.Parent().Name() == "os" || cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" ||
                cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connection" </span><span class="cov8" title="1">{
                cim.SetInType(inType)
                cim.SetOutType(outType)
        }</span> else<span class="cov8" title="1"> {
                ccm.SetInType(inType)
                ccm.SetOutType(outType)
        }</span>

        <span class="cov8" title="1">logger.Debug("--input parameter value : ", inType)
        logger.Debug("--output parameter value : ", outType)

        result = ""
        err = nil

        switch cmd.Parent().Name() </span>{
        case "os":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListCloudOS()</span>
                }
        case "driver":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateCloudDriver(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListCloudDriver()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetCloudDriverByParam(driverName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteCloudDriverByParam(driverName)</span>
                }
        case "credential":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateCredential(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListCredential()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetCredentialByParam(credentialName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteCredentialByParam(credentialName)</span>
                }
        case "region":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateRegion(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListRegion()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetRegionByParam(regionName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteRegionByParam(regionName)</span>
                }
        case "connection":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = cim.CreateConnectionConfig(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = cim.ListConnectionConfig()</span>
                case "get":<span class="cov8" title="1">
                        result, err = cim.GetConnectionConfigByParam(configName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = cim.DeleteConnectionConfigByParam(configName)</span>
                }
        case "image":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateImage(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListImageByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetImageByParam(connectionName, imageName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteImageByParam(connectionName, imageName)</span>
                }
        case "vmspec":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListVMSpecByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetVMSpecByParam(connectionName, specName)</span>
                case "listorg":<span class="cov8" title="1">
                        result, err = ccm.ListOrgVMSpecByParam(connectionName)</span>
                case "getorg":<span class="cov8" title="1">
                        result, err = ccm.GetOrgVMSpecByParam(connectionName, specName)</span>
                }
        case "vpc":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateVPC(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListVPCByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetVPCByParam(connectionName, vpcName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteVPCByParam(connectionName, vpcName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllVPCByParam(connectionName)</span>
                case "deletecsp":<span class="cov8" title="1">
                        result, err = ccm.DeleteCSPVPCByParam(connectionName, cspID)</span>
                case "add-subnet":<span class="cov8" title="1">
                        result, err = ccm.AddSubnet(inData)</span>
                case "remove-subnet":<span class="cov8" title="1">
                        result, err = ccm.RemoveSubnetByParam(connectionName, vpcName, subnetName, force)</span>
                case "removecsp-subnet":<span class="cov8" title="1">
                        result, err = ccm.RemoveCSPSubnetByParam(connectionName, vpcName, cspID)</span>
                }
        case "security":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateSecurity(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListSecurityByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetSecurityByParam(connectionName, securityName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteSecurityByParam(connectionName, securityName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllSecurityByParam(connectionName)</span>
                case "deletecsp":<span class="cov8" title="1">
                        result, err = ccm.DeleteCSPSecurityByParam(connectionName, cspID)</span>
                }
        case "keypair":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = ccm.CreateKey(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListKeyByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetKeyByParam(connectionName, keypairName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = ccm.DeleteKeyByParam(connectionName, keypairName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllKeyByParam(connectionName)</span>
                case "deletecsp":<span class="cov8" title="1">
                        result, err = ccm.DeleteCSPKeyByParam(connectionName, cspID)</span>
                }
        case "vm":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "start":<span class="cov8" title="1">
                        result, err = ccm.StartVM(inData)</span>
                case "control":<span class="cov0" title="0">
                        result, err = ccm.ControlVMByParam(connectionName, vmName, action)</span>
                case "liststatus":<span class="cov8" title="1">
                        result, err = ccm.ListVMStatusByParam(connectionName)</span>
                case "getstatus":<span class="cov8" title="1">
                        result, err = ccm.GetVMStatusByParam(connectionName, vmName)</span>
                case "list":<span class="cov8" title="1">
                        result, err = ccm.ListVMByParam(connectionName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = ccm.GetVMByParam(connectionName, vmName)</span>
                case "terminate":<span class="cov8" title="1">
                        result, err = ccm.TerminateVMByParam(connectionName, vmName, force)</span>
                case "listall":<span class="cov8" title="1">
                        result, err = ccm.ListAllVMByParam(connectionName)</span>
                case "terminatecsp":<span class="cov8" title="1">
                        result, err = ccm.TerminateCSPVMByParam(connectionName, cspID)</span>
                }
        case "ssh":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "run":<span class="cov0" title="0">
                        result, err = ccm.SSHRun(inData)</span>
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if outType == "yaml" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "message: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(cmd.OutOrStdout(), "{\"message\": \"%v\"}\n", err)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", result)
        }</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewImageCmd - Image    Cobra Command 
func NewImageCmd() *cobra.Command <span class="cov8" title="1">{

        imageCmd := &amp;cobra.Command{
                Use:   "image",
                Short: "This is a manageable command for image",
                Long:  "This is a manageable command for image",
        }

        //  Adds the commands for application.
        imageCmd.AddCommand(NewImageCreateCmd())
        imageCmd.AddCommand(NewImageListCmd())
        imageCmd.AddCommand(NewImageGetCmd())
        imageCmd.AddCommand(NewImageDeleteCmd())

        return imageCmd
}</span>

// NewImageCreateCmd - Image    Cobra Command 
func NewImageCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for image",
                Long:  "This is create command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewImageListCmd - Image    Cobra Command 
func NewImageListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for image",
                Long:  "This is list command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewImageGetCmd - Image    Cobra Command 
func NewImageGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for image",
                Long:  "This is get command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if imageName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", imageName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;imageName, "name", "n", "", "image name")

        return getCmd</span>
}

// NewImageDeleteCmd - Image    Cobra Command 
func NewImageDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for image",
                Long:  "This is delete command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if imageName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", imageName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;imageName, "name", "n", "", "image name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewKeyPairCmd - KeyPair    Cobra Command 
func NewKeyPairCmd() *cobra.Command <span class="cov8" title="1">{

        keyPairCmd := &amp;cobra.Command{
                Use:   "keypair",
                Short: "This is a manageable command for keypair",
                Long:  "This is a manageable command for keypair",
        }

        //  Adds the commands for application.
        keyPairCmd.AddCommand(NewKeyPairCreateCmd())
        keyPairCmd.AddCommand(NewKeyPairListCmd())
        keyPairCmd.AddCommand(NewKeyPairGetCmd())
        keyPairCmd.AddCommand(NewKeyPairDeleteCmd())
        keyPairCmd.AddCommand(NewKeyPairListAllCmd())
        keyPairCmd.AddCommand(NewKeyPairDeleteCSPCmd())

        return keyPairCmd
}</span>

// NewKeyPairCreateCmd - KeyPair    Cobra Command 
func NewKeyPairCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for keypair",
                Long:  "This is create command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewKeyPairListCmd - KeyPair    Cobra Command 
func NewKeyPairListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for keypair",
                Long:  "This is list command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewKeyPairGetCmd - KeyPair    Cobra Command 
func NewKeyPairGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for keypair",
                Long:  "This is get command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if keypairName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", keypairName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;keypairName, "name", "n", "", "keypair name")

        return getCmd</span>
}

// NewKeyPairDeleteCmd - KeyPair    Cobra Command 
func NewKeyPairDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for keypair",
                Long:  "This is delete command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if keypairName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", keypairName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;keypairName, "name", "n", "", "keypair name")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return deleteCmd</span>
}

// NewKeyPairListAllCmd -  KeyPair    Cobra Command 
func NewKeyPairListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for keypair",
                Long:  "This is list all command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewKeyPairDeleteCSPCmd -  KeyPair    Cobra Command 
func NewKeyPairDeleteCSPCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCSPCmd := &amp;cobra.Command{
                Use:   "deletecsp",
                Short: "This is delete csp command for keypair",
                Long:  "This is delete csp command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return deleteCSPCmd</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewOsCmd - Cloud OS    Cobra Command 
func NewOsCmd() *cobra.Command <span class="cov8" title="1">{

        osCmd := &amp;cobra.Command{
                Use:   "os",
                Short: "This is a manageable command for cloud os",
                Long:  "This is a manageable command for cloud os",
        }

        //  Adds the commands for application.
        osCmd.AddCommand(NewOsListCmd())

        return osCmd
}</span>

// NewOsListCmd - Cloud OS    Cobra Command 
func NewOsListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud os",
                Long:  "This is list command for cloud os",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRegionCmd - Region    Cobra Command 
func NewRegionCmd() *cobra.Command <span class="cov8" title="1">{

        regionCmd := &amp;cobra.Command{
                Use:   "region",
                Short: "This is a manageable command for region",
                Long:  "This is a manageable command for region",
        }

        //  Adds the commands for application.
        regionCmd.AddCommand(NewRegionCreateCmd())
        regionCmd.AddCommand(NewRegionListCmd())
        regionCmd.AddCommand(NewRegionGetCmd())
        regionCmd.AddCommand(NewRegionDeleteCmd())

        return regionCmd
}</span>

// NewRegionCreateCmd - Region    Cobra Command 
func NewRegionCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for region",
                Long:  "This is create command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewRegionListCmd - Region    Cobra Command 
func NewRegionListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for region",
                Long:  "This is list command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return listCmd</span>
}

// NewRegionGetCmd - Region    Cobra Command 
func NewRegionGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for region",
                Long:  "This is get command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return getCmd</span>
}

// NewRegionDeleteCmd - Region    Cobra Command 
func NewRegionDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for region",
                Long:  "This is delete command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

// Package cmd -    Cobra  CLI Commands  
package cmd

import (
        "fmt"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/config"
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

var (
        Version   string = "latest"
        CommitSHA string = "development build"
        Time      string = ""
        User      string = ""
)

var (
        configFile string
        inData     string
        inFile     string
        inType     string
        outType    string

        driverName     string
        credentialName string
        regionName     string
        configName     string

        connectionName string
        imageName      string
        specName       string
        vpcName        string
        subnetName     string
        securityName   string
        keypairName    string
        vmName         string
        action         string
        cspID          string
        force          string

        parser config.Parser
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRootCmd -    Root Cobra Command 
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{

        rootCmd := &amp;cobra.Command{
                Use:     "spctl",
                Version: fmt.Sprintf("%s, build %s", Version, CommitSHA),
                Short:   "spctl is an cb-spider grpc cli tool",
                Long:    "This is a lightweight cb-spider grpc cli tool for Cloud-Barista Spider",
        }

        //   
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "./grpc_conf.yaml", "config file")
        rootCmd.PersistentFlags().StringVarP(&amp;inType, "input", "i", "yaml", "input format (json/yaml)")
        rootCmd.PersistentFlags().StringVarP(&amp;outType, "output", "o", "yaml", "output format (json/yaml)")

        // Viper     
        parser = config.MakeParser()

        //  Adds the commands for application.
        rootCmd.AddCommand(NewVersionCmd())

        rootCmd.AddCommand(NewOsCmd())
        rootCmd.AddCommand(NewDriverCmd())
        rootCmd.AddCommand(NewCredentialCmd())
        rootCmd.AddCommand(NewRegionCmd())
        rootCmd.AddCommand(NewConnectionCmd())

        rootCmd.AddCommand(NewImageCmd())
        rootCmd.AddCommand(NewVMSpecCmd())
        rootCmd.AddCommand(NewVPCCmd())
        rootCmd.AddCommand(NewSecurityCmd())
        rootCmd.AddCommand(NewKeyPairCmd())
        rootCmd.AddCommand(NewVMCmd())

        rootCmd.AddCommand(NewSSHCmd())

        return rootCmd
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSecurityCmd - Security    Cobra Command 
func NewSecurityCmd() *cobra.Command <span class="cov8" title="1">{

        securityCmd := &amp;cobra.Command{
                Use:   "security",
                Short: "This is a manageable command for security",
                Long:  "This is a manageable command for security",
        }

        //  Adds the commands for application.
        securityCmd.AddCommand(NewSecurityCreateCmd())
        securityCmd.AddCommand(NewSecurityListCmd())
        securityCmd.AddCommand(NewSecurityGetCmd())
        securityCmd.AddCommand(NewSecurityDeleteCmd())
        securityCmd.AddCommand(NewSecurityListAllCmd())
        securityCmd.AddCommand(NewSecurityDeleteCSPCmd())

        return securityCmd
}</span>

// NewSecurityCreateCmd - Security    Cobra Command 
func NewSecurityCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for security",
                Long:  "This is create command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewSecurityListCmd - Security    Cobra Command 
func NewSecurityListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for security",
                Long:  "This is list command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewSecurityGetCmd - Security    Cobra Command 
func NewSecurityGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for security",
                Long:  "This is get command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if securityName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", securityName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;securityName, "name", "n", "", "security name")

        return getCmd</span>
}

// NewSecurityDeleteCmd - Security    Cobra Command 
func NewSecurityDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for security",
                Long:  "This is delete command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if securityName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", securityName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;securityName, "name", "n", "", "security name")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return deleteCmd</span>
}

// NewSecurityListAllCmd -  Security    Cobra Command 
func NewSecurityListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for security",
                Long:  "This is list all command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewSecurityDeleteCSPCmd -  Security    Cobra Command 
func NewSecurityDeleteCSPCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCSPCmd := &amp;cobra.Command{
                Use:   "deletecsp",
                Short: "This is delete csp command for security",
                Long:  "This is delete csp command for security",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return deleteCSPCmd</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSSHCmd - SSH    Cobra Command 
func NewSSHCmd() *cobra.Command <span class="cov8" title="1">{

        sshCmd := &amp;cobra.Command{
                Use:   "ssh",
                Short: "This is a manageable command for ssh",
                Long:  "This is a manageable command for ssh",
        }

        //  Adds the commands for application.
        sshCmd.AddCommand(NewSSHRunCmd())

        return sshCmd
}</span>

// NewSSHRunCmd - SSH    Cobra Command 
func NewSSHRunCmd() *cobra.Command <span class="cov8" title="1">{

        runCmd := &amp;cobra.Command{
                Use:   "run",
                Short: "This is run command for ssh",
                Long:  "This is run command for ssh",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">runCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        runCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return runCmd</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "fmt"
        "runtime"

        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVersionCmd -     Cobra Command 
func NewVersionCmd() *cobra.Command <span class="cov8" title="1">{

        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "This is a version command for spctl",
                Long:  "This is a version command for spctl",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "spctl:\n    Version: %s\n    Commit SHA: %s\n    Go version: %s\n"+
                                "    OS/Arch: %s\n    Build Time: %s\n    Build User: %s\n",
                                Version, CommitSHA, runtime.Version(), fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH), Time, User)
                }</span>,
        }

        <span class="cov8" title="1">return versionCmd</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVMCmd - VM    Cobra Command 
func NewVMCmd() *cobra.Command <span class="cov8" title="1">{

        vmCmd := &amp;cobra.Command{
                Use:   "vm",
                Short: "This is a manageable command for vm",
                Long:  "This is a manageable command for vm",
        }

        //  Adds the commands for application.
        vmCmd.AddCommand(NewVMStartCmd())
        //vmCmd.AddCommand(NewVMControlCmd())
        vmCmd.AddCommand(NewVMListStatusCmd())
        vmCmd.AddCommand(NewVMGetStatusCmd())
        vmCmd.AddCommand(NewVMListCmd())
        vmCmd.AddCommand(NewVMGetCmd())
        vmCmd.AddCommand(NewVMTerminateCmd())
        vmCmd.AddCommand(NewVMListAllCmd())
        vmCmd.AddCommand(NewVMTerminateCSPCmd())

        return vmCmd
}</span>

// NewVMStartCmd - VM    Cobra Command 
func NewVMStartCmd() *cobra.Command <span class="cov8" title="1">{

        startCmd := &amp;cobra.Command{
                Use:   "start",
                Short: "This is start command for vm",
                Long:  "This is start command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">startCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        startCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return startCmd</span>
}

// NewVMControlCmd - VM    Cobra Command 
func NewVMControlCmd() *cobra.Command <span class="cov0" title="0">{

        controlCmd := &amp;cobra.Command{
                Use:   "control",
                Short: "This is control command for vm",
                Long:  "This is control command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if action == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --action parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)
                        logger.Debug("--action parameter value : ", action)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">controlCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        controlCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")
        controlCmd.PersistentFlags().StringVarP(&amp;action, "action", "a", "", "action name")

        return controlCmd</span>
}

// NewVMListStatusCmd - VM     Cobra Command 
func NewVMListStatusCmd() *cobra.Command <span class="cov8" title="1">{

        listStatusCmd := &amp;cobra.Command{
                Use:   "liststatus",
                Short: "This is list status command for vm",
                Long:  "This is list status command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listStatusCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listStatusCmd</span>
}

// NewVMGetStatusCmd - VM     Cobra Command 
func NewVMGetStatusCmd() *cobra.Command <span class="cov8" title="1">{

        getStatusCmd := &amp;cobra.Command{
                Use:   "getstatus",
                Short: "This is get status command for vm",
                Long:  "This is get status command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getStatusCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getStatusCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")

        return getStatusCmd</span>
}

// NewVMListCmd - VM    Cobra Command 
func NewVMListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for vm",
                Long:  "This is list command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewVMGetCmd - VM    Cobra Command 
func NewVMGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for vm",
                Long:  "This is get command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")

        return getCmd</span>
}

// NewVMTerminateCmd - VM    Cobra Command 
func NewVMTerminateCmd() *cobra.Command <span class="cov8" title="1">{

        terminateCmd := &amp;cobra.Command{
                Use:   "terminate",
                Short: "This is terminate command for vm",
                Long:  "This is terminate command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vmName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vmName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">terminateCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        terminateCmd.PersistentFlags().StringVarP(&amp;vmName, "name", "n", "", "vm name")
        terminateCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return terminateCmd</span>
}

// NewVMListAllCmd -  VM    Cobra Command 
func NewVMListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for vm",
                Long:  "This is list all command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewVMTerminateCSPCmd -  VM    Cobra Command 
func NewVMTerminateCSPCmd() *cobra.Command <span class="cov8" title="1">{

        terminateCSPCmd := &amp;cobra.Command{
                Use:   "terminatecsp",
                Short: "This is terminate csp command for vm",
                Long:  "This is terminate csp command for vm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">terminateCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        terminateCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return terminateCSPCmd</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVMSpecCmd - VM Spec    Cobra Command 
func NewVMSpecCmd() *cobra.Command <span class="cov8" title="1">{

        vmSpecCmd := &amp;cobra.Command{
                Use:   "vmspec",
                Short: "This is a manageable command for vm spec",
                Long:  "This is a manageable command for vm spec",
        }

        //  Adds the commands for application.
        vmSpecCmd.AddCommand(NewVMSpecListCmd())
        vmSpecCmd.AddCommand(NewVMSpecGetCmd())
        vmSpecCmd.AddCommand(NewVMSpecListOrgCmd())
        vmSpecCmd.AddCommand(NewVMSpecGetOrgCmd())

        return vmSpecCmd
}</span>

// NewVMSpecListCmd - VM Spec    Cobra Command 
func NewVMSpecListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for vm spec",
                Long:  "This is list command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewVMSpecGetCmd - VM Spec    Cobra Command 
func NewVMSpecGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for vm spec",
                Long:  "This is get command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if specName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", specName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;specName, "name", "n", "", "spec name")

        return getCmd</span>
}

// NewVMSpecListOrgCmd -   VM Spec    Cobra Command 
func NewVMSpecListOrgCmd() *cobra.Command <span class="cov8" title="1">{

        listOrgCmd := &amp;cobra.Command{
                Use:   "listorg",
                Short: "This is original list command for vm spec",
                Long:  "This is original list command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listOrgCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listOrgCmd</span>
}

// NewVMSpecGetOrgCmd -   VM Spec    Cobra Command 
func NewVMSpecGetOrgCmd() *cobra.Command <span class="cov8" title="1">{

        getOrgCmd := &amp;cobra.Command{
                Use:   "getorg",
                Short: "This is original get command for vm spec",
                Long:  "This is original get command for vm spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if specName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", specName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getOrgCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getOrgCmd.PersistentFlags().StringVarP(&amp;specName, "name", "n", "", "spec name")

        return getOrgCmd</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">// gRPC Runtime of CB-Spider.
// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
// The CB-Spider Mission is to connect all the clouds with a single interface.
//
//      * Cloud-Barista: https://github.com/cloud-barista
//
// by CB-Spider Team, 2020.09.

package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-spider/api-runtime/grpc-runtime/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVPCCmd - VPC    Cobra Command 
func NewVPCCmd() *cobra.Command <span class="cov8" title="1">{

        vpcCmd := &amp;cobra.Command{
                Use:   "vpc",
                Short: "This is a manageable command for vpc",
                Long:  "This is a manageable command for vpc",
        }

        //  Adds the commands for application.
        vpcCmd.AddCommand(NewVPCCreateCmd())
        vpcCmd.AddCommand(NewVPCListCmd())
        vpcCmd.AddCommand(NewVPCGetCmd())
        vpcCmd.AddCommand(NewVPCDeleteCmd())
        vpcCmd.AddCommand(NewVPCListAllCmd())
        vpcCmd.AddCommand(NewVPCDeleteCSPCmd())
        vpcCmd.AddCommand(NewSubnetAddCmd())
        vpcCmd.AddCommand(NewSubnetRemoveCmd())
        vpcCmd.AddCommand(NewSubnetRemoveCSPCmd())

        return vpcCmd
}</span>

// NewVPCCreateCmd - VPC    Cobra Command 
func NewVPCCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for vpc",
                Long:  "This is create command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewVPCListCmd - VPC    Cobra Command 
func NewVPCListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for vpc",
                Long:  "This is list command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listCmd</span>
}

// NewVPCGetCmd - VPC    Cobra Command 
func NewVPCGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for vpc",
                Long:  "This is get command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vpcName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        getCmd.PersistentFlags().StringVarP(&amp;vpcName, "name", "n", "", "vpc name")

        return getCmd</span>
}

// NewVPCDeleteCmd - VPC    Cobra Command 
func NewVPCDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for vpc",
                Long:  "This is delete command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--name parameter value : ", vpcName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCmd.PersistentFlags().StringVarP(&amp;vpcName, "name", "n", "", "vpc name")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return deleteCmd</span>
}

// NewVPCListAllCmd -  VPC    Cobra Command 
func NewVPCListAllCmd() *cobra.Command <span class="cov8" title="1">{

        listAllCmd := &amp;cobra.Command{
                Use:   "listall",
                Short: "This is list all command for vpc",
                Long:  "This is list all command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listAllCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")

        return listAllCmd</span>
}

// NewVPCDeleteCSPCmd -  VPC    Cobra Command 
func NewVPCDeleteCSPCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCSPCmd := &amp;cobra.Command{
                Use:   "deletecsp",
                Short: "This is delete csp command for vpc",
                Long:  "This is delete csp command for vpc",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        deleteCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return deleteCSPCmd</span>
}

// NewSubnetAddCmd - Subnet    Cobra Command 
func NewSubnetAddCmd() *cobra.Command <span class="cov8" title="1">{

        addCmd := &amp;cobra.Command{
                Use:   "add-subnet",
                Short: "This is add command for vpc subnet",
                Long:  "This is add command for vpc subnet",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">addCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        addCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return addCmd</span>
}

// NewSubnetRemoveCmd - Subnet    Cobra Command 
func NewSubnetRemoveCmd() *cobra.Command <span class="cov8" title="1">{

        removeCmd := &amp;cobra.Command{
                Use:   "remove-subnet",
                Short: "This is remove command for vpc subnet",
                Long:  "This is remove command for vpc subnet",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if subnetName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --sname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--vname parameter value : ", vpcName)
                        logger.Debug("--sname parameter value : ", subnetName)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">removeCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        removeCmd.PersistentFlags().StringVarP(&amp;vpcName, "vname", "", "", "vpc name")
        removeCmd.PersistentFlags().StringVarP(&amp;subnetName, "sname", "", "", "subnet name")
        removeCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flg (true/false)")

        return removeCmd</span>
}

// NewSubnetRemoveCSPCmd - CSP Subnet    Cobra Command 
func NewSubnetRemoveCSPCmd() *cobra.Command <span class="cov8" title="1">{

        removeCSPCmd := &amp;cobra.Command{
                Use:   "removecsp-subnet",
                Short: "This is remove csp command for vpc subnet",
                Long:  "This is remove csp command for vpc subnet",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if connectionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if vpcName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vname parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if cspID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--cname parameter value : ", connectionName)
                        logger.Debug("--vname parameter value : ", vpcName)
                        logger.Debug("--id parameter value : ", cspID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">removeCSPCmd.PersistentFlags().StringVarP(&amp;connectionName, "cname", "", "", "connection name")
        removeCSPCmd.PersistentFlags().StringVarP(&amp;vpcName, "vname", "", "", "vpc name")
        removeCSPCmd.PersistentFlags().StringVarP(&amp;cspID, "id", "", "", "csp id")

        return removeCSPCmd</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
