
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloud-barista/poc-cicd-ladybug/src/core/common/common.go (100.0%)</option>
				
				<option value="file1">github.com/cloud-barista/poc-cicd-ladybug/src/core/common/ns.go (0.0%)</option>
				
				<option value="file2">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/cluster.go (81.7%)</option>
				
				<option value="file3">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/node.go (86.7%)</option>
				
				<option value="file4">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/spider/base.go (37.5%)</option>
				
				<option value="file5">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/spider/connection.go (63.6%)</option>
				
				<option value="file6">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/spider/region.go (66.7%)</option>
				
				<option value="file7">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/status.go (100.0%)</option>
				
				<option value="file8">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/base.go (44.4%)</option>
				
				<option value="file9">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/firewall.go (33.3%)</option>
				
				<option value="file10">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/image.go (33.3%)</option>
				
				<option value="file11">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/mcis.go (60.9%)</option>
				
				<option value="file12">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/ns.go (71.4%)</option>
				
				<option value="file13">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/spec.go (42.1%)</option>
				
				<option value="file14">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/sshkey.go (42.1%)</option>
				
				<option value="file15">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/tvm.go (73.3%)</option>
				
				<option value="file16">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug/vpc.go (33.3%)</option>
				
				<option value="file17">github.com/cloud-barista/poc-cicd-ladybug/src/core/model/vm.go (63.3%)</option>
				
				<option value="file18">github.com/cloud-barista/poc-cicd-ladybug/src/core/service/cluster.go (73.8%)</option>
				
				<option value="file19">github.com/cloud-barista/poc-cicd-ladybug/src/core/service/common.go (84.8%)</option>
				
				<option value="file20">github.com/cloud-barista/poc-cicd-ladybug/src/core/service/csp.go (16.7%)</option>
				
				<option value="file21">github.com/cloud-barista/poc-cicd-ladybug/src/core/service/mcir.go (85.1%)</option>
				
				<option value="file22">github.com/cloud-barista/poc-cicd-ladybug/src/core/service/node.go (79.6%)</option>
				
				<option value="file23">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/cbadm/cmd/cluster.go (78.2%)</option>
				
				<option value="file24">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/cbadm/cmd/gclient.go (67.3%)</option>
				
				<option value="file25">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/cbadm/cmd/healthy.go (100.0%)</option>
				
				<option value="file26">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/cbadm/cmd/node.go (74.3%)</option>
				
				<option value="file27">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/cbadm/cmd/root.go (100.0%)</option>
				
				<option value="file28">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/cbadm/cmd/version.go (66.7%)</option>
				
				<option value="file29">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common/cbconnection.go (0.0%)</option>
				
				<option value="file30">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common/cbmessage.go (70.5%)</option>
				
				<option value="file31">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common/cbserver.go (34.8%)</option>
				
				<option value="file32">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common/grpcstatuserr.go (0.0%)</option>
				
				<option value="file33">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/config/config.go (23.9%)</option>
				
				<option value="file34">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/config/parser.go (37.5%)</option>
				
				<option value="file35">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/accesslog/client_interceptors.go (0.0%)</option>
				
				<option value="file36">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/accesslog/server_interceptors.go (55.0%)</option>
				
				<option value="file37">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/authjwt/auth.go (0.0%)</option>
				
				<option value="file38">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/authjwt/client_interceptors.go (0.0%)</option>
				
				<option value="file39">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/authjwt/server_interceptors.go (0.0%)</option>
				
				<option value="file40">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/jaegertracer/jaegertracer.go (0.0%)</option>
				
				<option value="file41">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger/logger.go (33.3%)</option>
				
				<option value="file42">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/request/mcar/cluster.go (75.0%)</option>
				
				<option value="file43">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/request/mcar/healthy.go (83.3%)</option>
				
				<option value="file44">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/request/mcar/node.go (75.0%)</option>
				
				<option value="file45">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/request/mcarapi.go (78.8%)</option>
				
				<option value="file46">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/server/mcar/cluster.go (77.8%)</option>
				
				<option value="file47">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/server/mcar/healthy.go (100.0%)</option>
				
				<option value="file48">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/server/mcar/mcar.go (70.8%)</option>
				
				<option value="file49">github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/server/mcar/node.go (75.0%)</option>
				
				<option value="file50">github.com/cloud-barista/poc-cicd-ladybug/src/rest-api/router/cluster.go (68.4%)</option>
				
				<option value="file51">github.com/cloud-barista/poc-cicd-ladybug/src/rest-api/router/healthy.go (100.0%)</option>
				
				<option value="file52">github.com/cloud-barista/poc-cicd-ladybug/src/rest-api/router/node.go (62.8%)</option>
				
				<option value="file53">github.com/cloud-barista/poc-cicd-ladybug/src/utils/app/ack.go (70.0%)</option>
				
				<option value="file54">github.com/cloud-barista/poc-cicd-ladybug/src/utils/app/client.go (100.0%)</option>
				
				<option value="file55">github.com/cloud-barista/poc-cicd-ladybug/src/utils/config/config.go (0.0%)</option>
				
				<option value="file56">github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang/functions.go (92.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package common

import (
        cbstore "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var CBStore icbs.Store

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        CBStore = cbstore.GetStore()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package common

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

func NsValidate() echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        ns := c.Param("namespace")
                        if ns == "" </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "Namespace cannot be empty")
                        }</span>
                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package model

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/common"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang"
)

const (
        STATUS_CREATED      = "created"
        STATUS_PROVISIONING = "provisioning"
        STATUS_COMPLETED    = "completed"
        STATUS_FAILED       = "failed"
)

type Cluster struct {
        Model
        Status        string `json:"status"`
        UId           string `json:"uid"`
        MCIS          string `json:"mcis"`
        Namespace     string `json:"namespace"`
        ClusterConfig string `json:"clusterConfig"`
        CpLeader      string `json:"cpLeader"`
        NetworkCni    string `json:"networkCni"`
        Nodes         []Node `json:"nodes"`
}

type ClusterList struct {
        ListModel
        namespace string
        Items     []Cluster `json:"items"`
}

func NewCluster(namespace string, name string) *Cluster <span class="cov8" title="1">{
        return &amp;Cluster{
                Model:     Model{Kind: KIND_CLUSTER, Name: name},
                Namespace: namespace,
                Nodes:     []Node{},
        }
}</span>

func NewClusterList(namespace string) *ClusterList <span class="cov8" title="1">{
        return &amp;ClusterList{
                ListModel: ListModel{Kind: KIND_CLUSTER_LIST},
                namespace: namespace,
                Items:     []Cluster{},
        }
}</span>

func (self *Cluster) Insert() error <span class="cov8" title="1">{
        self.Status = STATUS_CREATED
        return self.putStore()
}</span>

func (self *Cluster) Update() error <span class="cov8" title="1">{
        self.Status = STATUS_PROVISIONING
        return self.putStore()
}</span>

func (self *Cluster) Complete() error <span class="cov8" title="1">{
        self.Status = STATUS_COMPLETED
        return self.putStore()
}</span>

func (self *Cluster) Fail() error <span class="cov0" title="0">{
        self.Status = STATUS_FAILED
        return self.putStore()
}</span>

func (self *Cluster) putStore() error <span class="cov8" title="1">{
        key := lang.GetStoreClusterKey(self.Namespace, self.Name)
        value, _ := json.Marshal(self)
        err := common.CBStore.Put(key, string(value))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *Cluster) Select() error <span class="cov8" title="1">{
        key := lang.GetStoreClusterKey(self.Namespace, self.Name)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if keyValue == nil </span><span class="cov8" title="1">{
                return errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov8" title="1">json.Unmarshal([]byte(keyValue.Value), &amp;self)

        err = getClusterNodes(self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *Cluster) Delete() error <span class="cov8" title="1">{
        // delete node
        keyValues, err := common.CBStore.GetList(lang.GetStoreNodeKey(self.Namespace, self.Name, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, keyValue := range keyValues </span><span class="cov8" title="1">{
                err = common.CBStore.Delete(keyValue.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // delete cluster
        <span class="cov8" title="1">key := lang.GetStoreClusterKey(self.Namespace, self.Name)
        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *ClusterList) SelectList() error <span class="cov8" title="1">{
        keyValues, err := common.CBStore.GetList(lang.GetStoreClusterKey(self.namespace, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">self.Items = []Cluster{}
        for _, keyValue := range keyValues </span><span class="cov8" title="1">{
                if !strings.Contains(keyValue.Key, "/nodes") </span><span class="cov8" title="1">{
                        cluster := &amp;Cluster{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;cluster)

                        err = getClusterNodes(cluster)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">self.Items = append(self.Items, *cluster)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func getClusterNodes(cluster *Cluster) error <span class="cov8" title="1">{
        nodeKeyValues, err := common.CBStore.GetList(lang.GetStoreNodeKey(cluster.Namespace, cluster.Name, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, nodeKeyValue := range nodeKeyValues </span><span class="cov8" title="1">{
                node := &amp;Node{}
                json.Unmarshal([]byte(nodeKeyValue.Value), &amp;node)
                cluster.Nodes = append(cluster.Nodes, *node)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package model

import (
        "encoding/json"
        "errors"
        "fmt"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/common"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang"
)

type Node struct {
        Model
        namespace   string
        clusterName string
        Credential  string     `json:"credential"`
        PublicIP    string     `json:"publicIp"`
        UId         string     `json:"uid"`
        Role        string     `json:"role"`
        Spec        string     `json:"spec"`
        Csp         config.CSP `json:"csp"`
}

type NodeList struct {
        ListModel
        namespace   string
        clusterName string
        Items       []Node `json:"items"`
}

func NewNodeVM(namespace string, clusterName string, vm VM) *Node <span class="cov8" title="1">{
        return &amp;Node{
                Model:       Model{Kind: KIND_NODE, Name: vm.Name},
                Credential:  vm.Credential,
                PublicIP:    vm.PublicIP,
                Role:        vm.Role,
                Spec:        vm.Spec,
                Csp:         vm.Csp,
                namespace:   namespace,
                clusterName: clusterName,
        }
}</span>

func NewNode(namespace string, clusterName string, nodeName string) *Node <span class="cov8" title="1">{
        return &amp;Node{
                Model:       Model{Kind: KIND_NODE, Name: nodeName},
                namespace:   namespace,
                clusterName: clusterName,
        }
}</span>

func NewNodeList(namespace string, clusterName string) *NodeList <span class="cov8" title="1">{
        return &amp;NodeList{
                ListModel:   ListModel{Kind: KIND_NODE_LIST},
                Items:       []Node{},
                namespace:   namespace,
                clusterName: clusterName,
        }
}</span>

func (self *Node) Select() error <span class="cov8" title="1">{
        key := lang.GetStoreNodeKey(self.namespace, self.clusterName, self.Name)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if keyValue == nil </span><span class="cov8" title="1">{
                return errors.New(fmt.Sprintf("%s not found", key))
        }</span>

        <span class="cov8" title="1">json.Unmarshal([]byte(keyValue.Value), &amp;self)
        return nil</span>
}

func (self *Node) Insert() error <span class="cov8" title="1">{
        key := lang.GetStoreNodeKey(self.namespace, self.clusterName, self.Name)
        value, _ := json.Marshal(self)
        err := common.CBStore.Put(key, string(value))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *Node) Delete() error <span class="cov8" title="1">{
        key := lang.GetStoreNodeKey(self.namespace, self.clusterName, self.Name)
        err := common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *NodeList) SelectList() error <span class="cov8" title="1">{
        keyValues, err := common.CBStore.GetList(lang.GetStoreNodeKey(self.namespace, self.clusterName, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, keyValue := range keyValues </span><span class="cov8" title="1">{
                node := &amp;Node{}
                json.Unmarshal([]byte(keyValue.Value), &amp;node)
                self.Items = append(self.Items, *node)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package spider

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/go-resty/resty/v2"

        logger "github.com/sirupsen/logrus"
)

type Model struct {
}

// 결과 처리
func (m *Model) response(resp *resty.Response, err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() &gt; 300 &amp;&amp; resp.StatusCode() != http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Warnf("Spider : statusCode=%d, url=%s, body=%s", resp.StatusCode(), resp.Request.URL, resp)
                status := model.Status{}
                json.Unmarshal(resp.Body(), &amp;status)
                return errors.New(status.Message)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package spider

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/app"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        logger "github.com/sirupsen/logrus"
)

// connection config
type Connection struct {
        Model
        ConfigName     string `json:"ConfigName"`
        ProviderName   string `json:"ProviderName"`
        DriverName     string `json:"DriverName"`
        CredentialName string `json:"CredentialName"`
        RegionName     string `json:"RegionName"`
}

func NewConnection(name string) *Connection <span class="cov8" title="1">{
        return &amp;Connection{
                Model:      Model{},
                ConfigName: name,
        }
}</span>

// get connection config
func (self *Connection) GET() (bool, error) <span class="cov8" title="1">{

        url := fmt.Sprintf("%s/connectionconfig/%s", *config.Config.SpiderUrl, self.ConfigName)
        resp, err := app.ExecutHTTP(http.MethodGet, url, nil, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if err = self.response(resp, err); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Infof("Not found data (status=404, method=%s, url=%s)", http.MethodGet, url)
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package spider

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/app"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        logger "github.com/sirupsen/logrus"
)

type Region struct {
        Model
        RegionName       string     `json:"RegionName"`
        ProviderName     string     `json:"ProviderName"`
        KeyValueInfoList []KeyValue `json:"KeyValueInfoList"`
}

type KeyValue struct {
        Key   string
        Value string
}

func NewRegion(name string) *Region <span class="cov8" title="1">{
        return &amp;Region{
                Model:      Model{},
                RegionName: name,
        }
}</span>

// get region
func (self *Region) GET() (bool, error) <span class="cov8" title="1">{

        url := fmt.Sprintf("%s/region/%s", *config.Config.SpiderUrl, self.RegionName)
        resp, err := app.ExecutHTTP(http.MethodGet, url, nil, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Warnf("Not found data (status=404, method=%s, url=%s)", http.MethodGet, url)
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package model

const (
        STATUS_UNKNOWN   = 0
        STATUS_SUCCESS   = 1
        STATUS_NOT_EXIST = 404
        // STATUS_OK        = 200
        // STATUS_FAIL      = 500
)

type Status struct {
        Kind    string `json:"kind"`
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func NewStatus() *Status <span class="cov8" title="1">{
        return &amp;Status{
                Kind: KIND_STATUS,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package tumblebug

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/beego/beego/v2/core/validation"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/app"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        "github.com/go-resty/resty/v2"

        logger "github.com/sirupsen/logrus"
)

type KeyValue struct {
        Key   string
        Value string
}

type Model struct {
        Name      string `json:"name"`
        namespace string
}

func (self *Model) execute(method string, url string, body interface{}, result interface{}) (bool, error) <span class="cov8" title="1">{

        // validation
        if err := self.validate(validation.Validation{}); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">resp, err := app.ExecutHTTP(method, *config.Config.TumblebugUrl+url, body, result)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // response check
        <span class="cov8" title="1">if resp.StatusCode() &gt; 300 &amp;&amp; resp.StatusCode() != http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Warnf("Tumblebug : statusCode=%d, url=%s, body=%s", resp.StatusCode(), resp.Request.URL, resp)
                status := model.Status{}
                json.Unmarshal(resp.Body(), &amp;status)
                // message &gt; message 로 리턴되는 경우가 있어서 한번더 unmarshal 작업
                if json.Valid([]byte(status.Message)) </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(status.Message), &amp;status)
                }</span>
                <span class="cov0" title="0">return false, errors.New(status.Message)</span>
        }

        <span class="cov8" title="1">if method == http.MethodGet &amp;&amp; resp.StatusCode() == http.StatusNotFound </span><span class="cov8" title="1">{
                logger.Infof("Not found data (status=404, method=%s, url=%s)", method, url)
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}

// // 결과 처리
// func (self *Model) response(resp *resty.Response, err error) error {
//         if err != nil {
//                 return err
//         }
//         if resp.StatusCode() &gt; 300 &amp;&amp; resp.StatusCode() != http.StatusNotFound {
//                 logger.Warnf("statusCode=%d, url=%s, body=%s", resp.StatusCode(), resp.Request.URL, resp)
//                 status := model.Status{}
//                 json.Unmarshal(resp.Body(), &amp;status)
//                 // message &gt; message 로 리턴되는 경우가 있어서 한번더 unmarshal 작업
//                 if json.Valid([]byte(status.Message)) {
//                         json.Unmarshal([]byte(status.Message), &amp;status)
//                 }
//                 return errors.New(status.Message)

//         }
//         return nil
// }

func (self *Model) validate(valid validation.Validation) error <span class="cov8" title="1">{
        valid.Required(self.namespace, "namespace")
        valid.Required(self.Name, "name")
        if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// status :200 , body = {message: "Cannot find ..." }  형태의 response 에러처리
func (self *Model) hasResponseMessage(resp *resty.Response) error <span class="cov0" title="0">{
        var d map[string]interface{}
        json.Unmarshal(resp.Body(), &amp;d)
        if d["message"] != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("%s", d["message"]))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        logger "github.com/sirupsen/logrus"
)

type Firewall struct {
        Model
        Config               string          `json:"connectionName"`
        VPCId                string          `json:"vNetId"`
        Description          string          `json:"description"`
        FirewallRules        []FirewallRules `json:"firewallRules"`
        CspSecurityGroupId   string          `json:"cspSecurityGroupId"`   // output
        CspSecurityGroupName string          `json:"cspSecurityGroupName"` // output
        KeyValueList         []KeyValue      `json:"keyValueList"`         // output
}

type FirewallRules struct {
        From      string `json:"fromPort"`
        To        string `json:"toPort"`
        Protocol  string `json:"ipProtocol"`
        Direction string `json:"direction"`
}

func NewFirewall(ns string, name string, conf string) *Firewall <span class="cov8" title="1">{
        return &amp;Firewall{
                Model:  Model{Name: name, namespace: ns},
                Config: conf,
                FirewallRules: []FirewallRules{
                        {Protocol: "tcp", Direction: "inbound", From: "1", To: "65535"},
                        {Protocol: "udp", Direction: "inbound", From: "1", To: "65535"},
                        {Protocol: "icmp", Direction: "inbound", From: "-1", To: "-1"},
                },
        }
}</span>

func (self *Firewall) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/securityGroup/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *Firewall) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/securityGroup", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *Firewall) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/securityGroup/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete firewall skip (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        logger "github.com/sirupsen/logrus"
)

type Image struct {
        Model
        Config       string     `json:"connectionName"`
        CspImageId   string     `json:"cspImageId"`
        CspImageName string     `json:"cspImageName"` // output
        CreationDate string     `json:"creationDate"` // output
        Description  string     `json:"description"`  //
        GuestOS      string     `json:"guestOS"`      //
        Status       string     `json:"status"`       // output
        KeyValueList []KeyValue `json:"keyValueList"` // output
}

func NewImage(ns string, name string, conf string) *Image <span class="cov8" title="1">{
        return &amp;Image{
                Model:        Model{Name: name, namespace: ns},
                Config:       conf,
                CspImageName: "Ubuntu, 18.04",
                Description:  "Canonical, Ubuntu, 18.04 LTS, amd64 bionic",
                GuestOS:      "ubuntu",
                KeyValueList: []KeyValue{},
        }
}</span>

func (self *Image) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/image/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)
}</span>

func (self *Image) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/image?action=registerWithInfo", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *Image) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/image/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete image skip (name=%s, cause=not found)", self.Name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type MCIS struct {
        Model
        Description string     `json:"description"`
        VMs         []model.VM `json:"vm"` // output
}

func NewMCIS(ns string, name string) *MCIS <span class="cov8" title="1">{
        return &amp;MCIS{
                Model: Model{Name: name, namespace: ns},
                VMs:   []model.VM{},
        }
}</span>

func (self *MCIS) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/mcis/%s", self.namespace, self.Name), nil, &amp;self)

        // if err = self.hasResponseMessage(resp); err != nil {
        //         // 이부분은 향후 tumblebug 에서 수정해야 할듯
        //         if strings.HasPrefix(err.Error(), "Cannot find") {
        //                 return false, nil
        //         } else {
        //                 return false, err
        //         }
        // }
}</span>

func (self *MCIS) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/mcis", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *MCIS) DELETE() error <span class="cov8" title="1">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if exist </span><span class="cov8" title="1">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/mcis/%s", self.namespace, self.Name), nil, model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete MCIS skip (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *MCIS) TERMINATE() error <span class="cov8" title="1">{
        _, err := self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/mcis/%s?action=terminate", self.namespace, self.Name), nil, model.Status{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *MCIS) REFINE() error <span class="cov0" title="0">{
        _, err := self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/mcis/%s?action=refine", self.namespace, self.Name), nil, model.Status{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/app"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
)

type NS struct {
        ID          string `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

func NewNS(ns string) *NS <span class="cov8" title="1">{
        return &amp;NS{
                Name: ns,
                ID:   ns,
        }
}</span>

func (self *NS) GET() (bool, error) <span class="cov8" title="1">{

        resp, err := app.ExecutHTTP(http.MethodGet, fmt.Sprintf("%s/ns/%s", *config.Config.TumblebugUrl, self.Name), nil, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/beego/beego/v2/core/validation"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type Spec struct {
        Model
        Config      string `json:"connectionName"`
        CspSpecName string `json:"cspSpecName"`
}

func NewSpec(ns string, name string, conf string) *Spec <span class="cov8" title="1">{
        return &amp;Spec{
                Model:  Model{Name: name, namespace: ns},
                Config: conf,
        }
}</span>

func (self *Spec) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/spec/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *Spec) POST() error <span class="cov8" title="1">{

        // validation
        valid := validation.Validation{}
        valid.Required(self.CspSpecName, "cspSpecName")
        if err := self.validate(valid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/spec", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (self *Spec) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/spec/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        } else<span class="cov0" title="0"> {
                logger.Infof("delete spec skip.. (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/beego/beego/v2/core/validation"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type SSHKey struct {
        Model
        Config     string `json:"connectionName"`
        Username   string `json:"username"`
        PrivateKey string `json:"privateKey"` // output
}

func NewSSHKey(ns string, name string, conf string) *SSHKey <span class="cov8" title="1">{
        return &amp;SSHKey{
                Model:  Model{Name: name, namespace: ns},
                Config: conf,
        }
}</span>

func (self *SSHKey) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/sshKey/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *SSHKey) POST() error <span class="cov8" title="1">{
        // validation
        valid := validation.Validation{}
        valid.Required(self.Username, "username")
        if err := self.validate(valid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/sshKey", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (self *SSHKey) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/sshKey/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete sshkey skip (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type TVM struct {
        Model
        VM model.VM
}

func NewTVm(ns string, mcisName string) *TVM <span class="cov8" title="1">{
        return &amp;TVM{
                Model: Model{namespace: ns, Name: mcisName},
        }
}</span>

func (self *TVM) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/mcis/%s/vm/%s", self.namespace, self.Name, self.VM.Name), nil, &amp;self.VM)

}</span>

func (self *TVM) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/mcis/%s/vm", self.namespace, self.Name), self.VM, &amp;self.VM)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (self *TVM) DELETE() error <span class="cov8" title="1">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if exist </span><span class="cov8" title="1">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/mcis/%s/vm/%s", self.namespace, self.Name, self.VM.Name), nil, model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete VM skip (name=%s, cause=not found)", self.VM.Name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        logger "github.com/sirupsen/logrus"
)

type VPC struct {
        Model
        Config       string     `json:"connectionName"`
        CidrBlock    string     `json:"cidrBlock"`
        Subnets      []Subnet   `json:"subnetInfoList"`
        Description  string     `json:"description"`
        CspVNetId    string     `json:"cspVNetId"`    // output
        CspVNetName  string     `json:"cspVNetName"`  // output
        Status       string     `json:"status"`       // output
        KeyValueList []KeyValue `json:"keyValueList"` // output
}

type Subnet struct {
        Name      string `json:"Name"`
        CidrBlock string `json:"IPv4_CIDR"`
}

func NewVPC(ns string, name string, conf string) *VPC <span class="cov8" title="1">{
        return &amp;VPC{
                Model:     Model{Name: name, namespace: ns},
                Config:    conf,
                CidrBlock: "192.168.0.0/16",
                Subnets: []Subnet{
                        {
                                Name:      fmt.Sprintf("%s-subnet", name),
                                CidrBlock: "192.168.1.0/24"},
                },
        }
}</span>

func (self *VPC) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/vNet/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *VPC) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/vNet", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (self *VPC) DELETE() error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/vNet/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete vpc skip.. (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package model

import (
        "errors"
        "fmt"
        "regexp"
        "strings"

        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        ssh "github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"

        logger "github.com/sirupsen/logrus"
)

type VM struct {
        Name         string     `json:"name"`
        Config       string     `json:"connectionName"`
        VPC          string     `json:"vNetId"`
        Subnet       string     `json:"subnetId"`
        Firewall     []string   `json:"securityGroupIds"`
        SSHKey       string     `json:"sshKeyId"`
        Image        string     `json:"imageId"`
        Spec         string     `json:"specId"`
        UserAccount  string     `json:"vmUserAccount"`
        UserPassword string     `json:"vmUserPassword"`
        Description  string     `json:"description"`
        PublicIP     string     `json:"publicIP"`  // output
        PrivateIP    string     `json:"privateIP"` // output
        Credential   string     // private
        Role         string     `json:"role"`
        Csp          config.CSP `json:"csp"`
        IsCPLeader   bool       `json:"isCPLeader"`
}

type VMInfo struct {
        Name       string     `json:"name"`
        Credential string     // private
        Role       string     `json:"role"`
        Csp        config.CSP `json:"csp"`
        IsCPLeader bool       `json:"isCPLeader"`
}

const (
        remoteTargetPath = "/tmp"
)

func (self *VM) ConnectionTest(sshInfo *ssh.SSHInfo) error <span class="cov8" title="1">{
        cmd := "/bin/hostname"
        _, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("connection test error (server=%s, cause=%s)", sshInfo.ServerPort, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) CopyScripts(sshInfo *ssh.SSHInfo, networkCni string) error <span class="cov8" title="1">{
        sourcePath := fmt.Sprintf("%s/src/scripts", *config.Config.AppRootPath)
        sourceFile := []string{config.BOOTSTRAP_FILE}
        if self.Role == config.CONTROL_PLANE &amp;&amp; self.IsCPLeader </span><span class="cov8" title="1">{
                sourceFile = append(sourceFile, config.INIT_FILE)
                sourceFile = append(sourceFile, config.HA_PROXY_FILE)
        }</span>
        <span class="cov8" title="1">if networkCni == config.NETWORKCNI_CANAL </span><span class="cov0" title="0">{
                sourceFile = append(sourceFile, config.LADYBUG_BOOTSTRAP_CANAL_FILE)
        }</span> else<span class="cov8" title="1"> {
                sourceFile = append(sourceFile, config.LADYBUG_BOOTSTRAP_KILO_FILE)
        }</span>
        <span class="cov8" title="1">sourceFile = append(sourceFile, config.SYSTEMD_SERVICE_FILE)

        logger.Infof("start script file copy (vm=%s, src=%s, dest=%s)\n", self.Name, sourcePath, remoteTargetPath)
        for _, f := range sourceFile </span><span class="cov8" title="1">{
                src := fmt.Sprintf("%s/%s", sourcePath, f)
                dest := fmt.Sprintf("%s/%s", remoteTargetPath, f)
                if err := ssh.SSHCopy(*sshInfo, src, dest); err != nil </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("copy scripts error (server=%s, cause=%s)", sshInfo.ServerPort, err))
                }</span>
        }
        <span class="cov8" title="1">logger.Infof("end script file copy (vm=%s, server=%s)\n", self.Name, sshInfo.ServerPort)
        return nil</span>
}

func (self *VM) SetSystemd(sshInfo *ssh.SSHInfo, networkCni string) error <span class="cov8" title="1">{
        var bsFile string
        if networkCni == config.NETWORKCNI_CANAL </span><span class="cov0" title="0">{
                bsFile = config.LADYBUG_BOOTSTRAP_CANAL_FILE
        }</span> else<span class="cov8" title="1"> {
                bsFile = config.LADYBUG_BOOTSTRAP_KILO_FILE
        }</span>

        <span class="cov8" title="1">cmd := fmt.Sprintf("cd %s;./%s", remoteTargetPath, bsFile)
        _, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("create ladybug-bootstrap error (name=%s)", self.Name))
        }</span>

        <span class="cov8" title="1">cmd = fmt.Sprintf("cd %s;./%s", remoteTargetPath, config.SYSTEMD_SERVICE_FILE)
        _, err = ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("set systemd service error (name=%s)", self.Name))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) Bootstrap(sshInfo *ssh.SSHInfo) error <span class="cov8" title="1">{
        cmd := fmt.Sprintf("cd %s;./%s", remoteTargetPath, config.BOOTSTRAP_FILE)

        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("k8s bootstrap error")
        }</span>
        <span class="cov8" title="1">if strings.Contains(result, "kubectl set on hold") </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return errors.New(fmt.Sprintf("k8s bootstrap failed (name=%s)", self.Name))
        }</span>
}

func (self *VM) InstallHAProxy(sshInfo *ssh.SSHInfo, IPs []string) error <span class="cov8" title="1">{
        var servers string
        for i, ip := range IPs </span><span class="cov8" title="1">{
                servers += fmt.Sprintf("  server  api%d  %s:6443  check", i+1, ip)
                if i &lt; len(IPs)-1 </span><span class="cov0" title="0">{
                        servers += "\\n"
                }</span>
        }
        <span class="cov8" title="1">cmd := fmt.Sprintf("sudo sed 's/^{{SERVERS}}/%s/g' %s/%s", servers, remoteTargetPath, config.HA_PROXY_FILE)
        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("get haproxy command error (name=%s, cause=%v)", self.Name, err)
                return err
        }</span>
        <span class="cov8" title="1">_, err = ssh.SSHRun(*sshInfo, result)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("install haproxy error (name=%s, cause=%v)", self.Name, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) ControlPlaneInit(sshInfo *ssh.SSHInfo, reqKubernetes Kubernetes) ([]string, string, error) <span class="cov8" title="1">{
        var joinCmd []string

        cmd := fmt.Sprintf("cd %s;./%s %s %s %s", remoteTargetPath, config.INIT_FILE, reqKubernetes.PodCidr, reqKubernetes.ServiceCidr, reqKubernetes.ServiceDnsDomain)
        cpInitResult, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("control plane init error (name=%s, cause=%v)", self.Name, err)
                return nil, "", errors.New("k8s control plane node init error")
        }</span>
        <span class="cov8" title="1">if strings.Contains(cpInitResult, "Your Kubernetes control-plane has initialized successfully") </span><span class="cov8" title="1">{
                joinCmd = getJoinCmd(cpInitResult)
        }</span> else<span class="cov0" title="0"> {
                return nil, "", errors.New(fmt.Sprintf("control palne init failed (name=%s)", self.Name))
        }</span>

        <span class="cov8" title="1">cmd = "sudo cat /etc/kubernetes/admin.conf"
        clusterConfig, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error while running cmd %s (vm=%s, cause=%v)", cmd, self.Name, err)
        }</span>

        <span class="cov8" title="1">return joinCmd, clusterConfig, nil</span>
}

func (self *VM) InstallNetworkCNI(sshInfo *ssh.SSHInfo, networkCni string) error <span class="cov8" title="1">{
        var cmd string
        if networkCni == config.NETWORKCNI_CANAL </span><span class="cov0" title="0">{
                cmd = "sudo kubectl apply -f https://docs.projectcalico.org/manifests/canal.yaml --kubeconfig=/etc/kubernetes/admin.conf"
        }</span> else<span class="cov8" title="1"> {
                cmd = `sudo kubectl apply -f https://raw.githubusercontent.com/squat/kilo/main/manifests/crds.yaml --kubeconfig=/etc/kubernetes/admin.conf;
                sudo kubectl apply -f https://raw.githubusercontent.com/squat/kilo/master/manifests/kilo-kubeadm-flannel.yaml --kubeconfig=/etc/kubernetes/admin.conf;
                sudo kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml --kubeconfig=/etc/kubernetes/admin.conf;`
        }</span>

        <span class="cov8" title="1">_, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("networkCNI install failed (name=%s, cause=%v)", self.Name, err)
                return errors.New("NetworkCNI Install error")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) ControlPlaneJoin(sshInfo *ssh.SSHInfo, CPJoinCmd *string) error <span class="cov0" title="0">{
        if *CPJoinCmd == "" </span><span class="cov0" title="0">{
                return errors.New("control-plane node join command empty")
        }</span>
        <span class="cov0" title="0">cmd := fmt.Sprintf("sudo %s", *CPJoinCmd)
        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("control-plane join error (name=%s, cause=%v)", self.Name, err)
                return errors.New("control-plane node join error")
        }</span>

        <span class="cov0" title="0">if strings.Contains(result, "This node has joined the cluster") </span><span class="cov0" title="0">{
                _, err = ssh.SSHRun(*sshInfo, "sudo systemctl restart ladybug-bootstrap")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("ladybug-bootstrap restart error (name=%s, cause=%v)", self.Name, err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                logger.Warnf("control-plane join failed (name=%s)", self.Name)
                return errors.New(fmt.Sprintf("control-plane join failed (name=%s)", self.Name))
        }</span>
}

func (self *VM) WorkerJoin(sshInfo *ssh.SSHInfo, workerJoinCmd *string) error <span class="cov8" title="1">{
        if *workerJoinCmd == "" </span><span class="cov0" title="0">{
                return errors.New("worker node join command empty")
        }</span>
        <span class="cov8" title="1">cmd := fmt.Sprintf("sudo %s", *workerJoinCmd)
        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("worker join error (name=%s, cause=%v)", self.Name, err)
                return errors.New(fmt.Sprintf("worker node join error (name=%s)", self.Name))
        }</span>
        <span class="cov8" title="1">if strings.Contains(result, "This node has joined the cluster") </span><span class="cov8" title="1">{
                _, err = ssh.SSHRun(*sshInfo, "sudo systemctl restart ladybug-bootstrap")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("ladybug-bootstrap restart error (name=%s, cause=%v)", self.Name, err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        } else<span class="cov0" title="0"> {
                logger.Warnf("worker join failed (name=%s)", self.Name)
                return errors.New(fmt.Sprintf("worker node join failed (name=%s)", self.Name))
        }</span>
}

func getJoinCmd(cpInitResult string) []string <span class="cov8" title="1">{
        var join1, join2, join3 string
        joinRegex, _ := regexp.Compile("kubeadm\\sjoin\\s(.*?)\\s--token\\s(.*?)\\n")
        joinRegex2, _ := regexp.Compile("--discovery-token-ca-cert-hash\\ssha256:(.*?)\\n")
        joinRegex3, _ := regexp.Compile("--control-plane --certificate-key(.*?)\\n")

        if joinRegex.MatchString(cpInitResult) </span><span class="cov0" title="0">{
                join1 = joinRegex.FindString(cpInitResult)
        }</span>
        <span class="cov8" title="1">if joinRegex2.MatchString(cpInitResult) </span><span class="cov0" title="0">{
                join2 = joinRegex2.FindString(cpInitResult)
        }</span>
        <span class="cov8" title="1">if joinRegex3.MatchString(cpInitResult) </span><span class="cov0" title="0">{
                join3 = joinRegex3.FindString(cpInitResult)
        }</span>

        <span class="cov8" title="1">return []string{fmt.Sprintf("%s %s %s", join1, join2, join3), fmt.Sprintf("%s %s", join1, join2)}</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang"
        ssh "github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"

        logger "github.com/sirupsen/logrus"
)

func ListCluster(namespace string) (*model.ClusterList, error) <span class="cov8" title="1">{
        clusters := model.NewClusterList(namespace)

        err := clusters.SelectList()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return clusters, nil</span>
}

func GetCluster(namespace string, clusterName string) (*model.Cluster, error) <span class="cov8" title="1">{
        cluster := model.NewCluster(namespace, clusterName)
        err := cluster.Select()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cluster, nil</span>
}

func CreateCluster(namespace string, req *model.ClusterReq) (*model.Cluster, error) <span class="cov8" title="1">{
        clusterName := req.Name
        cluster := model.NewCluster(namespace, clusterName)
        cluster.UId = lang.GetUid()
        cluster.NetworkCni = req.Config.Kubernetes.NetworkCni
        mcisName := clusterName

        // Namespace 존재여부 확인
        ns := tumblebug.NewNS(namespace)
        exists, err := ns.GET()
        if err != nil </span><span class="cov0" title="0">{
                return cluster, err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return cluster, errors.New(fmt.Sprintf("namespace does not exist (name=%s)", namespace))
        }</span>

        // MCIS 존재여부 확인
        <span class="cov8" title="1">mcis := tumblebug.NewMCIS(namespace, mcisName)
        exists, err = mcis.GET()
        if err != nil </span><span class="cov0" title="0">{
                return cluster, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                return cluster, errors.New("MCIS already exists")
        }</span>

        <span class="cov8" title="1">var nodeConfigInfos []NodeConfigInfo
        // control plane
        cp, err := SetNodeConfigInfos(req.ControlPlane, config.CONTROL_PLANE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nodeConfigInfos = append(nodeConfigInfos, cp...)

        // worker
        wk, err := SetNodeConfigInfos(req.Worker, config.WORKER)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nodeConfigInfos = append(nodeConfigInfos, wk...)

        cIdx := 0
        wIdx := 0
        var nodes []model.Node
        var vmInfos []model.VMInfo

        for _, nodeConfigInfo := range nodeConfigInfos </span><span class="cov8" title="1">{
                // MCIR - 존재하면 재활용 없다면 생성 기준
                // 1. create vpc
                vpc, err := nodeConfigInfo.CreateVPC(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 2. create firewall
                <span class="cov8" title="1">fw, err := nodeConfigInfo.CreateFirewall(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 3. create sshKey
                <span class="cov8" title="1">sshKey, err := nodeConfigInfo.CreateSshKey(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 4. create image
                <span class="cov8" title="1">image, err := nodeConfigInfo.CreateImage(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 5. create spec
                <span class="cov8" title="1">spec, err := nodeConfigInfo.CreateSpec(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 6. vm
                <span class="cov8" title="1">for i := 0; i &lt; nodeConfigInfo.Count; i++ </span><span class="cov8" title="1">{
                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov8" title="1">{
                                cIdx++
                        }</span> else<span class="cov8" title="1"> {
                                wIdx++
                        }</span>

                        <span class="cov8" title="1">vm := model.VM{
                                Config:       nodeConfigInfo.Connection,
                                VPC:          vpc.Name,
                                Subnet:       vpc.Subnets[0].Name,
                                Firewall:     []string{fw.Name},
                                SSHKey:       sshKey.Name,
                                Image:        image.Name,
                                Spec:         spec.Name,
                                UserAccount:  nodeConfigInfo.Account,
                                UserPassword: "",
                                Description:  "",
                        }

                        vmInfo := model.VMInfo{
                                Credential: sshKey.PrivateKey,
                                Role:       nodeConfigInfo.Role,
                                Csp:        nodeConfigInfo.Csp,
                        }

                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov8" title="1">{
                                vm.Name = lang.GetNodeName(clusterName, config.CONTROL_PLANE, cIdx)
                                if cIdx == 1 </span><span class="cov8" title="1">{
                                        vmInfo.IsCPLeader = true
                                        cluster.CpLeader = vm.Name
                                }</span>
                        } else<span class="cov8" title="1"> {
                                vm.Name = lang.GetNodeName(clusterName, config.WORKER, wIdx)
                        }</span>
                        <span class="cov8" title="1">vmInfo.Name = vm.Name

                        mcis.VMs = append(mcis.VMs, vm)
                        vmInfos = append(vmInfos, vmInfo)</span>
                }
        }

        // MCIS 생성
        <span class="cov8" title="1">logger.Infof("start create MCIS (name=%s)", mcisName)
        if err = mcis.POST(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.Infof("create MCIS OK.. (name=%s)", mcisName)

        cpMcis := tumblebug.MCIS{}
        // 결과값 저장
        cluster.MCIS = mcisName
        for _, vm := range mcis.VMs </span><span class="cov8" title="1">{
                for _, vmInfo := range vmInfos </span><span class="cov8" title="1">{
                        if vm.Name == vmInfo.Name </span><span class="cov8" title="1">{
                                vm.Credential = vmInfo.Credential
                                vm.Role = vmInfo.Role
                                vm.Csp = vmInfo.Csp
                                vm.IsCPLeader = vmInfo.IsCPLeader

                                cpMcis.VMs = append(cpMcis.VMs, vm)
                                break</span>
                        }
                }

                <span class="cov8" title="1">node := model.NewNodeVM(namespace, cluster.Name, vm)
                node.UId = lang.GetUid()

                // insert node in store
                nodes = append(nodes, *node)
                err := node.Insert()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">err = cluster.Insert()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        c := make(chan error)
        wg.Add(len(cpMcis.VMs))

        // bootstrap
        logger.Infoln("start k8s bootstrap")

        time.Sleep(2 * time.Second)

        err = cluster.Update()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, vm := range cpMcis.VMs </span><span class="cov8" title="1">{
                go func(vm model.VM) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        sshInfo := ssh.SSHInfo{
                                UserName:   GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }
                        err = vm.ConnectionTest(&amp;sshInfo)
                        // retry
                        if err != nil </span><span class="cov0" title="0">{
                                vm.ConnectionTest(&amp;sshInfo)
                        }</span>

                        <span class="cov8" title="1">err := vm.CopyScripts(&amp;sshInfo, cluster.NetworkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                c &lt;- err
                        }</span>

                        <span class="cov8" title="1">err = vm.SetSystemd(&amp;sshInfo, cluster.NetworkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                c &lt;- err
                        }</span>

                        <span class="cov8" title="1">err = vm.Bootstrap(&amp;sshInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                c &lt;- err
                        }</span>
                }(vm)
        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(c)
                logger.Infoln("end k8s bootstrap")
        }</span>()

        <span class="cov8" title="1">for err := range c </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // init &amp; join
        <span class="cov8" title="1">var joinCmd []string
        IPs := GetControlPlaneIPs(cpMcis.VMs)

        logger.Infoln("start k8s init")
        for _, vm := range cpMcis.VMs </span><span class="cov8" title="1">{
                if vm.Role == config.CONTROL_PLANE &amp;&amp; vm.IsCPLeader </span><span class="cov8" title="1">{
                        sshInfo := ssh.SSHInfo{
                                UserName:   GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }

                        logger.Infof("install HAProxy (vm=%s)", vm.Name)
                        err := vm.InstallHAProxy(&amp;sshInfo, IPs)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">logger.Infoln("control plane init")
                        var clusterConfig string
                        joinCmd, clusterConfig, err = vm.ControlPlaneInit(&amp;sshInfo, req.Config.Kubernetes)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">cluster.ClusterConfig = clusterConfig

                        logger.Infoln("install networkCNI")
                        err = vm.InstallNetworkCNI(&amp;sshInfo, req.Config.Kubernetes.NetworkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>
                }
        }
        <span class="cov8" title="1">logger.Infoln("end k8s init")

        logger.Infoln("start k8s join")
        for _, vm := range cpMcis.VMs </span><span class="cov8" title="1">{
                if vm.Role == config.CONTROL_PLANE &amp;&amp; !vm.IsCPLeader </span><span class="cov0" title="0">{
                        sshInfo := ssh.SSHInfo{
                                UserName:   GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }
                        logger.Infof("control plane join (vm=%s)", vm.Name)
                        err := vm.ControlPlaneJoin(&amp;sshInfo, &amp;joinCmd[0])
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, vm := range cpMcis.VMs </span><span class="cov8" title="1">{
                if vm.Role == config.WORKER </span><span class="cov8" title="1">{
                        sshInfo := ssh.SSHInfo{
                                UserName:   GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }
                        logger.Infof("worker join (vm=%s)", vm.Name)
                        err := vm.WorkerJoin(&amp;sshInfo, &amp;joinCmd[1])
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>
                }
        }
        <span class="cov8" title="1">logger.Infoln("end k8s join")

        cluster.Complete()
        cluster.Nodes = nodes

        return cluster, nil</span>
}

func DeleteCluster(namespace string, clusterName string) (*model.Status, error) <span class="cov8" title="1">{
        mcisName := clusterName

        status := model.NewStatus()
        status.Code = model.STATUS_UNKNOWN

        logger.Infof("start delete Cluster (name=%s)", mcisName)
        mcis := tumblebug.NewMCIS(namespace, mcisName)
        cluster := model.NewCluster(namespace, clusterName)
        exist, err := mcis.GET()
        if err != nil </span><span class="cov0" title="0">{
                return status, err
        }</span>
        <span class="cov8" title="1">if exist </span><span class="cov8" title="1">{
                logger.Infof("terminate MCIS (name=%s)", mcisName)
                if err = mcis.TERMINATE(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("terminate mcis error : %v", err)
                        return status, err
                }</span>
                <span class="cov8" title="1">time.Sleep(5 * time.Second)

                logger.Infof("delete MCIS (name=%s)", mcisName)
                if err = mcis.DELETE(); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "Deletion is not allowed") </span><span class="cov0" title="0">{
                                logger.Infof("refine mcis (name=%s)", mcisName)
                                if err = mcis.REFINE(); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("refine MCIS error : %v", err)
                                        return status, err
                                }</span>
                                <span class="cov0" title="0">logger.Infof("delete MCIS (name=%s)", mcisName)
                                if err = mcis.DELETE(); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("delete MCIS error : %v", err)
                                        return status, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                logger.Errorf("delete MCIS error : %v", err)
                                return status, err
                        }</span>
                }

                <span class="cov8" title="1">logger.Infof("delete MCIS OK.. (name=%s)", mcisName)
                status.Message = fmt.Sprintf("cluster %s has been deleted", mcisName)

                if err := cluster.Delete(); err != nil </span><span class="cov0" title="0">{
                        status.Message = fmt.Sprintf("cluster %s has been deleted but cannot delete from the store", mcisName)
                        return status, nil
                }</span>
        } else<span class="cov8" title="1"> {
                logger.Infof("delete Cluster skip (MCIS cannot find).. (name=%s)", mcisName)
                status.Message = fmt.Sprintf("cluster %s not found", mcisName)

                if err := cluster.Delete(); err != nil </span><span class="cov0" title="0">{
                        status.Message = fmt.Sprintf("cluster %s not found and cannot delete from the store", mcisName)
                        return status, nil
                }</span>
        }

        <span class="cov8" title="1">status.Code = model.STATUS_SUCCESS
        return status, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "errors"
        "fmt"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model/spider"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
)

type NodeConfigInfo struct {
        model.NodeConfig
        Csp     config.CSP `json:"csp"`
        Role    string     `json:"role"`
        Region  string     `json:"region"`
        Account string     `json:"account"`
}

func SetNodeConfigInfos(nodeConfigs []model.NodeConfig, role string) ([]NodeConfigInfo, error) <span class="cov8" title="1">{
        var nodeConfigInfos []NodeConfigInfo

        for _, nodeConfig := range nodeConfigs </span><span class="cov8" title="1">{
                conn := spider.NewConnection(nodeConfig.Connection)
                exists, err := conn.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s Connection connect error (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s Connection does not exist (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">csp, err := GetCSPName(conn.ProviderName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">region := spider.NewRegion(conn.RegionName)
                exists, err = region.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s get region error (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s region does not exist (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">regionName := GetRegionName(region.KeyValueInfoList)

                var nodeConfigInfo NodeConfigInfo
                nodeConfigInfo.Connection = nodeConfig.Connection
                nodeConfigInfo.Count = nodeConfig.Count
                nodeConfigInfo.Spec = nodeConfig.Spec
                nodeConfigInfo.Csp = csp
                nodeConfigInfo.Role = role
                nodeConfigInfo.Region = regionName
                nodeConfigInfo.Account = GetUserAccount(nodeConfigInfo.Csp)

                nodeConfigInfos = append(nodeConfigInfos, nodeConfigInfo)</span>
        }

        <span class="cov8" title="1">return nodeConfigInfos, nil</span>
}

func GetControlPlaneIPs(VMs []model.VM) []string <span class="cov8" title="1">{
        var IPs []string
        for _, vm := range VMs </span><span class="cov8" title="1">{
                if vm.Role == config.CONTROL_PLANE </span><span class="cov8" title="1">{
                        IPs = append(IPs, vm.PrivateIP)
                }</span>
        }
        <span class="cov8" title="1">return IPs</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "errors"
        "fmt"
        "strings"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model/spider"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        logger "github.com/sirupsen/logrus"
)

const (
        GCP_IMAGE_ID   = "https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/ubuntu-1804-bionic-v20201014"
        AZURE_IMAGE_ID = "Canonical:UbuntuServer:18.04-LTS:latest"
)

// region별 AMI :  (AMI 이름 : ubuntu/images/hvm-ssd/ubuntu-bionic-18.04-amd64-server-20200908, 소유자:099720109477 )
var imageMap = map[string]string{
        "us-east-1":      "ami-0817d428a6fb68645", //미국 동부 (버지니아 북부)
        "us-east-2":      "ami-0e82959d4ed12de3f", //미국 동부 (오하이오)
        "us-west-1":      "ami-03fac5402e10ea93b", //미국서부 (캘리포니아)
        "us-west-2":      "ami-07a29e5e945228fa1", //미국서부 (오래곤)
        "af-south-1":     "",                      //아프리카 (케이프타운)
        "ap-east-1":      "",                      //아시아 태평양 (홍콩)
        "ap-south-1":     "ami-03f0fd1a2ba530e75", //아시아 태평양 (뭄바이)
        "ap-northeast-2": "ami-064ab8637cf33f1bb", //아시아 태평양 (서울)
        "ap-southeast-1": "ami-0c8e97a27be37adfd", //아시아 태평양 (싱가포르)
        "ap-southeast-2": "ami-099c1869f33464fde", //아시아 태평양 (시드니)
        "ap-northeast-1": "ami-02b658ac34935766f", //아시아 태평양 (도쿄)
        "ca-central-1":   "ami-0c27a26eca5dc74fc", //캐나다 (중부)
        "eu-central-1":   "ami-092391a11f8aa4b7b", //유럽 (프랑크푸르트)
        "eu-west-1":      "ami-0823c236601fef765", //유럽 (아일랜드)
        "eu-west-2":      "ami-09a1e275e350acf38", //유럽 (런던)
        "eu-south-1":     "",                      //유럽 (밀라노)
        "eu-west-3":      "ami-014d8dccd70fd2632", //유럽 (파리)
        "eu-north-1":     "ami-0ede7f804d699ea83", //유럽 (스톡홀름)
        "me-south-1":     "",                      //중동 (바레인)
        "sa-east-1":      "ami-0fd2c3d373788b726", //남아메리카 (상파울루)
}

// get vm user account
func GetUserAccount(csp config.CSP) string <span class="cov8" title="1">{
        return "cb-user"
}</span>

// get vm image-id
func GetVmImageId(csp config.CSP, configName string) (string, error) <span class="cov0" title="0">{

        if csp == config.CSP_GCP </span><span class="cov0" title="0">{
                return GCP_IMAGE_ID, nil
        }</span> else<span class="cov0" title="0"> if csp == config.CSP_AZURE </span><span class="cov0" title="0">{
                return AZURE_IMAGE_ID, nil
        }</span> else<span class="cov0" title="0"> if csp == config.CSP_AWS </span><span class="cov0" title="0">{
                // AWS : 리전별 AMI 가져오기
                conn := spider.NewConnection(configName)
                exists, err := conn.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS (cause = not found connection config `%s`)", configName))
                }</span>

                // http get region data
                <span class="cov0" title="0">region := spider.NewRegion(conn.RegionName)
                exists, err = region.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS (cause = not found region, connection='%s', region name='%s')", configName, conn.RegionName))
                }</span>

                // find region
                <span class="cov0" title="0">regionName := ""
                for i := 0; i &lt; len(region.KeyValueInfoList); i++ </span><span class="cov0" title="0">{
                        if region.KeyValueInfoList[i].Key == "Region" </span><span class="cov0" title="0">{
                                regionName = region.KeyValueInfoList[i].Value //get region name
                                break</span>
                        }
                }
                <span class="cov0" title="0">if regionName == "" </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS (cause = region name is empty, connection='%s', region name='%s')", configName, conn.RegionName))
                }</span>

                // TODO [update/hard-coding] region별 image id
                <span class="cov0" title="0">imageId := imageMap[regionName]
                if imageId == "" </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS image map (connection='%s', region='%s')", configName, regionName))
                }</span>

                <span class="cov0" title="0">logger.Infof("AMI find OK (ami='%s', region='%s')", imageId, regionName)
                return imageId, nil</span>

        } else<span class="cov0" title="0"> {
                return "", errors.New(fmt.Sprintf("CSP '%s' is not supported (Not found \"vm-machine-image\")", csp))
        }</span>

}

// get CSP Name
func GetCSPName(providerName string) (config.CSP, error) <span class="cov0" title="0">{
        switch strings.ToLower(providerName) </span>{
        case "aws":<span class="cov0" title="0">
                return config.CSP_AWS, nil</span>
        case "gcp":<span class="cov0" title="0">
                return config.CSP_GCP, nil</span>
        case "azure":<span class="cov0" title="0">
                return config.CSP_AZURE, nil</span>
        }
        <span class="cov0" title="0">return "", errors.New(providerName + "is not supported")</span>
}

// get Region Name
func GetRegionName(infoList []spider.KeyValue) string <span class="cov8" title="1">{
        regionName := ""
        for i := 0; i &lt; len(infoList); i++ </span><span class="cov8" title="1">{
                if infoList[i].Key == "Region" || infoList[i].Key == "location" </span><span class="cov8" title="1">{
                        regionName = infoList[i].Value //get region name
                        break</span>
                }
        }
        <span class="cov8" title="1">return regionName</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "fmt"
        "strings"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug"
        logger "github.com/sirupsen/logrus"
)

func (nodeConfigInfo *NodeConfigInfo) CreateVPC(namespace string) (*tumblebug.VPC, error) <span class="cov8" title="1">{
        vpcName := fmt.Sprintf("%s-vpc", getConfigName(nodeConfigInfo.Connection))
        logger.Infof("start create vpc (name=%s)", vpcName)
        vpc := tumblebug.NewVPC(namespace, vpcName, nodeConfigInfo.Connection)
        exists, e := vpc.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse vpc (name=%s, cause='already exists')", vpcName)
        }</span> else<span class="cov8" title="1"> {
                if e = vpc.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create vpc OK.. (name=%s)", vpcName)</span>
        }
        <span class="cov8" title="1">return vpc, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateFirewall(namespace string) (*tumblebug.Firewall, error) <span class="cov8" title="1">{
        firewallName := fmt.Sprintf("%s-sg", getConfigName(nodeConfigInfo.Connection))
        vpcName := fmt.Sprintf("%s-vpc", getConfigName(nodeConfigInfo.Connection))
        logger.Infof("start create firewall (name=%s)", firewallName)
        fw := tumblebug.NewFirewall(namespace, firewallName, nodeConfigInfo.Connection)
        fw.VPCId = vpcName
        exists, e := fw.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse firewall (name=%s, cause='already exists')", firewallName)
        }</span> else<span class="cov8" title="1"> {
                if e = fw.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create firewall OK.. (name=%s)", firewallName)</span>
        }
        <span class="cov8" title="1">return fw, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateSshKey(namespace string) (*tumblebug.SSHKey, error) <span class="cov8" title="1">{
        sshkeyName := fmt.Sprintf("%s-sshkey", getConfigName(nodeConfigInfo.Connection))
        logger.Infof("start create ssh key (name=%s)", sshkeyName)
        sshKey := tumblebug.NewSSHKey(namespace, sshkeyName, nodeConfigInfo.Connection)
        sshKey.Username = nodeConfigInfo.Account
        exists, e := sshKey.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse ssh key (name=%s, cause='already exists')", sshkeyName)
        }</span> else<span class="cov8" title="1"> {
                if e = sshKey.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create ssh key OK.. (name=%s)", sshkeyName)</span>
        }
        <span class="cov8" title="1">return sshKey, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateImage(namespace string) (*tumblebug.Image, error) <span class="cov8" title="1">{
        imageId, e := GetVmImageId(nodeConfigInfo.Csp, nodeConfigInfo.Connection)
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>

        <span class="cov8" title="1">imageName := fmt.Sprintf("%s-ubuntu1804", getConfigName(nodeConfigInfo.Connection))
        logger.Infof("start create image (name=%s)", imageName)
        image := tumblebug.NewImage(namespace, imageName, nodeConfigInfo.Connection)
        image.CspImageId = imageId
        exists, e := image.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse image (name=%s, cause='already exists')", imageName)
        }</span> else<span class="cov8" title="1"> {
                if e = image.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create image OK.. (name=%s)", imageName)</span>
        }
        <span class="cov8" title="1">return image, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateSpec(namespace string) (*tumblebug.Spec, error) <span class="cov8" title="1">{
        specName := fmt.Sprintf("%s-%s-spec", getConfigName(nodeConfigInfo.Connection), getSpecName(nodeConfigInfo.Spec))
        logger.Infof("start create spec (name=%s)", specName)
        spec := tumblebug.NewSpec(namespace, specName, nodeConfigInfo.Connection)
        spec.CspSpecName = nodeConfigInfo.Spec
        exists, e := spec.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse spec (name=%s, cause='already exists')", specName)
        }</span> else<span class="cov8" title="1"> {
                if e = spec.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create spec OK.. (name=%s)", specName)</span>
        }
        <span class="cov8" title="1">return spec, nil</span>
}

func getConfigName(name string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(name, "config-", "")
}</span>

func getSpecName(name string) string <span class="cov8" title="1">{
        specName := strings.ReplaceAll(name, ".", "-")
        specName = strings.ReplaceAll(specName, "_", "-")
        specName = strings.ReplaceAll(specName, " ", "-")
        specName = strings.ToLower(specName)
        return specName
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/common"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model/tumblebug"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang"

        ssh "github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"
        logger "github.com/sirupsen/logrus"
)

func ListNode(namespace string, clusterName string) (*model.NodeList, error) <span class="cov8" title="1">{
        nodes := model.NewNodeList(namespace, clusterName)
        err := nodes.SelectList()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return nodes, nil</span>
}

func GetNode(namespace string, clusterName string, nodeName string) (*model.Node, error) <span class="cov8" title="1">{
        node := model.NewNode(namespace, clusterName, nodeName)
        err := node.Select()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return node, nil</span>
}

func AddNode(namespace string, clusterName string, req *model.NodeReq) (*model.NodeList, error) <span class="cov8" title="1">{

        mcisName := clusterName
        mcis := tumblebug.NewMCIS(namespace, mcisName)

        exists, err := mcis.GET()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("MCIS not found")
        }</span>

        // get join command
        <span class="cov8" title="1">workerJoinCmd, err := getWorkerJoinCmdForAddNode(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("join command cannot get")
        }</span>
        <span class="cov8" title="1">networkCni := getClusterNetworkCNI(namespace, clusterName)

        var nodeConfigInfos []NodeConfigInfo
        // worker
        wk, err := SetNodeConfigInfos(req.Worker, config.WORKER)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nodeConfigInfos = append(nodeConfigInfos, wk...)

        cIdx := 0
        wIdx := 0
        maxCIdx, maxWIdx := getMaxIdx(namespace, clusterName)
        var TVMs []tumblebug.TVM

        for _, nodeConfigInfo := range nodeConfigInfos </span><span class="cov8" title="1">{
                // MCIR - 존재하면 재활용 없다면 생성 기준
                // 1. create vpc
                vpc, err := nodeConfigInfo.CreateVPC(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 2. create firewall
                <span class="cov8" title="1">fw, err := nodeConfigInfo.CreateFirewall(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 3. create sshKey
                <span class="cov8" title="1">sshKey, err := nodeConfigInfo.CreateSshKey(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 4. create image
                <span class="cov8" title="1">image, err := nodeConfigInfo.CreateImage(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 5. create spec
                <span class="cov8" title="1">spec, err := nodeConfigInfo.CreateSpec(namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 6. vm
                <span class="cov8" title="1">for i := 0; i &lt; nodeConfigInfo.Count; i++ </span><span class="cov8" title="1">{
                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov0" title="0">{
                                cIdx++
                        }</span> else<span class="cov8" title="1"> {
                                wIdx++
                        }</span>
                        <span class="cov8" title="1">tvm := tumblebug.NewTVm(namespace, mcisName)
                        tvm.VM = model.VM{
                                Config:       nodeConfigInfo.Connection,
                                VPC:          vpc.Name,
                                Subnet:       vpc.Subnets[0].Name,
                                Firewall:     []string{fw.Name},
                                SSHKey:       sshKey.Name,
                                Image:        image.Name,
                                Spec:         spec.Name,
                                UserAccount:  nodeConfigInfo.Account,
                                UserPassword: "",
                                Description:  "",
                                Credential:   sshKey.PrivateKey,
                                Role:         nodeConfigInfo.Role,
                                Csp:          nodeConfigInfo.Csp,
                        }

                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov0" title="0">{
                                tvm.VM.Name = lang.GetNodeName(clusterName, config.CONTROL_PLANE, maxCIdx+cIdx)
                        }</span> else<span class="cov8" title="1"> {
                                tvm.VM.Name = lang.GetNodeName(clusterName, config.WORKER, maxWIdx+wIdx)
                        }</span>

                        // vm 생성
                        <span class="cov8" title="1">logger.Infof("start create VM (mcisname=%s, nodename=%s)", mcisName, tvm.VM.Name)
                        err := tvm.POST()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("create VM error (mcisname=%s, nodename=%s)", mcisName, tvm.VM.Name)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">logger.Infof("create VM OK.. (mcisname=%s, nodename=%s)", mcisName, tvm.VM.Name)

                        TVMs = append(TVMs, *tvm)</span>
                }
        }

        <span class="cov8" title="1">var wg sync.WaitGroup
        c := make(chan error)
        wg.Add(len(TVMs))

        logger.Infoln("start connect VMs")
        for _, tvm := range TVMs </span><span class="cov8" title="1">{
                go func(vm model.VM) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        sshInfo := ssh.SSHInfo{
                                UserName:   GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }

                        _ = vm.ConnectionTest(&amp;sshInfo)
                        err := vm.CopyScripts(&amp;sshInfo, networkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>

                        <span class="cov8" title="1">logger.Infof("set systemd service (vm=%s)", vm.Name)
                        err = vm.SetSystemd(&amp;sshInfo, networkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>

                        <span class="cov8" title="1">logger.Infof("bootstrap (vm=%s)", vm.Name)
                        err = vm.Bootstrap(&amp;sshInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>

                        <span class="cov8" title="1">logger.Infof("join (vm=%s)", vm.Name)
                        err = vm.WorkerJoin(&amp;sshInfo, &amp;workerJoinCmd)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>
                }(tvm.VM)
        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(c)
                logger.Infoln("end connect VMs")
        }</span>()

        <span class="cov8" title="1">for err := range c </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("worker join error (cause=%v)", err)
                        return nil, err
                }</span>
        }

        // insert store
        <span class="cov8" title="1">nodes := model.NewNodeList(namespace, clusterName)
        for _, vm := range TVMs </span><span class="cov8" title="1">{
                node := model.NewNodeVM(namespace, clusterName, vm.VM)
                node.UId = lang.GetUid()
                err := node.Insert()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">nodes.Items = append(nodes.Items, *node)</span>
        }

        <span class="cov8" title="1">return nodes, nil</span>
}

func RemoveNode(namespace string, clusterName string, nodeName string) (*model.Status, error) <span class="cov8" title="1">{
        status := model.NewStatus()
        status.Code = model.STATUS_UNKNOWN

        cpNode, err := getCPLeaderNode(namespace, clusterName)
        if err != nil </span><span class="cov8" title="1">{
                status.Message = "control-plane node not found"
                return status, err
        }</span>

        <span class="cov8" title="1">hostName, err := getHostName(namespace, clusterName, nodeName)
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "get node name error"
                return status, err
        }</span>

        // drain node
        <span class="cov8" title="1">userAccount := GetUserAccount(cpNode.Csp)
        sshInfo := ssh.SSHInfo{
                UserName:   userAccount,
                PrivateKey: []byte(cpNode.Credential),
                ServerPort: fmt.Sprintf("%s:22", cpNode.PublicIP),
        }
        cmd := fmt.Sprintf("sudo kubectl drain %s --kubeconfig=/etc/kubernetes/admin.conf --ignore-daemonsets --force --delete-local-data", hostName)
        result, err := ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "kubectl drain failed"
                return status, err
        }</span>
        <span class="cov8" title="1">if strings.Contains(result, fmt.Sprintf("node/%s drained", hostName)) || strings.Contains(result, fmt.Sprintf("node/%s evicted", hostName)) </span><span class="cov8" title="1">{
                logger.Infoln("drain node success")
        }</span> else<span class="cov0" title="0"> {
                status.Message = "kubectl drain failed"
                return status, err
        }</span>

        // delete node
        <span class="cov8" title="1">cmd = fmt.Sprintf("sudo kubectl delete node %s --kubeconfig=/etc/kubernetes/admin.conf", hostName)
        result, err = ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "kubectl delete node failed"
                return status, err
        }</span>
        <span class="cov8" title="1">if strings.Contains(result, "deleted") </span><span class="cov8" title="1">{
                logger.Infoln("delete node success")
        }</span> else<span class="cov0" title="0"> {
                status.Message = "kubectl delete node failed"
                return status, errors.New("kubectl delete node failed")
        }</span>

        // delete vm
        <span class="cov8" title="1">vm := tumblebug.NewTVm(namespace, clusterName)
        vm.VM.Name = nodeName
        err = vm.DELETE()
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "delete vm failed"
                return status, err
        }</span>

        // delete node in store
        <span class="cov8" title="1">node := model.NewNode(namespace, clusterName, nodeName)
        if err := node.Delete(); err != nil </span><span class="cov0" title="0">{
                status.Message = err.Error()
                return status, nil
        }</span>

        <span class="cov8" title="1">status.Code = model.STATUS_SUCCESS
        status.Message = "success"

        return status, nil</span>
}

func getCluster(namespace string, clusterName string) (*model.Cluster, error) <span class="cov8" title="1">{
        key := lang.GetStoreClusterKey(namespace, clusterName)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValue == nil </span><span class="cov8" title="1">{
                return nil, errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov8" title="1">cluster := &amp;model.Cluster{}
        json.Unmarshal([]byte(keyValue.Value), cluster)

        return cluster, nil</span>
}

func getCPLeaderNode(namespace string, clusterName string) (*model.Node, error) <span class="cov8" title="1">{
        cluster, err := getCluster(namespace, clusterName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("cluster info not found")
        }</span>
        <span class="cov8" title="1">CpLeader := cluster.CpLeader

        key := lang.GetStoreNodeKey(namespace, clusterName, "")
        keyValues, err := common.CBStore.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if keyValues == nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov8" title="1">cpNode := &amp;model.Node{}
        for _, keyValue := range keyValues </span><span class="cov8" title="1">{
                node := &amp;model.Node{}
                json.Unmarshal([]byte(keyValue.Value), &amp;node)
                if node.Name == CpLeader </span><span class="cov8" title="1">{
                        cpNode = node
                        break</span>
                }
        }

        <span class="cov8" title="1">return cpNode, nil</span>
}

func getClusterNetworkCNI(namespace string, clusterName string) string <span class="cov8" title="1">{
        cluster, err := getCluster(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return cluster.NetworkCni</span>
}

func getHostName(namespace string, clusterName string, nodeName string) (string, error) <span class="cov8" title="1">{
        key := lang.GetStoreNodeKey(namespace, clusterName, "")
        keyValues, err := common.CBStore.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if keyValues == nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov8" title="1">dNode := &amp;model.Node{}
        for _, keyValue := range keyValues </span><span class="cov8" title="1">{
                node := &amp;model.Node{}
                json.Unmarshal([]byte(keyValue.Value), &amp;node)
                if node.Name == nodeName </span><span class="cov8" title="1">{
                        dNode = node
                        break</span>
                }
        }

        <span class="cov8" title="1">userAccount := GetUserAccount(dNode.Csp)
        sshInfo := ssh.SSHInfo{
                UserName:   userAccount,
                PrivateKey: []byte(dNode.Credential),
                ServerPort: fmt.Sprintf("%s:22", dNode.PublicIP),
        }
        cmd := "/bin/hostname"
        hostName, err := ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hostName, nil</span>
}

func getWorkerJoinCmdForAddNode(namespace string, clusterName string) (string, error) <span class="cov8" title="1">{
        cpNode, err := getCPLeaderNode(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("control-plane node not found")
        }</span>
        <span class="cov8" title="1">userAccount := GetUserAccount(cpNode.Csp)
        sshInfo := ssh.SSHInfo{
                UserName:   userAccount,
                PrivateKey: []byte(cpNode.Credential),
                ServerPort: fmt.Sprintf("%s:22", cpNode.PublicIP),
        }
        cmd := "sudo kubeadm token create --print-join-command"
        result, err := ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func getMaxIdx(namespace string, clusterName string) (maxCpIdx int, maxWkIdx int) <span class="cov8" title="1">{
        maxCpIdx = 0
        maxWkIdx = 0

        nodes := model.NewNodeList(namespace, clusterName)
        err := nodes.SelectList()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var arrCp, arrWk []int
        for _, node := range nodes.Items </span><span class="cov8" title="1">{
                slice := strings.Split(node.Name, "-")
                role := len(slice) - 3
                idx := len(slice) - 2

                if slice[role] == "c" </span><span class="cov8" title="1">{
                        arrCp = append(arrCp, lang.GetIdxToInt(slice[idx]))
                }</span> else<span class="cov8" title="1"> if slice[role] == "w" </span><span class="cov8" title="1">{
                        arrWk = append(arrWk, lang.GetIdxToInt(slice[idx]))
                }</span>
        }
        <span class="cov8" title="1">fmt.Println(maxCpIdx, maxWkIdx)
        maxCpIdx = lang.GetMaxNumber(arrCp)
        maxWkIdx = lang.GetMaxNumber(arrWk)
        return</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewClusterCmd - Cluster 관리 기능을 수행하는 Cobra Command 생성
func NewClusterCmd() *cobra.Command <span class="cov8" title="1">{

        clusterCmd := &amp;cobra.Command{
                Use:   "cluster",
                Short: "This is a manageable command for cluster",
                Long:  "This is a manageable command for cluster",
        }

        //  Adds the commands for application.
        clusterCmd.AddCommand(NewClusterCreateCmd())
        clusterCmd.AddCommand(NewClusterListCmd())
        clusterCmd.AddCommand(NewClusterGetCmd())
        clusterCmd.AddCommand(NewClusterDeleteCmd())

        return clusterCmd
}</span>

// NewClusterCreateCmd - Cluster 생성 기능을 수행하는 Cobra Command 생성
func NewClusterCreateCmd() *cobra.Command <span class="cov8" title="1">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for cluster",
                Long:  "This is create command for cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewClusterListCmd - Cluster 목록 기능을 수행하는 Cobra Command 생성
func NewClusterListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cluster",
                Long:  "This is list command for cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewClusterGetCmd - Cluster 조회 기능을 수행하는 Cobra Command 생성
func NewClusterGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for cluster",
                Long:  "This is get command for cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")

        return getCmd</span>
}

// NewClusterDeleteCmd - Cluster 삭제 기능을 수행하는 Cobra Command 생성
func NewClusterDeleteCmd() *cobra.Command <span class="cov8" title="1">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for cluster",
                Long:  "This is delete command for cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package cmd

import (
        "fmt"
        "io/ioutil"

        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
        lb_api "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/request"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

func readInDataFromFile() <span class="cov8" title="1">{
        logger := logger.NewLogger()
        if inData == "" </span><span class="cov0" title="0">{
                if inFile != "" </span><span class="cov0" title="0">{
                        dat, err := ioutil.ReadFile(inFile)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to read file : ", inFile)
                                return
                        }</span>
                        <span class="cov0" title="0">inData = string(dat)</span>
                }
        }
}

// ===== [ Public Functions ] =====

// SetupAndRun - Ladybug GRPC CLI 구동
func SetupAndRun(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        var (
                result string
                err    error

                mcar *lb_api.MCARApi = nil
        )

        // panic 처리
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("cbadm is stopped : ", r)
                }</span>
        }()

        <span class="cov8" title="1">if cmd.Parent().Name() == "cluster" || cmd.Parent().Name() == "node" || cmd.Name() == "healthy" </span><span class="cov8" title="1">{
                // LB API 설정
                mcar = lb_api.NewMCARManager()
                err = mcar.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov8" title="1">err = mcar.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("ladybug api open failed : ", err)
                        return
                }</span>
                <span class="cov8" title="1">defer mcar.Close()</span>
        }

        // 입력 파라미터 처리
        <span class="cov8" title="1">if outType != "json" &amp;&amp; outType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --output parameter : ", outType)
                return
        }</span>
        <span class="cov8" title="1">if inType != "json" &amp;&amp; inType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --input parameter : ", inType)
                return
        }</span>

        <span class="cov8" title="1">if cmd.Parent().Name() == "cluster" || cmd.Parent().Name() == "node" || cmd.Name() == "healthy" </span><span class="cov8" title="1">{
                mcar.SetInType(inType)
                mcar.SetOutType(outType)
        }</span>

        <span class="cov8" title="1">logger.Debug("--input parameter value : ", inType)
        logger.Debug("--output parameter value : ", outType)

        result = ""
        err = nil

        switch cmd.Parent().Name() </span>{
        case "cbadm":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "healthy":<span class="cov8" title="1">
                        result, err = mcar.Healthy()</span>
                }
        case "cluster":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "create":<span class="cov8" title="1">
                        result, err = mcar.CreateCluster(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcar.ListClusterByParam(nameSpaceID)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcar.GetClusterByParam(nameSpaceID, clusterName)</span>
                case "delete":<span class="cov8" title="1">
                        result, err = mcar.DeleteClusterByParam(nameSpaceID, clusterName)</span>
                }
        case "node":<span class="cov8" title="1">
                switch cmd.Name() </span>{
                case "add":<span class="cov8" title="1">
                        result, err = mcar.AddNode(inData)</span>
                case "list":<span class="cov8" title="1">
                        result, err = mcar.ListNodeByParam(nameSpaceID, clusterName)</span>
                case "get":<span class="cov8" title="1">
                        result, err = mcar.GetNodeByParam(nameSpaceID, clusterName, nodeName)</span>
                case "remove":<span class="cov8" title="1">
                        result, err = mcar.RemoveNodeByParam(nameSpaceID, clusterName, nodeName)</span>
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if outType == "yaml" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "message: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(cmd.OutOrStdout(), "{\"message\": \"%v\"}\n", err)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", result)
        }</span>

}
</pre>
		
		<pre class="file" id="file25" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewHealthyCmd - Ladybug 상태를 수행하는 Cobra Command 생성
func NewHealthyCmd() *cobra.Command <span class="cov8" title="1">{

        healthyCmd := &amp;cobra.Command{
                Use:   "healthy",
                Short: "This is a healthy command for checking ladybug",
                Long:  "This is a healthy command for checking ladybug",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov8" title="1">return healthyCmd</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewNodeCmd - Node 관리 기능을 수행하는 Cobra Command 생성
func NewNodeCmd() *cobra.Command <span class="cov8" title="1">{

        nodeCmd := &amp;cobra.Command{
                Use:   "node",
                Short: "This is a manageable command for node",
                Long:  "This is a manageable command for node",
        }

        //  Adds the commands for application.
        nodeCmd.AddCommand(NewNodeAddCmd())
        nodeCmd.AddCommand(NewNodeListCmd())
        nodeCmd.AddCommand(NewNodeGetCmd())
        nodeCmd.AddCommand(NewNodeRemoveCmd())

        return nodeCmd
}</span>

// NewNodeAddCmd - Node 생성 기능을 수행하는 Cobra Command 생성
func NewNodeAddCmd() *cobra.Command <span class="cov8" title="1">{

        addCmd := &amp;cobra.Command{
                Use:   "add",
                Short: "This is add command for node",
                Long:  "This is add command for node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">addCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        addCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return addCmd</span>
}

// NewNodeListCmd - Node 목록 기능을 수행하는 Cobra Command 생성
func NewNodeListCmd() *cobra.Command <span class="cov8" title="1">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for node",
                Long:  "This is list command for node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>

                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        listCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")

        return listCmd</span>
}

// NewNodeGetCmd - Node 조회 기능을 수행하는 Cobra Command 생성
func NewNodeGetCmd() *cobra.Command <span class="cov8" title="1">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for node",
                Long:  "This is get command for node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if nodeName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --node parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)
                        logger.Debug("--node parameter value : ", nodeName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")
        getCmd.PersistentFlags().StringVarP(&amp;nodeName, "node", "", "", "node name")

        return getCmd</span>
}

// NewNodeRemoveCmd - Node 삭제 기능을 수행하는 Cobra Command 생성
func NewNodeRemoveCmd() *cobra.Command <span class="cov8" title="1">{

        removeCmd := &amp;cobra.Command{
                Use:   "remove",
                Short: "This is remove command for node",
                Long:  "This is remove command for node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">if nodeName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --node parameter")
                                return
                        }</span>
                        <span class="cov8" title="1">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)
                        logger.Debug("--node parameter value : ", nodeName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov8" title="1">removeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        removeCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")
        removeCmd.PersistentFlags().StringVarP(&amp;nodeName, "node", "", "", "node name")

        return removeCmd</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package cmd - 어플리케이션 실행을 위한 Cobra 기반의 CLI Commands 기능 제공
package cmd

import (
        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/config"
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

const (
        // CLIVersion - cbadm cli 버전
        CLIVersion = "1.0"
)

var (
        configFile string
        inData     string
        inFile     string
        inType     string
        outType    string

        nameSpaceID string
        clusterName string
        nodeName    string

        parser config.Parser
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRootCmd - 어플리케이션 진입점으로 사용할 Root Cobra Command 생성
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{

        rootCmd := &amp;cobra.Command{
                Use:   "cbadm",
                Short: "cbadm is a lightweight grpc cli tool",
                Long:  "This is a lightweight grpc cli tool for Cloud-Barista",
        }

        // 옵션 플래그 설정
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "./grpc_conf.yaml", "config file")
        rootCmd.PersistentFlags().StringVarP(&amp;inType, "input", "i", "yaml", "input format (json/yaml)")
        rootCmd.PersistentFlags().StringVarP(&amp;outType, "output", "o", "yaml", "output format (json/yaml)")

        // Viper 를 사용하는 설정 파서 생성
        parser = config.MakeParser()

        //  Adds the commands for application.
        rootCmd.AddCommand(NewVersionCmd())

        rootCmd.AddCommand(NewHealthyCmd())
        rootCmd.AddCommand(NewClusterCmd())
        rootCmd.AddCommand(NewNodeCmd())

        return rootCmd
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVersionCmd - 버전 표시 기능을 수행하는 Cobra Command 생성
func NewVersionCmd() *cobra.Command <span class="cov8" title="1">{

        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "This is a version command for cbadm",
                Long:  "This is a version command for cbadm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("CBADM CLI VERSION %s\n", CLIVersion)
                }</span>,
        }

        <span class="cov8" title="1">return versionCmd</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package common

import (
        "errors"
        "io"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/jaegertracer"
        "github.com/opentracing/opentracing-go"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBConnection - CB-GRPC에서 사용하는 grpc 클라이언트를 위한 Wrapper 구조
type CBConnection struct {
        Conn *grpc.ClientConn
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBConnection - 초기화된 grpc 클라이언트의 인스턴스 생성
func NewCBConnection(gConf *config.GrpcClientConfig) (*CBConnection, io.Closer, error) <span class="cov0" title="0">{

        var (
                tracer opentracing.Tracer = nil
                closer io.Closer          = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc connection config is null")
        }</span>

        <span class="cov0" title="0">if gConf.ServerAddr == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("server addr is empty")
        }</span>

        <span class="cov0" title="0">opts := []grpc.DialOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewClientTLSFromFile(gConf.TLS.TLSCA, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov0" title="0"> {
                opts = append(opts, grpc.WithInsecure())
        }</span>

        // 인터셉터 설정
        <span class="cov0" title="0">unaryIntercepters := []grpc.UnaryClientInterceptor{}
        streamIntercepters := []grpc.StreamClientInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryClientInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamClientInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                        tracingOpts := []grpc_opentracing.Option{}
                        tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                        unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryClientInterceptor(tracingOpts...))
                        streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamClientInterceptor(tracingOpts...))
                }</span>

        }

        <span class="cov0" title="0">opts = append(opts, grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(unaryIntercepters...)))
        opts = append(opts, grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(streamIntercepters...)))
        conn, err := grpc.Dial(gConf.ServerAddr, opts...)

        return &amp;CBConnection{Conn: conn}, closer, err</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package common

import (
        "encoding/json"
        "strings"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"

        "gopkg.in/yaml.v2"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====s

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvertToMessage - 입력 데이터를 grpc 메시지로 변환
func ConvertToMessage(inType string, inData string, obj interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if inType == "yaml" </span><span class="cov8" title="1">{
                err := yaml.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">if inType == "json" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("json Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertToOutput - grpc 메시지를 출력포맷으로 변환
func ConvertToOutput(outType string, obj interface{}) (string, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if outType == "yaml" </span><span class="cov8" title="1">{
                // 메시지 포맷에서 불필요한 필드(XXX_로 시작하는 필드)를 제거하기 위해 json 태그를 이용하여 마샬링
                j, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // yaml 에서 지원하지 않는 control character 제거
                <span class="cov8" title="1">cleanStr := strings.Map(func(value rune) rune </span><span class="cov8" title="1">{
                        switch </span>{
                        case value == 0x09:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0A:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0D:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x20 &amp;&amp; value &lt;= 0x7E:<span class="cov8" title="1">
                                return value</span>
                        case value == 0x85:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xA0 &amp;&amp; value &lt;= 0xD7FF:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xE000 &amp;&amp; value &lt;= 0xFFFD:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x10000 &amp;&amp; value &lt;= 0x10FFFF:<span class="cov0" title="0">
                                return value</span>
                        default:<span class="cov0" title="0">
                                return -1</span> // control characters are not allowed
                        }
                }, string(j))

                // 필드를 소팅하지 않고 지정된 순서대로 출력하기 위해 MapSlice 이용
                <span class="cov8" title="1">jsonObj := yaml.MapSlice{}
                err2 := yaml.Unmarshal([]byte(cleanStr), &amp;jsonObj)
                if err2 != nil </span><span class="cov0" title="0">{
                        return "", err2
                }</span>

                // yaml 마샬링
                <span class="cov8" title="1">y, err3 := yaml.Marshal(jsonObj)
                if err3 != nil </span><span class="cov0" title="0">{
                        return "", err3
                }</span>
                <span class="cov8" title="1">logger.Debug("yaml Marshal: \n", string(y))

                return string(y), nil</span>
        }

        <span class="cov8" title="1">if outType == "json" </span><span class="cov8" title="1">{
                j, err := json.MarshalIndent(obj, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">outStr := string(j)

                // json.Marshal 함수는  &lt;,&gt;, &amp; 문자를 escape 함.. 다시 원래대로 변환
                outStr = strings.Replace(outStr, "\\u003c", "&lt;", -1)
                outStr = strings.Replace(outStr, "\\u003e", "&gt;", -1)
                outStr = strings.Replace(outStr, "\\u0026", "&amp;", -1)

                logger.Debug("json Marshal: \n", outStr)
                return outStr, nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// CopySrcToDest - 소스에서 타켓으로 데이터 복사
func CopySrcToDest(src interface{}, dest interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        j, err := json.MarshalIndent(src, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("source value : \n", string(j))

        err = json.Unmarshal(j, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">j, err = json.MarshalIndent(dest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("target value : \n", string(j))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package common

import (
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/jaegertracer"

        grpc_accesslog "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/accesslog"
        grpc_authjwt "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/interceptors/authjwt"
        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        opentracing "github.com/opentracing/opentracing-go"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBServer - CB-GRPC에서 사용하는 grpc 서버를 위한 Wrapper 구조
type CBServer struct {
        Server *grpc.Server
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBServer - 초기화된 grpc 서버의 인스턴스 생성
func NewCBServer(gConf *config.GrpcServerConfig) (*CBServer, io.Closer, error) <span class="cov8" title="1">{

        var (
                tracer      opentracing.Tracer             = nil
                closer      io.Closer                      = nil
                reg         *prometheus.Registry           = nil
                grpcMetrics *grpc_prometheus.ServerMetrics = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc server config is null")
        }</span>

        <span class="cov8" title="1">opts := []grpc.ServerOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(gConf.TLS.TLSCert, gConf.TLS.TLSKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        // 인터셉터 설정
        <span class="cov8" title="1">unaryIntercepters := []grpc.UnaryServerInterceptor{}
        streamIntercepters := []grpc.StreamServerInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamServerInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if gConf.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                                tracingOpts := []grpc_opentracing.Option{}
                                tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                                unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryServerInterceptor(tracingOpts...))
                                streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamServerInterceptor(tracingOpts...))
                        }</span>
                }

                // Prometheus Metrics 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{
                        grpcMetrics = grpc_prometheus.NewServerMetrics()
                        grpcMetrics.EnableHandlingTimeHistogram()

                        reg = prometheus.NewRegistry()
                        reg.MustRegister(grpcMetrics)
                        reg.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))
                        reg.MustRegister(prometheus.NewGoCollector())

                        unaryIntercepters = append(unaryIntercepters, grpcMetrics.UnaryServerInterceptor())
                        streamIntercepters = append(streamIntercepters, grpcMetrics.StreamServerInterceptor())
                }</span>

        }

        // recovery 인터셉터 기본 설정
        <span class="cov8" title="1">unaryIntercepters = append(unaryIntercepters, grpc_recovery.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_recovery.StreamServerInterceptor())

        opts = append(opts, grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(unaryIntercepters...)))
        opts = append(opts, grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(streamIntercepters...)))
        gs := grpc.NewServer(opts...)

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{
                if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{

                        // Create a HTTP server for prometheus.
                        httpServer := &amp;http.Server{
                                Handler: promhttp.HandlerFor(reg, promhttp.HandlerOpts{}),
                                Addr:    fmt.Sprintf("0.0.0.0:%d", gConf.Interceptors.PrometheusMetrics.ListenPort),
                        }
                        // Initialize all metrics.
                        grpcMetrics.InitializeMetrics(gs)
                        // Start your http server for prometheus.
                        go func() </span><span class="cov0" title="0">{
                                if err := httpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                                        log.Fatal("Unable to start a http server for prometheus.")
                                }</span>
                        }()

                }
        }

        <span class="cov8" title="1">return &amp;CBServer{Server: gs}, closer, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package common

import (
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvGrpcStatusErr - GRPC 상태 코드 에러로 변환
func ConvGrpcStatusErr(err error, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        if err != nil </span><span class="cov0" title="0">{
                if errStatus, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        logger.Error(tag, " error while calling ", method, " method: ", errStatus.Message())
                        return status.Errorf(errStatus.Code(), "%s error while calling %s method: %v ", tag, method, errStatus.Message())
                }</span>
                <span class="cov0" title="0">logger.Error(tag, " error while calling ", method, " method: ", err)
                return status.Errorf(codes.Internal, "%s error while calling %s method: %v ", tag, method, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewGrpcStatusErr - GRPC 상태 코드 에러 생성
func NewGrpcStatusErr(msg string, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Error(tag, " error while calling ", method, " method: ", msg)
        return status.Errorf(codes.Internal, "%s error while calling %s method: %s ", tag, method, msg)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package config - Configuration for Cloud-Barista's GRPC and provides the required process
package config

import (
        "fmt"
        "log"
        "os"
        "strings"
        "time"
)

// ===== [ Constants and Variables ] =====

const (
        // ConfigVersion - 설정 구조에 대한 버전
        ConfigVersion = 1
)

// ===== [ Types ] =====

// GrpcConfig - CB-GRPC 서비스 설정 구조
type GrpcConfig struct {
        Version int             `mapstructure:"version"`
        GSL     GrpcServiceList `mapstructure:"grpc"`
}

// GrpcServiceList - CB-GRPC 서비스 목록
type GrpcServiceList struct {
        LadybugSrv *GrpcServerConfig `mapstructure:"ladybugsrv"`
        LadybugCli *GrpcClientConfig `mapstructure:"ladybugcli"`
}

// GrpcServerConfig - CB-GRPC 서버 설정 구조
type GrpcServerConfig struct {
        Addr         string              `mapstructure:"addr"`
        Reflection   string              `mapstructure:"reflection"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// GrpcClientConfig - CB-GRPC 클라이언트 설정 구조
type GrpcClientConfig struct {
        ServerAddr   string              `mapstructure:"server_addr"`
        Timeout      time.Duration       `mapstructure:"timeout"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// TLSConfig - TLS 설정 구조
type TLSConfig struct {
        TLSCert string `mapstructure:"tls_cert"`
        TLSKey  string `mapstructure:"tls_key"`
        TLSCA   string `mapstructure:"tls_ca"`
}

// InterceptorsConfig - GRPC 인터셉터 설정 구조
type InterceptorsConfig struct {
        AuthJWT           *AuthJWTConfig           `mapstructure:"auth_jwt"`
        PrometheusMetrics *PrometheusMetricsConfig `mapstructure:"prometheus_metrics"`
        Opentracing       *OpentracingConfig       `mapstructure:"opentracing"`
}

// AuthJWTConfig - AuthJWT 설정 구조
type AuthJWTConfig struct {
        JWTKey   string `mapstructure:"jwt_key"`
        JWTToken string `mapstructure:"jwt_token"`
}

// PrometheusMetricsConfig - Prometheus Metrics 설정 구조
type PrometheusMetricsConfig struct {
        ListenPort int `mapstructure:"listen_port"`
}

// OpentracingConfig - Opentracing 설정 구조
type OpentracingConfig struct {
        Jaeger *JaegerClientConfig `mapstructure:"jaeger"`
}

// JaegerClientConfig - Jaeger Client 설정 구조
type JaegerClientConfig struct {
        Endpoint    string  `mapstructure:"endpoint"`
        ServiceName string  `mapstructure:"service_name"`
        SampleRate  float64 `mapstructure:"sample_rate"`
}

// UnsupportedVersionError - 설정 초기화 과정에서 버전 검증을 통해 반환할 오류 구조
type UnsupportedVersionError struct {
        Have int
        Want int
}

// ===== [ Implementations ] =====

// Init - 설정에 대한 검사 및 초기화
func (gConf *GrpcConfig) Init() error <span class="cov8" title="1">{
        // 설정 파일 버전 검증
        if gConf.Version != ConfigVersion </span><span class="cov0" title="0">{
                return &amp;UnsupportedVersionError{
                        Have: gConf.Version,
                        Want: ConfigVersion,
                }
        }</span>
        // 전역변수 초기화
        <span class="cov8" title="1">gConf.initGlobalParams()

        return nil</span>
}

// initGlobalParams - 전역 설정 초기화
func (gConf *GrpcConfig) initGlobalParams() <span class="cov8" title="1">{

        if gConf.GSL.LadybugSrv != nil </span><span class="cov8" title="1">{

                if gConf.GSL.LadybugSrv.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugSrv.TLS.TLSCert != "" </span><span class="cov0" title="0">{
                                gConf.GSL.LadybugSrv.TLS.TLSCert = ReplaceEnvPath(gConf.GSL.LadybugSrv.TLS.TLSCert)
                        }</span>
                        <span class="cov0" title="0">if gConf.GSL.LadybugSrv.TLS.TLSKey != "" </span><span class="cov0" title="0">{
                                gConf.GSL.LadybugSrv.TLS.TLSKey = ReplaceEnvPath(gConf.GSL.LadybugSrv.TLS.TLSKey)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.LadybugSrv.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugSrv.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.ServiceName = "grpc ladybug server"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

        <span class="cov8" title="1">if gConf.GSL.LadybugCli != nil </span><span class="cov8" title="1">{

                if gConf.GSL.LadybugCli.Timeout == 0 </span><span class="cov8" title="1">{
                        gConf.GSL.LadybugCli.Timeout = 90 * time.Second
                }</span>

                <span class="cov8" title="1">if gConf.GSL.LadybugCli.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugCli.TLS.TLSCA != "" </span><span class="cov0" title="0">{
                                gConf.GSL.LadybugCli.TLS.TLSCA = ReplaceEnvPath(gConf.GSL.LadybugCli.TLS.TLSCA)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.LadybugCli.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugCli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.ServiceName = "grpc dragonfly client"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

}

// Error - 비 호환 버전에 대한 오류 문자열 반환
func (u *UnsupportedVersionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Unsupported version: %d (wanted: %d)", u.Have, u.Want)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ReplaceEnvPath - $ABC/def ==&gt; /abc/def
func ReplaceEnvPath(str string) string <span class="cov0" title="0">{
        if strings.Index(str, "$") == -1 </span><span class="cov0" title="0">{
                return str
        }</span>

        // ex) input "$CBSTORE_ROOT/meta_db/dat"
        <span class="cov0" title="0">strList := strings.Split(str, "/")
        for n, one := range strList </span><span class="cov0" title="0">{
                if strings.Index(one, "$") != -1 </span><span class="cov0" title="0">{
                        cbstoreRootPath := os.Getenv(strings.Trim(one, "$"))
                        if cbstoreRootPath == "" </span><span class="cov0" title="0">{
                                log.Fatal(one + " is not set!")
                        }</span>
                        <span class="cov0" title="0">strList[n] = cbstoreRootPath</span>
                }
        }

        <span class="cov0" title="0">var resultStr string
        for _, one := range strList </span><span class="cov0" title="0">{
                resultStr = resultStr + one + "/"
        }</span>
        // ex) "/root/go/src/github.com/cloud-barista/cb-spider/meta_db/dat/"
        <span class="cov0" title="0">resultStr = strings.TrimRight(resultStr, "/")
        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        return resultStr</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package config

import (
        "fmt"
        "os"
        "reflect"
        "unsafe"

        "github.com/spf13/viper"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Parser - Viper lib를 활용하기 위한 Parser 정의 구조 형식
type Parser struct {
        viper *viper.Viper
}

// ===== [ Implementations ] =====

// GrpcParse - Viper lib를 이용해서 지정된 CB-GRPC configuration 정보 파싱
func (p Parser) GrpcParse(configFile string) (GrpcConfig, error) <span class="cov8" title="1">{
        p.viper.SetConfigFile(configFile)
        p.viper.AutomaticEnv()
        p.viper.SetConfigType("yaml")

        var cfg GrpcConfig

        // Reading
        if err := p.viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Unmarshal to struct
        <span class="cov8" title="1">if err := p.viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Initialize
        <span class="cov8" title="1">if err := cfg.Init(); err != nil </span><span class="cov0" title="0">{
                return cfg, CheckErr(err, configFile)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// ===== [ Private Functions ] =====

// checkErr - Viper lib 처리에서 발생한 오류 반환 (Nested call)
func checkErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case viper.ConfigParseError:<span class="cov0" title="0">
                var subErr error
                re := reflect.ValueOf(&amp;e).Elem()
                rf := re.Field(0)
                rse := reflect.ValueOf(&amp;subErr).Elem()
                rf = reflect.NewAt(rf.Type(), unsafe.Pointer(rf.UnsafeAddr())).Elem()
                rse.Set(rf)
                return checkErr(subErr, configFile)</span>
        default:<span class="cov0" title="0">
                return CheckErr(err, configFile)</span>
        }
}

// ===== [ Public Functions ] =====

// CheckErr - 검증된 오류 정보 반환
func CheckErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case *os.PathError:<span class="cov0" title="0">
                return fmt.Errorf("'%s' (%s): %s", configFile, e.Op, e.Err.Error())</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("'%s': %v", configFile, err)</span>
        }
}

// MakeParser - Viber lib를 활용하는 설정 Parser 생성
func MakeParser() Parser <span class="cov8" title="1">{
        return Parser{viper.New()}
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - rpc unary call 정보를 기록하는 클라이언트 인터셉터
func UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := invoker(ctx, method, req, reply, cc, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client unary call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return err
        }</span>
}

// StreamClientInterceptor - rpc stream call 정보를 기록하는 클라이언트 인터셉터
func StreamClientInterceptor() grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                clientStream, err := streamer(ctx, desc, cc, method, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client stream call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return clientStream, err
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/peer"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - rpc unary receive 정보를 기록하는 서버 인터셉터
func UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                startTime := time.Now()
                resp, err := handler(ctx, req)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(ctx); ok </span><span class="cov8" title="1">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov8" title="1">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server unary received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return resp, err</span>
        }
}

// StreamServerInterceptor - rpc stream receive 정보를 기록하는 서버 인터셉터
func StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov8" title="1">{
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := handler(srv, stream)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(stream.Context()); ok </span><span class="cov0" title="0">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov0" title="0">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server stream received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package authjwt

import (
        "context"
        "fmt"
        "time"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
        "github.com/golang-jwt/jwt/v4"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

func validateToken(ctx context.Context) (bool, error) <span class="cov0" title="0">{

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.InvalidArgument, "Retrieving metadata is failed")
        }</span>

        <span class="cov0" title="0">authHeader, ok := md["authorization"]
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Authorization jwt token is not supplied")
        }</span>

        <span class="cov0" title="0">tokenStr := authHeader[0]

        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(jwtKey), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Parsing jwt token is failed")
        }</span>

        <span class="cov0" title="0">if token.Valid </span><span class="cov0" title="0">{
                logger := logger.NewLogger()
                var tokenInfo string = "{"
                for key, val := range claims </span><span class="cov0" title="0">{
                        if key == "expire" </span><span class="cov0" title="0">{

                                if getTokenRemainingValidity(val) &lt; 0 </span><span class="cov0" title="0">{
                                        return false, status.Errorf(codes.Unauthenticated, "token is expired")
                                }</span>

                                <span class="cov0" title="0">var timestamp interface{} = val
                                t := time.Unix(int64(timestamp.(float64)), 0)
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %d-%02d-%02dT%02d:%02d:%02d, remainder seconds: %d,", key,
                                        t.Year(), t.Month(), t.Day(),
                                        t.Hour(), t.Minute(), t.Second(),
                                        getTokenRemainingValidity(val),
                                )</span>

                        } else<span class="cov0" title="0"> {
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %v,", key, val)
                        }</span>
                }
                <span class="cov0" title="0">tokenInfo = tokenInfo + " }"
                logger.Debug("token parsing result : ", tokenInfo)

                return true, nil</span>
        }

        <span class="cov0" title="0">return false, status.Errorf(codes.Unauthenticated, "Authorization is failed")</span>
}

func getTokenRemainingValidity(timestamp interface{}) int <span class="cov0" title="0">{
        if validity, ok := timestamp.(float64); ok </span><span class="cov0" title="0">{
                tm := time.Unix(int64(validity), 0)
                remainder := tm.Sub(time.Now())

                return int(remainder.Seconds())
        }</span>
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtToken = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - JWT 토큰을 전달하는 Unary 클라이언트 인터셉터
func UnaryClientInterceptor(token string) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return invoker(ctx, method, req, reply, cc, opts...)</span>
        }
}

// StreamClientInterceptor - JWT 토큰을 전달하는 Stream 클라이언트 인터셉터
func StreamClientInterceptor(token string) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return streamer(ctx, desc, cc, method, opts...)</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtKey = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - authentication 을 처리하는 Unary 서버 인터셉터
func UnaryServerInterceptor(key string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// StreamServerInterceptor - authentication 을 처리하는 Stream 서버 인터셉터
func StreamServerInterceptor(key string) grpc.StreamServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(stream.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return handler(srv, stream)</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package jaegertracer

import (
        "fmt"
        "io"

        opentracing "github.com/opentracing/opentracing-go"
        jaeger "github.com/uber/jaeger-client-go"
        config "github.com/uber/jaeger-client-go/config"

        grpcconfig "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/config"
)

// InitJaeger - Jaeger Tracer 초기화
func InitJaeger(jcConf *grpcconfig.JaegerClientConfig) (opentracing.Tracer, io.Closer) <span class="cov0" title="0">{
        cfg := &amp;config.Configuration{
                Sampler: &amp;config.SamplerConfig{
                        Type:  "probabilistic",
                        Param: jcConf.SampleRate,
                },
                Reporter: &amp;config.ReporterConfig{
                        LocalAgentHostPort: jcConf.Endpoint,
                },
        }
        tracer, closer, err := cfg.New(jcConf.ServiceName, config.Logger(jaeger.NullLogger))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))</span>
        }
        <span class="cov0" title="0">return tracer, closer</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package logger

import (
        "io"
        "io/ioutil"
        "os"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Logger - CB-LOG에서 사용하는 "logrus" Logger를 위한 Wrapper 구조
type Logger struct {
        *logrus.Logger
}

// ===== [ Implementations ] =====

// SetOutput - 로그 출력기 설정
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.Logger.Out = w
}</span>

// DisableOutput - 로그 출력 비활성화
func (l *Logger) DisableOutput() <span class="cov0" title="0">{
        l.SetOutput(ioutil.Discard)
}</span>

// SetFormatter - 로그 포맷터 설정
func (l *Logger) SetFormatter(f logrus.Formatter) <span class="cov0" title="0">{
        l.Logger.Formatter = f
}</span>

// SetLogLevel - 로그 레벨 설정
func (l *Logger) SetLogLevel(lv logrus.Level) <span class="cov0" title="0">{
        l.Logger.SetLevel(lv)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewLogger - 초기화된 Logger의 인스턴스 생성
func NewLogger() *Logger <span class="cov8" title="1">{
        // CBLOG_ROOT 환경변수가 설정되어 있지 않으면 현재 경로로 환경변수 설정)
        env := os.Getenv("CBLOG_ROOT")
        if env == "" </span><span class="cov0" title="0">{
                if dir, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                        os.Setenv("CBLOG_ROOT", dir)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Logger{
                Logger: cblog.GetLogger("CB-GRPC"),
        }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package mcar

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common"
        pb "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCluster - Cluster 생성
func (r *MCARRequest) CreateCluster() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ClusterCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListCluster - Cluster 목록
func (r *MCARRequest) ListCluster() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ClusterAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetCluster - Cluster 조회
func (r *MCARRequest) GetCluster() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ClusterQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteCluster - Cluster 삭제
func (r *MCARRequest) DeleteCluster() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ClusterQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file43" style="display: none">package mcar

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common"
        pb "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// Healthy - 상태확인
func (r *MCARRequest) Healthy() (string, error) <span class="cov8" title="1">{
        // 서버에 요청
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.Healthy(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file44" style="display: none">package mcar

import (
        "context"
        "errors"

        gc "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common"
        pb "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// AddNode - Node 추가
func (r *MCARRequest) AddNode() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.NodeCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.AddNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListNode - Node 목록
func (r *MCARRequest) ListNode() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.NodeAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetNode - Node 조회
func (r *MCARRequest) GetNode() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.NodeQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// RemoveNode - Node 삭제
func (r *MCARRequest) RemoveNode() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.NodeQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.RemoveNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file45" style="display: none">package request

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common"
        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/config"
        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
        pb "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/protobuf/cbladybug"
        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/request/mcar"

        "google.golang.org/grpc"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// MCARApi - LADYBUG API 구조 정의
type MCARApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientMCAR   pb.MCARClient
        requestMCAR  *mcar.MCARRequest
        inType       string
        outType      string
}

// ClusterCreateRequest - CLUSTER 생성 요청 구조 Wrapper 정의
type ClusterCreateRequest struct {
        Namespace string     `yaml:"namespace" json:"namespace"`
        Item      ClusterReq `yaml:"ReqInfo" json:"ReqInfo"`
}

// ClusterReq - CLUSTER 생성 요청 구조 정의
type ClusterReq struct {
        Name         string       `yaml:"name" json:"name"`
        ControlPlane []NodeConfig `yaml:"controlPlane" json:"controlPlane"`
        Worker       []NodeConfig `yaml:"worker" json:"worker"`
        Config       Config       `yaml:"config" json:"config"`
}

// NodeConfig - Node 환경설정 구조 정의
type NodeConfig struct {
        Connection string `yaml:"connection" json:"connection"`
        Count      int    `yaml:"count" json:"count"`
        Spec       string `yaml:"spec" json:"spec"`
}

// Config - 클러스터 환경설정 구조 정의
type Config struct {
        Kubernetes Kubernetes `yaml:"kubernetes" json:"kubernetes"`
}

// Kubernetes - 쿠버네티스 환경설정 구조 정의
type Kubernetes struct {
        NetworkCni       string `yaml:"networkCni" json:"networkCni"`
        PodCidr          string `yaml:"podCidr" json:"podCidr"`
        ServiceCidr      string `yaml:"serviceCidr" json:"serviceCidr"`
        ServiceDnsDomain string `yaml:"serviceDnsDomain" json:"serviceDnsDomain"`
}

// NodeCreateRequest - NODE 생성 요청 구조 Wrapper 정의
type NodeCreateRequest struct {
        Namespace string  `yaml:"namespace" json:"namespace"`
        Cluster   string  `yaml:"cluster" json:"cluster"`
        Item      NodeReq `yaml:"ReqInfo" json:"ReqInfo"`
}

// NodeReq - NODE 생성 요청 구조 정의
type NodeReq struct {
        ControlPlane []NodeConfig `yaml:"controlPlane" json:"controlPlane"`
        Worker       []NodeConfig `yaml:"worker" json:"worker"`
}

// ===== [ Implementations ] =====

// SetServerAddr - Ladybug 서버 주소 설정
func (m *MCARApi) SetServerAddr(addr string) error <span class="cov8" title="1">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.LadybugCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Ladybug 서버 주소 값 조회
func (m *MCARApi) GetServerAddr() (string, error) <span class="cov8" title="1">{
        return m.gConf.GSL.LadybugCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 설정
func (m *MCARApi) SetTLSCA(tlsCAFile string) error <span class="cov8" title="1">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if m.gConf.GSL.LadybugCli.TLS == nil </span><span class="cov8" title="1">{
                m.gConf.GSL.LadybugCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.LadybugCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA 값 조회
func (m *MCARApi) GetTLSCA() (string, error) <span class="cov8" title="1">{
        if m.gConf.GSL.LadybugCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return m.gConf.GSL.LadybugCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 설정
func (m *MCARApi) SetTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        m.gConf.GSL.LadybugCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout 값 조회
func (m *MCARApi) GetTimeout() (time.Duration, error) <span class="cov8" title="1">{
        return m.gConf.GSL.LadybugCli.Timeout, nil
}</span>

// SetJWTToken - JWT 인증 토큰 설정
func (m *MCARApi) SetJWTToken(token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov8" title="1">if m.gConf.GSL.LadybugCli.Interceptors == nil </span><span class="cov8" title="1">{
                m.gConf.GSL.LadybugCli.Interceptors = &amp;config.InterceptorsConfig{}
                m.gConf.GSL.LadybugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov8" title="1">if m.gConf.GSL.LadybugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                m.gConf.GSL.LadybugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov8" title="1">m.gConf.GSL.LadybugCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT 인증 토큰 값 조회
func (m *MCARApi) GetJWTToken() (string, error) <span class="cov8" title="1">{
        if m.gConf.GSL.LadybugCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if m.gConf.GSL.LadybugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return m.gConf.GSL.LadybugCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath - 환경설정 파일 설정
func (m *MCARApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Viper 를 사용하는 설정 파서 생성
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // LADYBUG CLIENT 필수 입력 항목 체크
        <span class="cov8" title="1">ladybugcli := gConf.GSL.LadybugCli

        if ladybugcli == nil </span><span class="cov0" title="0">{
                return errors.New("ladybugcli field are not specified")
        }</span>

        <span class="cov8" title="1">if ladybugcli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("ladybugcli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if ladybugcli.Timeout == 0 </span><span class="cov0" title="0">{
                ladybugcli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if ladybugcli.TLS != nil </span><span class="cov0" title="0">{
                if ladybugcli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("ladybugcli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if ladybugcli.Interceptors != nil </span><span class="cov0" title="0">{
                if ladybugcli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if ladybugcli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("ladybugcli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if ladybugcli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if ladybugcli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if ladybugcli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("ladybugcli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">m.gConf = &amp;gConf
        return nil</span>
}

// Open - 연결 설정
func (m *MCARApi) Open() error <span class="cov8" title="1">{

        ladybugcli := m.gConf.GSL.LadybugCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(ladybugcli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                m.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">m.conn = cbconn.Conn

        // grpc 클라이언트 생성
        m.clientMCAR = pb.NewMCARClient(m.conn)

        // grpc 호출 Wrapper
        m.requestMCAR = &amp;mcar.MCARRequest{Client: m.clientMCAR, Timeout: ladybugcli.Timeout, InType: m.inType, OutType: m.outType}

        return nil</span>
}

// Close - 연결 종료
func (m *MCARApi) Close() <span class="cov8" title="1">{
        if m.conn != nil </span><span class="cov8" title="1">{
                m.conn.Close()
        }</span>
        <span class="cov8" title="1">if m.jaegerCloser != nil </span><span class="cov0" title="0">{
                m.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">m.jaegerCloser = nil
        m.conn = nil
        m.clientMCAR = nil
        m.requestMCAR = nil</span>
}

// SetInType - 입력 문서 타입 설정 (json/yaml)
func (m *MCARApi) SetInType(in string) error <span class="cov8" title="1">{
        if in == "json" </span><span class="cov8" title="1">{
                m.inType = in
        }</span> else<span class="cov8" title="1"> if in == "yaml" </span><span class="cov8" title="1">{
                m.inType = in
        }</span> else<span class="cov8" title="1"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov8" title="1">if m.requestMCAR != nil </span><span class="cov8" title="1">{
                m.requestMCAR.InType = m.inType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInType - 입력 문서 타입 값 조회
func (m *MCARApi) GetInType() (string, error) <span class="cov8" title="1">{
        return m.inType, nil
}</span>

// SetOutType - 출력 문서 타입 설정 (json/yaml)
func (m *MCARApi) SetOutType(out string) error <span class="cov8" title="1">{
        if out == "json" </span><span class="cov8" title="1">{
                m.outType = out
        }</span> else<span class="cov8" title="1"> if out == "yaml" </span><span class="cov8" title="1">{
                m.outType = out
        }</span> else<span class="cov8" title="1"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov8" title="1">if m.requestMCAR != nil </span><span class="cov8" title="1">{
                m.requestMCAR.OutType = m.outType
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetOutType - 출력 문서 타입 값 조회
func (m *MCARApi) GetOutType() (string, error) <span class="cov8" title="1">{
        return m.outType, nil
}</span>

// Healthy - 상태확인
func (m *MCARApi) Healthy() (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">return m.requestMCAR.Healthy()</span>
}

// CreateCluster - Cluster 생성
func (m *MCARApi) CreateCluster(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.CreateCluster()</span>
}

// CreateClusterByParam - Cluster 생성
func (m *MCARApi) CreateClusterByParam(req *ClusterCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCAR.InData = string(j)
        result, err := m.requestMCAR.CreateCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// ListCluster - Cluster 목록
func (m *MCARApi) ListCluster(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.ListCluster()</span>
}

// ListClusterByParam - Cluster 목록
func (m *MCARApi) ListClusterByParam(namespace string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `"}`
        result, err := m.requestMCAR.ListCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// GetCluster - Cluster 조회
func (m *MCARApi) GetCluster(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.GetCluster()</span>
}

// GetClusterByParam - Cluster 조회
func (m *MCARApi) GetClusterByParam(namespace string, cluster string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `"}`
        result, err := m.requestMCAR.GetCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteCluster - Cluster 삭제
func (m *MCARApi) DeleteCluster(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.DeleteCluster()</span>
}

// DeleteClusterByParam - Cluster 삭제
func (m *MCARApi) DeleteClusterByParam(namespace string, cluster string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `"}`
        result, err := m.requestMCAR.DeleteCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// AddNode - Node 추가
func (m *MCARApi) AddNode(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.AddNode()</span>
}

// AddNodeByParam - Node 추가
func (m *MCARApi) AddNodeByParam(req *NodeCreateRequest) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">m.requestMCAR.InData = string(j)
        result, err := m.requestMCAR.AddNode()
        m.SetInType(holdType)

        return result, err</span>
}

// ListNode - Node 목록
func (m *MCARApi) ListNode(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.ListNode()</span>
}

// ListNodeByParam - Node 목록
func (m *MCARApi) ListNodeByParam(namespace string, cluster string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `"}`
        result, err := m.requestMCAR.ListNode()
        m.SetInType(holdType)

        return result, err</span>
}

// GetNode - Node 조회
func (m *MCARApi) GetNode(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.GetNode()</span>
}

// GetNodeByParam - Node 조회
func (m *MCARApi) GetNodeByParam(namespace string, cluster string, node string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `", "node":"` + node + `"}`
        result, err := m.requestMCAR.GetNode()
        m.SetInType(holdType)

        return result, err</span>
}

// RemoveNode - Node 삭제
func (m *MCARApi) RemoveNode(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.RemoveNode()</span>
}

// RemoveNodeByParam - Node 삭제
func (m *MCARApi) RemoveNodeByParam(namespace string, cluster string, node string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `", "node":"` + node + `"}`
        result, err := m.requestMCAR.RemoveNode()
        m.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewMCARManager - MCAR API 객체 생성
func NewMCARManager() (m *MCARApi) <span class="cov8" title="1">{

        m = &amp;MCARApi{}
        m.gConf = &amp;config.GrpcConfig{}
        m.gConf.GSL.LadybugCli = &amp;config.GrpcClientConfig{}

        m.jaegerCloser = nil
        m.conn = nil
        m.clientMCAR = nil
        m.requestMCAR = nil

        m.inType = "json"
        m.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package mcar

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common"
        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
        pb "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/protobuf/cbladybug"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/service"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCluster - Cluster 생성
func (s *MCARService) CreateCluster(ctx context.Context, req *pb.ClusterCreateRequest) (*pb.ClusterInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.CreateCluster()")

        // GRPC 메시지에서 LADYBUG 객체로 복사
        var mcarObj model.ClusterReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        <span class="cov8" title="1">s.ClusterReqDef(&amp;mcarObj)

        err = s.ClusterReqValidate(mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        <span class="cov8" title="1">cluster, err := service.CreateCluster(req.Namespace, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ClusterInfo
        err = gc.CopySrcToDest(&amp;cluster, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ClusterInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListCluster - Cluster 목록
func (s *MCARService) ListCluster(ctx context.Context, req *pb.ClusterAllQryRequest) (*pb.ListClusterInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.ListCluster()")

        clusterList, err := service.ListCluster(req.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListClusterInfoResponse
        err = gc.CopySrcToDest(&amp;clusterList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListCluster()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetCluster - Cluster 조회
func (s *MCARService) GetCluster(ctx context.Context, req *pb.ClusterQryRequest) (*pb.ClusterInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.GetCluster()")

        if err := s.Validate(map[string]string{"namespace": req.Namespace, "cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetCluster()")
        }</span>

        <span class="cov8" title="1">cluster, err := service.GetCluster(req.Namespace, req.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ClusterInfo
        err = gc.CopySrcToDest(&amp;cluster, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetCluster()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ClusterInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteCluster - Cluster 삭제
func (s *MCARService) DeleteCluster(ctx context.Context, req *pb.ClusterQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.DeleteCluster()")

        if err := s.Validate(map[string]string{"namespace": req.Namespace, "cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.DeleteCluster()")
        }</span>

        <span class="cov8" title="1">status, err := service.DeleteCluster(req.Namespace, req.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.DeleteCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.StatusResponse
        err = gc.CopySrcToDest(&amp;status, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.DeleteCluster()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file47" style="display: none">package mcar

import (
        "context"

        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
        pb "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// Healthy - 상태확인
func (s *MCARService) Healthy(ctx context.Context, req *pb.Empty) (*pb.MessageResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.Healthy()")

        resp := &amp;pb.MessageResponse{Message: "cb-barista cb-ladybug"}
        return resp, nil
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file48" style="display: none">package mcar

import (
        "errors"
        "fmt"

        "github.com/beego/beego/v2/core/validation"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// MCARService - LADYBUG 서비스 구현
type MCARService struct {
}

// ===== [ Implementations ] =====

func (s *MCARService) Validate(params map[string]string) error <span class="cov8" title="1">{
        valid := validation.Validation{}

        for key, element := range params </span><span class="cov8" title="1">{
                valid.Required(element, key)
        }</span>

        <span class="cov8" title="1">if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *MCARService) ClusterReqDef(clusterReq *model.ClusterReq) error <span class="cov8" title="1">{
        clusterReq.Config.Kubernetes.NetworkCni = lang.NVL(clusterReq.Config.Kubernetes.NetworkCni, config.NETWORKCNI_KILO)
        clusterReq.Config.Kubernetes.PodCidr = lang.NVL(clusterReq.Config.Kubernetes.PodCidr, config.POD_CIDR)
        clusterReq.Config.Kubernetes.ServiceCidr = lang.NVL(clusterReq.Config.Kubernetes.ServiceCidr, config.SERVICE_CIDR)
        clusterReq.Config.Kubernetes.ServiceDnsDomain = lang.NVL(clusterReq.Config.Kubernetes.ServiceDnsDomain, config.SERVICE_DOMAIN)

        return nil
}</span>

func (s *MCARService) ClusterReqValidate(req model.ClusterReq) error <span class="cov8" title="1">{
        if len(req.ControlPlane) == 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node count must be one")
        }</span>
        <span class="cov8" title="1">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node count must be at least one")
        }</span>
        <span class="cov8" title="1">if !(req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_CANAL || req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_KILO) </span><span class="cov0" title="0">{
                return errors.New("network cni allows only Kilo or Canal")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *MCARService) NodeReqValidate(req model.NodeReq) error <span class="cov8" title="1">{
        if len(req.ControlPlane) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node not supported")
        }</span>
        <span class="cov8" title="1">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node count must be at least one")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file49" style="display: none">package mcar

import (
        "context"

        gc "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/common"
        "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/logger"
        pb "github.com/cloud-barista/poc-cicd-ladybug/src/grpc-api/protobuf/cbladybug"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/service"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// AddNode - Node 추가
func (s *MCARService) AddNode(ctx context.Context, req *pb.NodeCreateRequest) (*pb.ListNodeInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.AddNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        // GRPC 메시지에서 LADYBUG 객체로 복사
        <span class="cov8" title="1">var mcarObj model.NodeReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        <span class="cov8" title="1">err = s.NodeReqValidate(mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        <span class="cov8" title="1">node, err := service.AddNode(req.Namespace, req.Cluster, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListNodeInfoResponse
        err = gc.CopySrcToDest(&amp;node, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListCluster()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// ListNode - Node 목록
func (s *MCARService) ListNode(ctx context.Context, req *pb.NodeAllQryRequest) (*pb.ListNodeInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.ListNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListNode()")
        }</span>

        <span class="cov8" title="1">nodeList, err := service.ListNode(req.Namespace, req.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ListNodeInfoResponse
        err = gc.CopySrcToDest(&amp;nodeList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListNode()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// GetNode - Node 조회
func (s *MCARService) GetNode(ctx context.Context, req *pb.NodeQryRequest) (*pb.NodeInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.GetNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster, "node": req.Node}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        <span class="cov8" title="1">node, err := service.GetNode(req.Namespace, req.Cluster, req.Node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.NodeInfo
        err = gc.CopySrcToDest(&amp;node, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.NodeInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// RemoveNode - Node 삭제
func (s *MCARService) RemoveNode(ctx context.Context, req *pb.NodeQryRequest) (*pb.StatusResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.RemoveNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster, "node": req.Node}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        <span class="cov8" title="1">status, err := service.RemoveNode(req.Namespace, req.Cluster, req.Node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.RemoveNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.StatusResponse
        err = gc.CopySrcToDest(&amp;status, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.RemoveNode()")
        }</span>

        <span class="cov8" title="1">return &amp;grpcObj, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file50" style="display: none">package router

import (
        "net/http"
        "time"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/service"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/app"
        "github.com/labstack/echo/v4"

        logger "github.com/sirupsen/logrus"
)

// ListCluster
// @Tags Cluster
// @Summary List Cluster
// @Description List Cluster
// @ID ListCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Success 200 {object} model.ClusterList
// @Router /ns/{namespace}/clusters [get]
func ListCluster(c echo.Context) error <span class="cov8" title="1">{
        clusterList, err := service.ListCluster(c.Param("namespace"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return app.Send(c, http.StatusOK, clusterList)</span>
}

// GetCluster
// @Tags Cluster
// @Summary Get Cluster
// @Description Get Cluster
// @ID GetCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Success 200 {object} model.Cluster
// @Router /ns/{namespace}/clusters/{cluster} [get]
func GetCluster(c echo.Context) error <span class="cov8" title="1">{
        if err := app.Validate(c, []string{"namespace", "cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">cluster, err := service.GetCluster(c.Param("namespace"), c.Param("cluster"))
        if err != nil </span><span class="cov8" title="1">{
                logger.Infof("not found a cluster (namespace=%s, cluster=%s, cause=%s)", c.Param("namespace"), c.Param("cluster"), err)
                return app.SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov8" title="1">return app.Send(c, http.StatusOK, cluster)</span>
}

// CreateCluster
// @Tags Cluster
// @Summary Create Cluster
// @Description Create Cluster
// @ID CreateCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param json body model.ClusterReq true "Reuest json"
// @Success 200 {object} model.Cluster
// @Router /ns/{namespace}/clusters [post]
func CreateCluster(c echo.Context) error <span class="cov8" title="1">{
        start := time.Now()
        clusterReq := &amp;model.ClusterReq{}
        if err := c.Bind(clusterReq); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">app.ClusterReqDef(*clusterReq)

        err := app.ClusterReqValidate(*clusterReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">cluster, err := service.CreateCluster(c.Param("namespace"), clusterReq)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">duration := time.Since(start)
        logger.Info("duration := ", duration)
        return app.Send(c, http.StatusOK, cluster)</span>
}

// DeleteCluster
// @Tags Cluster
// @Summary Delete a cluster
// @Description Delete a cluster
// @ID DeleteCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Success 200 {object} model.Status
// @Router /ns/{namespace}/clusters/{cluster} [delete]
func DeleteCluster(c echo.Context) error <span class="cov8" title="1">{
        if err := app.Validate(c, []string{"namespace", "cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">status, err := service.DeleteCluster(c.Param("namespace"), c.Param("cluster"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return app.Send(c, http.StatusOK, status)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package router

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

// Healthy Method
// @Tags Default
// @Summary Health Check
// @Description for health check
// @ID Healthy
// @Accept json
// @Produce json
// @Success 200 {string} string "ok"
// @Router /healthy [get]
func Healthy(c echo.Context) error <span class="cov8" title="1">{
        return c.String(http.StatusOK, "cb-barista cb-ladybug")
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package router

import (
        "net/http"
        "time"

        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/service"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/app"

        "github.com/labstack/echo/v4"
        logger "github.com/sirupsen/logrus"
)

// ListNode
// @Tags Node
// @Summary List Node
// @Description List Node
// @ID ListNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Success 200 {object} model.NodeList
// @Router /ns/{namespace}/clusters/{cluster}/nodes [get]
func ListNode(c echo.Context) error <span class="cov8" title="1">{
        if err := app.Validate(c, []string{"cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">nodeList, err := service.ListNode(c.Param("namespace"), c.Param("cluster"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return app.Send(c, http.StatusOK, nodeList)</span>
}

// GetNode
// @Tags Node
// @Summary Get Node
// @Description Get Node
// @ID GetNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Param        node        path        string        true  "node"
// @Success 200 {object} model.Node
// @Router /ns/{namespace}/clusters/{cluster}/nodes/{node} [get]
func GetNode(c echo.Context) error <span class="cov8" title="1">{
        if err := app.Validate(c, []string{"cluster", "node"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">node, err := service.GetNode(c.Param("namespace"), c.Param("cluster"), c.Param("node"))
        if err != nil </span><span class="cov8" title="1">{
                logger.Infof("not found a node (namespace=%s, cluster=%s, node=%s, cause=%s)", c.Param("namespace"), c.Param("cluster"), c.Param("node"), err)
                return app.SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov8" title="1">return app.Send(c, http.StatusOK, node)</span>
}

// AddNode
// @Tags Node
// @Summary Add Node
// @Description Add Node
// @ID AddNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Param json body model.NodeReq true "Reuest json"
// @Success 200 {object} model.Node
// @Router /ns/{namespace}/clusters/{cluster}/nodes [post]
func AddNode(c echo.Context) error <span class="cov8" title="1">{
        start := time.Now()
        if err := app.Validate(c, []string{"cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">nodeReq := &amp;model.NodeReq{}
        if err := c.Bind(nodeReq); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">err := app.NodeReqValidate(*nodeReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">node, err := service.AddNode(c.Param("namespace"), c.Param("cluster"), nodeReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">duration := time.Since(start)
        logger.Info(" duration := ", duration)
        return app.Send(c, http.StatusOK, node)</span>
}

// RemoveNode
// @Tags Node
// @Summary Remove Node
// @Description Remove Node
// @ID RemoveNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Param        node        path        string        true  "node"
// @Success 200 {object} model.Status
// @Router /ns/{namespace}/clusters/{cluster}/nodes/{node} [delete]
func RemoveNode(c echo.Context) error <span class="cov8" title="1">{
        if err := app.Validate(c, []string{"cluster", "node"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">status, err := service.RemoveNode(c.Param("namespace"), c.Param("cluster"), c.Param("node"))
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return app.Send(c, http.StatusOK, status)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package app

import (
        "errors"
        "fmt"

        "github.com/beego/beego/v2/core/validation"
        "github.com/cloud-barista/poc-cicd-ladybug/src/core/model"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang"
        "github.com/labstack/echo/v4"
)

type Status struct {
        Message string `json:"message"`
}

func SendMessage(c echo.Context, httpCode int, msg string) error <span class="cov8" title="1">{
        return c.JSON(httpCode, Status{Message: msg})
}</span>

func Send(c echo.Context, httpCode int, json interface{}) error <span class="cov8" title="1">{
        return c.JSON(httpCode, json)
}</span>

func Validate(c echo.Context, params []string) error <span class="cov8" title="1">{
        valid := validation.Validation{}

        for _, name := range params </span><span class="cov8" title="1">{
                valid.Required(c.Param(name), name)
        }</span>

        <span class="cov8" title="1">if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func ClusterReqDef(clusterReq model.ClusterReq) <span class="cov8" title="1">{
        clusterReq.Config.Kubernetes.NetworkCni = lang.NVL(clusterReq.Config.Kubernetes.NetworkCni, config.NETWORKCNI_KILO)
        clusterReq.Config.Kubernetes.PodCidr = lang.NVL(clusterReq.Config.Kubernetes.PodCidr, config.POD_CIDR)
        clusterReq.Config.Kubernetes.ServiceCidr = lang.NVL(clusterReq.Config.Kubernetes.ServiceCidr, config.SERVICE_CIDR)
        clusterReq.Config.Kubernetes.ServiceDnsDomain = lang.NVL(clusterReq.Config.Kubernetes.ServiceDnsDomain, config.SERVICE_DOMAIN)
}</span>

func ClusterReqValidate(req model.ClusterReq) error <span class="cov8" title="1">{
        if len(req.ControlPlane) == 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node must be at least one")
        }</span>
        <span class="cov8" title="1">if len(req.ControlPlane) &gt; 1 </span><span class="cov0" title="0">{
                return errors.New("only one control plane node is supported")
        }</span>
        <span class="cov8" title="1">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node must be at least one")
        }</span>
        <span class="cov8" title="1">if !(req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_CANAL || req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_KILO) </span><span class="cov0" title="0">{
                return errors.New("network cni allows only kilo or canal")
        }</span>

        <span class="cov8" title="1">if len(req.Name) == 0 </span><span class="cov0" title="0">{
                return errors.New("cluster name is empty")
        }</span> else<span class="cov8" title="1"> {
                err := lang.CheckName(req.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(req.Config.Kubernetes.PodCidr) &gt; 0 </span><span class="cov8" title="1">{
                err := lang.CheckIpCidr("podCidr", req.Config.Kubernetes.PodCidr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if len(req.Config.Kubernetes.ServiceCidr) &gt; 0 </span><span class="cov8" title="1">{
                err := lang.CheckIpCidr("serviceCidr", req.Config.Kubernetes.ServiceCidr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func NodeReqValidate(req model.NodeReq) error <span class="cov8" title="1">{
        if len(req.ControlPlane) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node is not supported")
        }</span>
        <span class="cov8" title="1">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node must be at least one")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package app

import (
        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/config"
        "github.com/go-resty/resty/v2"
)

func ExecutHTTP(method string, url string, body interface{}, result interface{}) (*resty.Response, error) <span class="cov8" title="1">{

        conf := config.Config

        req := resty.New().SetDisableWarn(true).R().SetBasicAuth(*conf.Username, *conf.Password)

        if body != nil </span><span class="cov8" title="1">{
                req.SetBody(body)
        }</span>
        <span class="cov8" title="1">if result != nil </span><span class="cov8" title="1">{
                req.SetResult(result)
        }</span>

        // execute
        <span class="cov8" title="1">return req.Execute(method, url)</span>

}
</pre>
		
		<pre class="file" id="file55" style="display: none">package config

import (
        "flag"
        "os"

        "github.com/cloud-barista/poc-cicd-ladybug/src/utils/lang"
        "github.com/sirupsen/logrus"
        logger "github.com/sirupsen/logrus"
)

type conf struct {
        RunMode      *string
        SpiderUrl    *string
        TumblebugUrl *string
        RootURL      *string
        Username     *string
        Password     *string
        AppRootPath  *string
        LoglevelHTTP *bool
}

var Config = &amp;conf{}

func Setup() <span class="cov0" title="0">{

        var logLevel *string

        Config.AppRootPath = flag.String("app-root", lang.NVL(os.Getenv("APP_ROOT"), ""), "application root path")
        Config.RootURL = flag.String("root-url", lang.NVL(os.Getenv("BASE_URL"), "/ladybug"), "root url")
        Config.SpiderUrl = flag.String("spider-url", lang.NVL(os.Getenv("SPIDER_URL"), "http://localhost:1024/spider"), "cb-spider service end-point url")
        Config.TumblebugUrl = flag.String("tumblebug-url", lang.NVL(os.Getenv("TUMBLEBUG_URL"), "http://localhost:1323/tumblebug"), "cb-tumblebug service end-point url")
        Config.Username = flag.String("basic-auth-username", lang.NVL(os.Getenv("BASIC_AUTH_USERNAME"), "default"), "rest-api basic auth usernmae")
        Config.Password = flag.String("basic-auth-password", lang.NVL(os.Getenv("BASIC_AUTH_PASSWORD"), "default"), "rest-api basic auth password")
        logLevel = flag.String("log-level", lang.NVL(os.Getenv("LOG_LEVEL"), "info"), "The log level")
        Config.LoglevelHTTP = flag.Bool("log-http", os.Getenv("LOG_HTTP") == "true", "The logging http data")

        flag.Parse()

        //logger
        logger.SetFormatter(&amp;logrus.TextFormatter{})
        logger.SetOutput(os.Stderr)

        level, err := logrus.ParseLevel(*logLevel)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span> else<span class="cov0" title="0"> if level != logrus.GetLevel() </span><span class="cov0" title="0">{
                logger.SetLevel(level)
        }</span> else<span class="cov0" title="0"> {
                logger.SetLevel(logrus.InfoLevel)
        }</span>

        // app root path
        <span class="cov0" title="0">if len(*Config.AppRootPath) == 0 </span><span class="cov0" title="0">{
                if pwd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                        Config.AppRootPath = &amp;pwd
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file56" style="display: none">package lang

import (
        "errors"
        "fmt"
        "math/rand"
        "regexp"
        "strconv"
        "time"

        "github.com/google/uuid"
)

const (
        // Random string generation
        letterBytes   = "abcdefghijklmnopqrstuvwxyz1234567890"
        letterIdxBits = 6
        letterIdxMask = 1&lt;&lt;letterIdxBits - 1
        letterIdxMax  = 63 / letterIdxBits
)

var (
        // Random source by nano time
        randSrc = rand.NewSource(time.Now().UnixNano())
)

// NVL is null value logic
func NVL(str string, def string) string <span class="cov8" title="1">{
        if len(str) == 0 </span><span class="cov8" title="1">{
                return def
        }</span>
        <span class="cov8" title="1">return str</span>
}

// get store cluster key
func GetStoreClusterKey(namespace string, clusterName string) string <span class="cov8" title="1">{
        if clusterName == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("/ns/%s/clusters", namespace)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("/ns/%s/clusters/%s", namespace, clusterName)
        }</span>
}

// get store node key
func GetStoreNodeKey(namespace string, clusterName string, nodeName string) string <span class="cov8" title="1">{
        if nodeName == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("/ns/%s/clusters/%s/nodes", namespace, clusterName)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("/ns/%s/clusters/%s/nodes/%s", namespace, clusterName, nodeName)
        }</span>
}

// get uuid
func GetUid() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>

// Random string generation
func GetRandomString(n int) string <span class="cov8" title="1">{
        b := make([]byte, n)
        for i, cache, remain := n-1, randSrc.Int63(), letterIdxMax; i &gt;= 0; </span><span class="cov8" title="1">{
                if remain == 0 </span><span class="cov8" title="1">{
                        cache, remain = randSrc.Int63(), letterIdxMax
                }</span>
                <span class="cov8" title="1">if idx := int(cache &amp; letterIdxMask); idx &lt; len(letterBytes) </span><span class="cov8" title="1">{
                        b[i] = letterBytes[idx]
                        i--
                }</span>
                <span class="cov8" title="1">cache &gt;&gt;= letterIdxBits
                remain--</span>
        }
        <span class="cov8" title="1">return string(b)</span>
}

// get node name
func GetNodeName(clusterName string, role string, idx int) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s-%d-%s", clusterName, role[:1], idx, GetRandomString(5))
}</span>

func GetIdxToInt(idx string) int <span class="cov8" title="1">{
        i, err := strconv.Atoi(idx)
        if err != nil </span><span class="cov0" title="0">{
                i = 0
        }</span>
        <span class="cov8" title="1">return i</span>
}

func GetMaxNumber(arr []int) int <span class="cov8" title="1">{
        max := 0
        for _, val := range arr </span><span class="cov8" title="1">{
                if val &gt; max </span><span class="cov8" title="1">{
                        max = val
                }</span>
        }
        <span class="cov8" title="1">return max</span>
}

func CheckName(name string) error <span class="cov8" title="1">{
        reg, _ := regexp.Compile("[a-z]([-a-z0-9]*[a-z0-9])?")
        filtered := reg.FindString(name)

        if filtered != name </span><span class="cov0" title="0">{
                return errors.New(name + ": The first character of name must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func CheckIpCidr(name string, val string) error <span class="cov8" title="1">{
        reg, _ := regexp.Compile("^((?:\\d{1,3}.){3}\\d{1,3})\\/(\\d{1,2})$")
        filtered := reg.FindString(val)

        if filtered != val </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("%s %s : Type mismatch ex)10.244.0.0/16", name, val))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
